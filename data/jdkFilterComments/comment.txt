true if this socket is exclusively bound
emulates SO_REUSEADDR when exclusiveBind is true
SO_REUSEADDR emulated when using exclusive bind
SO_REUSEADDR emulated when using exclusive bind
add this message to fix bug 21478
Earlier (JDK 1.4 XALAN 2.2-D11) at key code '204' the key name was ER_PRIORITY_NOT_PARSABLE
In latest Xalan code base key name is  ER_VALUE_SHOULD_BE_NUMBER. This should also be taken care
in locale specific files like XSLTErrorResources_de.java, XSLTErrorResources_fr.java etc.
NOTE: Not only the key name but message has also been changed.
Note to translators:  The following message should not normally be displayed
to users.  It describes a situation in which the processor has detected
an internal consistency problem in itself, and it provides this message
for the developer to help diagnose the problem.  The name
'ElemTemplateElement' is the name of a class, and should not be
Note to translators:  The following message should not normally be displayed
to users.  It describes a situation in which the processor has detected
an internal consistency problem in itself, and it provides this message
for the developer to help diagnose the problem.  The substitution text
provides further information in order to diagnose the problem.  The name
'RedundentExprEliminator' is the name of a class, and should not be
This code is shared with warning codes.
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "QNAME" is the XML data-type of
The following codes are shared with the warning codes...
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "ENUM" is the XML data-type of
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "NMTOKEN" is the XML data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "NCNAME" is the XML data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "boolean" is the XSLT data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "number" is the XSLT data-type
End of shared codes...
Note to translators:  A "match pattern" is a special form of XPath expression
that is used for matching patterns.  The substitution text is the name of
a function.  The message indicates that when this function is referenced in
a match pattern, its argument must be a string literal (or constant.)
ER_ARG_LITERAL - new error message for bugzilla 5202
Note to translators:  The following message indicates that two definitions of
a variable.  A "global variable" is a variable that is accessible everywher
in the stylesheet.
ER_DUPLICATE_GLOBAL_VAR - new error message for bugzilla #790
Note to translators:  The following message indicates that two definitions of
a variable were encountered.
ER_DUPLICATE_VAR - new error message for bugzilla #790
Note to translators:  "xsl:template, "name" and "match" are XSLT keywords
which must not be translated.
ER_TEMPLATE_NAME_MATCH - new error message for bugzilla #789
Note to translators:  "exclude-result-prefixes" is an XSLT keyword which
should not be translated.  The message indicates that a namespace prefix
encountered as part of the value of the exclude-result-prefixes attribute
was in error.
ER_INVALID_PREFIX - new error message for bugzilla #788
Note to translators:  An "attribute set" is a set of attributes that can
be added to an element in the output document as a group.  The message
was never defined.
ER_NO_ATTRIB_SET - new error message for bugzilla #782
Note to translators:  This message indicates that there was a reference
Note to translators:  This message indicates that the XSLT instruction
instructions (content) or a "select" attribute.  The word "select" is
an XSLT keyword in this case and must not be translated.
Note to translators:  This message indicates that the value argument
of setParameter must be a valid Java Object.
Following are the new WARNING keys added in XALAN code base after Jdk 1.4 (Xalan 2.2-D11)
Note to translators:  "name" and "xsl:processing-instruction" are keywords
and must not be translated.
Note to translators:  "name" and "xsl:processing-instruction" are keywords
and must not be translated.  "NCName" is an XML data-type and must not be
Note to translators:  This message is reported if the stylesheet that is
being processed attempted to construct an XML document with an attribute in a
place other than on an element.  The substitution text specifies the name of
Check: WHY THERE IS A GAP B/W NUMBERS in the XSLTErrorResources properties file?
Other miscellaneous text used inside the code...
Note to translators:  The following messages provide usage information
for the Xalan Process command line.  "Process" is the name of a Java class,
and should not be translated.
Note to translators: The option name and the parameter name do not need to
be translated. Only translate the messages in parentheses.  Note also that
leading whitespace in the messages is used to indent the usage information
for each option in the English messages.
Do not translate the keywords: XSLTC, SAX, DOM and DTM.
Following are the new options added in XSLTErrorResources.properties files after Jdk 1.4 (Xalan 2.2-D11)
Added by sboag/scurcuru; experimental
AddITIONAL  STRINGS that need L10n
Note to translators:  The following message describes usage of a particular
command-line option that is used to enable the "template inlining"
optimization.  The optimization involves making a copy of the code
generated for a template in another template that refers to it.
================= INFRASTRUCTURE ======================
-- This file was mechanically generated: Do not edit! --
For duplicates and slices
--- Methods to support CharSequence ---
iterator is not a clone
Calculate the position of the node in the set
on subsequent errors the validator should not report
serialVersionUID not constant
Serialization compatibility stuff:
Two serial forms are supported in this class. The selected form depends
on system property "jmx.serial.form":
- "1.0" for JMX 1.0
- any other value for JMX 1.1 and higher
Serial version for old serial form
Serial version for new serial form
Serializable fields in old serial form
Serializable fields in new serial form
Actual serial version and serial form
OK : Too bad, no compat with 1.0
END Serialization compatibility stuff
OK : Can never happen as the minimum
degree equals the maximum degree.
OK : Can never happen as the minimum
degree equals the maximum degree.
Revisit [cebro] Localize message
OK : Can never happen as the minimum degree and the maximum
degree were already checked at the time the roleInfo
instance was created.
Revisit [cebro] Localize message
Revisit [cebro] Localize message
Revisit [cebro] Localize message
Read an object serialized in the old serial form
Read an object serialized in the new serial form
Serializes this instance in the old serial form
Serializes this instance in the new serial form
Starts the server if it is not already running.
Starts the server if it is not already running.
get the port for the endpoint of the locator
to pick a particular port type.
From CORBA Spec, Table 6 Keywords.
Note that since all IDL identifiers are case
insensitive, java identifier comparisons to these
will be case insensitive also.
used to mangle java inner class names
used to form IDL array type names
used to mangling java identifiers that have a leading underscore
separator used between types in a mangled overloaded method name
string appended to attribute if it clashes with a method name
strings prepended to the attribute names in order to form their
Convert keyword to all caps to ease equality
Remote interface for name translation.
Maps used to hold name translations.  These do not need to be
synchronized since the translation is never modified after
Requirements for this method:
1. cls must be an exception but not a RemoteException.
2. If cls has an IDL keyword name, an underscore is prepended (1.3.2.2).
3. If cls jas a leading underscore, J is prepended (1.3.2.3).
4. If cls has an illegal IDL ident char, it is mapped to UXXXX where
XXXX is the unicode value in hex of the char (1.3.2.4).
5. double underscore for inner class (1.3.2.5).
6. The ID is "IDL:" + name with / separators + ":1.0".
holds method info, keyed by method
Handle the case of a non-public interface!
Take an initial pass through all the methods and create some
information that will be used to track the IDL name
Perform case sensitivity test first.  This applies to all
method names AND attributes.  Compare each method name and
attribute to all other method names and attributes.  If names
differ only in case, apply mangling as defined in section 1.3.2.7
of Java2IDL spec.  Note that we compare using the original names.
Now check for overloaded method names and apply 1.3.2.6.
Now mangle any properties that clash with method names.
Ensure that no mapped method names clash with mapped name
of container(1.3.2.9).  This is a case insensitive comparison.
Populate name translation maps.
Final check to see if there are any clashes after all the
manglings have been applied.  If so, this is treated as an
invalid interface.  Currently, we do a CASE-SENSITIVE
comparison since that matches the rmic behavior.
Apply leading underscore test (1.3.2.3)
This should be done before IDL Keyword clash test, since clashing
IDL keywords are mangled by adding a leading underscore.
Apply IDL keyword clash test (1.3.2.2).
This is not needed for attributes since when the full property
name is composed it cannot clash with an IDL keyword.
(Also, rmic doesn't do it.)
Replace illegal IDL identifier characters (1.3.2.4)
for all method names and attributes.
isIDLKeyword and mangleIDLKeywordClash are exposed here so that
IDLType can use them.
XXX refactoring needed:
1. Split off isIDLKeywork and mangleIDLKeywordClash (and possibly
other methods) into a utility class.
2. Move all of classToIDLType to a constructor inside IDLType.
The problem appears to be that we need all of the code that
performs various checks for name problems and the corresponding
fixes into a utility class.  Then we need to see what other
refactorings present themselves.
There is always at least one trailing underscore, whether or
not the identifier has uppercase letters.
This bit of logic is needed to ensure that we have
an underscore separated list of indices but no
trailing underscores.  Basically, after we have at least
one uppercase letter, we always put an undercore before
printing the next one.
1st char must be alphbetic.
NOTE that we can't use the java.lang.Character
isUpperCase, isLowerCase, etc. methods since they
include many characters other than the Alphabetic list in
the CORBA spec.  Instead, we test for inclusion in the
Unicode value ranges for the corresponding legal characters.
A - Z
a - z
other letter uppercase, other letter lowercase, which is
the entire upper half of C1 Controls except X and /
Start by appending the separator string
Calculate array depth, as well as base element type.
Section 1.3.2.5 of Java2IDL spec defines mangling rules for
replace inner class separator with double underscore
Get raw package name.  If there is a package, it
will still have the "." separators and none of the
mangling rules will have been applied.
If this is a generated IDL Entity Type we need to
prepend org_omg_boxedIDL per sections 1.3.5 and 1.3.9
Section 1.3.2.1 and 1.3.2.6 of Java2IDL spec defines
rules for mapping java packages to IDL modules and for
mangling module name portion of type name.  NOTE that
of the individual identifier mangling rules,
only the leading underscore test is done here.
The other two(IDL Keyword, Illegal Unicode chars) are
done in mangleOverloadedMethodName.
Try to get package name by introspection.  Some classloaders might
not provide this information, so check for null.
brute force method
If this is a property, originalName holds the original
attribute name. Otherwise, it holds the original method name.
If this is a property, mangledName holds the mangled attribute
name. Otherwise, it holds the mangled method name.
FACTORY STUFF, INCLUDING SHARING
Find out queue size
Notify potential waiting fetchNotification call
We no longer support calling this method from outside.
The JDK doesn't contain any such calls and users are not
supposed to be accessing this class.
Check arg validity
Skip security check if NotificationBufferFilter is not overloaded
These two are for reporting errors only
Traverse all child nodes - must be either When or Otherwise
Add a When child element
Add an Otherwise child element
It is an error if we find some other element here
Make sure that there is at least one <xsl:when> element
next element will hold a handle to the beginning of next
When/Otherwise if test on current When fails
remember end of condition
The When object should be ignored completely in case it tests
for the support of a non-available element
goto exit after executing the body of when
Translate any <xsl:otherwise> element
now that end is known set targets of exit gotos
Convert Exception to corresponding Error
Make an empty path match all.
Use a cached Style if possible, otherwise create a new one.
NOTE: merging is done backwards as DefaultSynthStyleFactory reverses
order, that is, the most specific style is first.
inner class AccessibleJCheckBoxMenuItem
Transition to sum, cumulate, or both
leftmost; no in
sib not ready
Transition to sum, cumulate, or both
leftmost; no in
sib not ready
Transition to sum, cumulate, or both
leftmost; no in
sib not ready
Transition to sum, cumulate, or both
leftmost; no in
sib not ready
translate css attributes to html
If an instance of an UNKNOWN Tag, or an instance of a
tag that is only visible during editing
Write out any styles.
Determine the name, as an HTML.Tag.
write out end tags for item on stack
If the head has not been output, output it and the styles.
Write out the maps, which is not stored as Elements in
PENDING: should this be changed to check for null first?
write out end tags for item on stack
translate css attributes to html
translate css attributes to html
First, find all the tags that need to be removed.
Then close them out.
Have to output any tags after firstIndex that still remaing,
as we closed them out, but they should remain open.
Output the areas
Don't write out the default style.
--- conversion support ---------------------------
add a bold tag is weight is bold
default is to store in a HTML style attribute
edit the parameters to the font tag
Overrides the writing methods to only break a string when
canBreakString is true.
In a future release it is likely AbstractWriter will get this
This will change, we need better support character level
Character level entities.
If the character is outside of ascii, write the
We implement a Stack here instead of using java.util.Stack because
java.util.Stack is thread-safe, negatively impacting performance.
We use an ArrayList instead since it is not thread-safe.
RequestInfoStack is used quite frequently.
The stack for RequestInfo objects.
Tests if this stack is empty.
Looks at the object at the top of this stack without removing it
from the stack.
Removes the object at the top of this stack and returns that
object as the value of this function.
Pushes an item onto the top of the stack
Keep in sync with DynAny[] components at all times.
get a hold of the default initialized Any without copying
This method has a different meaning for sequence and array:
For sequence value of 0 indicates an unbounded sequence,
values > 0 indicate a bounded sequence.
For array any value indicates the boundary.
DynAny interface methods
_REVISIT_ More efficient copy operation
Initializes the elements of the ordered collection.
If value does not contain the same number of elements as the array dimension,
the operation raises InvalidValue.
If one or more elements have a type that is inconsistent with the collections TypeCode,
the operation raises TypeMismatch.
This operation does not change the current position.
We know that this is of kind tk_sequence or tk_array
_REVISIT_ More info
Creates the appropriate subtype without copying the Any
_REVISIT_ More info
Other representations are invalidated by this operation
Same semantics as set_elements(Any[])
We know that this is of kind tk_sequence or tk_array
_REVISIT_ More info
_REVISIT_ More info
Other representations are invalidated by this operation
Type-specific CORBA::Object operations
add default recognized features
WARN_ON_DUPLICATE_ATTDEF,      from XMLDTDScannerImpl
WARN_ON_UNDECLARED_ELEMDEF,    from XMLDTDScannerImpl
ALLOW_JAVA_ENCODINGS,          from XMLEntityManager
NOTIFY_BUILTIN_REFS,   from XMLDocumentFragmentScannerImpl
NOTIFY_CHAR_REFS,          from XMLDocumentFragmentScannerImpl
WARN_ON_DUPLICATE_ENTITYDEF,   from XMLEntityManager
set state for default features
setFeature(WARN_ON_DUPLICATE_ATTDEF, false);   from XMLDTDScannerImpl
setFeature(WARN_ON_UNDECLARED_ELEMDEF, false);   from XMLDTDScannerImpl
setFeature(ALLOW_JAVA_ENCODINGS, false);       from XMLEntityManager
setFeature(NOTIFY_BUILTIN_REFS, false);    from XMLDocumentFragmentScannerImpl
setFeature(NOTIFY_CHAR_REFS, false);       from XMLDocumentFragmentScannerImpl
setFeature(WARN_ON_DUPLICATE_ENTITYDEF, false);    from XMLEntityManager
add default recognized properties
add message formatters
REVISIT: What is the right thing to do? -Ac
REVISIT: this method used to reset all the components and
construct the pipeline. Now reset() is called
in parse (boolean) just before we parse the document
Should this method still throw exceptions..?
reset and configure pipeline and set InputSource.
resets and sets the pipeline.
REVISIT - need to add new error message
close all streams opened by xerces
configure the pipeline and initialize the components
REVISIT: This should be better designed. In other words, we
need to figure out what is the best way for people to
re-use *most* of the standard configuration but do
things common things such as remove a component (e.g.
the validator), insert a new component (e.g. XInclude),
setup document pipeline
setup dtd pipeline
features and properties
Allows the parser to validate a document only when it
contains a grammar. Validation is turned on/off based
on each document instance, automatically.
Handle the methods from java.lang.Object
this plain Method.invoke is called only if the declaring class
is Object and so it's safe.
BootstrapResolver.java - Resolve entities and URIs internally
Ideally this method would not attempt to open the
InputStream, but there is a bug (in Xerces, at least)
that causes the parser to mistakenly open the wrong
system identifier if the returned InputSource does
not have a byteStream.
It could be argued that we still shouldn't do this here,
but since the purpose of calling the entityResolver is
almost certainly to open the input stream, it seems to
do little harm.
FIXME: silently fail?
try to make an absolute URI from the current base
don't bother if the absBase isn't different!
fall back for compatibility
can't create a new object of this class
hold the value of the key this Exception refers to.
End of file.
ARGHH!!  JAXP Uses Xerces without setting the namespace processing to ON!
* Constructor AttList
* @param attrs List of attributes this will contain
public AttList(NamedNodeMap attrs)
for the moment
for the moment
for the moment
Use the same hash function as for String
Map< Key, AOMEntry >
Map< AOMEntry, Servant >
Map< Servant, AOMEntry >
Map< AOMEntry, Key >
This case does not need the key.
Map< AOMEntry, Set< Key > >
default should be 'false' for StepPattern
Ignore if type is not node-set
setStartNode() should not be called if expr is a variable ref
Skip if different arity
The first method with the right arity is the default
Check if better than last one found
2^8 = 256
To maximize memory consumption the actual semantic of these fields vary
depending on the node type.
Implementation Note: The deferred element and attribute must know how to
interpret the int representing the qname.
Currently implemented as a singleton, since it's hardcoded
internal factory methods
save name, public id, system id
return node index
create extra data node to store internal subset
create extra data node
save name, public id, system id, and notation name
in extra data node set baseURI value
return node index
create extra data node
save name, public id, system id, and notation name
set other values in the extra chunk
return node index
DOM Level 3: setting encoding and version
DOM Level 3: sets element TypeInfo
get first extra data chunk
get second extra data chunk
return node index
return node index
return node index
set attribute's parent to element
get element's last attribute
add link from new attribute to last attribute
add link from element to new last attribute
store type information
return node index
set attribute's parent to element
get element's last attribute
add link from new attribute to last attribute
add link from element to new last attribute
return node index
return node index
return node index
use extra to store ignorableWhitespace info
return node index
return node index
return node index
return node index
clone immediate node
clone and attach children
return cloned node index
append parent index
set previous sibling of new child
update parent's last child
see if this attribute is already here
remove old attribute
remove connections to siblings
add new attribute
find element definition
is there anything to do?
get node type
create new node
Standard DOM node types
NOTE: Document fragments can never be "fast".
The parser will never ask to create a document
fragment during the parse. Document fragments
are used by the application *after* the parse.
this node is never "fast"
save the doctype node
check to see if this element needs to be
registered for its ID attributes
continue if there are more IDs for
non-standard DOM node types
switch node type
store and return
append data that is stored in fNodeValue
REVISIT: for text nodes it works differently than for CDATA
go in reverse order: find last child, then
its previous sibling, etc
add to the buffer in the correct order.
find if any other data stored in children
append data that is stored in fNodeValue
go in reverse order: find last child, then
its previous sibling, etc
add to the buffer in the correct order.
This assumes that the document is small
no need to sync in the future
fluff up enough nodes to fill identifiers hash
REVISIT: There has to be a more efficient way of
doing this. But keep in mind that the
tree can have been altered and re-ordered
before all of the element nodes with ID
attributes have been registered. For now
this is reasonable and safe. -Ac
ignore if it's already been registered
find path from this element to the root
Traverse path (backwards), fluffing the elements
along the way. When this loop finishes, "place"
will contain the reference to the element node
we're interested in. -Ac
register the element
see if there are more IDs on this element
we don't want to generate any event for this so turn them off
no need to sync in the future
create children and link them as siblings
save doctype and document type
set mutation events flag back to its original value
we don't want to generate any event for this so turn them off
no need to sync in the future
create children and link them as siblings or simply store the value
as a String if all we have is one piece of text
firstChild = firstNode
set mutation events flag back to its original value
we don't want to generate any event for this so turn them off
no need to sync in the future
create children and link them as siblings
set mutation events flag back to its original value
resize the tables
Done - there's sufficient capacity
create new chunks
ensure tables are large enough
return node index number
look for target value
is this the one we're looking for?
is this point higher or lower?
Re-create chunk if it was deleted.
Re-create chunk if it was deleted.
save ID and its associated element
init(SymbolTable, XMLGrammarPool, XMLErrorReporter, XMLEntityResolver)
createDTDScanner(SymbolTable, XMLErrorReporter, XMLEntityManager) : XMLDTDScannerImpl
getScannerVersion() : short
Parse the required prefix
Parse the protocol name
Parse the host name
Parse the port number
Parse the URL path
Check URL path
will throw exception
will throw exception
will throw exception
address contains colon if and only if it's a numeric IPv6 address
like String.indexOf but returns string length not -1 if not present
General Attribute Checking
get 'attribute declaration'
for error reporting
get 'value constraint'
Get the annotation associated witht the local attr decl
1 default and fixed must not both be present.
2 If default and use are both present, use must have the actual value optional.
Recover by honouring the default value
Recover by removing the default value
Recover by removing the default value
check 3.5.6 constraint
Attribute Use Correct
General Attribute Checking
Step 1: get declaration information
get 'target namespace'
get 'value constraint'
for local named attribute, value constraint is absent
get 'type definition'
Handle Anonymous type if there is one
Handle type attribute
Step 3: check against schema for schemas
Step 4: check 3.2.3 constraints
1 default and fixed must not both be present.
2 If default and use are both present, use must have the actual value optional.
This is checked in "traverse" method
3 If the item's parent is not <schema>, then all of the following must be true:
3.1 One of ref or name must be present, but not both.
This is checked in XSAttributeChecker
3.2 If ref is present, then all of <simpleType>, form and type must be absent.
Attributes are checked in XSAttributeChecker, elements are checked in "traverse" method
4 type and <simpleType> must not both be present.
Step 5: check 3.2.6 constraints
check for NOTATION type
Recover by removing the default value
Recover by removing the default value
Attribute without a name. Return null.
Step 2: register attribute decl to the grammar
also add it to extended map
throws an error if the constraint value is invalid for the given type
validate the original lexical rep, and set the actual value
validate the canonical lexical rep
throws an error if the constraint value is invalid for the given type
validate the original lexical rep, and set the actual value
validate the canonical lexical rep
-- This file was mechanically generated: Do not edit! --
last deflater buffer. Fit trailer at the end
if we can't fit the trailer at the end of the last
deflater buffer, we write it separately
Magic number (short)
Magic number (short)
Compression method (CM)
Modification time MTIME (int)
Modification time MTIME (int)
Modification time MTIME (int)
Modification time MTIME (int)
Extra flags (XFLG)
Operating system (OS)
CRC-32 of uncompr. data
Number of uncompr. bytes
2^8 = 256
2^10 = 1k
The XMLDTDDescription with which this Grammar is associated
is this grammar immutable?  (fully constructed and not changeable)
here saves the content spec binary trees for element decls,
each element with a content model will hold a pointer which is
the index of the head node of the content spec tree.
for buildSyntaxTree method
additional fields(columns) for the element Decl pool in the Grammar
additional fields(columns) for the attribute Decl pool in the Grammar
for mixedElement method
return the XMLDTDDescription object with which this is associated
keep track of this entity before fEntityDepth is increased
check if it is already defined
duplicate element, ignored.
create element decl
add(or set) this elementDecl to the local cache
set internal structure
if ElementDecl has already being created in the Grammar then remove from table,
then it is forward reference to a element decl, create the elementDecl first.
create element decl
add(or set) this elementDecl to the local cache
set internal structure
Get Grammar index to grammar array
return, when more than one definition is provided for the same attribute of given element type
only the first declaration is binding and later declarations are ignored
Create current Attribute Decl
REVISIT: Report error message. -Ac
REVISIT: The datatype should be stored with the attribute value
and not special-cased in the XMLValidator. -Ac
externalEntityDecl(String, XMLResourceIdentifier, Augmentations)
make sure our description contains useful stuff...
we don't know what the root is; so use possibleRoots...
sets the source of this handler
returns the source of this handler
set content model source
get content model source
REVISIT: Make this getAttributeDeclCount/getAttributeDeclAt. -Ac
lookup content spec node
If we have one, just return that. Otherwise, gotta create one
Get the type of content this element has
And create the content model according to the spec type
Just create a mixel content model object. This type of
content model is optimized for mixed content validation.
This method will create an optimal model for the complexity
of the element's defined model. If its simple, it will create
a SimpleContentModel object. If its a simple list, it will
create a SimpleListContentModel object. If its complex, it
will create a DFAContentModel object.
Add the new model to the content model for this element
create content spec node
set content spec node values
create content spec node
set content spec node values
create content spec node
set content spec node values
Get the content spec node for the element we are working on.
This will tell us what kind of node it is, which tells us what
kind of model we will try to create.
let fall through to build a DFAContentModel
Check that the left value is not -1, since any content model
with PCDATA should be MIXED, so we should not have gotten here.
Its a single leaf, so its an 'a' type of content model, i.e.
just one instance of one element. That one is definitely a
simple content model.
Lets see if both of the children are leafs. If so, then it
it has to be a simple content model
Its a simple choice or sequence, so we can do a simple
content model for it.
Its a repetition, so see if its one child is a leaf. If so
its a repetition of a single element, so we can do a simple
content model for that.
It is, so we can create a simple content model here that
will check for this repetition. We pass -1 for the unused
Its not a simple content model, so here we have to create a DFA
for this element. So we create a DFAContentModel object. He
encapsulates all of the work to create the DFA.
REVISIT: has to be fLeafCount because we convert x+ to x,x*, one more leaf
We will build a node at this level for the new tree
If this node is a leaf, then its an easy one. We just add it
to the tree.
Create a new leaf node, and pass it the current leaf count,
which is its DFA state position. Bump the leaf count after
storing it. This makes the positions zero based since we
store first and then increment.
Its not a leaf, so we have to recurse its left and maybe right
nodes. Save both values before we recurse and trash the node.
Recurse on both children, and return a binary op node
with the two created sub nodes as its children. The node
type is the same type as the source.
And return our new node for this level
Handle any and leaf nodes
resize arrays, if needed
save values and return length
Its not a leaf, so we have to recurse its left and maybe right
nodes. Save both values before we recurse and trash the node.
Private static methods
NOTE: The following set of data is mutually exclusive. It is
written this way because Java doesn't have a native
union data structure. -Ac
for unparsed entity notation!=null
Type-specific CORBA::Object operations
Sep 14, 2000:
Fixed serializer to report IO exception directly, instead at
the end of document processing.
Reported by Patrick Higgins <phiggins@transzap.com>
Can only enter DTD state once. Once we're out of DTD
state, can no longer re-enter it.
Only works if we're going out of DTD mode.
We don't throw an exception, but hold it
until the end of the document.
We don't throw an exception, but hold it
until the end of the document.
We don't throw an exception, but hold it
until the end of the document.
We don't throw an exception, but hold it
until the end of the document.
We don't throw an exception, but hold it
until the end of the document.
We don't throw an exception, but hold it
until the end of the document.
Write anything left in the buffer into the writer.
We don't throw an exception, but hold it
until the end of the document.
We don't throw an exception, but hold it
until the end of the document.
SNMP Runtime import
Invoke a getBulk operation
we need to allocate a new SnmpVarBind. Otherwise the first
sub request will modify the list...
Take the smallest (lexicographically)
Must compare agent used for reply
Take the deeper within the reply
we can assume that the run method is over ...
First go through all the values once ...
May be we should control the position ...
bugId 4641694: must check position in order to avoid
Now update the values which have been repeated
more than once.
List of code-drawn Icons
Accessor functions for Icons. Does the caching work.
don't cache these, bumps don't get updated otherwise
don't cache these, bumps don't get updated otherwise
File Chooser Detail View code
Draw outside edge of each of the documents
Draw little dots next to documents
Same color as outside edge
Draw inner highlight on documents
Draw inner inner highlight on documents
End class FileChooserDetailViewIcon
File Chooser Home Folder code
Draw outside edge of house
left edge of roof
right edge of roof
left edge of chimney
right edge of chimney
left edge of house
right edge of house
bottom edge of house
Draw door frame
same color as edge of house
Draw roof body
top toward bottom
same color as roof body
Paint the house
left of door
right of door
End class FileChooserHomeFolderIcon
File Chooser List View code
Draw outside edge of each of the documents
Draw little dots next to documents
Same color as outside edge
Draw inner highlight on documents
Draw inner inner highlight on documents
End class FileChooserListViewIcon
File Chooser New Folder code
Draw outside edge of folder
Draw inner folder highlight
Draw tab on folder
End class FileChooserNewFolderIcon
File Chooser Up Folder code
Draw outside edge of folder
Draw the UP arrow
same color as edge
Draw inner folder highlight
Draw tab on folder
End class FileChooserUpFolderIcon
Internal Frame Close code
if the inactive window
if inactive and pressed
darkHighlightColor is still "getBlack()"
Some calculations that are needed more than once later on.
16 -> 8
fill inside of box area
the top/left dark higlight - some of this will get overwritten
draw the inside bottom/right highlight
draw the light/outside, bottom/right highlight
draw the "normal" box
far up left
against body of "X"
against body of "X"
one pixel over from the body
Upper left to lower right
Lower left to upper right
End class InternalFrameCloseIcon
Internal Frame Alternate Maximize code (actually, the un-maximize icon)
ul = Upper Left and lr = Lower Right
if the internal frame is inactive
if inactive and pressed
if the button is pressed and the mouse is over it
darkHighlightColor is still "getBlack()"
fill inside the box
draw dark highlight color
extra pixel on bottom
draw lower right light highlight
draw upper left light highlight
draw the main box
Six extraneous pixels to deal with
do the shaft first
do a big block
bottom arrow head
draw the dark highlight
top of arrowhead
left of arrowhead
top of shaft
top,right of arrowhead
draw the light highlight
right of arrowhead
End class InternalFrameAltMaximizeIcon
Code for the default icons that goes in the upper left corner
draw background color for title area
catch four corners and title area
fill body of window
draw light parts of two "bumps"
draw line around edge of title and icon
entire inner edge
top outter edge
right outter edge
bottom outter edge
left outter edge
bottom of title bar area
draw dark part of four "bumps" (same color)
End class InternalFrameDefaultMenuIcon
Internal Frame Maximize code
ul = Upper Left and lr = Lower Right
if the internal frame is inactive
if inactive and pressed
if the button is pressed and the mouse is over it
darkHighlightColor is still "getBlack()"
fill inside the box
down,left to up,right - inside box
down,left to up,right - outside box
outside edge of arrow head
outside edge of arrow head
down,left to up,right - inside box
one down from this
outside edge arrow head
outside edge arrow head
main part of arrow
top edge of staff
bottom edge of staff
highlights inside of box
highlights inside of box
top of arrow head
right of arrow head
End class InternalFrameMaximizeIcon
Internal Frame Minimize code
ul = Upper Left and lr = Lower Right
if the internal frame is inactive
if inactive and pressed
if the button is pressed and the mouse is over it
darkHighlightColor is still "getBlack()"
fill inside the box
up right highlight
low left highlight
do the shaft first
do a big block
bottom arrow head
draw the dark highlight
top of arrowhead
left of arrowhead
top of shaft
top,right of arrowhead
draw the light highlight
right of arrowhead
End class InternalFrameMinimizeIcon
End class CheckBoxIcon
Radio button code
PENDING: this isn't quite right, when we're sure it won't
change it needs to be cleaned.
draw Dark Circle (start at top, go clockwise)
Set up colors per RadioButtonModel condition
draw Dark Circle (start at top, go clockwise)
draw Inner Left (usually) White Arc
start at lower left corner, go clockwise
draw Outer Right White Arc
start at upper right corner, go clockwise
End class RadioButtonIcon
Tree Computer Icon code
Fill glass portion of monitor
Draw outside edge of monitor
bottom right base
bottom left base
Draw the edge of the glass
Draw the edge of the CPU
Draw the disk drives
End class TreeComputerIcon
Tree HardDrive Icon code
Draw edges of the disks
Draw the down right shadows
Draw the up left highlight
End class TreeHardDriveIcon
Tree FloppyDrive Icon code
Fill body of floppy
Draw outside edge of floppy
Draw grey-ish highlights
metal disk protector part
top of label
left of label
right of label
Draw label and exposed disk
Draw text on label
End class TreeFloppyDriveIcon
PENDING: Replace this class with CachedPainter.
Draw tab top
Draw folder front
Draw tab bottom
first part of top
second part of top
part of slant 2
part of slant 2
part of slant 2
This data member should not have been exposed.  It's called
isLight, but now it really means isCollapsed.  Since we can't change
any APIs... that's life.
top left dot
top right dot
botom right dot
bottom left dot
Draw Center Dot
top left fill
top right fill
bottom left fill
End class MenuArrowIcon
End class MenuItemArrowIcon
End class CheckBoxMenuItemIcon
End class RadioButtonMenuItemIcon
Draw the frame
Fill in the background
Draw the bumps
Draw the highlight
Draw the frame
Fill in the background
Draw the bumps
Draw the highlight
Used for clipping when the orientation is left to right
Used for clipping when the orientation is right to left
Draw the frame
Used for clipping
Fill in the background
Draw the frame
The provider implementation (delegate)
Has this object been initialized?
default impl returns zero, which disables the calling
pointer to current position.
should this be of type javax.xml.stream.Attribute ?
make sure that only last returned item can be removed.
remove the attribute at current index and lower the current position by 1.
either the next method has been called yet, or the remove method has already been called
after the last call to the next method.
XXX print backtrace of cause
XXX print backtrace of cause
XXX print backtrace of cause
ScrollBar arrow buttons can be non-square when
the ScrollBar.squareButtons property is set to FALSE
and the ScrollBar.buttonSize property is non-null
For all other cases (including Spinner, ComboBox), we will
fall back on the single ArrowButton.size value to create
a square return value
handle scaling for sizeVarients for special case components. The
key "JComponent.sizeVariant" scales for large/small/mini
components are based on Apples LAF
Deal with overflow
Log wrapper class for Sun private system exceptions in group INTERCEPTORS
Generated by MC.java version 1.0, DO NOT EDIT BY HAND!
Generated from input file c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/corba/src/share/classes/com/sun/corba/se/spi/logging/data/Interceptors.mc on Fri Jul 21 21:58:44 PDT 2017
Extract the signer certs from the list of certificates.
there is no concept of signer certs, so we store the
entire cert array
Go through the list of certs and see if all the certs are
All the certs are signer certs, so we store the entire
extract the signer certs
if p wasn't signed, we don't have a match
all certs in this.certs must be present in certs
write out the total number of certs
write out each cert, including its type
process any new-style certs in the stream (if present)
we know of 3 different cert types: X.509, PGP, SDSI, which
could all be present in the stream at the same time
read the certificate type, and instantiate a certificate
factory of that type (reuse existing factory if possible)
reuse certificate factory
create new certificate factory
store the certificate factory so we can reuse it later
parse the certificate
bind initial name
linearization for top level UnionPathExprs
find all expressions in this Union
Put attribute iterators first
Check if the union contains a reverse iterator
No need to reverse anything if another expression lies on top of this
Create the UnionIterator and leave it on the stack
Add the various iterators to the UnionIterator
Order the iterator only if strictly needed
Only error that can occur:
Contains the names of all references attribute sets
Go through each attribute set and generate a method call
Get the attribute set name
Get the AttributeSet reference from the symbol table
Compile the call to the set's method if the set exists
Generate an error if the attribute set does not exist
private constructor defined to "hide" the default public constructor
Starts the server if it is not already running.
Starts the server if it is not already running.
get the port for the endpoint of the locator
to pick a particular port type.
Type-specific CORBA::Object operations
Flag is set already
Delete flag ?
Flag not set
Set flag ?
============ privates ============
serialization compatibility with JDK1.1
Mask unused bits
Size of range > Long.MAX_VALUE
Split the range in two and concatenate
Note: if the range is [Long.MIN_VALUE, Long.MAX_VALUE) then
the lower range, [Long.MIN_VALUE, 0) will be further split in two
Size of range > Long.MAX_VALUE
Split the range in two and concatenate
Note: if the range is [Long.MIN_VALUE, Long.MAX_VALUE] then
the lower range, [Long.MIN_VALUE, 0), and upper range,
[0, Long.MAX_VALUE], will both be further split in two
Cannot create one of these
Case is ignored
Check the keys for each provider.
We should skip the currentKey if it contains a
whitespace. The reason is: such an entry in the
provider property contains attributes for the
implementation of an algorithm. We are only interested
in entries which lead to the implementation
Node name, followed by description, or
Node name + "/" + AttributeName, followed by description
DSR -- code to try to get a unit scale
Clone the original ParameterBlock; if the ParameterBlock
contains RenderableImage sources, they will be replaced by
This assumes that if there is no renderable source, that there
is a rendered source in paramBlock
Add this rendered image to the ParameterBlock's
list of RenderedImages.
This should never happen
Really limited pool - in this case just creating several at a time...
if (cache.size() <= MAX_CACHE_SIZE)
Hashtable is synchronized thus thread-safe
Fourth try: Load classes via repository
Fourth try: Use default class loader
Adapt the class name to the passed value
computed by serialver tool
Setup the object
Compare the keys by comparing name's id and kind
If id is set is must be equal
If One is Null and the other is not then it's a mismatch
So, return false
If kind is set it must be equal
If One is Null and the other is not then it's a mismatch
So, return false
We have checked all the possibilities, so return true
Return precomputed value
hashcode of a list containing just v is
v.hashCode() + 31, see List.hashCode()
index for backtrack if "*" attempt fails
index for backtrack if "*" attempt fails, +1
Mismatched, can we backtrack to a "*"?
Retry the match one position later in str
ContentHandler.java - handle main document content.
Written by David Megginson
NO WARRANTY!  This class is in the public domain.
$Id: ContentHandler.java,v 1.2 2004/11/03 22:44:51 jsuttor Exp $
end of ContentHandler.java
Sep 14, 2000:
Fixed comments to preserve whitespaces and add a line break
when indenting. Reported by Gervase Markham <gerv@gerv.net>
Sep 14, 2000:
Fixed serializer to report IO exception directly, instead at
the end of document processing.
Reported by Patrick Higgins <phiggins@transzap.com>
Sep 13, 2000:
Aug 25, 2000:
Fixed processing instruction printing inside element content
to not escape content. Reported by Mikael Staldal
Aug 25, 2000:
Added ability to omit comments.
Contributed by Anupam Bagchi <abagchi@jtcsv.com>
Aug 26, 2000:
Fixed bug in newline handling when preserving spaces.
Contributed by Mike Dusseault <mdusseault@home.com>
Aug 29, 2000:
Fixed state.unescaped not being set to false when
entering element state.
Reported by Lowell Vaughn <lvaughn@agillion.com>
DOM L3 implementation
Constructor and initialization
If the output stream has been set, use it to construct
the writer. It is possible that the serializer has been
reused with the same output stream and different encoding.
DOM document serializing methods
Print any PIs and Comments which appeared in 'node'
SAX document handler serializing methods
Nothing to do here. All the magic happens in startDocument(String)
Check if text should be print as CDATA section or unescaped
based on elements listed in the output format (the element
state) or whether we are inside a CDATA section or entity.
Print a CDATA section. The text is not escaped, but ']]>'
appearing in the code must be identified and dealt with.
The contents of a text node is considered space preserving.
check if it is surrogate
The character is not printable -- split CDATA section
If preserving space then hold of indentation so no
excessive spaces are printed at line breaks, escape
the text content without replacing spaces and print
the text breaking only at line breaks.
Print ignorable whitespaces only when indenting, after
all they are indentation. Cancel the indentation to
not indent twice.
Create the processing instruction textual representation.
Make sure we don't have '?>' inside either target or code.
If before the root element (or after it), do not print
the PI directly but place it in the pre-root vector.
Create the processing comment textual representation.
Make sure we don't have '-->' inside the comment.
If before the root element (or after it), do not print
the comment directly but place it in the pre-root vector.
Indent this element on a new line if the first
content of the parent element or immediately
following an element.
Print all the elements accumulated outside of
the root element.
Flush the output, this is necessary for fStrBuffered output.
Nothing to do
SAX content handler serializing methods
SAX DTD/Decl handler serializing methods
Nothing to do here, all the magic occurs in startDocument(String).
Generic node serializing methods methods
Based on the node type call the suitable SAX handler.
Only comments entities and documents which are not
handled by SAX are serialized directly.
skip the CDATA node
transform into a text node
skip the comment node
remove the node
skip this node
skip this node
If there is a document type, use the SAX events to
DOM Level 2 (or higher)
DOM Level 1 -- does implementation have methods?
!! Fall through
By definition this will happen if the node is a document,
document fragment, etc. Just serialize its contents. It will
work well for other nodes that we do not know how to serialize.
Serialize the document declaration appreaing at the head
of very XML document (unless asked not to).
Always serialize these, even if not te first root element.
System identifier must be specified to print DOCTYPE.
If public identifier is specified print 'PUBLIC
<public> <system>', if not, print 'SYSTEM <system>'.
If we accumulated any DTD contents while printing.
this would be the place to print it.
Need to close CData section first
If this is the first content in the element,
change the state to not-empty and close the
opening element tag.
Except for one content type, all of them
are not last element. That one content
type will take care of itself.
Except for one content type, all of them
are not last comment. That one content
type will take care of itself.
Check if text should be print as CDATA section or unescaped
based on elements listed in the output format (the element
state) or whether we are inside a CDATA section or entity.
Print a CDATA section. The text is not escaped, but ']]>'
appearing in the code must be identified and dealt with.
The contents of a text node is considered space preserving.
If preserving space then hold of indentation so no
excessive spaces are printed at line breaks, escape
the text content without replacing spaces and print
the text breaking only at line breaks.
Text pretty printing and formatting methods
check for ']]>'
REVISIT: this means that if DOM Error handler is not registered we don't report any
fatal errors and might serialize not wellformed document
issue fatal error
split CDATA section
check if it is surrogate
The character is not printable -- split CDATA section
Preserving spaces: the text must print exactly as it is,
without breaking when spaces appear in the text and without
consolidating spaces. If a line terminator is used, a line
break will occur.
Not preserving spaces: print one part at a time, and
use spaces between parts to break them into different
lines. Spaces at beginning of line will be stripped
by printing mechanism. Line terminator is treated
no different than other text part.
Preserving spaces: the text must print exactly as it is,
without breaking when spaces appear in the text and without
consolidating spaces. If a line terminator is used, a line
break will occur.
Not preserving spaces: print one part at a time, and
use spaces between parts to break them into different
lines. Spaces at beginning of line will be stripped
by printing mechanism. Line terminator is treated
no different than other text part.
If there is a suitable entity reference for this
character, print it. The list of available entity
references is almost but not identical between
XML and HTML.
Non printables are below ASCII space but not tab or line
terminator, ASCII delete, or above a certain Unicode threshold.
Element state handling methods
Need to create a larger array of states. This does not happen
often, unless the document is really deep.
this is to make the stack depth consistent with 1.1
this is to make the stack depth consistent with 1.1
this is to make the stack depth consistent with 1.1
this is to make the stack depth consistent with 1.1
this is to make the stack depth consistent with 1.1
now close any remaining streams.
Suppress any remaining exceptions
Package found, so check package sealing.
Verify that code source URL is the same.
Make sure we are not attempting to seal the package
at this code source URL.
Also called by VM to define Package for classes loaded from the CDS
parallel-capable class loaders: re-verify in case of a
Should never happen
Check if package already loaded.
Now read the class bytes and define the class
Use (direct) ByteBuffer:
must read certificates AFTER reading bytes.
if the permission has a separator char on the end,
it means the codebase is a directory, and we need
to add an additional permission to read recursively
make sure the person that created this class loader
would have this permission
Save the caller's context
Need a privileged block to create the class loader
Save the caller's context
Need a privileged block to create the class loader
First check if we have permission to access the package. This
should go away once we've added support for exported packages.
ELEMNAME_ANCHOR_PATTERN = 23,
ELEMNAME_DEFINECONSTANT = 29,
ELEMNAME_DEFINEMACRO = 10,
Pattern by example support
ELEMNAME_WITHPARAM = 56,
namespace declaration prefix -- NOT an attribute by itself
We don't bother excluding the case where the name is
exactly the string "MXBean" since that would mean there
was no package name, which is pretty unlikely in practice.
Check interface for MXBean compliance
Check interface for MBean compliance
p should now be the JList.
Strings get interned...
time to fire off characters event
no namespace support for HTML
no namespace support for HTML
no namespace support for HTML
End of file.
The following code was generated by CUP v0.10j
Thu Oct 06 10:09:26 PDT 2005
Priority is set by hand if no other predicates exist
Set priority for case prefix:* and prefix:@* (no predicates)
Is it a local var or param ?
QName ::= ID
QName ::= SELF
QName ::= PRECEDINGSIBLING
QName ::= PRECEDING
QName ::= PARENT
QName ::= NAMESPACE
QName ::= FOLLOWINGSIBLING
QName ::= FOLLOWING
QName ::= DESCENDANTORSELF
QName ::= DESCENDANT
QName ::= CHILD
QName ::= ATTRIBUTE
QName ::= ANCESTORORSELF
QName ::= ANCESTOR
QName ::= KEY
QName ::= MOD
QName ::= DIV
QName ::= QNAME
NameTest ::= QName
NameTest ::= STAR
NodeTest ::= PI
NodeTest ::= PIPARAM LPAREN Literal RPAREN
NodeTest ::= COMMENT
NodeTest ::= TEXT
NodeTest ::= NODE
NodeTest ::= NameTest
Argument ::= Expr
VariableName ::= QName
FunctionName ::= QName
NonemptyArgumentList ::= Argument COMMA NonemptyArgumentList
NonemptyArgumentList ::= Argument
FunctionCall ::= FunctionName LPAREN NonemptyArgumentList RPAREN
Special case for extension function nodeset()
FunctionCall ::= FunctionName LPAREN RPAREN
VariableReference ::= DOLLAR VariableName
An empty qname prefix for a variable or parameter reference
should map to the null namespace and not the default URI.
PrimaryExpr ::= FunctionCall
PrimaryExpr ::= REAL
PrimaryExpr ::= INT
PrimaryExpr ::= Literal
PrimaryExpr ::= LPAREN Expr RPAREN
PrimaryExpr ::= VariableReference
FilterExpr ::= PrimaryExpr Predicates
FilterExpr ::= PrimaryExpr
AbbreviatedStep ::= DDOT
AbbreviatedStep ::= DOT
AxisName ::= SELF
AxisName ::= PRECEDINGSIBLING
AxisName ::= PRECEDING
AxisName ::= PARENT
AxisName ::= NAMESPACE
AxisName ::= FOLLOWINGSIBLING
AxisName ::= FOLLOWING
AxisName ::= DESCENDANTORSELF
AxisName ::= DESCENDANT
AxisName ::= CHILD
AxisName ::= ATTRIBUTE
AxisName ::= ANCESTORORSELF
AxisName ::= ANCESTOR
AxisSpecifier ::= ATSIGN
AxisSpecifier ::= AxisName DCOLON
Step ::= AbbreviatedStep
Step ::= AxisSpecifier NodeTest
Step ::= AxisSpecifier NodeTest Predicates
Step ::= NodeTest Predicates
Step ::= NodeTest
AbbreviatedAbsoluteLocationPath ::= DSLASH RelativeLocationPath
Expand '' into '/descendant-or-self::node()/' or
AbbreviatedRelativeLocationPath ::= RelativeLocationPath DSLASH Step
Compress '.child:E' into 'descendant::E' - if possible
Expand 'rlpchild::E' into 'rlp/descendant::E'
Expand '.step' -> 'descendant-or-self::*/step'
Expand 'rlpstep' -> 'rlp/descendant-or-self::*/step'
Expand 'rlpstep' -> 'rlp/descendant-or-self::*/step'
Expand 'rlpstep' -> 'rlp/descendant-or-self::node()/step'
AbsoluteLocationPath ::= AbbreviatedAbsoluteLocationPath
AbsoluteLocationPath ::= SLASH RelativeLocationPath
AbsoluteLocationPath ::= SLASH
RelativeLocationPath ::= AbbreviatedRelativeLocationPath
RelativeLocationPath ::= RelativeLocationPath SLASH Step
Remove './' from the middle
Remove '/.' from the end
RelativeLocationPath ::= Step
LocationPath ::= AbsoluteLocationPath
LocationPath ::= RelativeLocationPath
PathExpr ::= FilterExpr DSLASH RelativeLocationPath
Expand '' into '/descendant-or-self::node()/' or
PathExpr ::= FilterExpr SLASH RelativeLocationPath
PathExpr ::= FilterExpr
PathExpr ::= LocationPath
UnionExpr ::= PathExpr VBAR UnionExpr
UnionExpr ::= PathExpr
UnaryExpr ::= MINUS UnaryExpr
UnaryExpr ::= UnionExpr
MultiplicativeExpr ::= MultiplicativeExpr MOD UnaryExpr
MultiplicativeExpr ::= MultiplicativeExpr DIV UnaryExpr
MultiplicativeExpr ::= MultiplicativeExpr STAR UnaryExpr
MultiplicativeExpr ::= UnaryExpr
AdditiveExpr ::= AdditiveExpr MINUS MultiplicativeExpr
AdditiveExpr ::= AdditiveExpr PLUS MultiplicativeExpr
AdditiveExpr ::= MultiplicativeExpr
RelationalExpr ::= RelationalExpr GE AdditiveExpr
RelationalExpr ::= RelationalExpr LE AdditiveExpr
RelationalExpr ::= RelationalExpr GT AdditiveExpr
RelationalExpr ::= RelationalExpr LT AdditiveExpr
RelationalExpr ::= AdditiveExpr
EqualityExpr ::= EqualityExpr NE RelationalExpr
EqualityExpr ::= EqualityExpr EQ RelationalExpr
EqualityExpr ::= RelationalExpr
AndExpr ::= AndExpr AND EqualityExpr
AndExpr ::= EqualityExpr
OrExpr ::= OrExpr OR AndExpr
OrExpr ::= AndExpr
Expr ::= OrExpr
Predicate ::= LBRACK Expr RBRACK
Predicates ::= Predicate Predicates
Predicates ::= Predicate
ChildOrAttributeAxisSpecifier ::= ATTRIBUTE DCOLON
ChildOrAttributeAxisSpecifier ::= CHILD DCOLON
ChildOrAttributeAxisSpecifier ::= ATSIGN
NameTestPattern ::= QName
NameTestPattern ::= STAR
NodeTestPattern ::= PI
NodeTestPattern ::= COMMENT
NodeTestPattern ::= TEXT
NodeTestPattern ::= NODE
NodeTestPattern ::= NameTestPattern
StepPattern ::= ChildOrAttributeAxisSpecifier ProcessingInstructionPattern Predicates
TODO: report error if axis is attribute
StepPattern ::= ChildOrAttributeAxisSpecifier ProcessingInstructionPattern
TODO: report error if axis is attribute
StepPattern ::= ChildOrAttributeAxisSpecifier NodeTestPattern Predicates
StepPattern ::= ChildOrAttributeAxisSpecifier NodeTestPattern
StepPattern ::= ProcessingInstructionPattern Predicates
StepPattern ::= ProcessingInstructionPattern
StepPattern ::= NodeTestPattern Predicates
StepPattern ::= NodeTestPattern
RelativePathPattern ::= StepPattern DSLASH RelativePathPattern
RelativePathPattern ::= StepPattern SLASH RelativePathPattern
RelativePathPattern ::= StepPattern
ProcessingInstructionPattern ::= PIPARAM LPAREN Literal RPAREN
IdKeyPattern ::= KEY LPAREN Literal COMMA Literal RPAREN
IdKeyPattern ::= ID LPAREN Literal RPAREN
LocationPathPattern ::= RelativePathPattern
LocationPathPattern ::= DSLASH RelativePathPattern
LocationPathPattern ::= IdKeyPattern DSLASH RelativePathPattern
LocationPathPattern ::= IdKeyPattern SLASH RelativePathPattern
LocationPathPattern ::= IdKeyPattern
LocationPathPattern ::= SLASH RelativePathPattern
LocationPathPattern ::= SLASH
Pattern ::= LocationPathPattern VBAR Pattern
Pattern ::= LocationPathPattern
TopLevel ::= EXPRESSION Expr
TopLevel ::= PATTERN Pattern
$START ::= TopLevel EOF
implements JMXConnector interface
Get RMIServer stub from directory or URL encoding if needed.
Check for secure RMIServer stub if the corresponding
client-side environment property is set to "true".
Connect IIOP Stub if needed.
Calling newClient on the RMIServer stub.
Always use one of:
ClassLoader provided in Map at connect time,
or contextClassLoader at connect time.
The connectionId variable is used in doStart(), when
reconnecting, to identify the "old" connection.
we do a remote call to have an IOException if the connection is broken.
see the bug 4939578
allows to do close after setting the flag "terminated" to true.
It is necessary to avoid a deadlock, see 6296324
Return if already cleanly closed.
Already closed, but not cleanly. Attempt again.
OK, the server maybe closed itself.
Clean up MBeanServerConnection table
throw exception if needed
added for re-connection
added for re-connection
send a failed notif if necessary
Implementation of MBeanServerConnection
Specific Notification Handle ----------------------------------
used for a successful re-connection
or a transient network problem
Examine the chain of exceptions to determine whether this
is a deserialization issue. If so - we propagate the
appropriate exception to the caller, who will then
proceed with fetching notifications one by one
reconnection OK, back to "while" to do again
the connection is closed.
We received an IOException - but the communicatorAdmin
did not close the connection - possibly because
the original exception was raised by a transient network
We already know that this exception is not due to a deserialization
issue as we already took care of that before involving the
communicatorAdmin. Moreover - we already made one retry attempt
at fetching the same batch of notifications - and the
Since trying again doesn't seem to solve the issue, we will now
close the connection. Doing otherwise might cause the
NotifFetcher thread to die silently.
We are closing
the connection is closed here.
JDK-8049303 possible transient network problem,
let's try one more time
specially treating for an UnmarshalException
the fix of 6937053 made ClientNotifForwarder.fetchNotifs
fetch one by one with UnmarshalException
IIOP will throw MarshalException wrapping a NotSerializableException
when a server fails to serialize a response.
Not serialization problem, return.
need to restart
check if the connection is broken
we should close the connection,
but send a failed notif at first
We are closing
forward the exception
OK, we will do one by one
Get RMIServer stub from directory or URL encoding if needed.
Connect IIOP Stub if needed.
Calling newClient on the RMIServer stub.
Private stuff - Serialization
Initialization of transient variables.
Private stuff - Check if stub can be trusted.
Check remote stub is from the expected class.
Check RemoteRef in stub is from the expected class
Check RMIClientSocketFactory in stub is from the expected class
Private stuff - RMIServer creation
Make sure java.naming.corba.orb is in the Map.
could forbid "rmi:" URL here -- but do we need to?
could forbid "iiop:" URL here -- but do we need to?
so just return the original stub, which will work for all
but the most exotic class loading situations
Translate all full groups from base64 to byte array elements
Translate partial group, if present
Private stuff - Find / Set default class loader
WARNING - WARNING - WARNING - WARNING - WARNING - WARNING
Any transient variable which needs to be initialized should
be initialized in the method initTransient()
TRACES & DEBUG
Delegate our fitness test to ContainerOrder so that we only have to
code the algorithm once.
using default sorting algo
Fix for 5070991.
A workaround for a transitivity problem caused by ROW_TOLERANCE,
because of that the component may be missed in the binary search.
Try to search it again directly.
Before all the ckecks below we first see if it's an FTP provider or a focus cycle root.
If it's the case just go down cycle (if it's set to "implicit").
See if the component is inside of policy provider.
FTP knows how to find component after the given. We don't.
Null result means that we overstepped the limit of the FTP's cycle.
In that case we must quit the cycle, otherwise return the component found.
See if the component is inside of policy provider.
FTP knows how to find component after the given. We don't.
Null result means that we overstepped the limit of the FTP's cycle.
In that case we must quit the cycle, otherwise return the component found.
If the provider is traversable it's returned.
Create our own subclass and change accept to public so that we can call
-- This file was mechanically generated: Do not edit! --
enforce limit == capacity
The method reference action::accept is never null
The method reference action::accept is never null
The method reference action::accept is never null
Explicit instantiation of this class is prohibited.
[if an error occurstype map used??]
this shouldn't happen, since we are Cloneable
----------------------- Multiple Results --------------------------
--------------------------JDBC 4.1 -----------------------------
--------------------------JDBC 4.2 -----------------------------
Fixed constants for Java IDL object key template forms
write out serverid, orbid, oaid
All subclasses should set the version in their constructors.
Public so it can be used in a white-box test.
test "from" value, "to" value will be tested by setValue()
ABSTRACT METHOD IMPLEMENTATIONS: CONTROL
Get the name of the requested service
Look it up
Write reply value
Marshal the exception thrown
DefaultHandler2.java - extended DefaultHandler
Public Domain: no warranty.
$Id: DefaultHandler2.java,v 1.2 2004/11/03 22:49:08 jsuttor Exp $
SAX2 ext-1.0 LexicalHandler
SAX2 ext-1.0 DeclHandler
SAX2 ext-1.1 EntityResolver2
Do not access the location path itterator during this operation!
If you don't check for the cloneList here, you'll go into an
recursive infinate loop.
First, look for clone on list.
=============== TreeWalker Implementation ===============
%OPT% Get this directly from the lpi.
I shouldn't have to do this the check for current node, I think.
numbering\numbering24.xsl fails if I don't do this.  I think
it occurs as the walkers are backing up. -sb
if(null != nextNode)
while(null != walker)
============= End TreeWalker Implementation =============
TODO: Should probably save this in the iterator.
============= State Data =============
raises exception on error
GIOP 1.2 LocateReply message bodies are not aligned on
8 byte boundaries.
The code below reads the reply body in some cases
LOC_SYSTEM_EXCEPTION & OBJECT_FORWARD & OBJECT_FORWARD_PERM &
read GIOP::AddressingDisposition from body and resend the
original request using the requested addressing mode. The
resending is transparent to the caller.
Note, this writes only the header information. SystemException or
IOR or GIOP::AddressingDisposition may be written afterwards into the
reply mesg body.
GIOP 1.2 LocateReply message bodies are not aligned on
8 byte boundaries.
default transparnt pixel
one slot for transparent color
nothing to reduce
look for element with lower color count
save pointer to first reducible node
NB: current color count for node could be changed in future
we need to process it
No instances for you.
Default equals and hashCode are fine.
helpful exception message
Construct the exception that we will probably throw
No compatibility requirement here
Is the compatibility property set?
We don't expect an exception here but if we get one then
we'll simply assume that the property is not set.
better refer to these two class names like this, rather than hardcoding a string,
in case the package of these classes should change (who knows...)
We trust bootstrap classes.
Check if className describes an array class, and determines its elements' class name.
(eg: a 3-dimensional array of Strings has for class name: "[[[Ljava.lang.String;")
class name of array elements
removes the n leading '[' + the 'L' characters
and the last ';' character
removes the n leading '[' characters
not an array
Check that eltClassName's value is one of the allowed basic data types for open data
A version of getClassName() that can only be called from within this
package and that cannot be overridden.
Attributes2Impl.java - extended AttributesImpl
Public Domain: no warranty.
$Id: Attributes2Impl.java,v 1.3 2005/02/24 11:20:18 gg156739 Exp $
Implementation of Attributes2
javadoc mostly from interface
javadoc mostly from interface
javadoc mostly from interface
javadoc entirely from superclass
Serialization compatibility stuff:
Two serial forms are supported in this class. The selected form depends
on system property "jmx.serial.form":
- "1.0" for JMX 1.0
- any other value for JMX 1.1 and higher
Serial version for old serial form
Serial version for new serial form
Serializable fields in old serial form
Serializable fields in new serial form
Actual serial version and serial form
OK: No compat with 1.0
END Serialization compatibility stuff
Java doc inherited from MOdelMBeanInfo interface
if no descriptors of that type, will return empty array
throw RuntimeOperationsException - invalid descriptor
empty list, no-op
throw RuntimeOperationsException - invalid descriptor
Read an object serialized in the old serial form
Read an object serialized in the new serial form
Serializes this instance in the old serial form
Serializes this instance in the new serial form
Tell our listeners that "everything" has changed.
NO defensive copy
select all nodes, also the comments.
if a not-wellformed nodeset exists, put a container around it...
Get the value from the MBeanServer
this class is only used by JDK chronology implementations and makes assumptions based on that fact
Call two argument add method.
Call two argument remove method.
REMIND: this is NOT getting called
fix for bug 4153892
For better backward compatibility, only install inactive
properties if they are defined.
remove the old html view client property if one
existed, and install a new one if the text installed
into the JLabel is html source.
Note that info is shared across multiple threads
using the same subcontract, each of which may
have its own operation.  Therefore we need to copy it.
Use a shared daemon timer to serve all the WaitDispatchSupports
When this WDS expires, we cancel the timer task leaving the
shared timer up and running
We have two mechanisms for blocking: if we're on the
dispatch thread, start a new event pump; if we're
on any other thread, call wait() on the treelock
Dispose SequencedEvent we are dispatching on the the current
AppContext, to prevent us from hang - see 4531693 for details
In case the exit() method is called before starting
new event pump it will post the waking event to EDT.
The event will be handled after the the new event pump
starts. Thus, the enter() method will not hang.
Event pump should be privileged. See 6300270.
If the waiting process has been stopped because of the
time interval passed or an exception occurred, the state
should be changed
The default subcontract ID to use if
there is no more specific ID available.
This happens when invoking a foreign IOR.
Set of all ObjectAdapterFactory instances
Read-only view of oaf instances
Map from obect key string to
for special bootstrap IORs
Methods to find the subcontract side subcontract
Note that both forms of getServerRequestDispatcher need to return
the default server delegate if no other match is found.
This is essential to proper handling of errors for
malformed requests.  In particular, a bad MAGIC will
result in a lookup in the named key table (stringToServerSubcontract),
which must return a valid ServerRequestDispatcher.  A bad subcontract ID
will similarly need to return the default ServerRequestDispatcher.
now parse rawdata
"random" value for empty lists
both null -> equal, only one null -> not equal
eat the ';'
now parse the parameter name
find the end of the token char run
now parse the '=' that separates the name from the value
eat it and parse the parameter value
now find out whether or not we have a quoted value
yup it's quoted so eat it and capture the quoted string
find the next unescqped quote
found an escape sequence so pass this and the next character
eat the quote
nope it's an ordinary token so it ends with a non-token char
it ain't a value
now put the data into the hashtable
setup the next iteration
Heuristic: 8 characters per field
below here be scary parsing related things
check to see if we actually have to quote this thing
add the initial quote
add the properly escaped text
add the closing quote
Same for all primitives; name of the boxing method
Table of opcodes for widening primitive conversions; NOP = no conversion
Table of wrappers for primitives, indexed by ASM type sorts
Not a class type (array or method), so not a boxed type
or not in the right package
Pare it down to the simple class name
Hash to a Wrapper
In descriptor form
Already in internal name form
Both primitives: widening
Primitive argument to reference target
The target is a boxed primitive type, widen to get there before boxing
Otherwise, box and cast
Cast to convert to possibly more specific type, and generate CCE for invalid arg
Reference argument to primitive target
Boxed number to primitive
Character or Boolean
Source type is reference type, but not boxed type,
assume it is super type of target type
Boxed number to primitive
Character or Boolean
Both reference types: just case to target type
fallthrough in switch is expected, suppress it
Allocate only segments[SEG_RAW] here. The rest are
allocated on demand.
just copy quotes in parts
throw away other segments
Skip any leading space chars for SEG_TYPE.
fall through, so we keep quotes in other parts
later, make this more extensible
do nothing, string format
match up to format
leave index as is to signal error
now use format
if at end, use longest possible match
otherwise uses first match to intervening string
does NOT recursively try all possibilities
leave index as is to signal error
leave index as is to signal error
leave index as is to signal error
unchanged, returned object is null
clone arrays. Can't do with utility because of bug in Cloneable
for primitives or immutables, shallow clone is enough
enough for reasonable distribution
Proclaim serial compatibility with 1.4 FCS
note: this implementation assumes a fast substring & index.
if this is not true, would be better to append chars one by one.
format number if can
format a Date if can
At this point we are in two states, either subFormatter
is non-null indicating we should format obj using it,
or arg is non-null and we should use it as the value.
If characterIterators is non-null, it indicates we need
to get the CharacterIterator from the child formatter.
Indices for segments
modifier or subformat
Indices for type keywords
Indices for number modifiers
common in number and date-time
Indices for date-time modifiers
Date-time style values corresponding to the date-time modifiers.
get the argument number
resize format information arrays if necessary
now get the format
Try trimmed lowercase.
Make sure you clone the following mutable arrays before passing to
potentially untrusted objects such as OutputStreams.
Fills the nssymbtable with the definitions of the parent of the root subnode
illegal node type during traversal
Add a level to the nssymbtable. So latter can be pop-back.
we output all Attrs which are available
We finished with this level, pop to the previous definitions.
We finished with this level, pop to the previous definitions.
illegal node type during traversal
Add a level to the nssymbtable. So latter can be pop-back.
we output all Attrs which are available
We finished with this level, pop to the previous definitions.
We finished with this level, pop to the previous definitions.
Obtain all the parents of the element
Visit them in reverse order.
The null xmlns definition.
If this is the composed text element, merge the content attribute to it
Make sure we send out a change for the length of the paragraph.
grabs a write-lock for this initialization and
abandon it during initialization so in normal
operation we can detect an illegitimate attempt
to mutate attributes.
Should handle this better
Should handle this better
Elements were inserted, do the cleanup.
We don't want a newline if elem is a leaf, and doesn't contain
If we are going to insert the string into the body
section, it is necessary to set the corrsponding flag.
Cleanup the flag, if any.
For some leaf elements we store the actual attributes inside
the AttributeSet of the Element (such as anchors).
Found it, do the insert.
index must be > 0 otherwise no insert would have happened.
e.getElement(index - 1) should represent the newline.
The hiearchies don't match, we'll have to manually
recreate the leaf at e.getElement(index - 1)
The hierarchies for the end Element and
e.getElement(index - 1), match, we can safely remove
the Elements and the end content will be aligned
Not a leaf, descend until we find the leaf representing
start - 1 and remove it.
These two are provided for inner class access. The are named different
than the super class as the super class implementations are final.
Provided for inner class access.
we found the next one
PENDING(sky): Add throws BadLocationException and remove
register handlers for the well known tags
Previous isn't in body, but current is. Have to
do some end specs, followed by join next.
Insert a newline, if necessary.
Should never throw, but will catch anyway.
We should probably throw an exception if (count == -1)
Or look for the body and reset the offset.
Remove the fake second body.
Insert a new element to represent the end that the
second body was representing.
We now have two \n's, one part of the Document.
We need to remove one
Mark the edit as done.
-- HTMLEditorKit.ParserCallback methods --------------------
We won't insert when
see if complex glyph layout support is needed
if a default direction of right-to-left has been specified,
we want complex layout even if the text is all left to right.
Assume content should be added.
If content is added directly to the body, it should
be wrapped by p-implied.
Increment inBlock since we know we are in the body,
this is needed incase an implied-p is needed. If
inBlock isn't incremented, and an implied-p is
encountered, addContent won't be called!
Map the style attributes.
Comment outside of body, will not be able to show it,
but can add it as a property on the Document.
No place to put comment.
Map the style attributes.
unknown tag, only add if should preserve it.
---- tag handling support ------------------------------
initialize a ButtonGroupsMap when
FORM tag is encountered.  This will
be used for any radio buttons that
might be defined in the FORM.
for new group new ButtonGroup will be created (fix for 4529702)
group name is a key in radioButtonGroupsMap
reset the button group to null since
the form has ended.
This check of the insertTag is put in to avoid considering
the implied-p that is generated for the head. This allows
inserts for HR to work correctly.
See if there is a StyleSheet to link to.
First element gives type.
Only choose if type==text/css
Select link if rel==stylesheet.
Otherwise if rel==alternate stylesheet and
title matches default style.
set inPre to false after closing, so that if a newline
is added it won't generate a blockOpen.
Note that the third argument should really be based off
inParagraph and impliedP. If we're wrong (that is
insertTagDepthDelta shouldn't be changed), we'll end up
removing an extra EndSpec, which won't matter anyway.
Note that the third argument should really be based off
inParagraph and impliedP. If we're wrong (that is
insertTagDepthDelta shouldn't be changed), we'll end up
removing an extra EndSpec, which won't matter anyway.
We also need to add attr, otherwise we lose custom
attributes, including class/id for style lookups, and
further confuse style lookup (doesn't have tag).
set flag to catch empty anchors
if the anchor was empty it was probably a
named anchor point and we don't want to throw
build the element, unless this is an option.
plain text model
plain text model
fix for 4772743
--- utility methods used by the reader ------------------
Should do something reasonable
Add a new line, if the last character wasn't one. This is
needed for proper positioning of the cursor. addContent
with true will force an implied paragraph to be generated if
there isn't one. This may result in a rather bogus structure
(perhaps a table with a child pargraph), but the paragraph
is needed for proper positioning and display.
an open/close with no content will be removed, so we
add a space of content to keep the element being formed.
Set this to avoid generating a newline for frames, frames
shouldn't have any content, and shouldn't need a newline.
When inserting via an insertTag, the depths (of the tree
being read in, and existing hierarchy) may not match up.
This attemps to clean it up.
If this starts with content (or popDepth > 0 &&
pushDepth > 0) and ends with EndTagTypes, make sure
the last content isn't a \n, otherwise will end up with
an extra \n in the middle of content.
Make sure there is in fact a newline
Allow the insert if t matches the insert tag, or
insertAfterImplied is true and the element is implied.
Need to insert a newline.
Determine if we can use JoinPrevious, we can't
if the Element has some attributes that are
not meant to be duplicated.
If not joining with the previous element, be
sure and set the name (otherwise it will be
A start spec will be added (for this tag), so we account
for it here.
An implied paragraph close (end spec) is going to be added,
so we account for it here.
always return a ValueDef or throw BAD_PARAM if
<em>repid</em> does not represent a valuetype
inner class AccessibleAWTCanvas
* Get the description of the value of this object.
* @return description of the value of the object
inner class AccessibleJRadioButtonMenuItem
-- This file was mechanically generated: Do not edit! --
For duplicates and slices
Insure that its one of the types we require
Store the node and init any data that needs it
Package, final methods
Package, inherited methods
For debugging purposes, make sure we got rid of all non '*'
repetitions. Otherwise, '*' style nodes are always nullable.
Protected, inherited methods
Its just based on our child node's first pos
Its just based on our child node's last pos
Private data members
This is the reference to the one child that we have for this
The ORB that created this Codec Factory
The maximum minor version of GIOP supported by this codec factory.
Currently, this is 1.2.
The pre-created minor versions of Codec version 1.0, 1.1, ...,
Precreate a codec for version 1.0 through
1.(MAX_MINOR_VERSION_SUPPORTED).  This can be
done since Codecs are immutable in their current implementation.
This is an optimization that eliminates the overhead of creating
a new Codec each time create_codec is called.
This is the only format we can currently create codecs for:
Store the information
Leaf nodes are never nullable unless its an epsilon node
If we are an epsilon node, then the first pos is an empty set
Otherwise, its just the one bit of our position
If we are an epsilon node, then the last pos is an empty set
Otherwise, its just the one bit of our position
root -> ImageDescriptor
/ Should the max value be 1.7976931348623157e+308 ?
root -> Palette
root -> Palette -> PaletteEntry
root -> CommentExtensions
root -> CommentExtensions -> CommentExtension
pass a dummy InputSource. We don't care
this object will pretend as an XMLReader.
no matter what parameter is specified to the parse method,
it just parse the contentObject.
we will store this value but never use it by ourselves.
SAX allows ContentHandler to be changed during the parsing,
but JAXB doesn't. So this repeater will sit between those
parses a content object by using the given marshaller
SAX events will be sent to the repeater, and the repeater
will further forward it to an appropriate component.
wrap it to a SAXException
if the consumer sets an error handler, it is our responsibility
to notify it.
this is a fatal error. Even if the error handler
returns, we will abort anyway.
true if copyObjects call needs for args
true if copyObject call needs for result
Assume that cls is not Remote, !isAnyClass(cls), and
!org.omg.CORBA.Object.class.isAssignableFrom( cls ).
Then return whether cls is an RMI-IIOP abstract interface.
Either cls is an interface that extends IDLEntity, or else
cls does not extend java.rmi.Remote and all of its methods
Check that all methods (other than those declared in java.lang.Object)
throw an exception that is a subclass of RemoteException.
Check that some exceptionType is a subclass of RemoteException
For anything else, just read it as a value type.
This could be further optimized to avoid
copying if argTypes contains at most one
immutable object type.
These message should be read from a locale-specific resource bundle
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of ToolTipPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of ToolTipPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
Corresponding BigDecimal rounding constant
read and discard the repository ID
write the repository ID
Execute the XPath, and have it return the result
Return a NodeList.
Create an object to resolve namespace prefixes.
XPath namespaces are resolved from the input context node's document element
if it is a root node, or else the current context node (for lack of a better
resolution space, given the simplicity of this sample code).
Execute the XPath, and have it return the result
The singleton uses the maximum version indicated by our
The chained value isn't a SQLWarning.
This is a programming error by whoever added it to
the SQLWarning chain.  We throw a Java "Error".
if there was an implied CR
if this is non-empty paragraph
When done with the returned Segment it should be released by
the classname should probably come from a property file.
--- TabableView methods --------------------------------------
setting expander can change horizontal span of the view,
so we have to call preferenceChanged()
--- View methods ---------------------------------------------
there's a highlighter (bug 4532590), and
selected text color is different from regular foreground
the selection is out of this view
the whole view is selected
the array is lazily created only when the view
is partially selected
the array represents view positions [0, p1-p0+1]
later will iterate this array and sum its
elements. Positions with sum == 0 are not selected.
the view is partially selected
searching for the next selection start
paint unselected text
searching for next start position of unselected text
render the glyphs
render underline or strikethrough if set.
calculate x coordinates
strip whitespace on end
calculate y coordinate
move y coordinate above baseline
the rest of the view is non-breakable
Note: getBreakSpot returns the *last* breakspot
else, no break in the region, return a fragment of the
Re-calculate breakpoints for the whole view
Breaker should work on the parent element because there may be
a valid breakpoint at the end edge of the view (space, etc.)
Backward search should start from end+1 unless there's NO end+1
The break spot is within the view
checks if the paragraph is empty and updates impliedCR flag
Drop the break spots. They will be re-calculated during
layout. It is necessary for proper line break calculation.
justifiable content start
justifiable content end
states for the parsing
we parse conent to the right of the rightmost TAB only.
we are looking for the trailing and leading spaces.
position after the leading spaces (startContentPosition)
position before the trailing spaces (endContentPosition)
--- variables ------------------------------------------------
if it is an implied newline character
Presumably pos is between startOffset and endOffset,
since GlyphView is only one line, we won't contain
the position to the nort/south, therefore return -1.
End case for bidi text where newline is at beginning
Assumed not used in bidi text, GlyphPainter2 will
override as necessary, therefore return -1.
End case for bidi text where newline is at beginning
Assumed not used in bidi text, GlyphPainter2 will
override as necessary, therefore return -1.
* Tells whether both locks are held by current thread.
return (putLock.isHeldByCurrentThread() &&
Never contended, but necessary for visibility
this doc comment is overridden to remove the reference to collections
greater in size than Integer.MAX_VALUE
this doc comment is a modified copy of the inherited doc comment,
without the reference to unlimited queues.
Note: convention in all put/take/etc is to preset local var
holding count negative to indicate failure unless set.
p.next is not changed, to allow iterators that are
traversing p to maintain their weak-consistency guarantee.
count.get provides visibility to first n Nodes
Restore invariants even if c.add() threw
current node; null until initialized
batch size for splits
true when no more nodes
Write out any hidden stuff, plus capacity
Write out all elements in the proper order.
Use trailing null as sentinel
Read in capacity, and any hidden stuff
Read in all elements and place in queue
Message keys used by the serializer
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The localname is the portion after the optional colon; the message indicates
that there is a problem with that part of the QNAME.
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The prefix is the portion before the optional colon; the message indicates
that there is a problem with that part of the QNAME.
From this point the map should not be modified
Get next line
Continue lines that end in slashes if they are not comments
Advance beyond whitespace on new line
Find start of key
Blank lines are ignored
Find separation between key and value
Skip over whitespace after key if any
Skip over one non whitespace key value separators if any
Skip over white space after other separators if any
Convert then store key and value
We need to store the charset and eoln
parameters, if any, so that the
DataTransferer will have this information
for conversion into the native format.
But don't store any of these parameters in the
DataFlavor itself for any text natives (even
non-charset ones). The SystemFlavorMap will
synthesize the appropriate mappings later.
Read the xxxx
Prepending the platform-specific mappings ensures
that the flavors added with
addFlavorForUnencodedNative() are at the end of
Prepend the platform-specific mappings to ensure
that the natives added with
addUnencodedNativeForFlavor() are at the end of
In this case we shouldn't synthesize a native for this flavor,
since its mappings were explicitly specified.
For text/* flavors, flavor-to-native mappings specified in
flavormap.properties are stored per flavor's base type.
Also include text/plain natives, but don't duplicate Strings
In this branch it is guaranteed that natives explicitly
listed for flav's MIME type were added with
addUnencodedNativeForFlavor(), so they have lower priority.
In this branch it is guaranteed that natives explicitly
listed for flav's MIME type were added with
addUnencodedNativeForFlavor(), so they have lower priority.
Create a copy, because client code can modify the returned list.
Cannot happen, since we checked all mappings
on load from flavormap.properties.
Check for equality to plainTextFlavor so
that we can ensure that the exact charset of
plainTextFlavor, not the canonical charset
or another equivalent charset with a
different name, is used.
Non-charset text natives should be treated as
opaque, 8-bit data in any of its various
Use getNativesForFlavor to generate extra natives for text flavors
Use getFlavorsForNative to generate extra flavors for text natives
Return null if we can't evaluate at compile time
Get the left and right operand types
Check if the operator supports the two operand types
Yes, the operation is supported
Check if left-hand side operand must be type casted
Check if right-hand side operand must be type casted
Return the result type for the operator we will use
Translate left hand side - must be true
Need this for chaining any OR-expression children
Translate left right side - must be true
Need this for chaining any OR-expression children
Append child expression false-lists to our false-list
Special case for OR-expression as a left child of AND.
The true-list of OR must point to second clause of AND.
Special case for OR-expression as a right child of AND
The true-list of OR must point to true-list of AND.
Translate left-hand side expression and produce true/false list
This GOTO is used to skip over the code for the last test
in the case where the the first test succeeds
Translate right-hand side expression and produce true/false list
-- This file was mechanically generated: Do not edit! --
these declarations are here as documentation
lexicalRepresentation must be non-null
Java to IDL ptc 02-01-12 1.4.11
A new ORB started server registers itself with the Activator
Install a particular kind of endpoint
list active servers
If the server is not running, start it up.
If the server is running, shut it down
currently running, this method will activate it.
list all registered ORBs for a server
After this hook completes, the server may still be running.
Starts the server if it is not already running.
Starts the server if it is not already running.
get the port for the endpoint of the locator
to pick a particular port type.
Type-specific CORBA::Object operations
serialVersionUID must be constant
Serialization compatibility stuff:
Two serial forms are supported in this class. The selected form depends
on system property "jmx.serial.form":
- "1.0" for JMX 1.0
- any other value for JMX 1.1 and higher
Serial version for old serial form
Serial version for new serial form
Serializable fields in old serial form
Serializable fields in new serial form
Actual serial version and serial form
OK : Too bad, no compat with 1.0
END Serialization compatibility stuff
Removes from selected ObjectNames, if present
Adds it in deselected ObjectNames
If all are deselected, no need to do anything :)
ObjectName was not already deselected
Removes from deselected ObjectNames, if present
Adds it in selected ObjectNames
If all are selected, no need to do anything :)
ObjectName was not already selected
Checks the type first
We have a MBeanServerNotification: downcasts it
Checks the ObjectName
Is it selected?
Not all are implicitly selected:
checks for explicit selection
All are explicitly not selected
Not in the explicit selected list
Not explicitly selected: is it deselected?
All are implicitly deselected and it is not explicitly
Read an object serialized in the old serial form
Read an object serialized in the new serial form
Serializes this instance in the old serial form
Serializes this instance in the new serial form
SAX parser factory.
No warranty; no copyright -- use this as you will.
$Id: ParserFactory.java,v 1.2 2004/11/03 22:53:09 jsuttor Exp $
Default to 0
Note: offset or count might be near -1>>>1.
Note: offset or count might be near -1>>>1.
Pass 1: Compute precise size of char[]
Pass 2: Allocate and fill in char[]
Argument is a StringBuffer, StringBuilder
Argument is a String
Argument is a generic CharSequence
use serialVersionUID from JDK 1.2.2 for interoperability
No overflow because of numeric promotion
Note: toffset, ooffset, or len might be near -1>>>1.
Note: toffset, ooffset, or len might be near -1>>>1.
If characters don't match but case may be ignored,
try converting both characters to uppercase.
If the results match, then the comparison scan should
Unfortunately, conversion to uppercase does not work properly
for the Georgian alphabet, which has strange rules about case
conversion.  So we need to make one last check before
Note: toffset might be near -1>>>1.
Note: fromIndex might be near -1>>>1.
handle most cases here (ch is a BMP code point or a
negative value (invalid code point))
handle most cases here (ch is a BMP code point or a
negative value (invalid code point))
If no match was found, return this
Add remaining segment
Number of elements not likely worth Arrays.stream overhead.
GREEK CAPITAL LETTER SIGMA
LATIN CAPITAL LETTER I WITH DOT ABOVE
Cannot use Arrays.copyOf because of class initialization order issues
The array to hold all data
Number of elements in this list
This method recurses, traversing towards the root in order
size the array. On the way back, it fills in the nodes,
starting from the root and working back to the original node.
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Save the root, if its Serializable.
End of class DefaultTreeModel
If more modes are added, this should be updated.
Return a deep copy of the array
setters and getters
retrieve the initial set of grammars for the validator
to work with.
REVISIT:  does this need to be synchronized since it's just reading?
retrieve a particular grammar.
REVISIT:  does this need to be synchronized since it's just reading?
give the grammarPool the option of caching these grammars.
This certainly must be synchronized.
given to the validator may be included).
better give both grammars a shot...
unregister server definition
get server definition
Return whether the server has been installed
if the server is currently marked as installed.
if the server is currently marked as uninstalled.
list registered servers
Find the ServerID associated with the given application name.
Methods for reading attributes from the stream of SQL data.
These methods correspond to the column-accessor methods of
Methods for reading items of SQL user-defined types from the stream.
---------------------------- JDBC 3.0 -------------------------
---------------------------- JDBC 4.0 -------------------------
--------------------------JDBC 4.2 -----------------------------
Resolve axis to an absolute value (either X_AXIS or Y_AXIS)
determine the child placements
flush changes to the container
The requests have been invalidated... recalculate
the request information.
Resolve axis to an absolute value (either X_AXIS or Y_AXIS)
Utility methods for the UI's
Make sure we can at least get the default UI
Don't bother returning the multiplexing UI if all we did was
get a UI from just the default look and feel.
store a proxy for the package info that has no annotations
First, update the system package map with new package names
Get the cached code source url for the file name
URL not found, so create one
If loading a JAR file, then also cache the manifest
Convert to "."-separated package name
The map of loaded system packages
Maps each directory or zip file name to its corresponding url
Maps each code source url for a jar file to its manifest
disabled icons are generated by LF so they should be unset here
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
If component already exists, remove corresponding
tab so that new tab gets added correctly
Note: we are allowing component=null because of compatibility,
but we really should throw an exception because much of the
rest of the JTabbedPane implementation isn't designed to deal
with null components for tabs.
Container.add() interprets -1 as "append", so convert
the index appropriately to be handled by the vector
Container.add() interprets -1 as "append", so convert
the index appropriately to be handled by the vector
Force the tabComponent to be cleaned up.
NOTE 4/15/2002 (joutwate):
This fix is implemented using client properties since there is
currently no IndexPropertyChangeEvent.  Once
IndexPropertyChangeEvents have been added this code should be
modified to use it.
We can't assume the tab indices correspond to the
container's children array indices, so make sure we
remove the correct child!
Container#remove(comp) invokes Container#remove(int)
so make sure JTabbedPane#remove(int) isn't called here
We invoke removeTabAt for each tab, otherwise we may end up
removing Components added by the UI.
Getters for the Pages
Setters for the Pages
Fire the accessibility Visible data change
why not if (page.component.getParent() == this) remove(component)
end of Page setters
If ToolTipText != null, then the tooltip has already been
unregistered by JComponent.compWriteObjectNotify()
If ToolTipText != null, then the tooltip has already been
registered by JComponent.readObject()
initialize AccessibleContext for the existing pages
TIGER - 4732339
may be null
promote to node-set
Backwards branches are prohibited if an uninitialized object is
on the stack by section 4.9.4 of the JVM Specification, 2nd Ed.
We don't know whether this code might contain backwards branches,
so we mustn't create the new object until after we've created
the suspect arguments to its constructor.  Instead we calculate
the values of the arguments to the constructor first, store them
in temporary variables, create the object and reload the
arguments from the temporaries to avoid the problem.
Compile relative path iterator(s)
Create new Dup Filter Iterator
Initialize Dup Filter Iterator with iterator from the stack
lazy initialization of default provider
Ignore the security exception, try the next provider
focus forward traversal key
focus backward traversal key
sets the focus forward and backward traversal keys to null
to restore the defaults
Rollover is only supported on XP
Note: don't call getTabAreaInsets(), because it causes rotation.
Make sure "TabbedPane.tabsOverlapBorder" is set to true in WindowsLookAndFeel
Expand area by tabAreaInsets.bottom to allow tabs to overlap onto the border.
Align with right edge
Methods unique to this class
org.w3c.dom.traversal.NodeFilter API follows
Theoretically, we could release dtm_iter at this point. But
some of the operations may still want to consult it even though
navigation is now invalid.
check for valid wbmp image
Read image width
Read image height
If the destination is provided, then use it.  Otherwise, create new one
Get the image data.
Get the SampleModel.
If noTransform is necessary, read the data.
cache the values to avoid duplicated computation
get the bit and assign to the data buffer of the raster
read and discard the repository ID
write the repository ID
Aug 21, 2000:
Added ability to omit DOCTYPE declaration.
Reported by Lars Martin <lars@smb-tec.com>
Aug 25, 2000:
Added ability to omit comments.
Contributed by Anupam Bagchi <abagchi@jtcsv.com>
whether java names for encodings are permitted
If document is derived from HTMLDocument then the default
method is html.
Lookup the root element and the text nodes preceding it.
If root element is html and all text nodes contain whitespace
only, the method is html.
FIXME (SM) should we care about namespaces here?
If the root element is html, the method is html.
If a text node preceding the root element contains
only whitespace, this might be html, otherwise it's
Anything else, the method is xml.
Note on catch: DOM Level 1 does not specify this method
and the code will throw a NoSuchMethodError
Note on catch: DOM Level 1 does not specify this method
and the code will throw a NoSuchMethodError
Import general CORBA classes
Import org.omg.CosNaming classes
NextOne actually returns the next one
Take the smallest of what's left and what's being asked for
Create a resulting BindingList
Keep iterating as long as there are entries
Found any at all?
Set into holder
Destroy actually destroys
Header is always given it's preferred size.
Baseline is either from the header, in which case it's always
the same size and therefor can be created as CONSTANT_ASCENT.
If the header doesn't have a baseline than the baseline will only
be valid if it's BaselineResizeBehavior is
CONSTANT_ASCENT, so, return CONSTANT_ASCENT.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
find which scrollbar to scroll, or return if none
When the scrolling speed is set to maximum, it's possible
for a single wheel click to scroll by more units than
will fit in the visible area.  This makes it
hard/impossible to get to certain parts of the scrolling
Component with the wheel.  To make for more accurate
low-speed scrolling, we limit scrolling to the block
increment if the wheel was only rotated one click.
Check if we should use the visibleRect trick
5078454: Under maximum acceleration, we may scroll
by many 100s of units in ~1 second.
BasicScrollBarUI.scrollByUnits() can bog down the EDT
with repaints in this situation.  However, the
Scrollable interface allows us to pass in an
arbitrary visibleRect.  This allows us to accurately
calculate the total scroll amount, and then update
the GUI once.  This technique provides much faster
accelerated wheel scrolling.
Modify the visible rect for the next unit, and
check to see if we're at the end already.
(direction > 0
Set the final view position on the ScrollBar
rightToLeft scrollbars are oriented with
minValue on the right and maxValue on the
Viewport's view is not a Scrollable, or fast wheel
scrolling is not enabled.
ChangeListener: This is added to the vieport, and hsb/vsb models.
PropertyChangeListener: This is installed on both the JScrollPane
and the horizontal/vertical scrollbars.
Listens for changes in the model property and reinstalls the
PropertyChangeListener for the horizontal and vertical scrollbars.
read and discard the repository ID
write the repository ID
These message should be read from a locale-specific resource bundle
%REVIEW% Is there a better way of doing this?
Upside is minimum object churn. Downside is that we don't have a useful
backtrace in the exception itself -- but we don't expect to need one.
Patch for Christine's gripe. She wants her errorHandler to return from
a fatal error and continue trying to parse, rather than throwing an exception.
Without the patch, that put us into an endless loop.
%REVIEW% Is there a better way of doing this?
%REVIEW% Are there any other cases which need the safety net?
(and if so do we care right now, or should we rewrite the XPath
grammar engine and can fix it at that time?)
What I _want_ to do is null out this XPath.
I doubt this has the desired effect, but I'm not sure what else to do.
Terminate for safety.
Patch for Christina's gripe. She wants her errorHandler to return from
this error and continue trying to parse, rather than throwing an exception.
Without the patch, that put us into an endless loop.
Patch for Christina's gripe. She wants her errorHandler to return from
this error and continue trying to parse, rather than throwing an exception.
Without the patch, that put us into an endless loop.
TO DO: Need to get stylesheet Locator from here.
Should never happen.
TO DO: Need to get stylesheet Locator from here.
TO DO: Need to get stylesheet Locator from here.
These are nodetests, xpathparser treats them as functions when parsing
============= EXPRESSIONS FUNCTIONS =================
If FilterExpr had Predicates, a OP_LOCATIONPATH opcode would already
have been inserted.
"Relative location path expected following '/' or ''"
Terminate for safety.
Node type tests look like function calls, but they're not
Terminate for safety.
============= GRAMMAR FUNCTIONS =================
Tell how long the step is without the predicate
Neither a '/' nor a RelativeLocationPath - i.e., matched nothing
"Location path expected, but found "+m_token+" was encountered."
Terminate for safety.
RelativeLocationPath can't end with a trailing '/'
"Location step expected following '/' or ''"
At most a single '/' before each Step is consumed by caller; if the
first thing is a '/', that means we had '' and the Step must not
Have to fix up for patterns such as '@foo' or 'attribute::foo',
which translate to 'descendant-or-self::node()/attribute::foo'.
notice I leave the '/' on the queue, so the next will be processed
by a regular step pattern.
Make room for telling how long the step is without the predicate
Tell how long the step is without the predicate
Tell how long the step is with the predicate
Tell how long the step is without the predicate
Tell how long the step is without the predicate
There is probably a better way to test for this
transition... but it gets real hairy if you try
to do it in basis().
Tell how long the entire step is.
No Step matched - that's an error if previous thing was a ''
"Location step expected following '/' or ''"
The next blocks guarantee that a FROM_XXX will be added.
Make room for telling how long the step is without the predicate
Tell how long the step is without the predicate
Assume name of attribute or element.
Minimalist check for an NCName - just check first character
to distinguish from other possible tokens
"Node test that matches either NCName:* or QName was expected."
Minimalist check for an NCName - just check first character
to distinguish from other possible tokens
"Node test that matches either NCName:* or QName was expected."
Terminate for safety.
Mutate the token to remove the quotes and have the XString object
Mutate the token to remove the quotes and have the XNumber object
XPath 1.0 does not support number in exp notation
to shut up compiler.
============= PATTERN FUNCTIONS =================
Tell how long the step is without the predicate
Added this to fix bug reported by Myriam for match="x/a"
patterns.  If you don't do this, the 'x' step will think it's part
of a '' pattern, and so will cause 'a' to be matched when it has
any ancestor that is 'x'.
Tell how long the step is without the predicate
"A relative path pattern was expected."
Terminate for safety.
Caller will have consumed any '/' or '' preceding the
RelativePathPattern, so let StepPattern know it can't begin with a '/'
StepPattern() may consume first slash of pair in "ab" while
processing StepPattern "a".  On next iteration, let StepPattern know
that happened, so it doesn't match ill-formed patterns like "a/b".
The next blocks guarantee that a MATCH_XXX will be added.
"A step was expected in the pattern, but '/' was encountered."
Make room for telling how long the step is without the predicate
Tell how long the step is without the predicate
For "ab", where "a" is current step, we need to mark operation of
current step as "MATCH_ANY_ANCESTOR".  Then we'll consume the first
slash and subsequent step will be treated as a MATCH_IMMEDIATE_ANCESTOR
(unless it too is followed by ''.)
%REVIEW%  Following is what happens today, but I'm not sure that's
%REVIEW%  correct behaviour.  Perhaps no valid case could be constructed
%REVIEW%  where it would matter?
If current step is on the attribute axis (e.g., "@xb"), we won't
change the current step, and let following step be marked as
MATCH_ANY_ANCESTOR on next call instead.
Tell how long the entire step is.
should be private final, keeping original modifier due to backwards compatibility
make defensive copies of arguments
reset value to pre-append initialLength
lock the length so that we can seize the data to be appended
before initiate copying to avoid interference, especially when
Remember that we never actually append the suffix unless we return
the full (present) value or some sub-string or length of it, so that
we can add on more if we need to.
Private static methods
Allow simply setting the prop to turn on debug
this will ensure bootclassloader is used
Figure out which ClassLoader to use for loading the provider
class.  If there is a Context ClassLoader then use it.
Assert: we are on JDK 1.1 or we have no Context ClassLoader
or any Context ClassLoader in chain of system classloader
(including extension ClassLoader) so extend to widest
ClassLoader (always look in system ClassLoader if Xerces
is in boot/extension/system classpath and in current
ClassLoader otherwise); normal classloaders delegate
back to system ClassLoader first so this widening doesn't
change the fact that context ClassLoader will be consulted
Assert: Current ClassLoader in chain of
Assert: Current ClassLoader not in chain of
boot ClassLoader reached
Check for any extension ClassLoaders in chain up to
Assert: Context ClassLoader not in chain of
throw security exception if the calling thread is not allowed to access the package
restrict the access to package as speicified in java.security policy
use the bootstrap ClassLoader.
Fall back to current classloader
NOTE! This is a duplicate of utils.ClassLoaderUtils with public
modifiers changed to package-private. Make sure to integrate any future
changes to utils.ClassLoaderUtils to this file.
certain classloaders need it without the leading /
certain classloaders need it without the leading /
certain classloaders need it without the leading /
certain classloaders need it without the leading /
Depending on old position value
Position may be shifted by preceding expansions
to large for short (estimate)
5 - 3
Common UI methods
SAXNotRecognizedException.java - unrecognized feature or value.
Written by David Megginson
NO WARRANTY!  This class is in the Public Domain.
$Id: SAXNotRecognizedException.java,v 1.3 2004/11/03 22:55:32 jsuttor Exp $
Added serialVersionUID to preserve binary compatibility
end of SAXNotRecognizedException.java
We don't write DRI segments; the IJG library does.
Fields from Image Descriptor
Fields from Graphic Control Extension
Fields from Plain Text Extension
Fields from ApplicationExtension
List of byte[]
List of byte[]
List of byte[]
Fields from CommentExtension
List of byte[]
Local color table
Graphic control extension
Gamma not in format
BackgroundIndex not in image
BackgroundColor not in format
BitRate not in format
PlanarConfiguration not in format
BitsPerSample not in image
SignificantBitsPerSample not in format
SampleMSB not in format
PixelAspectRatio not in image
HorizontalPixelSize not in format
VerticalPixelSize not in format
HorizontalPhysicalPixelSpacing not in format
VerticalPhysicalPixelSpacing not in format
HorizontalPosition not in format
VerticalPosition not in format
HorizontalScreenSize not in image
VerticalScreenSize not in image
Document not in image
Alpha not in format
TransparentColor not in format
TileTransparencies not in format
TileOpacities not in format
SNMP Runtime import
We get a ref on the pdu in order to pass it to SnmpMibRequest.
Pre-allocate room for storing varbindlist and translation table.
cast to NonSyncVector<SnmpVarBind>
The translation table is easy in this case ...
This is an optimization:
The SnmpMibRequest created in the check() phase is
reused in the set() phase.
This is a request comming from an SnmpV3AdaptorServer.
If we're doing the check() phase, we store the SnmpMibRequest
so that we can reuse it in the set() phase.
Invoke a get operation
end of switch
This function does a best-effort to map global error status
to SNMP v1 valid global error status.
An SnmpStatusException can contain either:
<li> v2 local error codes (that should be stored in the varbind)</li>
<li> v2 global error codes </li>
<li> v1 global error codes </li>
v2 local error codes (noSuchInstance, noSuchObject) are
transformed in a global v1 snmpRspNoSuchName error.
v2 global error codes are transformed in the following way:
If the request was a GET/GETNEXT then either
snmpRspNoSuchName or snmpRspGenErr is returned.
snmpRspAuthorizationError, snmpRspNotWritable, snmpRspNoCreation
=> snmpRspReadOnly  (snmpRspNoSuchName for GET/GETNEXT)
=> snmpRspBadValue  (snmpRspNoSuchName for GET/GETNEXT)
Map v2 codes onto v1 codes
At this point we should have a V1 error code
We have a snmpRspGenErr, or something which is not defined
in RFC1905 => return a snmpRspGenErr
This function does a best-effort to map global error status
to SNMP v2 valid global error status.
An SnmpStatusException can contain either:
<li> v2 local error codes (that should be stored in the varbind)</li>
<li> v2 global error codes </li>
<li> v1 global error codes </li>
v2 local error codes (noSuchInstance, noSuchObject)
should not raise this level: they should have been stored in the
varbind earlier. If they, do there is nothing much we can do except
to transform them into:
<li> a global snmpRspGenErr (if the request is a GET/GETNEXT) </li>
<li> a global snmpRspNoSuchName otherwise. </li>
v2 global error codes are transformed in the following way:
If the request was a GET/GETNEXT then snmpRspGenErr is returned.
(snmpRspGenErr is the only global error that is expected to be
raised by a GET/GETNEXT request).
Otherwise the v2 code itself is returned
v1 global error codes are transformed in the following way:
=> snmpRspNoAccess  (snmpRspGenErr for GET/GETNEXT)
=> snmpRspNotWritable (snmpRspGenErr for GET/GETNEXT)
=> snmpRspWrongValue  (snmpRspGenErr for GET/GETNEXT)
Map v1 codes onto v2 codes
For get / getNext / getBulk the only global error
(PDU-level) possible is genErr.
Map to noSuchName
if ((errorStatus == SnmpDefinitions.snmpRspNoSuchName) ||
(errorStatus == SnmpStatusException.noSuchInstance) ||
(errorStatus == SnmpStatusException.noSuchObject))
SnmpStatusException.noSuchObject can't happen...
Map to notWritable
Map to wrongValue
Other valid V2 codes
Ivalid V2 code => genErr
Too bad, an error occurs ... we need to translate it ...
An error occurs. We need to be carefull because the index
we are getting is a valid SNMP index (so range starts at 1).
FIX ME: Shall we double-check the range here ?
The response is : YES :
bugId 4641694: must check position in order to avoid
All the methods of the Vector class are synchronized.
Synchronization is a very expensive operation. In our case it is not always
we never serialize this
cast to E
We should convert endOfStream to a final static dummy end node
REVISIT - This should go in BufferManagerRead. But, since
BufferManagerRead is an interface. BufferManagerRead
might ought to be an abstract class instead of an
print address of ByteBuffer being queued
print address of ByteBuffer being dequeued
Release bbwi.byteBuffer to the ByteBufferPool only if
this BufferManagerStream is not marked for potential restore.
print address of ByteBuffer being released
Release any queued ByteBufferWithInfo's byteBuffers to the
release ByteBuffers on fragmentQueue
IMPORTANT: The fragment queue may have one ByteBuffer
on it that's also on the CDRInputStream if
this method is called when the stream is 'marked'.
Thus, we'll compare the ByteBuffer passed
in (from a CDRInputStream) with all ByteBuffers
on the stack. If one is found to equal, it will
not be released to the ByteBufferPool.
print address of ByteBuffer released
release ByteBuffers on fragmentStack
IMPORTANT: The fragment stack may have one ByteBuffer
on it that's also on the CDRInputStream if
this method is called when the stream is 'marked'.
Thus, we'll compare the ByteBuffer passed
in (from a CDRInputStream) with all ByteBuffers
on the stack. If one is found to equal, it will
not be released to the ByteBufferPool.
print address of ByteBuffer being released
Mark and reset handler ----------------------------------------
List of fragment ByteBufferWithInfos received since
the mark was engaged.
Original state of the stream
Get the magic Object that the stream will use to
reconstruct it's state when reset is called
Collects fragments received since the mark was engaged.
REVISIT - call to reset without call to mark
If we actually did peek across fragments, we need
to push those fragments onto the front of the
Give the stream the magic Object to restore
You can't press a disabled slider
You can't have a rollover on a disabled slider
Methods for writing attributes to the stream of SQL data.
These methods correspond to the column-accessor methods of
Methods for writing items of SQL user-defined types to the stream.
These methods pass objects to the database as values of SQL
Structured Types, Distinct Types, Constructed Types, and Locator
Types.  They decompose the Java object(s) and write leaf data
items using the methods above.
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of DesktopPanePainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of DesktopPanePainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
[[[ PENDING:  WDW - the implementation of this does not need
to always use a vector of states.  It could be improved by
caching the states as a bit set.]]]
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of OptionPanePainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of OptionPanePainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
add this message to fix bug 21478
Earlier (JDK 1.4 XALAN 2.2-D11) at key code '204' the key name was ER_PRIORITY_NOT_PARSABLE
In latest Xalan code base key name is  ER_VALUE_SHOULD_BE_NUMBER. This should also be taken care
in locale specific files like XSLTErrorResources_de.java, XSLTErrorResources_fr.java etc.
NOTE: Not only the key name but message has also been changed.
Note to translators:  The following message should not normally be displayed
to users.  It describes a situation in which the processor has detected
an internal consistency problem in itself, and it provides this message
for the developer to help diagnose the problem.  The name
'ElemTemplateElement' is the name of a class, and should not be
Note to translators:  The following message should not normally be displayed
to users.  It describes a situation in which the processor has detected
an internal consistency problem in itself, and it provides this message
for the developer to help diagnose the problem.  The substitution text
provides further information in order to diagnose the problem.  The name
'RedundentExprEliminator' is the name of a class, and should not be
This code is shared with warning codes.
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "QNAME" is the XML data-type of
The following codes are shared with the warning codes...
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "ENUM" is the XML data-type of
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "NMTOKEN" is the XML data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "NCNAME" is the XML data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "boolean" is the XSLT data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "number" is the XSLT data-type
End of shared codes...
Note to translators:  A "match pattern" is a special form of XPath expression
that is used for matching patterns.  The substitution text is the name of
a function.  The message indicates that when this function is referenced in
a match pattern, its argument must be a string literal (or constant.)
ER_ARG_LITERAL - new error message for bugzilla 5202
Note to translators:  The following message indicates that two definitions of
a variable.  A "global variable" is a variable that is accessible everywher
in the stylesheet.
ER_DUPLICATE_GLOBAL_VAR - new error message for bugzilla #790
Note to translators:  The following message indicates that two definitions of
a variable were encountered.
ER_DUPLICATE_VAR - new error message for bugzilla #790
Note to translators:  "xsl:template, "name" and "match" are XSLT keywords
which must not be translated.
ER_TEMPLATE_NAME_MATCH - new error message for bugzilla #789
Note to translators:  "exclude-result-prefixes" is an XSLT keyword which
should not be translated.  The message indicates that a namespace prefix
encountered as part of the value of the exclude-result-prefixes attribute
was in error.
ER_INVALID_PREFIX - new error message for bugzilla #788
Note to translators:  An "attribute set" is a set of attributes that can
be added to an element in the output document as a group.  The message
was never defined.
ER_NO_ATTRIB_SET - new error message for bugzilla #782
Note to translators:  This message indicates that there was a reference
Note to translators:  This message indicates that the XSLT instruction
instructions (content) or a "select" attribute.  The word "select" is
an XSLT keyword in this case and must not be translated.
Note to translators:  This message indicates that the value argument
of setParameter must be a valid Java Object.
Following are the new WARNING keys added in XALAN code base after Jdk 1.4 (Xalan 2.2-D11)
Note to translators:  "name" and "xsl:processing-instruction" are keywords
and must not be translated.
Note to translators:  "name" and "xsl:processing-instruction" are keywords
and must not be translated.  "NCName" is an XML data-type and must not be
Note to translators:  This message is reported if the stylesheet that is
being processed attempted to construct an XML document with an attribute in a
place other than on an element.  The substitution text specifies the name of
Check: WHY THERE IS A GAP B/W NUMBERS in the XSLTErrorResources properties file?
Other miscellaneous text used inside the code...
Note to translators:  The following messages provide usage information
for the Xalan Process command line.  "Process" is the name of a Java class,
and should not be translated.
Note to translators: The option name and the parameter name do not need to
be translated. Only translate the messages in parentheses.  Note also that
leading whitespace in the messages is used to indent the usage information
for each option in the English messages.
Do not translate the keywords: XSLTC, SAX, DOM and DTM.
Following are the new options added in XSLTErrorResources.properties files after Jdk 1.4 (Xalan 2.2-D11)
Added by sboag/scurcuru; experimental
AddITIONAL  STRINGS that need L10n
Note to translators:  The following message describes usage of a particular
command-line option that is used to enable the "template inlining"
optimization.  The optimization involves making a copy of the code
generated for a template in another template that refers to it.
================= INFRASTRUCTURE ======================
Type-specific CORBA::Object operations
Use the GIOP version of the ORB.  Should
be specified in ServiceContext.
See REVISIT below concerning giopVersion.
We need to store this so that we can have access
to the CodeBase for unmarshaling possible
RMI-IIOP valuetype data within an encapsulation.
(Known case: UnknownExceptionInfo)
Fix for bug 4904723
REVISIT.  GIOP version should be specified as
part of a service context's definition, so should
be accessible from ServiceContextData via
its ServiceContext implementation class.
Since we don't have that, yet, I'm using the GIOP
version of the input stream, presuming that someone
can't send a service context of a later GIOP
version than its stream version.
Note:  As of Jan 2001, no standard OMG or Sun service contexts
ship wchar data or are defined as using anything but GIOP 1.0 CDR.
Now the input stream passed to a ServiceContext
constructor is already the encapsulation input
stream with the endianness read off, so the
service context should just unmarshal its own
Make service context 12 bytes longer by adding
JAVAIDL_ALIGN_SERVICE_ID service context at end.
The exact length
must be >8 (minimum service context size) and
=4 mod 8, so 12 is the minimum.
Temporarily remove this rather than check it per iteration
Write the UnknownExceptionInfo service context last
(so it will be after the CodeBase) and restore it in
If it's still in byte[] form, we don't need to
unmarshal it here, just copy the bytes into
the new stream.
We actually unmarshaled it into a ServiceContext
at some point.
Lazy unmarshaling on first use.
Define the default namespace (initially maps to "" uri)
Prefixes "xml" and "xmlns" cannot be redefined
Prefixes "xml" and "xmlns" cannot be redefined
Get the stack that contains URIs for the specified prefix
not much we can do if they aren't willing to listen
the depth of the element where declartion was made
end of StateEngine.java
temporary directory location
file name generation, same as java.io.File for now
the generated name should be a simple file name
default file and directory permissions (lazily initialized)
in POSIX environments use default file and directory permissions
if initial permissions not given by caller.
no attributes so use default permissions
check if posix permissions given; if not use default
loop generating random names until file or directory can be created
don't reveal temporary directory location
don't reveal temporary directory location
25 in CORBA 2.3.1 13.6.3
-- File contents --
-- Directories --
avoid creating a matcher if all entries are required.
create a matcher and return a filter that uses it.
-- Creation and deletion --
attempt to create the directory
file exists and is not a directory
parent may not exist or other reason
don't have permission to get absolute path
find a decendent that exists
does not exist
unable to find existing parent
-- Copying and moving files --
-- Miscellenous --
lazy loading of default and installed file type detectors
creates the default file type detector
loads all installed file type detectors
try installed file type detectors
fallback to default
-- File Attributes --
only one attribute should be read
-- Accessibility --
attempt to read attributes without following links
does not exist or unable to determine if file exists
attempt to read attributes without following links
file confirmed not to exist
-- Recursive operations --
if SKIP_SIBLINGS and SKIP_SUBTREE is returned then
there shouldn't be any more events for the current
SKIP_SIBLINGS is a no-op for postVisitDirectory
-- Utility methods for simple usages --
buffer size used for reading and writing
ensure not null before opening file
check for REPLACE_EXISTING
attempt to delete an existing file
attempt to create target file. If it fails with
FileAlreadyExistsException then it may be because the security
manager prevented us from deleting the file, in which case we just
throw the SecurityException.
someone else won the race and created the file
do the copy
ensure not null before opening file
read to EOF which may read more or less than initialSize (eg: file
is truncated while we are reading)
if last call to source.read() returned -1, we are done
otherwise, try to read one more byte; if that failed we're done too
one more byte was read; need to allocate a larger buffer
ensure bytes is not null before opening file
ensure lines is not null before opening file
-- Stream APIs --
Re-wrap DirectoryIteratorException to UncheckedIOException
Pos after last (rightmost) byte written
this will call checkClosed() for us
this will call checkClosed() for us
this will call checkClosed() for us
System.out.println("CompoundEdit(" + i + "): Discarding " +
If this is the first subedit received, just add it.
Otherwise, give the last one a chance to absorb the new
one.  If it won't, give the new one a chance to absorb
the last one.
Update the new parent bounds for next resize, but don't
let the super method touch this frame
Border (and other defaults) may need to change
Not within an invocation context
The get_interface() method has been replaced by get_interface_def()
Wrap the InputStream so that it is possible to rewind it.
If this is an HTTP connection attach any request properties to the request.
set request properties
set preference for redirection
Wrap the InputStream so that it is possible to rewind it.
content type will be string like "text/xml; charset=UTF-8" or "text/xml"
text/xml and application/xml offer only one optional parameter
this should be something like "text/xml"
this should be something like "charset=UTF-8", but we want to
strip it down to just "UTF-8"
8 is the length of "charset="
strip quotes, if present
see RFC2376 or 3023, section 3.1
see RFC2376 or 3023, section 3.2
else 3 or 4.
eat the Byte Order Mark
If the document is UTF-8 or US-ASCII use
the Xerces readers for these encodings. For
US-ASCII consult the encoding map since
this encoding has many aliases.
Try to use a Java reader.
If the specified encoding wasn't a recognized IANA encoding throw an IOException.
The XIncludeHandler will report this as a ResourceError and then will
attempt to include a fallback if there is one.
this has the potential to throw an exception
it will be fixed when we ensure the stream is rewindable (see note above)
First three bytes are not BOM, so reset.
First two bytes are not BOM, so reset.
We could do UTF-32, but since the getEncodingName() doesn't support that
we won't support it here.
To implement UTF-32, look for:  00 00 FE FF for big-endian
or  FF FE 00 00 for little-endian
UTF-16, with BOM
UTF-8 with a BOM
UCS-4, big endian (1234)
UCS-4, little endian (4321)
UCS-4, unusual octet order (2143)
UCS-4, unusual octect order (3412)
UTF-16, big-endian, no BOM
(or could turn out to be UCS-2...
UTF-16, little-endian, no BOM
(or could turn out to be UCS-2...
a la xerces1, return CP037 instead of EBCDIC here
this signals us to use the value from the encoding attribute
retrieve next character
handle rare boundary case
convert surrogates to a supplemental character
--- View methods ---------------------------------------------
--- variables ------------------------------------------------
There's a situation with chunking with fragmentation
in which the alignment for a primitive value is needed
to fill fragment N, but the primitive won't fit so
must go into fragment N + 1.  The behavior is the same
as that for specialChunks.
Unfortunately, given the current code, we can't reuse
specialChunk.  If you wrap each of the following
write calls with handleSpecialChunkBegin/End, you
will lose your state because the primitive calls will
change the variables, etc.
All of the CDR code should be rewritten moving chunking
to a different level, perhaps in the buffer managers.
We want to move to a compositional model rather than
Note that in the grow case, chunks are _NOT_ closed
at grow points, now.
Since we will not support valuetypes with GIOP 1.1, that
also means we do not support chunking there.
Used in chunking.  Here's how this works:
When chunking and writing an array of primitives, a string, or a
wstring, _AND_ it won't fit in the buffer do the following.  (As
you can see, this is a very "special" chunk.)
1.  Write the length of the chunk including the array length
2.  Set specialChunk to true
3 applies to ALL chunking:
3.  In grow, if we need to fragment and specialChunk is false
a) call end_block
Now back to the array only case:
[write the data]
4.  if specialChunk is true
a) Close the chunk
b) Set specialChunk to false
Indicates whether the header should be padded. In GIOP 1.2 and above, the
body must be aligned on a 8-octet boundary, and so the header needs to be
padded appropriately. However, if there is no body to a request or reply
message, there is no need to pad the header, in the unfragmented case.
If we're chunking and the item won't fit in the buffer
Duplicating some code from end_block.  Compute
and write the total chunk length.
Set the special flag so we don't end the chunk when
If we're in a chunk and the item spanned fragments
This is unnecessary, but I just want to show that
we're done with the current chunk.  (the end_block
call is inappropriate here)
Start a new chunk since we fragmented during the item.
Thus, no one can go back to add more to the chunk length
Now turn off the flag so we go back to the normal
behavior of closing a chunk when we fragment and
Called after writing primitives
It would be nice to have a StreamPosition
abstraction if we could avoid allocation
Start a new chunk
Called by RequestMessage_1_2 or ReplyMessage_1_2 classes only.
headerPadding bit is set by the write operation of RequestMessage_1_2
or ReplyMessage_1_2 classes. When set, the very first body write
operation (from the stub code) would trigger an alignAndReserve
method call, that would in turn add the appropriate header padding,
such that the body is aligned on a 8-octet boundary. The padding
is required for GIOP versions 1.2 and above, only if body is present.
In GIOP 1.2, we always end fragments at our
fragment size, which is an "evenly divisible
8 byte boundary" (aka divisible by 16).  A fragment can
end with appropriate alignment padding, but no padding
is needed with respect to the next GIOP fragment
header since it ends on an 8 byte boundary.
Save the current size for possible post-fragmentation calculation
See notes where specialChunk is defined, as well as the
above notes for primitiveAcrossFragmentedChunk.
If we're writing a primitive and chunking, we need to update
the chunk length to include the length of the primitive (unless
this complexity is handled by specialChunk).
Note that this is wasted processing in the grow case, but that
we don't actually close the chunk in that case.
At this point, if we fragmented, we should have a ByteBufferWithInfo
with the fragment header already marshalled.  The buflen and position
should be updated accordingly, and the fragmented flag should be set.
Note that fragmented is only true in the streaming and collect cases.
Clear the flag
Update fragmentOffset so indirections work properly.
At this point, oldSize is the entire length of the
previous buffer.  bbwi.position() is the length of the
fragment header of this buffer.
We just fragmented, and need to signal that we should
start a new chunk after writing the primitive.
In GIOP 1.2, a wchar is encoded as an unsigned octet length
followed by the octets of the converted wchar.  This is good,
but it causes problems with our chunking code.  We don't
want that octet to get put in a different chunk at the end
of the previous fragment.
Ensure that this won't happen by overriding write_wchar_array
and doing our own handleSpecialChunkBegin/End here.
Write the bytes without messing with chunking
Unfortunately, because of chunking, we have to convert the
entire char[] to a byte[] array first so we can know how
many bytes we're writing ahead of time.  You can't split
an array of primitives into multiple chunks.
Remember that every wchar starts with an octet telling
its length.  The buffer size is an upper bound estimate.
Convert one wchar
Make sure to add the octet length
Copy it into our buffer
Now that we know the total length, we can deal with chunking.
Note that we don't have to worry about alignment since they're
Must use totalNumBytes rather than buffer.length since the
buffer.length is only the upper bound estimate.
In GIOP 1.2, wstrings are not terminated by a null.  The
length is the number of octets in the converted format.
A zero length string is represented with the 4 byte length
value of 0.
Write the octet array without tampering with chunking
The start element event
The end element event
The empty element event
Should only happen if size() != keys.length, which should only
happen if mutated from multiple threads (or a bogus subclass).
XXX print backtrace of cause
XXX print backtrace of cause
XXX print backtrace of cause
NewInstance.java - create a new instance of a class by name.
Written by Edwin Goei, edwingo@apache.org
and by David Brownell, dbrownell@users.sourceforge.net
NO WARRANTY!  This class is in the Public Domain.
$Id: NewInstance.java,v 1.2 2005/06/10 03:50:50 jeffsuttor Exp $
make sure we have access to restricted packages
We can be sure that typeCode is of kind tk_struct
Initialize components lazily, on demand.
This is an optimization in case the user is only interested in storing Anys.
We can be sure that typeCode is of kind tk_struct
For DynStruct, the operation sets the current position to -1
for empty exceptions and to zero for all other TypeCodes.
The members (if any) are (recursively) initialized to their default values.
Methods differing from DynValues
Set up JavaSecurityAccess in SharedSecrets
internal permission collection already has AllPermission -
no need to go to policy
called by the VM -- do not remove
Check if policy is set; we don't want to load
the policy prematurely here
fall thru and return false
Build a vector of domain permissions for subsequent merge
Build a vector of Policy permissions for subsequent merge
Weed out the duplicates from the policy. Unless a refresh
has occurred since the pd was consed this should result in
an empty vector.
domain vs policy
The equals() method on some permissions
have some side effects so this manual
comparison is sufficient.
the order of adding to merged perms and permissions
needs to preserve the bugfix 4301064
bind initial name
Type-specific CORBA::Object operations
Some places assume margins are non-null.
Overriden to do nothing, all our painting is done from update/paint.
Installs the text cursor on the component
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of TreePainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of TreePainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
the name of the attribute
the target namespace of the attribute
the simple type of the attribute
value constraint type: default, fixed or !specified
enclosing complex type, when the scope is local
value constraint value
The namespace schema information item corresponding to the target namespace
of the attribute declaration, if it is globally declared; or null otherwise.
REVISIT: SCAPI: what's the proper representation
it's not here
it's not here
Copyright (c) 1995-96 by Cisco Systems, Inc.
name identifying this list.
do deepcopy of all vars.
Serialization compatibility stuff:
Two serial forms are supported in this class. The selected form depends
on system property "jmx.serial.form":
- "1.0" for JMX 1.0
- any other value for JMX 1.1 and higher
Serial version for old serial form
Serial version for new serial form
Serializable fields in old serial form
Serializable fields in new serial form
Actual serial version and serial form
OK : Too bad, no compat with 1.0
END Serialization compatibility stuff
Read an object serialized in the old serial form
Read an object serialized in the new serial form
Serializes this instance in the old serial form
Serializes this instance in the new serial form
note that it is vital that each method supplies a constant, not a
calculated value, as they will be checked for using ==
it is also vital that each constant is different (due to the == checking)
as such, alterations to this code must be done with care
special constants should be used to extract information from a TemporalAccessor
that cannot be derived in other ways
Javadoc added here, so as to pretend they are more normal than they really are
non-special constants are standard queries that derive information from other information
Avoid creation of special accessor
Boxing is OK here, since few values will actually flow into the sink
Boxing is OK here, since few values will actually flow into the sink
Boxing is OK here, since few values will actually flow into the sink
name of current class
file to write to
Don't know what to do about this one
Increment number of attributes found so far
Some directly printable values
Get handled exceptions and list them
Index in constant pool
Create Link to _cp.html
List thrown exceptions
List line number pairs
List name, range and type
List inner classes
Such as Unknown attribute or Deprecated
add more if necessary.
End of file.
These "redundant fields" are initialized with recognizable nonsense
values, and cached the first time they are needed (or never, if they
(1 << 26)
Check for at most one leading sign
Skip leading zeros and compute number of digits in magnitude
Pre-allocate array of expected size. May be too large but can
never be too small. Typically exact.
Process first (potentially short) digit group
Process remaining digit groups
Required for cases where the array was overallocated.
Skip leading zeros and compute number of digits in magnitude
Pre-allocate array of expected size
Process first (potentially short) digit group
Process remaining digit groups
Create an integer with the digits between the two indexes
Assumes start < end. The result may be negative, but it
is to be treated as an unsigned value.
bitsPerDigit in the given radix times 1024
Rounded up to avoid underallocation.
Multiply x array times word y in place, and add word z
Perform the multiplication word by word
Perform the addition
Generate random bytes and mask out any excess bits
Minimum size in bits that the requested prime number has
before we use the large prime number generating algorithms.
The cutoff of 95 was chosen empirically for best performance.
Certainty required to meet the spec of probablePrime
High bit of high int
Bits to keep in high int
Construct a candidate
Ensure exact length
Make odd if bitlen > 2
Do cheap "pre-test" if applicable
Candidate is composite; try another
All candidates of bitLength 2 and 3 are prime by this point
Do expensive test if we survive pre-test (or it's inapplicable)
Use a sieve length likely to contain the next prime number
Handle trivial cases
Fastpath for small numbers
Ensure an odd number
Do cheap "pre-test" if applicable
Candidate is composite; try another
All candidates of bitLength 2 and 3 are prime by this point
The expensive test
Start at previous even number
Looking for the next large prime
The relationship between the certainty and the number of rounds
we perform is given in the draft standard ANSI X9.80, "PRIME
NUMBER GENERATION, PRIMALITY TESTING, AND PRIMALITY CERTIFICATES".
5, -7, 9, -11, ...
Algorithm and comments adapted from Colin Plumb's C library.
Make p positive
3 (011) or 7 (111) mod 8
Get rid of factors of 2 in p
3 (011) or 5 (101) mod 8
Then, apply quadratic reciprocity
p = u = 3 (mod 4)?
And reduce u mod p
Now compute Jacobi(u,p), u < p
3 (011) or 5 (101) mod 8
Now both u and p are odd, so use quadratic reciprocity
u = p = 3 (mod 4)?
Now u >= p, so it can be reduced
Find a and m such that m is odd and this == 1 + 2**a * m
Do the tests
Generate a uniform random on (1, this)
Static Factory Methods
If -MAX_CONSTANT < val < MAX_CONSTANT, return stashed constant
Copy remainder of longer number while carry propagation is required
Copy remainder of longer number
Grow result if necessary
If x is shorter, swap the two arrays
Add common parts of both numbers
Copy remainder of longer number while carry propagation is required
Copy remainder of longer number
Grow result if necessary
Subtract remainder of longer number while borrow propagates
Copy remainder of longer number
little.length == 2
Subtract remainder of longer number while borrow propagates
Copy remainder of longer number
Subtract common parts of both numbers
Subtract remainder of longer number while borrow propagates
Copy remainder of longer number
higher order bits
lower order bits
The number of ints in each half of the number.
xl and yl are the lower halves of x and y respectively,
xh and yh are the upper halves.
p1 = xh*yh
p2 = xl*yl
result = p1 * 2^(32*2*half) + (p3 - p1 - p2) * 2^(32*half) + p2
k is the size (in ints) of the lower-order slices.
Equal to ceil(largest/3)
r is the size (in ints) of the highest-order slice.
Obtain slices of the numbers. a2 and b2 are the most significant
bits of the numbers a and b, and a0 and b0 the least significant.
The algorithm requires two divisions by 2 and one by 3.
All divisions are known to be exact, that is, they do not produce
remainders, and all results are positive.  The divisions by 2 are
implemented as right shifts which are relatively efficient, leaving
only an exact division by 3, which is done by a specialized
Number of bits to shift left.
While performing Toom-Cook, all slices are positive and
the sign is adjusted when the final number is composed.
Did we make the number go negative?
0xAAAAAAAB is the modular inverse of 3 (mod 2^32).  Thus,
the effect of this is to divide by 3 (mod 2^32).
This is much faster than division on most architectures.
Now check the borrow. The second check can of course be
eliminated if the first fails.
Execute checks before calling intrinsified method.
Store the squares, right shifted one bit (i.e., divided by 2)
Add in off-diagonal sums
Shift back up and set low bit
xhs = xh^2
xls = xl^2
xh^2 << 64  +  (((xl+xh)^2 - (xh^2 + xl^2)) << 32) + xl^2
k is the size (in ints) of the lower-order slices.
Equal to ceil(largest/3)
r is the size (in ints) of the highest-order slice.
Obtain slices of the numbers. a2 is the most significant
bits of the number, and a0 the least significant.
The algorithm requires two divisions by 2 and one by 3.
All divisions are known to be exact, that is, they do not produce
remainders, and all results are positive.  The divisions by 2 are
implemented as right shifts which are relatively efficient, leaving
only a division by 3.
The division by 3 is done by an optimized algorithm for this case.
Number of bits to shift left.
Factor out powers of two from the base, as the exponentiation of
these can be done by left shifts only.
The remaining part can then be exponentiated faster.  The
powers of two will be multiplied back at the end.
Factor the powers of two out quickly by shifting right, if needed.
Nothing left but +/- 1?
Nothing left but +/- 1?
This is a quick way to approximate the size of the result,
similar to doing log2[n] * exponent.  This will give an upper bound
of how big the result can be, and which algorithm to use.
Use slightly different algorithms for small and large operands.
See if the result will safely fit into a long. (Largest 2^63-1)
Small number algorithm.  Everything fits into a long.
Perform exponentiation using repeated squaring trick
Multiply back the powers of two (quickly, by shifting left)
Fits in long?
Large number algorithm.  This is basically identical to
the algorithm above, but calls multiply() and square()
which may use more efficient algorithms for large numbers.
Perform exponentiation using repeated squaring trick
Multiply back the (exponentiated) powers of two (quickly,
by shifting left)
If shift can be done without recopy, do so
Array must be resized
shifts a up to len right n bits assumes no leading zeros, 0<n<32
shifts a up to len left n bits assumes no leading zeros, 0<=n<32
Modular Arithmetic Operations
Tear m apart into odd part (m1) and power of 2 (m2)
Max pow of 2 that divides m
Calculate new base from m1
Caculate (base ** exponent) mod m1.
Calculate (this ** exponent) mod m2
Combine results using Chinese Remainder Theorem
Montgomery multiplication.  These are wrappers for
implMontgomeryXX routines which are expected to be replaced by
virtual machine intrinsics.  We don't use the intrinsics for
very large operands: MONTGOMERY_INTRINSIC_THRESHOLD should be
larger than any reasonable crypto key.
Very long argument: do not use an intrinsic
Very long argument: do not use an intrinsic
Make sure that the int array z (which is expected to contain
the result of a Montgomery multiplication) is present and
These methods are intended to be be replaced by virtual machine
Special case for exponent of one
Special case for base of zero
Make modLen even. It is conventional to use a cryptographic
modulus that is 512, 768, 1024, or 2048 bits, so this code
will not normally be executed. However, it is necessary for
the correct functioning of the HotSpot intrinsics.
Select an appropriate window size
if exponent is 65537 (0x10001), use minimum window size
Calculate appropriate table size
Allocate table for precomputed odd powers of base in Montgomery form
Compute the modular inverse of the least significant 64-bit
digit of the modulus
Convert base to Montgomery form
MutableBigInteger.divide() assumes that its
divisor is in normal form.
Pad table[0] with leading zeros so its length is at least modLen
Set b to the square of the base
Set t to high half of b
Fill in the table with odd powers of the base
Pre load the window that slides over the exponent
The first iteration, which is hoisted out of the main loop
The main loop
Advance the window
Examine the window for pending multiplies
Check if done
Square the input
Convert result out of Montgomery form and return
Carry out of number
Copy remaining ints of mag
Mask out any excess bits
Calculate (this mod m)
Possible int overflow in (-n) is not a trouble,
because shiftRightImpl considers its argument unsigned
because shiftLeft considers its argument unsigned
Special case: entire contents shifted off the end
Find out whether any one-bits were shifted off the end.
Single Bit Operations
lowestSetBit not initialized yet
Search for lowest order nonzero int
Miscellaneous Bit Operations
bitLength not initialized yet
offset by one to initialize
Calculate the bit length of the magnitude
Check if magnitude is a power of two
bitCount not initialized yet
offset by one to initialize
Count the bits in the magnitude
Count the trailing zeros in the magnitude
This test is just an optimization, which may or may not help
If it's small enough, use smallToString.
Otherwise use recursive toString, which requires positive arguments.
The results will be concatenated into this StringBuilder
Compute upper bound on number of digit groups and allocate space
Translate number to string, a digit group at a time
Put sign (if any) and first digit group into result buffer
Append remaining digit groups padded with leading zeros
Prepend (any) leading zeros for this digit group
Pad with internal zeros if necessary.
Don't pad if we're at the beginning of the string.
May be a faster way to
Calculate a value for n in the equation radix^(2^n) = u
and subtract 1 from that value.  This is used to find the
cache index that contains the best value to divide u.
Now recursively build the two halves of each number.
volatile read again
volatile write, publish
exponent == floor(log2(abs(this)))
twiceSignifFloor will be == abs().shiftRight(shift).intValue()
We do the shift into an int directly to improve performance.
remove the implied bit
exponent == floor(log2(abs(this))Double)
twiceSignifFloor will be == abs().shiftRight(shift).longValue()
We do the shift into a long directly to improve performance.
remove the implied bit
Find first nonzero byte
Find first nonzero byte
Find first nonzero byte
Allocate new array and copy relevant part of input array
Find first non-sign (0xff) byte of input
Mask indicates which bits must be complemented
Add one to one's complement to generate two's complement
Find first non-sign (0xffffffff) int of input
Add one to one's complement to generate two's complement
firstNonzeroIntNum not initialized yet
Search for the first nonzero int
offset by two to initialize
prepare to read the alternate persistent fields
Read the alternate persistent fields that we care about
Commit final fields via Unsafe
Calculate mag field from magnitude and discard magnitude
Support for resetting final fields while deserializing
set the values of the Serializable fields
The values written for cached fields are compatible with older
versions, but are ignored in readObject so don't otherwise matter.
Check whether the currencyCode is valid
Check whether the locale is valid
any parsing exceptions, return false
this will return 'true' if 'o' is a sun.security.x509.X500Name
and the X500Names are equal
Inital size, sufficient in most cases
First entry (0) used by JVM
Already in CP
Already in CP
Already in CP
Already in CP
Already in CP
Already in CP
Wastes one entry according to spec
Already in CP
Wastes one entry according to spec
Already in CP
Already in CP
Already in CP
Already in CP
MurmurHash3 mix constants
force to be odd
ensure enough transitions
power of two
reject over-represented candidates
range not representable as long
correct for rounding
Specialize internalNextInt for origin 0
power of two
reject over-represented candidates
Specialize internalNextLong for origin 0
power of two
reject over-represented candidates
correct for rounding
stream methods, coded in a way intended to better isolate for
maintenance purposes the small differences across forms.
Type strings for this class and its superclases
DSI Dispatch call
We need a place to store the color the JLabel should be returned
to after its foreground and background colors have been set
to the selection background color.
These ivars will be made protected when their names are finalized.
p should now be the JTable.
Strings get interned...
focus painted same color as text on Basic??
Note: The border may be compound, containing an outer
opaque border (supplied by the application), plus an
inner transparent margin border. We want to size the
background to fill the transparent part, but stay
inside the opaque part.
Outside border is opaque, keep looking
Inside is non-opaque, use outside insets
Found non-opaque somewhere in the inside (which is
Outside is either all non-opaque or has non-opaque
border inside another compound border
1. it should be possible to do the following
DOMInputImpl extends XMLInputSource implements LSInput
2. we probably need only the default constructor.  -- el
Installs the text cursor on the component
Overriden to do nothing, all our painting is done from update/paint.
we need to repaint the entire scrollbar because state change for each
button causes a state change for the thumb and other button on Vista
Pending: Implement rollover (hot) and pressed
we need to repaint the entire scrollbar because state change for thumb
causes state change for incr and decr buttons on Vista
normal, rollover, pressed, disabled
XXX needs an SPI or else it does not belong here
XXX Should there be a SPI level constants ?
As much as possible, this class should be stateless.  However,
there are a few reasons why it is not:
1. The ORB debug flags are defined here because they are accessed
frequently, and we do not want a cast to the impl just for that.
2. typeCodeMap and primitiveTypeCodeConstants are here because they
are needed in both ORBImpl and ORBSingleton.
3. Logging support is here so that we can avoid problems with
incompletely initialized ORBs that need to perform logging.
Flag set at compile time to debug flag processing: this can't
be one of the xxxDebugFlags because it is used to debug the mechanism
that sets the xxxDebugFlags!
Currently defined debug flags.  Any additions must be called xxxDebugFlag.
All debug flags must be public boolean types.
These are set by passing the flag -ORBDebug x,y,z in the ORB init args.
Note that x,y,z must not contain spaces.
SystemException log wrappers.  Protected so that they can be used in
This map is needed for resolving recursive type code placeholders
based on the unique repository id.
XXX Should this be a WeakHashMap for GC?
ByteBufferPool - needed by both ORBImpl and ORBSingleton
XXX clean this up, probably remove these
Invocation stack manipulation
wrapperMap maintains a table of LogWrapper instances used by
different classes to log exceptions.  The key is a StringPair
representing LogDomain and ExceptionGroup.
First try the configured class name, if any
Use the default. Log the error as a warning.
No security manager or AppContext
Initialize logging first, since it is needed nearly
everywhere (for example, in TypeCodeImpl).
Typecode support: needed in both ORBImpl and ORBSingleton
Special non-standard set_parameters method for
creating a precisely controlled ORB instance.
An ORB created by this call is affected only by
those properties passes explicitly in props, not by
the system properties and orb.properties files as
with the standard ORB.init methods.
XXX This needs a better name
Dispatch support: in the ORB because it is needed for shutdown.
This is used by the first level server side subcontract.
XXX These next 7 methods should be moved to a ResolverManager.
XXX The next 5 operations should be moved to an IORManager.
Determine the correct ORBId.  There are 3 cases:
1. odata is null, which happens if we are getting a logger before
ORB initialization is complete.  In this case we cannot determine
the ORB ID (it's not known yet), so we set the ORBId to
2. odata is not null, so initialization is complete, but ORBId is set to
the default "".  To avoid a ".." in
the log domain, we simply use _DEFAULT_ in this case.
3. odata is not null, ORBId is not "": just use the ORBId.
get a reference to a ByteBufferPool, a pool of NIO ByteBuffers
NOTE: ByteBuffer pool must be unique per ORB, not per process.
There can be more than one ORB per process.
This method must also be inherited by both ORB and ORBSingleton.
End of file.
-- This file was mechanically generated: Do not edit! --
enforce limit == capacity
--- Methods to support CharSequence ---
SAX default implementation for Locator.
No warranty; no copyright -- use this as you will.
$Id: LocatorImpl.java,v 1.2 2004/11/03 22:53:09 jsuttor Exp $
Implementation of org.xml.sax.Locator
Setters for the properties (not in org.xml.sax.Locator)
end of LocatorImpl.java
First Clean the URL Escapes if there are any
There is something wrong with the URL escapes used
so throw an exception
If there is no '/' then the endIndex is at the end of the URL
_REVISIT_: Add a testcase to check 'corbaloc:/'
The url starts with a '/', it's an error
Anything between corbaloc: and / is the host,port information
of the server where the Service Object is located
There should be atleast one token, because there are checks
to make sure that there is host information before the
delimiter '/'. So no need to explicitly check for number of
tokens != 0
Right now we are not allowing any other protocol
other than iiop:, rir: so raise exception indicating
that the URL is malformed
Add the Host information if RIR flag is set,
If RIR is set then it means use the internal Boot
Strap protocol for Key String resolution
If there is something after corbaloc:endpointInfo/
then that is the keyString
Check the iiop syntax
String after ":"
The format can be 1.2@<host>:<port>
There can be 1 or 2 tokens with '@' as the delimiter
- if there is only 1 token then there is no GIOP version
information.  A Default GIOP version of 1.2 is used.
- if there are 2 tokens then there is GIOP version is specified
- if there are no tokens or more than 2 tokens, then that's an
There is VersionInformation after iiop:
There is a version without ., which means
A Hack to differentiate IPV6 address
from IPV4 address, Current Resolution
is to use [ ] to differentiate ipv6 host
ipv6Host should be enclosed in
[ ], if not it will result in a
There are three possible cases here
1. Host and Port is explicitly specified by using ":" as a
2. Only Host is specified without the port
3. HostAndPort info is null
Case 1: There is Host and Port Info
Case 2: Only Host is specified. iiopEndpointInfo is
initialized to use the default INS port, if no port is
Case 3: If no Host and Port info is provided then we use the
the default LocalHost and INSPort. iiopEndpointInfo is
already initialized with this info.
Any kind of Exception is bad here.
Possible causes: A Number Format exception because port info is
If there is port information, then it has to be after ] bracket
indexOf returns the count from the index of zero as the base, so
equality check requires squareBracketEndIndex + 1.
PortInformation  should be after ']:' delimiter
If there is an exception then it will be caught in
checkcorbaGrammer method and rethrown as BAD_PARAM
ipv6Host should be enclosed in
[ ], if not it will result in a
get the host between [ ]
timeout in millisec
only create the fd after we know we will be able to create the socket
TODO - should make better effort to read TOS or TCLASS
should never get here
If we have a ref. to the Socket, then sets the flags
created, bound & connected to true.
This is normally done in Socket.connect() but some
subclasses of Socket may call impl.connect() directly!
These message should be read from a locale-specific resource bundle
only mouse events supported for drag operations
only support known actions
only support valid source actions
read-only property. ignore
zero or more than one argument, ignore
read-only property. ignore
zero or more than one argument, ignore
found the desired descriptor
--- Transferable methods ----------------------------------------------
addDropTargetListener is overridden
we specifically need to add to the superclass
Since the super class only supports one DropTargetListener,
and we add one from the constructor, we always add to the
--- DropTargetListener methods (multicast) --------------------------
If the Drop target is inactive the dragExit will not be dispatched to the dtListener,
so make sure that we clean up the dtListener anyway.
compute the outer
compute the insets
set the inner from the insets
--- DropTargetListener methods -----------------------------------
--- DragGestureListener methods -----------------------------------
--- DragSourceListener methods -----------------------------------
any of these calls may throw IllegalStateException
clipboard was unavailable
this is a paste action, import data into the component
PENDING(rjrjr) when vector grows a removeRange() method
(expected in JDK 1.2), trimEdits() will be nice and
efficient, and this method can call that instead.
System.out.print("limit: " + limit +
" size: " + size +
" indexOfNextAdd: " + indexOfNextAdd +
These are ints we're playing with, so dividing by two
rounds down for odd numbers, so make sure the limit was
honored properly. Note that the keep range is
The keep range is centered on indexOfNextAdd,
but odds are good that the actual edits Vector
isn't. Move the keep range to keep it legal.
System.out.println("Trimming " + from + " " + to + " with index " +
System.out.println("JUM: Discarding " +
PENDING(rjrjr) when Vector supports range deletion (JDK
1.2) , we can optimize the next line considerably.
Trim from the indexOfNextAdd to the end, as we'll
never reach these edits once the new one is added.
Maybe super added this edit, maybe it didn't (perhaps
an in progress compound edit took it instead. Or perhaps
this UndoManager is no longer in progress). So make sure
the indexOfNextAdd is pointed at the right place.
Enforce the limit
Break is in a word;  back up to previous break.
NOTE:  I think that breakIter.preceding(limit) should be
equivalent to breakIter.last(), breakIter.previous() but
the authors of BreakIterator thought otherwise...
If they were equivalent then the first branch would be
first word doesn't fit on line
Bare implementation of CORBA Object.
-- Socket-specific operations --
-- ByteChannel operations --
Make sure level isn't null, by calling random method.
Assign a thread ID and a unique sequence number.
We have to call defaultWriteObject first.
Write our version number.
Write string values for the parameters.
We have to call defaultReadObject first.
Read version number.
If necessary, try to regenerate the resource bundle.
use system class loader to ensure the ResourceBundle
instance is a different instance than null loader uses
This is not a good place to throw an exception,
so we simply leave the resourceBundle null.
Private method to infer the caller's class and method names
Calling getStackTraceElement directly prevents the VM
from paying the cost of building the entire stack frame.
Skip all frames until we have found the first logger frame.
skip reflection call
We've found the relevant frame.
We haven't found a suitable frame, so just punt.  This is
OK as we are only committed to making a "best effort" here.
the log record could be created for a platform logger
Copying routines, needed to quickly fabricate new Field,
Method, and Constructor objects from templates
Comparison and hashing
non-private to simplify nested class access
assert (initCapacity & -initCapacity) == initCapacity;  power of 2
Allow for a bit of growth
Multiply by -127, and left-shift to use least bit as part of hash
Use optimized form of 3 * s.
Next capacity is len, 2 * current capacity.
assert (newCapacity & -newCapacity) == newCapacity;  power of 2
can't expand any further
Adapted from Knuth Section 6.4 Algorithm R
Look for items to swap into newly vacated slot
starting at index immediately following deletion,
and continuing until a null slot is seen, indicating
the end of a run of possibly-colliding keys.
The following test triggers if the item at slot i (which
hashes to be at slot r) should take the spot vacated by d.
If so, we swap it in, and then continue with d now at the
newly vacated i.  This process will terminate when we hit
the null slot at the end of this run.
The test is messy because we are using a circular table.
o is not a Map
to support fast-fail
to allow remove()
To avoid unnecessary next computation
reference to main table or copy
back up index to revisit new contents after deletion
Removal code proceeds as in closeDeletion except that
it must catch the rare case where an element already
seen is swapped into a vacant slot that will be later
traversed by this iterator. We cannot allow future
next() calls to return it again.  The likelihood of
this occurring under 2/3 load factor is very slim, but
when it does happen, we must make a copy of the rest of
the table to use for the rest of the traversal. Since
this can only happen when we are near the end of the table,
even in these rare cases, this is not very expensive in
time or space.
vacate the slot
If traversing a copy, remove in real table.
We can skip gap-closure on copy.
See closeDeletion for explanation of this conditional
If we are about to swap an already-seen element
into a slot that may later be returned by next(),
then clone the rest of table for use in future
next() calls. It is OK that our copy will have
a gap in the "wrong" place, since it will never
be used for searching anyway.
if shadowing, force into main table
key present ?
more elements than expected -> concurrent modification from other thread
fewer elements than expected or concurrent modification from other thread detected
final null marker as per spec
key present ?
more elements than expected -> concurrent modification from other thread
fewer elements than expected or concurrent modification from other thread detected
final null marker as per spec
key present ?
more elements than expected -> concurrent modification from other thread
fewer elements than expected or concurrent modification from other thread detected
final null marker as per spec
Write out and any hidden stuff
Write out size (number of Mappings)
Write out keys and values (alternating)
Read in any hidden stuff
Read in size (number of Mappings)
Read the keys and values, and put the mappings in the table
current index, modified on advance/split
-1 until first use; then one past last index
initialized when fence set
initialize fence and size on first use
The fully qualified exception class name
The vmcid part
The minor code part
The completion status part
Determines the current byte stream position
(also handles fragmented streams)
mark/reset from java.io.InputStream
end pass loop
case OpCodes.OP_QUO :
should never hit this here.
if(null != expr)
protected Expression quo(int opPos) throws TransformerException
cast OK, I guess.
bit-o-hackery, but this code is due for the morgue anyway...
This is the magic and invisible "." at the head of every
match pattern, and corresponds to the current node in the context
list, from where predicates are counted.
So, in order to calculate "foo[3]", it has to count from the
current node in the context list, so, from that current node,
the full pattern is really "self::node()/child::foo[3]".  If you
translate this to a select pattern from the node being tested,
which is really how we're treating match patterns, it works out to
self::foo/parent::node[child::foo[3]]", or close enough.
The current id for extension functions.
We create a method key to uniquely identify this function so that we
can cache the object needed to invoke it.  This way, we only pay the
reflection overhead on the first call.
should never happen
+"; file "+te.getSystemId()
+"; line "+te.getLineNumber()
Encoding and version info will be available only after startElement
is called for first time. So, defer START_DOCUMENT event of StAX till
that point of time.
clear the namespaces
set document location
create attribute and namespace events
Drat. We were trying to postpone this until the first element so that we could get
the locator, but we can't output a comment before the start document, so we're just
going to have to do without the locator if it hasn't been set yet.
Drat. We were trying to postpone this until the first element so that we could get
the locator, but we can't output a PI before the start document, so we're just
going to have to do without the locator if it hasn't been set yet.
namespace declaration disguised as an attribute. If the
namespace has already been declared, skip it, otherwise
write it as an namespace
These imports needed only as a workaround for a JavaDoc bug
1. Try user-specified system property
FIXME: This code should be run in a doPrivileged and
not use the context classloader, to avoid being
dependent on the invoking thread.
Checking AllPermission also seems wrong.
workaround for javaws, plugin,
load factory class using non-system classloader
2. Try service provider interface
choose first provider instance
Ignore the security exception, try the next provider
3. Use platform-specific system-wide default
Yes, so make sure it is connected and converted
to a stub (if needed)...
read and discard the repository ID
write the repository ID
needs to validate for ID attribute normalization
fall through and return not equal
Explicitly reset hash code value to -1
for javadoc and covariant return type
override for performance
override for performance
override for performance
ThaiBuddhistChronology is implicit in the THAIBUDDHIST_DATE_TYPE
should be protected and package private
--------- object factory stuff
Try to use current class loader
ignore and continue
All other exceptions are passed up.
Not in class path; try to use codebase
Try each factory until one succeeds
Use builder if installed
builder must return non-null factory
Use reference if possible
if reference identifies a factory, use exclusively
No factory found, so return original refInfo.
Will reach this point if factory class is not in
class path and reference does not contain a URL for it
if reference has no factory, check for addresses
try using any specified factories
If refInfo is a URL string, try to use its URL context factory
If no context found, continue to try object factories.
If refInfo is an array of URL strings,
try to find a context factory for any one of its URLs.
If no context found, continue to try object factories.
%%% Ignore environment for now.  OK since method not public.
Used by ContinuationContext
%%% Ignore environment for now.  OK since method not public.
pass in 'null' to indicate creation of generic context for scheme
(i.e. not specific to a URL).
Found object factory
------------ Initial Context Factory Stuff
No factory installed, use property
Get initial context factory class name
-----  Continuation Context Stuff
Make a (shallow) copy of the environment.
------------ State Factory Stuff
Try each factory until one succeeds
----------- Methods to support ordered multivalued attributes
Type-specific CORBA::Object operations
read_longdouble not supported by IDL/Java mapping
default constructor for NEXT_TERMINATOR, PREV_TERMINATOR
Check for head updates every other hop.
If p == q, we are sure to follow head instead.
p is first node
Successful CAS is the linearization point
for e to become an element of this deque,
and for newNode to become "live".
hop two nodes at a time
Failure is OK.
Lost CAS race to another thread; re-read prev
Check for tail updates every other hop.
If p == q, we are sure to follow tail instead.
p is last node
Successful CAS is the linearization point
for e to become an element of this deque,
and for newNode to become "live".
hop two nodes at a time
Failure is OK.
Lost CAS race to another thread; re-read next
Unlink interior node.
This is the common case, since a series of polls at the
same end will be "interior" removes, except perhaps for
the first one, since end nodes cannot be unlinked.
At any time, all active nodes are mutually reachable by
following a sequence of either next or prev pointers.
Our strategy is to find the unique active predecessor
and successor of x.  Try to fix up their links so that
they point to each other, leaving x unreachable from
active nodes.  If successful, and if x has no live
predecessor/successor, we additionally try to gc-unlink,
leaving active nodes unreachable from x, by rechecking
that the status of predecessor and successor are
unchanged and ensuring that x is not reachable from
tail/head, before setting x's prev/next links to their
logical approximate replacements, self/TERMINATOR.
Find active predecessor
Find active successor
TODO: better HOP heuristics
always squeeze out interior deleted nodes
Squeeze out deleted nodes between activePred and
activeSucc, including x.
Try to gc-unlink, if possible
Recheck expected state of predecessor and successor
Ensure x is not reachable from head
Ensure x is not reachable from tail
Finally, actually gc-unlink
Ensure o is not reachable from head
Ensure o is not reachable from tail
Finally, actually gc-unlink
Ensure o is not reachable from head
Ensure o is not reachable from tail
Finally, actually gc-unlink
Either head already points to an active node, or we keep
trying to cas it to the first node until it does.
It is possible that p is PREV_TERMINATOR,
but if so, the CAS is guaranteed to fail.
Either tail already points to an active node, or we keep
trying to cas it to the last node until it does.
It is possible that p is NEXT_TERMINATOR,
but if so, the CAS is guaranteed to fail.
found active CAS target
found active CAS target
TODO: should we skip deleted nodes here?
Check for head updates every other hop.
If p == q, we are sure to follow head instead.
It is possible that p is PREV_TERMINATOR,
but if so, the CAS is guaranteed to fail.
Check for tail updates every other hop.
If p == q, we are sure to follow tail instead.
It is possible that p is NEXT_TERMINATOR,
but if so, the CAS is guaranteed to fail.
Minor convenience utilities
Copy c into a private chain of Nodes
Avoid edge case of a single Node with non-null item.
Collection.size() spec says to max out
As historically specified in AbstractQueue#addAll
Copy c into a private chain of Nodes
Atomically append the chain at the tail of this collection
Check for tail updates every other hop.
If p == q, we are sure to follow tail instead.
p is last node
Successful CAS is the linearization point
for all elements to be added to this deque.
Try a little harder to update tail,
since we may be adding many elements.
Lost CAS race to another thread; re-read next
p might be active end or TERMINATOR node; both are OK
current node; null until initialized
batch size for splits
true when no more nodes
Write out any hidden stuff
Write out all elements in the proper order.
Use trailing null as sentinel
Read in elements until trailing null sentinel found
Only for JRadioButton
Need to get traversal key event
Map actions to the arrow keys
Only for JRadioButton
Unmap actions from the arrow keys
Paint the radio button
Use selected icon
Draw the Text
find the union of the icon and text rects (from Rectangle.java)
/ Private functions
Get the source of the event.
Check whether the source is JRadioButton, it so, whether it is visible
/ Inner Classes
Check if given object is in the button group
Check if the next object to gain focus belongs
to the button group or not
If next component in the button group, use last/first button as base focus
otherwise, use the activeBtn as the base focus
Get the button model from the source.
If the button model is DefaultButtonModel, and use it, otherwise return.
get the ButtonGroup of the button from the button model
Get all the buttons in the group
If firstBtn is not set yet, curElement is that first button
The source has not been yet found and the current element
is the last previousBtn
The source has been found and the current element
is the next valid button of the list
Set new last "valid" JRadioButton of the list
Select Next button. Cycle to the first button if the source
button is the last of the group.
Select previous button. Cycle to the last button if the source
button is the first button of the group.
In case the button does not belong to any group, it needs
to be treated as a component
Update the component we will use as base to transfer
If next component in the parent window is not in
the button group, current active button will be
base, otherwise, the base will be first or last
button in the button group
This listener checks if the key event is a KeyEvent.VK_TAB
or shift + KeyEvent.VK_TAB event on a radio button, consume the event
if so and move the focus to next/previous component
Get the source of the event.
Check whether the source is a visible and enabled JRadioButton
largest numerical value
These would not be used for EN. Only used for traditional numbering
These only used for mutiplicative-additive numbering
For infinity and NaN, use the decimal output.
Initialized to maximum size of output.
value is negative,
so append sign info
Isolate significand bits and OR in a high-order bit
so that the string representation has a known
Subnormal values have a 0 implicit bit; normal
values have a 1 implicit bit.
Isolate the low-order 13 digits of the hex
representation.  If all the digits are zero,
replace with a single 0; otherwise, remove all
If the value is subnormal, use the E_min exponent
value for double; otherwise, extract and report d's
exponent (the representation of a subnormal uses
Check for NaN based on values of bit fields, maximum
exponent and nonzero significand.
Neither val is NaN, thisVal is smaller
Neither val is NaN, thisVal is larger
Cannot use doubleToRawLongBits because of possibility of NaNs.
Values are equal
(-0.0, 0.0) or (!NaN, NaN)
(0.0, -0.0) or (NaN, !NaN)
-- This file was mechanically generated: Do not edit! --
Identical to ConstantClass except for this name
-- This file was mechanically generated: Do not edit! --
enforce limit == capacity
Output method constants
Set import precedence for this stylesheet
Set import precedence for all included stylesheets
Set import precedence for the stylesheet that imported this one
Set import precedence for the stylesheet that included this one
Start with precedence of current stylesheet as a basis.
Recursively examine all imported/included stylesheets.
Return true if this stylesheet includes/imports itself
Then check with any stylesheets that included/imported this one
Add the implicit mapping of 'xml' to the XML namespace URI
Report and error if more than one stylesheet defined
Error: more that one stylesheet defined
If this is a simplified stylesheet we must create a template that
grabs the root node of the input doc ( <xsl:template match="/"/> ).
This template needs the current element (the one passed to this
method) as its only child, so the Template class has a special
method that handles this (parseSimplified()).
Parse the children of this node
Exclude XSLT uri
We have to scan the stylesheet element's top-level elements for
variables and/or parameters before we parse the other elements
Now go through all the other top-level elements...
All template code should be compiled as methods if the
<xsl:apply-imports/> element was ever used in this stylesheet
Define a new class by extending TRANSLET_CLASS
Compile transform() to initialize parameters, globals & output
and run the transformation
Translate all non-template elements and filter out all templates
Separate templates by modes
save the element for later to pass to compileConstructor
Global variables and parameters are handled elsewhere.
Other top-level non-template elements are ignored. Literal
elements outside of templates will never be output.
Create fields of type char[] that will contain literal text from
Put the names array into the translet - used for dom/translet mapping
Put the namespace names array into the translet
Grab all the literal text in the stylesheet and put it in a char[]
Call the constructor in the AbstractTranslet superclass
Compile in code to set the output configuration from <xsl:output>
Set all the output settings files in the translet
Compile default decimal formatting symbols.
This is an implicit, nameless xsl:decimal-format top-level element.
Define and initialize 'current' variable with the root node
Create a new list containing variables/params + keys
Determine a partial order for the variables/params and keys
Translate vars/params and keys in the right order
Compile code for other top-level elements
Translate all whitespace strip/preserve rules
Compute max locals + stack and add method to class
If nothing was changed in this pass then we have a circular ref
Compute max locals + stack and add method to class
call resetPrefixIndex at the beginning of transform
Define and initialize current with the root node
push translet for PUTFIELD
prepare appropriate DOM implementation
DOMAdapter is on the stack
MultiDOM is on the stack
store to _dom variable
continue with globals initialization
Transfer the output settings to the output post-processor
Look for top-level elements that need handling
Compile method for handling top-level elements
Get a reference to that method
Push all parameters on the stack and call topLevel()
The 'this' pointer
The DOM reference
The output handler
push first arg for applyTemplates
push translet for GETFIELD to get DOM arg
push remaining 2 args
Compute max locals + stack and add method to class
TODO: move target down into the list
do we need this wrapper ?????
Return templates if no imported/included stylesheets
Is returned value cached?
Cache results in top-level stylesheet only
Error categories used to report errors to Parser.reportError()
Unexpected internal errors, such as null-ptr exceptions, etc.
Immediately terminates compilation, no translet produced
XSLT elements that are not implemented and unsupported ext.
Immediately terminates compilation, no translet produced
Fatal error in the stylesheet input (parsing or content)
Immediately terminates compilation, no translet produced
Other error in the stylesheet input (parsing or content)
Does not terminate compilation, no translet produced
Other error in the stylesheet input (content errors only)
Does not terminate compilation, a translet is produced
start with 1
pre-load and initialize InterruptedException and Cleaner classes
so that we don't get into trouble later in the run loop if there's
memory shortage while loading/initializing them lazily.
'instanceof' might throw OutOfMemoryError sometimes
so do this before un-linking 'r' from the 'pending' chain...
unlink 'r' from 'pending' chain
The waiting on the lock may cause an OutOfMemoryError
because it may try to allocate exception objects.
retry if waited
Give other threads CPU time so they hopefully drop some live references
and GC reclaims some space.
Also prevent CPU intensive spinning in case 'r instanceof Cleaner' above
persistently throws OOME for some time...
Fast path for cleaners
provide access in SharedSecrets
use default cookie policy if not specify one
if not specify CookieStore to use, use default one
if there's no default CookieStore, no way for us to get any cookie
apply path-matches rule (RFC 2965 sec. 3.3.4)
and check for the possible "secure" tag (i.e. don't send
'secure' cookies over unsecure links)
Enforce httponly attribute
Let's check the authorize port list if it exists
apply sort rule (RFC 2965 sec. 3.3.4)
if there's no default CookieStore, no need to remember any cookie
RFC 2965 3.2.2, key must be 'Set-Cookie2'
we also accept 'Set-Cookie' here for backward compatibility
Bogus header, make an empty list and log the error
If no path is specified, then by default
the path is the directory of the page/doc
As per RFC 2965, section 3.3.1:
Domain  Defaults to the effective request-host.  (Note that because
there is no dot at the beginning of effective request-host,
the default Domain can only domain-match itself.)
Empty port list means this should be restricted
to the incoming URI port
Only store cookies with a port list
IF the URI port is in that list, as per
RFC 2965 section 3.3.2
invalid set-cookie header string
to determine whether or not accept this cookie
pretect against malicious callback
Netscape cookie spec and RFC 2965 have different format of Cookie
header; RFC 2965 requires a leading $Version="1" string while Netscape
The workaround here is to add a $Version="1" string in advance
path rule only applies to the cookies with same name
those with more specific Path attributes precede those with less specific
As this instance is immutable, these two values
need only be calculated once.
Check and initialize state defined by parent.
Check rowType is not null
Check indexNames is neither null nor empty and does not contain any null element or empty string
Check all indexNames values are valid item names for rowType
initialize indexNames (copy content so that subsequent
modifs to the array referenced by the indexNames parameter
have no impact)
if obj is null or not a TabularData, return false
if obj is not a TabularData, return false
if obj is null, return false
if obj is not a TabularType, return false
Now, really test for equality between this TabularType instance and the other:
their names should be equal
their row types should be equal
their index names should be equal and in the same order (ensured by List.equals())
All tests for equality were successfull
Calculate the hash code value if it has not yet been done (ie 1st call to hashCode())
return always the same hash code for this instance (immutable)
Calculate the string representation if it has not yet been done (ie 1st call to toString())
return always the same string representation for this instance (immutable)
read and discard the repository ID
write the repository ID
may be null
promote to node-set
Compile relative path iterator(s)
Backwards branches are prohibited if an uninitialized object is
on the stack by section 4.9.4 of the JVM Specification, 2nd Ed.
We don't know whether this code might contain backwards branches,
so we mustn't create the new object until after we've created
this argument to its constructor.  Instead we calculate the
value of the argument to the constructor first, store it in
a temporary variable, create the object and reload the argument
from the temporary to avoid the problem.
Create new AbsoluteIterator
Initialize AbsoluteIterator with iterator from the stack
Clearing all of the links between nodes is "unnecessary", but:
- helps a generational GC if the discarded nodes inhabit
more than one generation
- is sure to free memory even if there is a reachable Iterator
Positional Access Operations
Put clone into "virgin" state
Initialize clone with our elements
Write out any hidden serialization magic
Write out size
Write out all elements in the proper order.
Read in any hidden serialization magic
Read in size
Read in all elements in the proper order.
batch array size increment
null OK unless traversed
current node; null until initialized
size estimate; -1 until first needed
initialized when est set
batch size for splits
Override the setEscaping method just to indicate that this class is
aware that that method might be called.
SAX & Xerces feature ids
REVISIT: this value should be null by default and should be set during creation of
Schema validation is false by default and hence there is no
need to set it to false here.  Also, schema validation is
not a recognized feature for DTDConfiguration's and so
setting this feature here would result in a Configuration
XML Schem validation
add recognized features
turn off deferred DOM
Set values so that the value of the
infoset parameter is true (its default value).
true: namespace-declarations, well-formed,
element-content-whitespace, comments, namespaces
false: validate-if-schema, entities,
set other default values
REVISIT: by default Xerces assumes that input is certified.
default is different from the one specified in the DOM spec
Xerces datatype-normalization feature is on by default
This is a recognized feature only for XML Schemas. If the
configuration doesn't support this feature, ignore it.
get state of namespace-declarations parameter.
true is not supported
setting those features to false is no-op
Setting false has no effect.
true: namespaces, namespace-declarations,
false: validate-if-schema, entities,
false is not supported
setting these features to true is no-op
REVISIT: implement "namespace-declaration" feature
Note: validation and dynamic validation are mutually exclusive
XSModel - turn on PSVI augmentation
or any Xerces feature
REVISIT: type mismatch
REVISIT: type mismatch
map DOM schema-location to JAXP schemaSource property
tokenize location string
REVISIT: type mismatch
turn off schema features
map to JAXP schemaLanguage
turn on schema features
map to JAXP schemaLanguage
turn off schema features
map to JAXP schemaLanguage
Try to set the property.
If this is a boolean parameter a type mismatch should be thrown.
Parameter is not recognized
REVISIT: This is somewhat expensive to compute
but it's possible that the user has a reference
to the configuration and is changing the values
of these features directly on it.
This could be a recognized feature or property.
This isn't a feature; perhaps it's a property
true is not supported
false is not supported
Recognize Xerces features.
REVISIT: add Xerces recognized properties/features
If DOMParser insstance is already busy parsing another document when this
method is called, then raise INVALID_STATE_ERR according to DOM L3 LS spec
reset interrupt state
Consume this exception if the user
issued an interrupt or an abort.
need to wrap the LSInput with an XMLInputSource
reset interrupt state
Consume this exception if the user
issued an interrupt or an abort.
REVISIT: need to implement.
need to wrap the LSInput with an XMLInputSource
check whether there is a Reader
according to DOM, we need to treat such reader as "UTF-16".
check whether there is an InputStream
if there is a string data, use a StringReader
according to DOM, we need to treat such data as "UTF-16".
otherwise, just use the public/system/base Ids
all inputs are null
If parse operation is in progress then reset it
If not busy then this is noop
namespace declarations parameter has no effect if namespaces is false.
handled by ELEMENT_NODE
These node types are ignored!!!
in the case where there is no lex handler, we still
want the text of the cdate to make its way through.
should be handled!!!
Process all namespace declarations
Ignore everything but NS declarations here
Process all other attributes
Ignore NS declarations here
Uri may be implicitly declared
If no prefix for this attr, we need to create
one because we cannot use the default ns
Add attribute to list
Now process the element itself
Uri may be implicitly declared
Generate SAX event to start element
Traverse all child nodes of the element (if any)
Generate SAX event to close element
Generate endPrefixMapping() for all pushed prefixes
check if this dialog should be modal blocked BEFORE calling peer.show(),
otherwise, a pair of FOCUS_GAINED and FOCUS_LOST may be mistakenly
generated for the dialog
keep the KeyEvents from being dispatched
until the focus has been transfered
This call is required as the show() method of the Dialog class
does not invoke the super.show(). So wried... :(
now guaranteed never to block
if this dialog is toolkit-modal, the filter should be added
to all EDTs (for all AppContexts)
it may occur that EDT for appContext hasn't been started yet, so
we post an empty invocation event to trigger EDT initialization
if this dialog is toolkit-modal, its filter must be removed
from all EDTs (for all AppContexts)
Restore normal key event dispatching
dialog can be shown and then disposed before its
modal filter is created
fix for 5048370: if hide() is called from super.doDispose(), then
hideAndDisposeHandler() should not be called here as it will be called
at the end of doDispose()
fix for 5048370: set isInDispose flag to true to prevent calling
to hideAndDisposeHandler() from hide()
On some platforms, changing the resizable state affects
the insets of the Dialog. If we could, we'd call invalidate()
from the peer, but we need to guarantee that we're not holding
the Dialog lock when we call invalidate().
find all the dialogs that block this one
add all blockers' blockers to blockers :)
find all windows from blockers' hierarchies
block all windows from scope of blocking except from blockers' hierarchies
we should unblock all the windows first...
also removes w from blockedWindows
... and only after that check if they should be blocked
by another dialogs
check if w is from children hierarchy
fix for 6271546: we should also take into consideration child hierarchies
of this dialog's blockers
application- and toolkit-excluded windows are not blocked by
document-modal dialogs from outside their children hierarchy
in 1.5 or earlier modalityType was absent, so use "modal" instead
inner class AccessibleAWTDialog
import debug stuff
Allocate the array to receive the encoding.
Encode the pdu
Reminder: BerEncoder does backward encoding !
The easy work.
Copyright (c) 1995-96 by Cisco Systems, Inc.
We can't specify Vector<SnmpOidTable> because the subinterface SnmpOidTable
overrides this method to return Vector<SnmpOidRecord>
Internal status report
%REVIEW% support multiple?
%REVIEW% support multiple?
%REVIEW% support multiple?
%REVIEW% support multiple?
Flag indicating that no more events should be delivered -- either
because input stream ran to completion (endDocument), or because
the user requested an early stop via deliverMoreNodes(false).
Support for startParse()
to report fatal errors in filtering mode
Not supported by all SAX2 filters:
Nothing we can do about it
Nothing we can do about it
Should we also bind as other varieties of handler?
(DTDHandler and so on)
Register a content handler for us to output to
Register a DTD handler for us to output to
Register a lexical handler for us to output to
Not all filters support this...
??? Should we register directly on the filter?
NOTE NAME -- subclassing issue in the Xerces version
Register an error handler for us to output to
NOTE NAME -- subclassing issue in the Xerces version
Set the number of events between resumes of our coroutine
Immediately resets number of events before _next_ resume as well.
These  pass the data to our client ContentHandler...
but they also count the number of events passing through,
and resume our coroutine each time that counter hits zero and
Note that for everything except endDocument and fatalError, we do the count-and-yield
BEFORE passing the call along. I'm hoping that this will encourage JIT
compilers to realize that these are tail-calls, reducing the expense of
the additional layer of data flow.
%REVIEW% Glenn suggests that pausing after endElement, endDocument,
and characters may be sufficient. I actually may not want to
stop after characters, since in our application these wind up being
concatenated before they're processed... but that risks huge blocks of
text causing greater than usual readahead. (Unlikely? Consider the
possibility of a large base-64 block in a SOAP stream.)
EXCEPTION: In this case we need to run the event BEFORE we yield.
This can cause a hang.  -sb
Otherwise, begin normal event delivery
LexicalHandler support. Not all SAX2 filters support these events
but we may want to pass them through when they exist...
%REVIEW% These do NOT currently affect the eventcounter; I'm asserting
that they're rare enough that it makes little or no sense to
pause after them. As such, it may make more sense for folks who
actually want to use them to register directly with the filter.
But I want 'em here for now, to remind us to recheck this assertion!
PROBLEM: Xerces is apparently _not_ calling the ErrorHandler for
exceptions thrown by the ContentHandler, which prevents us from
handling this properly when running in filtering mode with Xerces
as our event source.  It's unclear whether this is a Xerces bug
or a SAX design flaw.
%REVIEW% Current solution: In filtering mode, it is REQUIRED that
event source make sure this method is invoked if the event stream
abends before endDocument is delivered. If that means explicitly calling
us in the exception handling code because it won't be delivered as part
of the normal SAX ErrorHandler stream, that's fine; Not Our Problem.
EXCEPTION: In this case we need to run the event BEFORE we yield --
just as with endDocument, this terminates the event stream.
Nobody called init()? Do it now...
Coroutine system says we haven't registered. That's an
application coding error, and is unrecoverable.
Horrendous kluge to run filter to completion. See below.
Coroutine manager might throw no-such.
Yield control, resume parsing when done
If we're at end of document or were told to stop early
Running under startParseThread()
We'll co_exit from there.
Yield control. We do NOT expect anyone to ever ask us again.
Shouldn't happen unless we've miscoded our coroutine logic
"Shut down the garbage smashers on the detention level!"
Convenience: Run an XMLReader in a thread
Xalan thread pooling...
Guard against direct invocation of start().
Initially assume we'll run successfully.
For the duration of this operation, all coroutine handshaking
will occur in the co_yield method. That's the nice thing about
coroutines; they give us a way to hand off control from the
middle of a synchronous method.
Expected and harmless
Expected and harmless
Mark as no longer running in thread.
Mark as done and yield control to the controller coroutine
Shouldn't happen unless we've miscoded our coroutine logic
"CPO, shut down the garbage smashers on the detention level!"
If parsing is already done, we can immediately say so
SHOULD NEVER OCCUR, since the coroutine number and coroutine manager
are those previously established for this IncrementalSAXSource_Filter...
So I'm just going to return it as a parsing exception, for now.
Uninstall the listeners added by the WindowsInternalFrameTitlePane
Windows desktop icons can not be resized.  Therefore, we should
always return the minimum size of the desktop icon. See
false if this is a request node
initially non-null if isData; CASed to match
null until waiting
CAS methods for fields
CAS methods for fields
for untimed poll, tryTransfer
for offer, put, add
for transfer, take
for timed poll, tryTransfer
the node to append, if needed
restart on append race
find & match first node
update by 2 unless singleton
advance and retry
unless slack < 2
Use head if p offlist
No matches available
lost race vs opposite mode
move p to last node and append
temps for reads of next & tail
lost race vs opposite mode
not last; keep traversing
restart if off list
re-read on CAS failure
update if slack now >= 2
advance and retry
initialized after first item and cancel checks
bound if needed
establish spins at/near front
request unpark then recheck
probably at front
pred apparently spinning
next node to return item for
the corresponding item
last returned node, to support remove
predecessor to unlink lastRet
reset lastPred upon possible deletion of lastRet
next lastPred is old lastRet
at start of list
help with removal of lastPred.next
current node; null until initialized
batch size for splits
true when no more nodes
forget unneeded fields
check if at, or could be, head
at head or list empty
recheck if offlist
sweep now if enough votes
Unmatched nodes are never self-linked
trailing node is pinned
No need to also check for p == s, since that implies s == n
failure possible only due to interrupt
Use trailing null as sentinel
NOTE: This is a SUN PROPRIETARY EXTENSION
Constants shared across ForkJoinPool and WorkQueue
short bits == max index
max #workers - 1
even short bits
max 64 (even) slots
Masks and units for WorkQueue.scanState and ctl sp subfield
false when running tasks
must be negative
Mode bits for ForkJoinPool.config and WorkQueue.config
top half of int
must be negative
versioned, <0: inactive; odd:scanning
pool stack (ctl) predecessor
number of steals
randomization and stealer index hint
pool index and mode
1: locked, < 0: terminate; else 0
index of next slot for poll
index of next slot for push
the elements (initially unallocated)
the containing pool (may be null)
owning thread or null if shared
== owner during call to park; else null
task being joined in awaitJoin
mainly used by helpStealer
Place indices in the center of array (that is not yet allocated)
ignore odd/even tag bit
non-owner callers must read base first
ignore transient negative
possibly one task
ignore if queue removed
fenced write for task visibility
emulate poll from old array, push to new array
Specialized execution methods
mark as busy
release for GC
collect on overflow
if negative, correct for overflow
traverse from s to b
shorter than expected
replace with proxy
to sense movement on re-poll
Unsafe mechanics. Note that some are (and must be) the same as in FJP
static fields (initialized in static initializer below)
static configuration constants
Lower and upper word masks
runState bits: SHUTDOWN must be negative, others arbitrary powers of two
main pool control
to generate worker index
to create worker name string
also used as sync monitor
clears RSIGNAL bit
Creating, registering and deregistering workers
check if terminating
assign a pool index
skip if no array
unlikely to collide
step by approx half n
use as random seed
remove index from array
cancel remaining tasks
wake up replacement
don't need replacement
help clean on way out
too few active
no idle workers
too few workers
no more work
v is at top of stack
Scanning for tasks
initially holds randomization hint
avoid 0 for xorShift
try to activate
move and rescan
continue until stable
try to inactivate
hold prev stack top
w is terminating
see if pred parking
recheck after spins
is last waiter
shrink excess spares
else use timed wait
recheck before park
arbitrary seed for origin
first queue to scan
1:ran, >1:contended, <0:hash
run local task
poll other queues
move and restart
for stability check
v is subtask stealer
can't find stealer
help v or descend
clear local tasks too
can't further help
release idle worker
two passes of odd indices
unstable or stale
similar to tryAddWorker
CAS within lock
throws on exception
one-shot version of scan loop
run locals before each scan
re-establish active count
decrement active count without queuing
cannot shut down
enter SHUTDOWN phase
repeat until stable
still active workers
arrange for recheck
try to disable external
enter STOP phase
3 passes to help terminate
or until done or stable
try to disable
can't further help
try to dequeue
initialize caller's probe
create workQueues array with size a power of two
ensure at least 2 slots
initial submission or resizing
locked version of push
move on failure
create new queue
move if busy
offset ctl counts
In previous versions of this class, this method constructed
a task to run ForkJoinTask.invokeAll, but now external
invocation of multiple tasks is at least as efficient.
suppress momentarily negative values
Use a single pass through workQueues to collect counts
ignore transient negative
AbstractExecutorService overrides.  These rely on undocumented
fact that ForkJoinTask.adapt returns ForkJoinTasks that also
initialize field offsets for CAS etc
report 1 even if threads disabled
ignore exceptions in accessing/parsing properties
use security-managed default
default 1 less than #cores
This needs to grow too.
Nesting of '[' so we can know if the given element should be
counted inside the m_patternMap.
fall-through on purpose
fall-through on purpose
Unused at the moment
Unused at the moment
Unused at the moment
fall through on purpose
Assume last was wildcard. This is not legal according
to the draft. Set the below to true to make namespace
To older XPath code it doesn't matter if
error() is called or errorForDOM3().
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of PopupMenuPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of PopupMenuPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
for re-use in engineUpdate(ByteBuffer input)
Accumulating negatively avoids surprises near MAX_VALUE
format == null assumed here
has already been set
Format the output string using the values array and the fmt. tokens
Append separation token before first digit/letter/numeral
Append next digit/letter/numeral and separation token
Append separation token after last digit/letter/numeral
Special case for Greek alphabet
General case: search for end of group
a result code of zero indicates success
the paint context returned will have a few dummy values. The
implementation of doPaint doesn't bother with the "decode" methods
but calculates where to paint the circles manually. As such, we
only need to indicate in our PaintContext that we don't want this
to ever be cached
it is assumed that in the normal orientation the separator renders
horizontally. Other code rotates it as necessary for a vertical
The scrollpane won't work with a windowless child... it assumes
it is moving a child window around so the windowless child is
wrapped with a window.
calculate the view size, accounting for border but not scrollbars
- don't use right/bottom insets since they vary depending
on whether or not scrollbars were displayed on last resize
determine whether or not horz or vert scrollbars will be displayed
adjust predicted view size to account for scrollbars
if child is smaller than view, size it up
update adjustables... the viewport size may have changed
with the scrollbars coming or going so the viewport size
is updated before the adjustables.
Bug 4124460. Save the current adjustable values,
so they can be restored after addnotify. Set the
adjustables to 0, to prevent crashes for possible
Bug 4124460. Restore the adjustable values.
4352819: We only need this degenerate writeObject to make
it safe for future versions of this class to write optional
data to the stream.
4352819: Gotcha!  Cannot use s.defaultReadObject here and
then continue with reading optional data.  Use GetField instead.
Note to future maintainers
We are reading pre-1.4 stream that doesn't have
optional data, not even the TC_ENDBLOCKDATA marker.
Reading anything after this point is unsafe as we will
read unrelated objects further down the stream (4352819).
Reading data from 1.4 or later, it's ok to try to read
optional data as OptionalDataException with eof == true
will be correctly reported
The actual etherealize operation
for this entry.  It is
represented as a Thread because
the POA.deactivate_object never
waits for the completion.
single element holder for counter
accessed in actions
accessed in actions
XXX Log this
State,   Input,     Guard,                  Action,             new State
Methods that drive the FSM: the real interface to this class
Most just call the doIt method, but startEtherealize needs
PublicId.java - Information about public identifiers
HeadlessException will be thrown by TextComponent's readObject
Make sure the state we just read in for columns, rows,
and scrollbarVisibility has legal values
private objects to cache the locale and resource bundle
memorize the most-recent locale
ignored - kept around for compatibility
get the Credential Class
get the Principal Class
get the Principal Name
we have a name with spaces in it --
keep parsing until we find the end quote,
and keep the spaces in the name
this should never happen
this should never happen
perform new initialization from the permission name
name only has a credential class specified
perform regular initialization
initialize metadata fields by default values
The list of interceptors to be invoked
True if interceptors are to be invoked, or false if not
Note: This is a global enable/disable flag, whereas the enable flag
in the RequestInfoStack in PIHandlerImpl is only for a particular Thread.
NOTE: Be careful about adding additional attributes to this class.
Multiple threads may be calling methods on this invoker at the same
If invocation is not yet enabled, don't do anything.
Create IORInfo object to pass to IORInterceptors:
Call each IORInterceptor:
This loop counts backwards for greater efficiency.
Benchmarks have shown that counting down is more efficient
than counting up in Java for loops, as a compare to zero is
faster than a subtract and compare to zero.  In this case,
it doesn't really matter much, but it's simply a force of habit.
as per PI spec (orbos/99-12-02 sec 7.2.1), if
establish_components throws an exception, ignore it.
Change the state so that only template operations are valid
Note that exceptions here are NOT ignored, as per the
ORT spec (orbos/01-01-04)
Change the state so that no operations are valid,
in case a reference to info escapes this scope.
This also completes the actions associated with the
template interceptors on this POA.
No-op: ignore exception in this case
No-op: ignore exception in this case
If invocation is not yet enabled, don't do anything.
Make a a fresh slot table available to TSC in case
interceptors need to make out calls.
Client's TSC is now RSC via RequestInfo.
Get all ClientRequestInterceptors:
We will assume that all interceptors returned successfully,
and adjust the flowStackIndex to the appropriate value if
we later discover otherwise.
Determine whether we are calling send_request or send_poll:
(This is currently commented out because our ORB does not
yet support the Messaging specification, so send_poll will
never occur.  Once we have implemented messaging, this may
Again, it is not necessary for a switch here, since
there is only one starting point call type (see
as per PI spec (orbos/99-12-02 sec 5.2.1.), if
interception point throws a ForwardRequest,
no other Interceptors' send_request operations are
For some reason, using break here causes the VM on
NT to lose track of the value of flowStackIndex
after exiting the for loop.  I changed this to
check a boolean value instead and it seems to work
as per PI spec (orbos/99-12-02 sec 5.2.1.), if
interception point throws a SystemException,
no other Interceptors' send_request operations are
For some reason, using break here causes the VM on
NT to lose track of the value of flowStackIndex
after exiting the for loop.  I changed this to
check a boolean value instead and it seems to
Remember where we left off in the flow stack:
Make the SlotTable fresh for the next interception point.
end enabled check
If invocation is not yet enabled, don't do anything.
NOTE: It is assumed someplace else prepared a
fresh TSC slot table.
Get all ClientRequestInterceptors:
Determine whether we are calling receive_reply,
receive_exception, or receive_other:
If we would be calling RECEIVE_REPLY, but this is a
one-way call, override this and call receive_other:
Only step through the interceptors whose starting points
have successfully returned.
Unlike the previous loop, this one counts backwards for a
reason - we must execute these in the reverse order of the
as per PI spec (orbos/99-12-02 sec 5.2.1.), if
interception point throws a ForwardException,
ending point call changes to receive_other.
as per PI spec (orbos/99-12-02 sec 5.2.1.), if
interception point throws a SystemException,
ending point call changes to receive_exception.
See doc for setPICurrentPushed as to why this is necessary.
Check info for null in case errors happen before initiate.
After the pop, original client's TSC slot table
remains avaiable via PICurrent.
end enabled check
If invocation is not yet enabled, don't do anything.
Make a fresh slot table for RSC.
Make a fresh slot table for TSC in case
interceptors need to make out calls.
Get all ServerRequestInterceptors:
We will assume that all interceptors returned successfully,
and adjust the flowStackIndex to the appropriate value if
we later discover otherwise.
Currently, there is only one server-side starting point
interceptor called receive_request_service_contexts.
as per PI spec (orbos/99-12-02 sec 5.3.1.), if
interception point throws a ForwardRequest,
no other Interceptors' starting points are
called and send_other is called.
For some reason, using break here causes the VM on
NT to lose track of the value of flowStackIndex
after exiting the for loop.  I changed this to
check a boolean value instead and it seems to work
as per PI spec (orbos/99-12-02 sec 5.3.1.), if
interception point throws a SystemException,
no other Interceptors' starting points are
For some reason, using break here causes the VM on
NT to lose track of the value of flowStackIndex
after exiting the for loop.  I changed this to
check a boolean value instead and it seems to
Remember where we left off in the flow stack:
The remaining points, ServantManager and Servant
all run in the same logical thread.
Now TSC and RSC are equivalent.
end enabled check
If invocation is not yet enabled, don't do anything.
NOTE: do not touch the slotStack.  The RSC and TSC are
equivalent at this point.
Get all ServerRequestInterceptors:
Currently, there is only one server-side intermediate point
interceptor called receive_request.
as per PI spec (orbos/99-12-02 sec 5.3.1.), if
interception point throws a ForwardRequest,
no other Interceptors' intermediate points are
called and send_other is called.
as per PI spec (orbos/99-12-02 sec 5.3.1.), if
interception point throws a SystemException,
no other Interceptors' starting points are
end enabled check
If invocation is not yet enabled, don't do anything.
NOTE: do not touch the slotStack.  The RSC and TSC are
equivalent at this point.
REVISIT: This is moved out to PIHandlerImpl until dispatch
path is rearchitected.  It must be there so that
it always gets executed so if an interceptor raises
an exception any service contexts added in earlier points
this point get put in the exception reply (via the SC Q).
Get all ServerRequestInterceptors:
Determine whether we are calling
send_exception, or send_other:
Only step through the interceptors whose starting points
have successfully returned.
as per PI spec (orbos/99-12-02 sec 5.3.1.), if
interception point throws a ForwardException,
ending point call changes to receive_other.
as per PI spec (orbos/99-12-02 sec 5.3.1.), if
interception point throws a SystemException,
ending point call changes to send_exception.
Remember that all interceptors' starting and ending points
have already been executed so we need not do anything.
Get rid of the Server side RSC.
end enabled check
ForwardRequest may be null if the forwarded IOR is set internal
to the ClientRequestDispatcher rather than explicitly through Portable
Interceptors.  In this case, we need not update the client
delegate ForwardRequest object.
Convert the forward object into an IOR:
Can't be a descendant, has fewer components in the path.
wrap XNI exceptions as SAX exceptions
must be a parser exception; mine it for locator info and throw
why did we create an XMLParseException?
wrap XNI exceptions as SAX exceptions
must be a parser exception; mine it for locator info and throw
why did we create an XMLParseException?
controls whether the methods of an object implementing
org.xml.sax.ext.EntityResolver2 will be used by the parser.
Refresh EntityResolver wrapper.
controls whether the methods of an object implementing
org.xml.sax.ext.EntityResolver2 will be used by the parser.
check if the property is managed by security manager
fall back to the default configuration to handle the property
c.toArray might (incorrectly) not return Object[] (see 6260652)
Let gc do its work
this shouldn't happen, since we are Cloneable
Positional Access Operations
Let gc do its work
Let gc do its work
index of next element to return
index of last element returned; -1 if no such
Racy but within spec, since modifications are checked
within or after synchronization in next/previous
update once at end of iteration to reduce heap write traffic
figure out which elements are to be removed
any exception thrown from the filter predicate at this stage
will leave the collection unmodified
shift surviving elements left over the spaces left by removed elements
Let gc do its work
current index, modified on advance/split
-1 until used; then one past last index
initialized when fence set
initialize on first use
hoist accesses and checks from loop
determine default setting for i18n support
REMIND(bcb) This creates an initial bidi element to account for
the \n that exists by default in the content.  Doing it this way
seems to expose a little too much knowledge of the content given
to us by the sub-class.  Consider having the sub-class' constructor
make an initial call to insertUpdate.
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
if (e == null)
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
if (e == null)
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
if (e == null)
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
if (e == null)
--- Document methods -----------------------------------------
REMIND - this needs to flip on the i18n property if run dir
is rtl and the i18n property is not already on.
Check whether the position of interest is the composed text
Mark the edit as done.
only fire undo if Content implementation supports it
undo for the composed text is not supported for now
see if complex glyph layout support is needed
if a default direction of right-to-left has been specified,
we want complex layout even if the text is all left to right.
Mark the edit as done.
only fire undo if Content implementation supports it
undo for the composed text is not supported for now
---- local methods -----------------------------------------
Check if a multi byte is encountered in the inserted text.
Should never happen
Calculate the range of paragraphs affected by the change.
Calculate the bidi levels for the affected range of paragraphs.  The
levels array will contain a bidi level for each character in the
Calculate the first span of characters in the affected range with
the same bidi level.  If this level is the same as the level of the
previous bidi element (the existing bidi element containing
firstPStart-1), then merge in the previous element.  If not, but
the previous element overlaps the affected range, truncate the
previous element at firstPStart.
Calculate the last span of characters in the affected range with
the same bidi level.  If this level is the same as the level of the
next bidi element (the existing bidi element containing lastPEnd),
then merge in the next element.  If not, but the next element
overlaps the affected range, adjust the next element to start at
If the first and last spans are contiguous and have the same level,
merge them and create a single new element for the entire span.
Otherwise, create elements for the first and last spans as well as
any spans in between.
Create an element for the first span.
Create elements for the spans in between the first and last
Create an element for the last span.
Calculate the set of existing bidi elements which must be
Update the change record.
Update the bidi element structure.
For each paragraph in the given range of paragraphs, get its
levels array and add it to the levels array for the entire span.
default run direction for the paragraph.  This will be
null if there is no direction override specified (i.e.
the direction will be determined from the content).
Create a Bidi over this paragraph then get the level
REMIND(bcb) we should really be using a Segment here.
REMIND(bcb) remove this code when debugging is done.
--- Document locking ----------------------------------
Assuming one doesn't do something wrong in a
subclass this should only happen if a
DocumentListener tries to mutate the document.
writer has full read access.... may try to acquire
lock in notification
writer has full read access.... may try to acquire
lock in notification
--- serialization ---------------------------------------------
Restore bidi structure
REMIND(bcb) This creates an initial bidi element to account for
the \n that exists by default in the content.
At this point bidi root is only partially correct. To fully
restore it we need access to getDefaultRootElement. But, this
is created by the subclass and at this point will be null. We
thus use registerValidation.
----- member variables ------------------------------------------
dump the attributes
--- AttributeSet ----------------------------
delegated to the immutable field "attributes"
The delegate nor it's resolvers had a match,
so we'll try to resolve through the parent
--- MutableAttributeSet ----------------------------------
should fetch a new immutable record for the field
--- Element methods -------------------------------------
--- TreeNode methods -------------------------------------
--- serialization ---------------------------------------------
---- variables -----------------------------------------------------
need to grow the array
patch the existing array
--- Element methods -----------------------------------
see if the last index can be used.
last index wasn't a hit, but it does give useful info about
where a hit (if any) would be.
found the location
didn't find it, but we indicate the index of where it would belong
------ TreeNode ----------------------------------------------
------ members ----------------------------------------------
--- Element methods ---------------------------------------------
------ TreeNode ----------------------------------------------
--- serialization ---------------------------------------------
set the range with positions that track change
---- members -----------------------------------------------------
System.out.println("BidiElement: start = " + start
Level 0 is base level (non-embedded) left-to-right
--- CompoundEdit methods --------------------------
if the number of changes gets too great, start using
a hashtable for to locate the change for a given element.
if we have a hashtable... add the entry if it's
change the state
fire a DocumentEvent to notify the view(s)
change the state
fire a DocumentEvent to notify the view(s)
--- DocumentEvent methods --------------------------
--- member variables ------------------------------------
DocumentEvent methods delegated to DefaultDocumentEvent source
except getType() which depends on operation (Undo or Redo).
Since this event will be reused, switch around added/removed.
PENDING(prinz) need MutableElement interface, canRedo() should check
PENDING(prinz) need MutableElement interface, canUndo() should check
Since this event will be reused, switch around added/removed.
invariant: begin <= pos <= end
NOTE: This is not used or set any where. Were we allowed to remove
fields, this would be removed.
Amount to offset text, the value of this comes from
defaultTextShiftOffset once setTextShiftOffset has been invoked.
Value that is set in shiftOffset once setTextShiftOffset has been
invoked. The value of this comes from the defaults table.
load shared instance defaults
set the following defaults on the button
perform UI specific press action, e.g. Windows L&F shifts text
Paint the Icon
paint UI specific focus
revert back to 0 offset
Method signature defined here overriden in subclasses.
Perhaps this class should be abstract?
layout the text and icon
inner class AccessibleJCheckBox
should never happen.
trace creates and disposes
show reuse hits/misses
show bad params, misc.
Get screen bounds
If we have GraphicsConfiguration use it to get screen bounds
If we don't have GraphicsConfiguration use primary screen
Calculate the screen size that popup should fit
Insets include the task bar. Take them into account.
Ensure that popup menu fits the screen
If not found and we have invoker, ask invoker about his gc
NOTE: this use to set the flag on a shared JPopupMenu, which meant
this effected ALL JPopupMenus.
PENDING(ges): Why not use an array?
Is it a no-op?
if closing, first close all Submenus
4234793: This is a workaround because JPopupMenu.firePopupMenuCanceled is
a protected method and cannot be called from BasicPopupMenuUI directly
The real solution could be to make
firePopupMenuCanceled public and call it directly.
This is a popup menu with MenuElement children,
set selection path before popping up!
4694797: When popup menu is made invisible, selected path
should be cleared
adjust the location of the popup
Use the invoker's frame so that events
are propagated properly
To avoid integer overflow
notify listeners that the popup became visible
notify listeners that a popup list item is selected
notify listeners that the popup became hidden
get the popup list
get the first selected item
fire the event with the popup invoker as the source.
Check invokerContext because Component.getAccessibleContext
returns null. Classes that extend Component are responsible
for returning a non-null AccessibleContext.
inner class AccessibleJPopupMenu
Save the invoker, if its Serializable.
Save the popup, if its Serializable.
Message keys used by the serializer
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The localname is the portion after the optional colon; the message indicates
that there is a problem with that part of the QNAME.
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The prefix is the portion before the optional colon; the message indicates
that there is a problem with that part of the QNAME.
indices happen to align
adjacent parsing mode, update setting in previous parsers
Append the width to the subsequentWidth of the active parser
Append the new parser as a fixed width
Retain the previous active parser
Modify the active parser to be fixed width
The new parser becomes the mew active parser
Replace the modified parser with the updated one
The new Parser becomes the active parser
pad and continue parsing
Fields defined by Locale
Fields defined by Locale
Fields defined by Locale
end of literal
SDF = SimpleDateFormat
SDF, LDML (different to both for 1/2 chars)
LDML (different in SDF)
LDML (removed quarter from 310)
SDF, LDML (stand-alone)
SDF, LDML (different to both for 1/2 chars)
LDML (needs localized week number)
LDML (SDF uses milli-of-second number)
310 (proposed for LDML)
310 (proposed for LDML)
310 - z - time-zone names, matches LDML and SimpleDateFormat 1 to 4
310 - Z - matches SimpleDateFormat and LDML
310 - V - time-zone id, matches LDML
310 - p - prefix for padding
310 - X - matches LDML, almost matches SDF for 1, exact match 2&3, extended 4&5
310 - x - matches LDML
310 - w, W, and Y are localized forms matching LDML
LDML - U - cycle year name, not supported by 310 yet
LDML - l - deprecated
LDML - j - not relevant
LDML - g - modified-julian-day
LDML - v,V - extended time-zone names
return original position
input checked by DateTimeFormatterBuilder
cache context before changed by decorated parser
no more characters in the string
not enough characters in the string to meet the parse width
parse of decorated field didn't parse to the end
nothing to do here
using ordinals to avoid javac synthetic inner class
using ordinals to avoid javac synthetic inner class
validated by caller
validated by caller
validated by caller
IOOBE if invalid position
need at least min width digits
re-parse now we know the correct width
minus zero not allowed
minus zero not allowed
'+' only parsed if minWidth exceeded
'+' must be parsed if minWidth exceeded
overflow, parse 1 less digit
Use the reduced value if it fits in minWidth
Otherwise truncate to fit in maxWidth
In case the Chronology is changed later, add a callback when/if it changes
scale is zero if value is zero
valid if whole field is optional, invalid if minimum width
valid if whole field is optional, invalid if minimum width
need at least min width digits
can use int because we are only parsing up to 9 digits
need at least min width digits
validated by caller
days in a 400 year cycle = 146097
days in a 10,000 year cycle = 146097 * 25
seconds per day = 86400
use INSTANT_SECONDS, thus this code is not bound by Instant.MAX
format mostly using LocalDateTime.toString
before current era
new context to avoid overwriting fields like year/month/day
parser restricts most fields to 2 digits, so definitely int
correctly parsed nano is also guaranteed to be valid
order used in pattern builder
anything larger than 99 silently dropped
parse normal plus/minus offset
IOOBE if invalid position
handle special case of empty no offset text
TODO: get localized version of 'GMT'
anything larger than 99 silently dropped
TODO: get localized version of 'GMT'
parse normal plus/minus offset
IOOBE if invalid position
use the id
cache per instance for now
don't convert zid -> metazone
if we have a set of preferred zones, need a copy and
add the preferred zones again to overwrite
prepare parse tree
handle fixed time-zone IDs
'0' or 'Z' after prefix is not part of a valid ZoneId; use bare prefix
performance optimization to avoid the
boundary check cost of key.charat(0)
down the tree
add the node as the child of the current node
have an existing <key, value> already, overwrite it
split the existing node
validated by caller
simple looping parser to find the chronology
validated by caller
Compile expression is 'select' attribute if present
If not, compile result tree from parameter body if present.
Store result tree into local variable for releasing it later
If neither are present then store empty string in parameter slot
Translate the value and put it on the stack
Make name acceptable for use as field name in class
Load reference to the translet (method is in AbstractTranslet)
Load the name of the parameter
TODO: namespace ?
Generete the value of the parameter (use value in 'select' by def.)
Mark this parameter value is not being the default value
Pass the parameter to the template
-- This file was mechanically generated: Do not edit! --
NPCTE fix for bugId 4499265, esc 0, MR 04 sept 2001
end of NPCTE fix for bugId 4499265
Implementation of the SnmpTableEntryFactory interface
XXXX xxxx zzz ZZZZ => public? or protected?
Implementation of the SnmpTableEntryFactory interface
Protected Abstract methods
protected void removeEntry(ObjectName name, Object entry)
all access entries imply read
Add some more information to help people with deployments that
worked before we required explicit create clauses. We're not giving
any information to the bad guys, other than that the access control
is based on a file, which they could have worked out from the stack
We studiously avoided regexes when parsing the properties file,
because that is done whenever the VM is started with the
appropriate -Dcom.sun.management options, even if nobody ever
creates an MBean.  We don't want to incur the overhead of loading
all the regex code whenever those options are specified, but if we
get as far as here then the VM is already running and somebody is
doing the very unusual operation of remotely creating an MBean.
Because that operation is so unusual, we don't try to optimize
by hand-matching or by caching compiled Pattern objects.
pseudo-codepoint "end of string"
just for better error messages
the string we're parsing
At any point, either c is s.codePointAt(i), or i == len and
c is EOS.  We use int rather than char because it is conceivable
(if unlikely) that a classname in a create clause might contain
"supplementary characters", the ones that don't fit in the original
16 bits for Unicode.
We don't check that classname components begin with suitable
characters (so we accept 1.2.3 for example).  This means that
there are only two states, which we can call dotOK and !dotOK
according as a dot (.) is legal or not.  Initially we're in
!dotOK since a classname can't start with a dot; after a dot
we're in !dotOK again; and after any other characters we're in
dotOK.  The classname is only accepted if we end in dotOK,
so we reject an empty name or a name that ends with a dot.
Advance c and i to the next character, unless already at EOS.
Message keys used by the serializer
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The localname is the portion after the optional colon; the message indicates
that there is a problem with that part of the QNAME.
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The prefix is the portion before the optional colon; the message indicates
that there is a problem with that part of the QNAME.
Facade to ResponseWaitingRoom.
Can never be unset...
Begin Code Base methods ---------------------------------------
Set this connection's code base IOR.  The IOR comes from the
SendingContext.  This is an optional service context, but all
JavaSoft ORBs send it.
The set and get methods don't need to be synchronized since the
first possible get would occur during reading a valuetype, and
that would be after the set.
Sets this connection's code base IOR.  This is done after
getting the IOR out of the SendingContext service context.
Our ORBs always send this, but it's optional in CORBA.
Get a CodeBase stub to use in unmarshaling.  The CachedCodeBase
won't connect to the remote codebase unless it's necessary.
End Code Base methods -----------------------------------------
REVISIT: WRONG: should not expose sockets here.
REVISIT - MessageMediator parameter?
End of file.
Description of this filter.
NOTE: we tested implementations using Maps, binary search
on a sorted list and this implementation. All implementations
provided roughly the same speed, most likely because of
overhead associated with java.io.File. Therefor we've stuck
with the simple lightweight approach.
Implements the method defined in SnmpMibNode.
if the entry does not exists, then registers an error for
each varbind involved (nb: should not happen, the error
should have been registered earlier)
Implements the method defined in SnmpMibNode.
Implements the method defined in SnmpMibNode.
public void addEntry(SnmpIndex index, Object entry)
protected synchronized void addEntry(SnmpIndex index, ObjectName name,
triggers callbacks on the entry factory
sends the notifications
Get the insertion position ...
bug jaw.00356.B : use oid rather than index to get the
Add a new element in the vectors ...
Insert new element ...
triggers callbacks on the entry factory
sends the notifications
looking for listener in handbackTable
Add the handback and the filter
looking for listener in handbackTable
If handback is null, remove the listener entry
PROTECTED METHODS - RowStatus
PROTECTED METHODS - get next
Just a simple check to speed up retrieval of last element ...
Last element of the table ...
First find the oid. This will allow to speed up retrieval process
during smart discovery of table (using the getNext) as the
management station will use the valid index returned during a
previous getNext ...
Returns the position following the position at which resOid
is found, or the position at which resOid should be inserted.
If the position returned is not out of bound, we will find
the next element in the array.
We are dealing with the last element of the table ..
Abstract Protected Methods
Construct the sub-oid starting at pos.
This sub-oid correspond to the oid part just after the entry
Register an exception when checking the RowStatus variable
Register an exception when checking the RowStatus variable
Implements the method defined in SnmpMibNode.
Checks that the oid is valid
Gets the part of the OID that identifies the entry
Finds the entry: false means that the entry does not exists
Fails if the entry is not found and the table does not
not support creation.
We know that the entry does not exists if (isentry == false).
we're not doing a set
we're doing a set but creation is disabled.
Validate the entry id
The entry already exists - validate the id
Registers this node for the identified entry.
We only try to identify the RowStatus for SET operations
Implements the method defined in SnmpMibNode. The algorithm is very
largely inspired from the original getNext() method.
This should be considered as a genErr, but we do not want to
abort the whole request, so we're going to throw
If the querried oid contains less arcs than the OID of the
xxxEntry object, we must return the first leaf under the
first columnar object: the best way to do that is to reset
the queried oid:
oid[0] = nodeId (arc of the xxxEntry object)
pos    = 0 (points to the arc of the xxxEntry object)
then we just have to proceed...
this will have the side effect to set
oid[pos] = nodeId
(pos+1) = length
so we won't fall into the "else if" cases below -
so using "else if" rather than "if ..." is guaranteed
to be safe.
oid[pos] is expected to be the id of the xxxEntry ...
The id requested is greater than the id of the xxxEntry,
so we won't find the next element in this table... (any
element in this table will have a smaller OID)
we must return the first leaf under the first columnar
object, so we are back to our first case where pos was
out of bounds... => reset the oid to contain only the
arc of the xxxEntry object.
The arc at the position "pos+1" is the id of the columnar
object (ie: the id of the variable in the table entry)
Now that we've got everything right we can begin.
pos points to the last arc in the oid, and this arc is
guaranteed to be the xxxEntry id (we have handled all
the other possibilities before)
We must therefore return the first leaf below the first
columnar object in the table.
Get the first index. If an exception is raised,
then it means that the table is empty. We thus do not
have to catch the exception - we let it propagate to
In that case we have (pos+1) = (length-1), so pos
points to the arc of the querried variable (columnar object).
Since the requested oid stops there, it means we have
to return the first leaf under this columnar object.
So we first get the first index:
Note: if this raises an exception, this means that the table
is empty, so we can let the exception propagate to the caller.
XXX revisit: not exactly perfect:
a specific row could be empty.. But we don't know
how to make the difference! => tradeoff holes
in tables can't be properly supported (all rows
must have the same holes)
So now there remain one last case, namely: some part of the
index is provided by the oid...
We build a possibly incomplete and invalid index from
The piece of index provided should begin at pos+2
oid[pos]   = id of the xxxEntry object,
oid[pos+1] = id of the columnar object,
oid[pos+2] ... oid[length-1] = piece of index.
We get the next index following the provided index.
If this raises an exception, then it means that we have
reached the last index in the table, and we must then
try with the next columnar object.
Bug fix 4269251
The SnmpIndex is defined to contain a valid oid:
this is not an SNMP requirement for the getNext request.
So we no more use the SnmpIndex but directly the SnmpOid.
If the variable must ne skipped, fall through...
XXX revisit: not exactly perfect:
a specific row could be empty.. But we don't know
how to make the difference! => tradeoff holes
in tables can't be properly supported (all rows
must have the same holes)
Loop on each var (column)
This should not happen. If it happens, (bug, or customized
methods returning garbage instead of raising an exception),
it probably means that there is nothing to return anyway.
So we throw the exception.
=> will skip to next node in the MIB tree.
So here we know both the row (entryoid) and the column (var)
Raising an exception here will make the catch() clause
switch to the next variable. If `var' is not readable
for this specific entry, it is not readable for any
other entry => skip to next column.
Prepare the result and the ACM checker.
Copy the entryOid at the end of `result'
Set the node Id and var Id in result.
Append nodeId.varId.<rowOid> to ACM checker.
No we're going to ACM check our OID.
No exception thrown by checker => this is all OK!
we have it: register the handler and return the
Skip to the next entry. If an exception is
thrown, will be catch by enclosing catch
and a skip is done to the next var.
Clean the checker.
Catching an exception here means we have to skip to the
Back to the first row.
Find out the next column.
This should not happen. If it happens, (bug, or customized
methods returning garbage instead of raising an exception),
it probably means that there is nothing to return anyway.
No need to continue, we throw an exception.
=> will skip to next node in the MIB tree.
Control the length of the oid
Check that the entry identifier is specified
loop on listener
Get the associated handback list and the associated filter list
loop on handback
never know ...we might find something ...
never know ...we might find something ...
Vector must be enlarged
Save old vector
Allocate larger vectors
Check pos validity
Copy original vector up to `pos'
Copy original vector from `pos' to end, leaving
an empty room at `pos' in the new vector.
Vector is large enough to accommodate one additional
Shift vector, making an empty room at `pos'
Fill the gap at `pos'
Validate that the new Temporal is a ChronoLocalDate (and not something else)
The Chronology is checked in with(date,time)
no overflow (256 is multiple of 2)
9223372036854775808 long, 2147483648 int
The following properties may be used to create a Connection.
The following properties may be used to create a Statement.
Reading and writing data
HOUR1 has no corresponding calendar field, thus, map
it to HOUR0 which will give the correct behavior.
Add a PropertyChangeListener to our AppContext so we're alerted
when the AppContext is disposed(), at which time this laf should
Note that we're likely calling removePropertyChangeListener()
during the course of AppContext.firePropertyChange().
However, EventListenerAggreggate has code to safely modify
the list under such circumstances.
this key defines which of the various cues to render.
L&Fs that want auditory feedback NEED to override playList.
InternalFrame Auditory Cue Mappings
hides the last open submenu,
and move selection one step back
resets selection and
hide the entire structure of open menu and its submenus
the cancel menu action behaviour
if set to true then top level menu selection
the menu itself will be unselect with the next cancel action
Internal Frame Auditory Cue Mappings
These window InputMap bindings are used when the Menu is
You can additionaly define OptionPane.messageFont which will
dictate the fonts used for the message, and
OptionPane.buttonFont, which defines the font for the buttons.
OptionPane Auditory Cue Mappings
Info and Plain
DEPRECATED - DO NOT USE!
DEPRECATED - DO NOT USE!
Causes tabs to be painted on top of the content area border.
The amount of overlap is then controlled by tabAreaInsets.bottom,
which is zero by default
cell text color
cell background color
grid line color
header text color
Support for changing the background/border of the currently
selected header column when the header has the keyboard focus.
like text component bg
ToolTips also support backgroundInactive, borderInactive,
ToolTipManager.enableToolTipMode currently supports:
enables tool tips for all windows of all java applications,
whether the windows are active or inactive
enables tool tips for windows of an application only when
the application has an active window
Bind specific keys that can invoke popup on currently
These bindings are only enabled when there is a default
button set on the rootpane.
also see the "AuditoryCues" section of the defaults table
We strive to only play one sound at a time (other platforms
appear to do this). This is done by maintaining the field
clipPlaying. Every time a sound is to be played,
cancelCurrentSound is invoked to cancel any sound that may be
create a HashSet to help us decide to play or not
get the name of the Action
if the actionName is in the audioCues HashSet, play it.
pass off firing the Action to a utility method
Return value not used.
We shall not interfere with already opened menu
Special case - if user clicks on divider we must
invoke popup from the SplitPane
Activate the frame.
The next ten enum values are reserved.
The next ten enum values are reserved.
which is going to be right most of the time
Casts to int are safe since the spine array index is the index minus
the prior element count from the current spine
completed chunks, if any
The current spine index
Last spine index
The current element index into the current spine
Last spine's last element index + 1
When splSpineIndex >= lastSpineIndex and
splElementIndex >= lastSpineElementFence then
this spliterator is fully traversed
tryAdvance can set splSpineIndex > spineIndex if the last spine is full
The current spine array
# of elements prior to end -
# of elements prior to current
completed chunks, if any
last (or current uncompleted) chunk
split just before last chunk (if it is full this means 50:50 split)
position to start of last chunk
The chunk we're currently writing into
All chunks, or null if there is only one chunk
completed chunks, if any
The current spine index
Last spine index
The current element index into the current spine
Last spine's last element index + 1
When splSpineIndex >= lastSpineIndex and
splElementIndex >= lastSpineElementFence then
this spliterator is fully traversed
tryAdvance can set splSpineIndex > spineIndex if the last spine is full
The current spine array
# of elements prior to end -
# of elements prior to current
completed chunks, if any
last (or current uncompleted) chunk
split just before last chunk (if it is full this means 50:50 split)
position us to start of last chunk
Casts to int are safe since the spine array index is the index minus
the prior element count from the current spine
Casts to int are safe since the spine array index is the index minus
the prior element count from the current spine
Casts to int are safe since the spine array index is the index minus
the prior element count from the current spine
customized config only
state saved in the event a user-specified asynchronous exception
was specified and thrown
get the Configuration
get the LoginModules configured for this application
clone returned array
Don't use bootstrap class loader directly to ensure
proper package access control!
get the default handler class
secure it with the caller's ACC
module invoked in doPrivileged
module invoked in doPrivileged
first clear state
throw the exception
start at moduleIndex
- this can only be non-zero if methodName is LOGIN_METHOD
instantiate the LoginModule
Allow any object to be a LoginModule as long as it
conforms to the interface.
call the LoginModule's initialize method
invoke the LoginModule initialize method
Throws ArrayIndexOutOfBoundsException if no such
method defined.  May improve to use LoginException in
find the requested method in the LoginModule
set up the arguments to be passed to the LoginModule method
invoke the LoginModule method
Throws ArrayIndexOutOfBoundsException if no such
method defined.  May improve to use LoginException in
if SUFFICIENT, return if no prior REQUIRED errors
if a module's LOGIN_METHOD threw a PendingException
then immediately throw it.
when LoginContext is called again,
the module that threw the exception is invoked first
(the module list is not invoked from the start).
previously thrown exception state is still present.
it is assumed that the module which threw
the exception can have its
LOGIN_METHOD invoked twice in a row
without any commit/abort in between.
in all cases when LoginContext returns
(either via natural return or by throwing an exception)
we need to call clearState before returning.
the only time that is not true is in this case -
do not call throwException here.
do not want privacy leak
(e.g., sensitive file path in exception msg)
capture an unexpected LoginModule exception
if REQUISITE, then immediately throw an exception
mark down that a REQUIRED module failed
mark down that an OPTIONAL module failed
we went thru all the LoginModules.
a REQUIRED module failed -- return the error
no module succeeded -- return the first error
no module succeeded -- all modules were IGNORED
The "selectionForeground" is the color of the text when it is painted
over a filled area of the progress bar. The "selectionBackground"
is for the text over the unfilled progress bar area.
0 1|numFrames-1 ... numFrames/2
must be repaintInterval*2*aPositiveInteger
make this false for
the current painting area
used to see if the size changed
maximum X (horiz) or Y box location
Listen for changes in the progress bar's data.
Listen for changes between determinate and indeterminate state.
Many of the Basic*UI components have the following methods.
This component does not have these methods because *ProgressBarUI
is not a compound component and does not accept input.
protected void installComponents()
protected void uninstallComponents()
protected void installKeyboardActions()
protected void uninstallKeyboardActions()
assert currentFrame >= 0 && currentFrame < numFrames
VERTICAL indeterminate progress bar
VERTICAL progress bar
If we're doing bouncing-box animation, update delta.
end of HORIZONTAL
VERTICAL progress bar
end of VERTICAL
area for border
Paint the bouncing box.
Deal with possible text painting
area for border
amount of progress to draw
draw the cells
draw one big Rect because there is no space between cells
draw each individual cell
draw the cells
draw one big Rect because there is no space between cells
draw each individual cell
Deal with possible text painting
Ensure that the progress string will fit
I'm doing this for completeness.
This uses both Height and Descent to be sure that
there is more than enough room in the progress bar
This does have a strange dependency on
getStringPlacememnt() in a funny way.
Ensure that the progress string will fit.
This is also for completeness.
needs to be recalculated
needs to be recalculated
Get the previous box drawn.
Update the frame number.
Get the next box to draw.
animationIndex == newValue
initialize repaint interval
initialize cycle length
Make sure repaintInterval is reasonable.
Make sure cycleTime is reasonable.
Force cycleTime to be a even multiple of repaintInterval.
assert cycleTime/repaintInterval is a whole multiple of 2.
we only bother installing the HierarchyChangeListener if we
start the animation thread if necessary
stop the animation thread if necessary
Called from initIndeterminateValues to initialize the animation index.
This assumes that numFrames is set to a correct value.
If this is a left-to-right progress bar,
start at the first frame.
If we go right-to-left or vertically, start at the right/bottom.
used to tune the repaint interval
the fixed repaint interval
the last time actionPerformed was called
XXX maybe should cache this after a while
actual = time - lastCall
difference = actual - interval
nextDelay = previousDelay - difference
= previousDelay - (time - lastCall - interval)
paint next frame
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
we don't want the animation to keep running if we're not displayable
|| p.startsWith("com.sun.") || p.equals("com.sun")
The topological sort (roughly) follows the algorithm described in
Horowitz and Sahni, _Fundamentals of Data Structures_ (1976),
Maps Objects to DigraphNodes that contain them
The set of Objects
DigraphNode -> Integer
Initialize scratch in-degree values, zero list
Add nodes with zero in-degree to the zero list
For each out node of the output node, decrement its in-degree
If the in-degree has fallen to 0, place the node on the list
Bound property names
Mark the root as expanded, if it isn't a leaf.
No tip from the renderer get our own tip
The following are convenience methods that get forwarded to the
Add the path if it is expanded, a descendant of parent,
and it is visible (all parents expanded). This is rather
Only expand if not leaf!
Following are primarily convenience methods for mapping from
row based selections to path selections.  Sometimes it is
easier to deal with these than paths (mouse downs, key downs
usually just deal with index based selections).
Since row based selections require a UI many of these won't work
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
if (e == null)
start search from the next/previous element froom the
Save the cellRenderer, if its Serializable.
Save the cellEditor, if its Serializable.
Save the treeModel, if its Serializable.
Save the selectionModel, if its Serializable.
Create an instance of expanded state.
Reinstall the redirector.
Listener to TreeModel.
End of class JTree.TreeSelectionRedirector
Make sure all parents of path are expanded.
collapse last path.
A descendant was selected, select the parent.
Expand last path.
Might be better to call getDescendantSelectedPaths
numerous times, then push to the model.
NOTE: If I change this to NOT remove the descendants
and update BasicTreeUIs treeStructureChanged method
to update descendants in response to a treeStructureChanged
event, all the children of the event won't collapse!
New root, remove everything!
Mark the root as expanded, if it isn't a leaf.
Add a tree model listener for JTree
Fire the visible data changes for the model changes.
Set parent to null so AccessibleJTreeNode computes
TIGER - 4839971
Set parent to null so AccessibleJTreeNode computes
is the object visible?
if so, get row, selected, focus & leaf state,
and then get the renderer component and return it
Overridden methods from AccessibleJComponent
JTree.this is NOT the parent; parent will get computed later
the root node
return the root's first set of children count
return the root node Accessible
return Accessible for one of root's child nodes
didn't ever need to override this...
The JTree can have only one accessible child, the root.
The JTree can have only one accessible child, the root.
Tree nodes can't be so complex that they have
two sets of children -> we're ignoring that case
is the object visible?
if so, get row, selected, focus & leaf state,
and then get the renderer component and return it
how to tell?? -PK
fall back to the client property
need to test here, 'cause the underlying component
is a cellRenderer, which is never showing...
someone wants to know, so we need to create our parent
if we don't have one (hey, we're a talented kid!)
we're the top!
we're an only child!
index is invalid 'till we have an accessibleParent...
Tree nodes can't be so complex that they have
two sets of children -> we're ignoring that case
Tree nodes can't be so complex that they have
two sets of children -> we're ignoring that case
to override getBounds()
out of range
out of range
TIGER - 4766636
inner class AccessibleJTreeNode
inner class AccessibleJTree
End of class JTree
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of SeparatorPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of SeparatorPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
These message should be read from a locale-specific resource bundle
Get string for opcode
Just in case we have a corrupt program
If it's unprintable, convert to '\###'
Return the character as a string
Get opcode and opdata for node
Return opcode as a string and opdata value
Loop through the whole program
Get opcode, opdata and next fields of current program node
Display the current program node
If there's no next, say 'none', otherwise give absolute index of next node
Move past node
If character class
Opening bracket for start of char class
Show each range in the char class
Get first and last chars in range
Print range as X-Y, unless range encompasses only one char
Annotate the end of the char class
Print each character in the atom
Print a newline
Check out the matrix.  A non-integral scale will force ARGB
since the edge conditions can't be guaranteed.
Need to convert first
Get the bounding box of the src and transform the corners
Get the min, max of the dst
If r.x (or r.y) is < 0, then we want to only create an image
that is in the positive range.
If r.x (or r.y) is > 0, then we need to create an image that
includes the translation.
Should never get here
We need to be able to invert the transform if we want to
transform the image.  If the determinant of the matrix is 0,
then we can't invert the transform.
remove the CR, if there is one
in.ready synchronizes on readLock already
Set up JavaIOAccess in SharedSecrets
Add a shutdown hook to restore console's echo state should
it be necessary.
shutdown is already in progress and console is first used
by a shutdown hook
This method is called in sun.security.util.Password,
cons already exists when this method is called
Resolve using EntityResolver2
error resolving external subset
unable to resolve external subset
When both pubId and sysId are null, the user's entity resolver
can do nothing about it. We'd better not bother calling it.
This happens when the resourceIdentifier is a GrammarDescription,
which describes a schema grammar of some namespace, but without
any schema location hint. -Sg
Resolve using EntityResolver2
error resolving entity
unable to resolve entity
read and discard the repository ID
write the repository ID
NamespaceSupport.java - generic Namespace support for SAX.
Written by David Megginson
This class is in the Public Domain.  NO WARRANTY!
$Id: NamespaceSupport.java,v 1.5 2004/11/03 22:53:09 jsuttor Exp $
Extend the array if necessary
Allocate the context if necessary.
Set the parent, if any.
Operations within a context.
throw new IllegalStateException (
may wipe out another prefix
Select the appropriate table.
Start by looking in the cache, and
return immediately if the name
is already known in this content
We haven't seen this name in this
context before.  Maybe in the parent
context, but we can't assume prefix
bindings are the same.
Save in the cache for future use.
(Could be shared with parent context...)
end of NamespaceSupport.java
Known element names
Known attribute names
getHandler() is never called before parse() so it is safe
to create a URLClassLoader with _resourceBase.
getResource(".") is called to ensure we have the directory
containing the resources in the case the resource base is a
The following methods are invoked from startElement/stopElement
Just RGB, or some portion of it.
Single character alpha: #ARRGGBB.
Color has alpha and is of the form
The following split decoding is mandatory due to
Integer.decode() behavior which won't decode
hexadecimal values higher than #7FFFFFFF.
Thus, when an alpha channel is detected, it is
decoded separately from the RGB channels.
Type of the value: 0=idref, 1=boolean, 2=dimension, 3=insets,
Not in an inputmap, bail.
SAX methods, these forward to the DocumentHandler if we don't know
the element name.
Common UI methods
Maintain an OutputStreamWriter with default CharToByteConvertor
(just like new PrintStream) for writing log message prefixes.
synchronize on "this" first to avoid potential deadlock
construct prefix for log messages:
...and thread name
write prefix through to underlying byte stream
finally, write the already converted bytes of
the log message
We should probably make a function on the iterator for this,
as a given implementation could optimize.
while (DTM.NULL != nl.nextNode())
valid if negative or (positive and lenient)
valid if lenient and not fixed width
SNMP Runtime imports
GETTERS AND SETTERS
GETTERS FOR SNMP GROUP (MIBII)
Type check predicates and turn all optimizations off if appropriate
If not predicates left, translate primary expression
Get the next predicate to be translated
Translate the rest of the predicates from right to left
Backwards branches are prohibited if an uninitialized object
is on the stack by section 4.9.4 of the JVM Specification,
2nd Ed.  We don't know whether this code might contain
backwards branches, so we mustn't create the new object unti
after we've created the suspect arguments to its constructor
Instead we calculate the values of the arguments to the
constructor first, store them in temporary variables, create
the object and reload the arguments from the temporaries to
avoid the problem.
Translate predicates from right to left
Backwards branches are prohibited if an uninitialized object is
on the stack by section 4.9.4 of the JVM Specification, 2nd Ed.
We don't know whether this code might contain backwards branches,
so we mustn't create the new object until after we've created
the suspect arguments to its constructor.  Instead we calculate
the values of the arguments to the constructor first, store them
in temporary variables, create the object and reload the
arguments from the temporaries to avoid the problem.
Create a CurrentNodeListIterator
Has this object already been exported to IIOP?
Yes, so this is an error...
Can we load a Tie?
Yes, so export it to IIOP...
No, so export to JRMP. If this is called twice for the
same object, it will throw an ExportException...
If the class is already an IIOP stub then return it.
If the class is already a JRMP stub then return it.
Has it been exported to IIOP?
Is narrowTo an interface that might be
implemented by a servant running on iiop?
Create an id from the narrowTo type...
Is this a servant that was exported to iiop?
Yes. Do we have an ORB from the source object?
If not, we're done - there is nothing to do to
connect a JRMP object. If so, it is an error because
the caller mixed JRMP and IIOP...
The target object is IIOP. Make sure we have a
valid ORB from the source object...
And, finally, connect it up...
Is the tie already connected?
Yes. Is it the same orb?
Yes, so nothing to do...
No, so this is an error...
No, so do it...
The stub or tie was already connected...
overflow caught later
override for Javadoc
no overflow (256 is multiple of 2)
9223372036854775808 long, 2147483648 int
override for Javadoc
override for Javadoc
override for Javadoc and performance
override for Javadoc and performance
override for Javadoc and performance
override for Javadoc and performance
override for Javadoc and performance
DOMCatalogParser.java - An interface for reading catalog files
These message should be read from a locale-specific resource bundle
REVISIT:  make this class smarter and *way* more complete!
the unique grammar from fGrammars (or that we're
building) that is used in validation.
is the "active" grammar standalone?
retrieve a DTDGrammar given an XMLDTDDescription
is the active grammar standalone?  This must live here because
at the time the validator discovers this we don't yet know
what the active grammar should be (no info about root)
set the "active" grammar:
we don't allow instantiation
used by updateCurrentCursor
if the cursor has been previously set then don't do any defaults
do defaults processing
no drop possible
Implementation assumes 'transferable' is never null.
packed slot & value counts
packed prim & double counts
the canonical erasure
the canonical erasure, with primitives simplified
Cached adapter information:
Indexes into methodHandles:
cached instance of MH.invokeBasic
cached helper for LF.NamedFunction
uninitialized call site
Cached lambda form information, for basic types only:
Indexes into lambdaForms:
DMH invokeStatic with <clinit> barrier
Counting DelegatingMethodHandle w/ @DontInline
invokeExact_MT (for invokehandle)
generic invoke_MT (for invokehandle)
primitives must be flattened also
Simulate a CAS, to avoid racy duplication of results.
Simulate a CAS, to avoid racy duplication of results.
Walk the argument types, looking for primitives.
#slots = #args + #longs
even void.class counts as a prim here
adjust #slots, #args
fill in rest of data from the basic type:
argument "-1" is past end of slots
"+1" see argSlotToParameter note
filled the table
have primitives but no long primitives; share slot counts with generic
first arg is deepest in stack
argument "-1" is past end of slots
"+1" see argSlotToParameter note
Initialize caches, but only for basic types
word==0 => return a, ==3 => return d
# outgoing values
# outgoing interpreter slots
= 0 (V), or 1
= 0 (V), 2 (J/D), or 1
= 0 (obj), or 1
= 1 (J/D), or 0
Note:  Empty slots are represented by zero in this table.
Valid arguments slots contain incremented entries, so as to be non-zero.
We return -1 the caller to mean an empty slot.
It is already erased.  Make a new MethodTypeForm.
Share the MethodTypeForm with the erased version.
It is already canonical.
Find the erased version of the method type:
no change, ever
no change, usually
everything else returns as an int
no change; return null to signify
a Void parameter was unwrapped to void; ignore
simply don't care if this operation failed
Nothing to do
Nothing to do
reinitialize the params
Color space types
Copyright (c) 1995-96 by Cisco Systems, Inc.
This boolean is used to stop handling requests while the corresponding SnmpQManager
is being destroyed.
Wait until the thread die.
NOTE: These are not really needed, but at this point we can't pull
them. Their values are updated purely for historical reasons.
If there is text
If there is an icon and no text
focus forward traversal key
focus backward traversal key
Only way to force BasicSplitPaneDivider to reread the
This is done to update package private variables in
The singleton of DontCareFieldPosition.
Common UI methods
skip past op, len, len without predicates
Should assert error
int index = (argLenOfStep == 3) ? m_opMap[opPosOfStep+5]
End of file.
Util (sed marker, don't remove!)
This class must be able to function with non-Sun ORBs.
This means that any of the following com.sun.corba classes
must only occur in contexts that also handle the non-Sun case.
Runs as long as there are exportedServants
Maps targets to ties.
Used by TOAFactory.shutdown to unexport all targets for this
particular ORB.  This happens during ORB shutdown.
Bug 4476347: BAD_OPERATION is thrown if the ties delegate isn't set.
We can ignore this because it means the tie is not connected to an ORB.
We neglect this exception if at all if it is
raised. It is not harmful.
Build the message string...
Now map to the correct RemoteException type...
Pre-Merlin Sun ORBs used the incorrect minor code for
this case.  See Java to IDL ptc-00-01-08 1.4.8.
Just map to a generic RemoteException...
Make sure we have a connected object...
Handle the null case, including backwards
If they're our Any and ORB implementations,
we may want to do type code related versioning.
Preserve backwards compatibility with Kestrel and Ladybird
by not fully implementing interop issue resolution 3857,
and returning a null TypeCode with a tk_value TCKind.
If we're not talking to Kestrel or Ladybird, fall through
to the abstract interface case (also used for foreign ORBs).
Use tk_abstract_interface as detailed in the resolution
REVISIT: Define this in IDL and get the ID in generated code
Make sure we have a connected object, then
write it out...
Make sure we have a connected object, then
write it out...
Do we already have this target registered?
No, so register it and set the target...
Do we need to instantiate our keep-alive thread?
Yes. Instantiate our keep-alive thread and start
This can happen when the target was never associated with a POA.
We can safely ignore this case.
Is it time to shut down our keep alive thread?
For the Sun ORB
For a non-Sun ORB
Bug fix for 5018613: JCK test expects copyObjects to throw
NPE when obj==null.  This is actually not in the spec, since
obj is not really an RMI-IDL data type, but we follow our
test here, and force this error to be thrown.
obj is an array of remote impl types.  This
causes problems with stream copier, so we copy
it over to an array of Remotes instead.
This gets the copier for the current invocation, which was
previously set by preinvoke.
copyObject was invoked outside of an invocation, probably by
a test.  Get the default copier from the ORB.
XXX should we just make the default copier available directly
and avoid constructing one on each call?
Defined so that this class isn't flagged as a potential problem when
searches for missing serialVersionUID fields are done.
Type-specific CORBA::Object operations
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of InternalFrameTitlePaneIconifyButtonPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of InternalFrameTitlePaneIconifyButtonPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
true if this socket is exclusively bound
emulates SO_REUSEADDR when exclusiveBind is true and socket is bound
disconnect doesn't throw any exceptions
close doesn't throw any exceptions
socket already bound, emulate SO_REUSEADDR
SO_BINDADDR is not a socket option.
read and discard the repository ID
write the repository ID
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of TextAreaPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of TextAreaPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
NEVER track source locators for RTFs; they aren't meaningful. I think.
(If we did track them, we'd need to tail-prune these too.)
Record initial sizes of fields that are pushed and restored
for RTF tail-pruning.  More entries can be popped than pushed, so
we need this to mark the primordial state of the DTM.
Safety net; should never happen
Re-initialize the tree append process
no longer open
Values from DTMDefaultBase
%REVIEW% Can the namespace stack sizes ever differ? If not, save space!
Values from SAX2DTM
Values from SAX2DTM - m_data always has a reserved entry
Return true iff DTM now empty
Dummy value to associate with an Object in the backing Map
Use linear-time version if applicable
NavigableSet API methods
Write out any hidden stuff
Write out Comparator
Write out size
Write out all elements in the proper order.
Read in any hidden stuff
Read in Comparator
Create backing TreeMap
Read in size
disconnect the logger from a bigger framework (if any)
and take the matters into our own hands
don't change the setting of this logger
to honor what other frameworks
have done on configurations.
just to be extra safe. in particular System.getProperty may throw
one of our exceptions, just re-throw
avoid wrapping exceptions unnecessarily
we don't care where the impl class is, we want to know where JAXBContext lives in the impl
avoid wrapping RuntimeException to JAXBException,
because it indicates a bug in this code.
can't catch JAXBException because the method is hidden behind
reflection.  Root element collisions detected in the call to
createContext() are reported as JAXBExceptions - just re-throw it
some other type of exception - just wrap it
first check the method that takes Map as the third parameter.
this is added in 2.0.
any failure in invoking this method would be considered fatal
it's not an error for the provider not to have this method.
try the old method that doesn't take properties. compatible with 1.0.
it is an error for an implementation not to have both forms of the createContext method.
any failure in invoking this method would be considered fatal
the cast would fail, so generate an exception with a nice message
for other exceptions, wrap the internal target exception
with a JAXBException
avoid wrapping RuntimeException to JAXBException,
because it indicates a bug in this code.
can't catch JAXBException because the method is hidden behind
reflection.  Root element collisions detected in the call to
createContext() are reported as JAXBExceptions - just re-throw it
some other type of exception - just wrap it
extra check to avoid costly which operation if not logged
the cast would fail, so generate an exception with a nice message
TODO: do we want/need another layer of searching in $java.home/lib/jaxb.properties like JAXP?
search context path for jaxb.properties first
no context is specified
com.acme.foo - > com/acme/foo/jaxb.properties
search for a system property second (javax.xml.bind.JAXBContext)
leave this here to assure compatibility
search META-INF services next
should never happen
else no provider found
search for jaxb.properties in the class loader of each class first
this classloader is used only to load jaxb.properties, so doing this should be safe.
this is possible for primitives, arrays, and classes that are loaded by poorly implemented ClassLoaders
TODO: do we want to optimize away searching the same package?  org.Foo, org.Bar, com.Baz
classes from the same package might come from different class loades, so it might be a bad idea
TODO: it's easier to look things up from the class
build the resource name and use the property loader code
trim() seems redundant, but adding to satisfy customer complaint
search for a system property second (javax.xml.bind.JAXBContext)
leave it here for compatibility reasons
search META-INF services next
should never happen
else no provider found
Use reflection to avoid having any dependency on ServiceLoader class
make sure that the current thread has an access to the package of the given name.
anyone can access the platform default factory class without permission
the pool this thread works in
Use a placeholder until a useful name can be set in registerWorker
clear before registering
only run once
Set up to allow setting thread fields in constructor
to erase ThreadLocals
to always report system loader
to silently fail
fall through if null as cannot-happen safeguard
orbos 98-01-18: Objects By Value
orbos 98-01-18: Objects By Value
orbos 98-01-18: Objects By Value -- begin
orbos 98-01-18: Objects By Value -- end
orbos 98-01-18: Objects By Value
orbos 98-01-18: Objects By Value
In case queue is empty.
Constrain value of period sufficiently to prevent numeric
overflow while still being effectively infinitely large.
In case queue was already empty.
Someone killed this Thread, behave as if Timer cancelled
Eliminate obsolete references
Wait for queue to become non-empty
Queue is empty and will forever remain; die
Queue nonempty; look at first evt and do the right thing
No action required, poll queue again
Repeating task, reschedule
Task hasn't yet fired; wait
Task fired; run it, holding no locks
Grow backing store if necessary
Drop extra reference to prevent memory leak
Drop extra ref to prevent memory leak
Null out task references to prevent memory leak
j indexes smallest kid
Sep 14, 2000:
Fixed serializer to report IO exception directly, instead at
the end of document processing.
Reported by Patrick Higgins <phiggins@transzap.com>
SAX content handler serializing methods
SAX document handler serializing methods
If this is the root element handle it differently.
If the first root element in the document, serialize
the document's DOCTYPE. Space preserving defaults
to that of the output format.
For any other element, if first in parent, then
use the parnet's space preserving.
Do not change the current element state yet.
This only happens in endElement().
Ignore all other attributes of the element, only printing
Now it's time to enter a new element state
with the tag name and space preserving.
We still do not change the curent element state.
Works much like content() with additions for closing
an element. Note the different checks for the closed
element's state and the parent element's state.
Leave the element state and update that of the parent
(if we're not root) to not empty and after element.
Generic node serializing methods methods
Required to stop processing the DTD, even though the DTD
is not printed.
Always serialize these, even if not te first root element.
If this is the root element handle it differently.
If the first root element in the document, serialize
the document's DOCTYPE. Space preserving defaults
to that of the output format.
For any other element, if first in parent, then
use the parnet's space preserving.
Do not change the current element state yet.
This only happens in endElement().
Ignore all other attributes of the element, only printing
If element has children, then serialize them, otherwise
serialize en empty tag.
Enter an element state, and serialize the children
one by one. Finally, end the element.
After element but parent element is no longer empty.
Based on the node type call the suitable SAX handler.
Only comments entities and documents which are not
handled by SAX are serialized directly.
!!! Fall through
By definition this will happen if the node is a document,
document fragment, etc. Just serialize its contents. It will
work well for other nodes that we do not know how to serialize.
If this is the first content in the element,
change the state to not-empty.
Except for one content type, all of them
are not last element. That one content
type will take care of itself.
-- Socket-specific operations --
-- ByteChannel operations --
End of file.
NOTE: this uses setOpaque vs LookAndFeel.installProperty as there
is NO reason for the RootPane not to be opaque. For painting to
work the contentPane must be opaque, therefor the RootPane can
also be opaque.
inner class AccessibleJDialog
hasNext should've prefetched the header for us,
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of OptionPaneMessageAreaPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of OptionPaneMessageAreaPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
getAlignment() returns ALIGN_LEFT by default, and HR should
use ALIGN_CENTER by default, so we check if the alignment
attribute is actually defined
This will be removed and centralized at some point, need to unify this
and avoid private classes.
--- View methods ---------------------------------------------
Align the rule horizontally.
Paint either a shaded rule or a solid line.
--- variables ------------------------------------------------
for now, simple implementation; later, do proper IEEE native stuff
We have to check for this, because this is the one NEGATIVE value
we represent.  If we tried to just pass the digits off to parseLong,
we'd get a parse failure.
Figure out if the result will fit in a long.  We have to
then check the size.  If the digit count is 18 or less, then
the value can definitely be represented as a long.  If it is 19
then it may be too large.
Trim trailing zeros.  This does not change the represented value.
Positive zero fits into a long, but negative zero can only
be represented as a double. - bug 4162852
At this point we have decimalAt == count, and count == MAX_COUNT.
The number will overflow if it is larger than 9223372036854775807
or smaller than -9223372036854775808.
At this point the first count digits match.  If decimalAt is less
than count, then the remaining digits are zero, and we return true.
Now we have a representation of Long.MIN_VALUE, without the leading
negative sign.  If this represents a positive value, then it does
not fit; otherwise it fits.
Number of zeros between decimal point and first non-zero digit after
decimal point, for numbers < 1.
The negative of the exponent represents the number of leading
zeros between the decimal and the first non-zero digit, for
a value < 0.1 (e.g., for 0.00123, -decimalAt == 2).  If this
is more than the maximum fraction digits, then we have an underflow
for the printed representation.
Handle an underflow to zero when we round something like
0.0009 to 2 fractional digits.
If we round 0.0009 to 3 fractional digits, then we have to
create a new one digit in the least significant location.
else fall through
Eliminate trailing zeros.
Eliminate digits beyond maximum digits to be displayed.
Round up if appropriate.
Eliminate digits beyond maximum digits to be displayed.
Round up if appropriate.
Rounding up involved incrementing digits from LSD to MSD.
In most cases this is simple, but in a worst case situation
(9999..99) we have to adjust the decimalAt value.
We have all 9's, so we increment to a single digit
of one and adjust the exponent.
Adjust the count
digits[maximumDigits] = '0';  Unnecessary since we'll truncate this
Increment for use as count
Eliminate trailing zeros.
Value is above tie ==> must round up
Digit at rounding position is a '5'. Tie cases.
There are remaining digits. Above tie => must round up
Digit at rounding position is the last one !
Exact binary representation. On the tie.
Apply rounding given by roundingMode.
Not an exact binary representation.
Digit sequence either rounded up or truncated.
Round up only if it was truncated.
Digit at rounding position is < '5' ==> no round up.
Just let do the default, which is no round up (thus break).
Implement IEEE half-even rounding
the rounding position is exactly the last index :
If FloatingDecimal rounded up (value was below tie),
then we should not round up again.
Otherwise if the digits don't represent exact value,
value was above tie and FloatingDecimal truncated
digits to tie. We must round up.
This is an exact tie value, and FloatingDecimal
provided all of the exact digits. We thus apply
HALF_EVEN rounding rule.
Rounds up if it gives a non null digit after '5'
This method does not expect a negative number. However,
"source" can be a Long.MIN_VALUE (-9223372036854775808),
if the number being formatted is a Long.MIN_VALUE.  In that
case, it will be formatted as -Long.MIN_VALUE, a number
which is outside the legal range of a long, but which can
be represented by DigitList.
Values <= 0 format as zero
Rewritten to improve performance.  I used to call
Long.toString(), which was about 4x slower than this code.
Don't copy trailing zeros.  We are guaranteed that there is at
least one non-zero digit, so we don't have to check lower bounds.
(1) same object?
The digit part of -9223372036854775808L
Top level log domain for CORBA
trace creates and disposes
show reuse hits/misses
show bad params, misc.
NOTE: This will be null if the action is registered in the
ActionMap. For the timer use it will be non-null.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
only disable the menu highlighting if it's disabled and the property isn't
true. This allows disabled rollovers to work in WinL&F
A top level menu's parent is by definition
when crossMenuMnemonic is not set, we don't open a toplevel
menu if another toplevel menu is already open
Fix 6939261: to return in case not on the main menu
and has a pop-up.
after return code will be handled in BasicPopupMenuUI.java
SAX entity resolver.
No warranty; no copyright -- use this as you will.
$Id: EntityResolver.java,v 1.2 2004/11/03 22:44:52 jsuttor Exp $
end of EntityResolver.java
REVISIT - delete these after framework merging.
A unique id used in ServerRequestInfo.
This does not correspond to the GIOP request id.
Stores the codec factory for producing codecs
The arguments passed to the application's main method.  May be null.
This is used for ORBInitializers and set from set_parameters.
The list of portable interceptors, organized by type:
Cached information for optimization - do we have any interceptors
registered of the given types?  Set during ORB initialization.
temp always true
The class responsible for invoking interceptors
There will be one PICurrent instantiated for every ORB.
This table contains a list of PolicyFactories registered using
Key for the table is PolicyType which is an Integer
Value is PolicyFactory.
Table to convert from a ReplyMessage.? to a PI replyStatus short.
Note that this table relies on the order and constants of
ReplyMessage not to change.
ThreadLocal containing a stack to store client request info objects
and a disable count.
ThreadLocal containing the current server request info object.
Class to contain all ThreadLocal data for ClientRequestInfo
We use an ArrayList instead since it is not thread-safe.
RequestInfoStack is used quite frequently.
Number of times a request has been made to disable interceptors.
When this reaches 0, interception hooks are disabled.  Any higher
value indicates they are enabled.
NOTE: The is only currently used on the client side.
Create codec factory:
Create new interceptor list:
Create a new PICurrent.
Create new interceptor invoker, initially disabled:
Register the PI current and Codec factory objects
If we have any orb initializers, make use of them:
Create the ORBInitInfo object to pass to ORB intializers:
Make sure get_slot and set_slot are not called from within
Call pre_init on all ORB initializers:
Call post_init on all ORB initializers:
Proprietary: sort interceptors:
Re-enable get_slot and set_slot to be called from within
Ensure nobody makes any more calls on this object.
Set cached flags indicating whether we have interceptors
registered of a given type.
XXX This must always be true, so that using the new generic
RPC framework can pass info between the PI stack and the
framework invocation stack.  Temporary until Harold fixes
this.  Note that this must never be true until after the
ORBInitializer instances complete executing.
hasClientInterceptors = interceptorList.hasInterceptorsOfType(
Enable interceptor invoker (not necessary if no interceptors
are registered).  This should be the last stage of ORB
Invoke the starting interception points and record exception
and reply status info in the info object:
Check reply status.  If we will not have another chance later
to invoke the client ending points, do it now.
Note: Transport retry cannot happen here since this happens
before the request hits the wire.
Do not throw anything.  Otherwise, it must be a
SystemException, UserException or RemarshalException.
It should not be possible for an interceptor to throw
a UserException.  By asserting instead of throwing the
UserException, we need not declare anything but
RemarshalException in the throws clause.
Needed when an error forces a retry AFTER initiateClientPIRequest
but BEFORE invokeClientPIStartingPoint.
Translate ReplyMessage.replyStatus into PI replyStatus:
Note: this is also an assertion to make sure a valid replyStatus
is passed in (IndexOutOfBoundsException will be thrown otherwise)
Invoke the ending interception points and record exception
and reply status info in the info object:
Check reply status:
If this is a forward or a retry, reset and reuse
fix for 6763340:
... and return a RemarshalException so the orb internals know
Get the most recent info object from the thread local
In RequestImpl.doInvocation we already called
initiateClientPIRequest( true ), so ignore this initiate.
If there is no info object or if we are not retrying a request,
push a new ClientRequestInfoImpl on the stack:
6763340: don't push unless this is not a retry
Note: the entry count is automatically initialized to 0.
Reset the retry request flag so that recursive calls will
push a new info object, and bump up entry count so we know
when to pop this info object:
KMC 6763340: I don't know why this wasn't set earlier,
but we do not want a retry to pick up the previous
reply status, so clear it here.  Most likely a new
info was pushed before, so that this was not a problem.
If this is a DII request, make sure we ignore the next initiate.
fix for 6763340
If the replyStatus has not yet been set, this is an indication
that the ORB threw an exception before we had a chance to
invoke the client interceptor ending points.
_REVISIT_ We cannot handle any exceptions or ForwardRequests
flagged by the ending points here because there is no way
to gracefully handle this in any of the calling code.
This is a rare corner case, so we will ignore this for now.
Decrement entry count, and if it is zero, pop it from the stack.
fix for 6763340, and probably other cases (non-recursive retry)
RequestInfoStack<ClientRequestInfoImpl> infoStack =
Handle SystemException or ForwardRequest:
Clear servant from info object so that the user has control over
Handle SystemException or ForwardRequest:
REVISIT: This needs to be done "early" for the following workaround.
REVISIT: This was done inside of invokeServerInterceptorEndingPoint
but needs to be here for now.  See comment in that method for why.
It is possible we might have entered this method more than
once (e.g. if an ending point threw a SystemException, then
a new ServerResponseImpl is created).
Translate ReplyMessage.replyStatus into PI replyStatus:
Note: this is also an assertion to make sure a valid
replyStatus is passed in (IndexOutOfBoundsException will be
Make forwarded IOR available to interceptors, if applicable:
REVISIT: Do early above for now.
Make reply message available to interceptors:
Remember exception so we can tell if an interceptor changed it.
_REVISIT_ We do not have access to the User Exception at
this point, so treat it as an UNKNOWN for now.
Note that if this is a DSI call, we do have the user exception.
Invoke the ending interception points:
Check reply status.  If an interceptor threw a SystemException
and it is different than the one that we came in with,
rethrow it so the proper response can be constructed:
If we are to forward the location:
Treat a ForwardRequest as a ForwardException.
Treat a ForwardRequest by changing the IOR.
Notify request object that once response is constructed, make
sure we execute ending points.
If a system exception was thrown, throw it to caller:
If an interceptor throws a forward request, convert it
into a ForwardException for easier handling:
Inform ORBInitInfo we are in pre_init stage
Step through each initializer instantiation and call its
pre_init.  Ignore any exceptions.
As per orbos/99-12-02, section 9.3.1.2, "If there are
any exceptions, the ORB shall ignore them and proceed."
Inform ORBInitInfo we are in post_init stage
Step through each initializer instantiation and call its post_init.
Ignore any exceptions.
As per orbos/99-12-02, section 9.3.1.2, "If there are
any exceptions, the ORB shall ignore them and proceed."
arguments comes from set_parameters.  May be null.
_REVISIT_ The spec does not specify which ID this is to be.
We currently get this from the corba.ORB, which reads it from
the ORB_ID_PROPERTY property.
We will assume interceptor is not null, since it is called
Register with interceptor list:
The array to hold all data
Number of elements in this list
used to indicate what triggered the call
Do this to keep format from crying.
This is better than making a bunch of conditional
code all over the place.
if we get past the line above we have create the message ... hurray!
Get the message that the format failed.
We couldn't even get the message that the format of
the message failed ... so fall back to English.
true if this socket is exclusively bound
emulates SO_REUSEADDR when exclusiveBind is true
Intentional fallthrough after SO_REUSEADDR
timeout implemented through select.
SO_REUSEADDR emulated when using exclusive bind
SO_BINDADDR is not a socket option.
return value doesn't matter.
SO_REUSEADDR emulated when using exclusive bind
Nothing available (non-blocking)
doc comment inherited from MBeanServerConnection
doc comment inherited from MBeanServerConnection
doc comment inherited from MBeanServerConnection
doc comment inherited from MBeanServerConnection
doc comment inherited from MBeanServerConnection
doc comment inherited from MBeanServerConnection
doc comment inherited from MBeanServerConnection
doc comment inherited from MBeanServerConnection
doc comment inherited from MBeanServerConnection
doc comment inherited from MBeanServerConnection, plus:
doc comment inherited from MBeanServerConnection
doc comment inherited from MBeanServerConnection
doc comment inherited from MBeanServerConnection
doc comment inherited from MBeanServerConnection
doc comment inherited from MBeanServerConnection
doc comment inherited from MBeanServerConnection
private static final int
get 3 extra bytes to make buffer overflow checking simpler and faster
we won't have to keep checking for a few extra characters
Big enough to hold the input chars that will be transformed
into output bytes in m_ouputBytes.
the old body of this constructor, before the buffersize was changed to a constant
public WriterToUTF8Buffered(final OutputStream out, final int size)
if (size <= 0)
throw new IllegalArgumentException(
We multiply the length by three since this is the maximum length
of the characters that we can put into the buffer.  It is possible
for each Unicode character to expand to three bytes.
The requested length is greater than the unused part of the buffer
Adjust the end of the chunk if it ends on a high char
of a Unicode surrogate pair and low char of the pair
is not going to be in the same chunk
The last Java char that we were going
to process is the first of a
Java surrogate char pair that
represent a Unicode character.
Avoid spanning by including the low
char in the current chunk of chars.
local reference for faster access
local integer for faster access
Store the local integer back into the instance variable
We multiply the length by three since this is the maximum length
of the characters that we can put into the buffer.  It is possible
for each Unicode character to expand to three bytes.
The requested length is greater than the unused part of the buffer
Adjust the end of the chunk if it ends on a high char
of a Unicode surrogate pair and low char of the pair
is not going to be in the same chunk
Exclude char in this chunk,
to avoid spanning a Unicode character
that is in two Java chars as a high/low surrogate
local reference for faster access
local integer for faster access
Store the local integer back into the instance variable
Only one of getWriter() or getOutputStream() can return null
This type of writer wraps an OutputStream, not a Writer.
Create an instance for this AppContext
Hardwire standard SPIs
FIX: load only from application classpath
Note that the next() call is required to be inside
the try/catch block; see 6342404.
In the applet case, we will catch the  error so
registration of other plugins can  proceed
In the application case, we will  throw the
error to indicate app/system  misconfiguration
In order to handle the 'all' semantics of
nodeset comparisons, we always call the
Replace StringBuffer with StringBuilder now that we no long support jdk1.4
Ignore text nodes of length 0
No text nodes can be children of root (DOM006 exception)
try to set document version
Add namespace declarations first
Add attributes to element
Add attributes to element
checking if Namespace processing is being done
Append this new node onto current stack node
If the SAX2DOM is created with a non-null next sibling node,
insert the result nodes before the next sibling under the root.
Push this node onto stack
Lexical Handler methods- not implemented
default implementation is thread safe
UnsupportedEncodingException should be thrown
ensure charset is checked before the file is opened
ensure charset is checked before the file is opened
Node name, followed by description
Every StatisticMonitoredAttribute will have a StatisticAccumulator. User
will use Statisticsaccumulator to accumulate the samples associated with
this Monitored Attribute
Mutex is passed from the user class which is providing the sample values.
getValue() and clearState() is synchronized on this user provided mutex
Perform the conversion of the provided char or String,
allowing the caller to query for more information
How many bytes resulted from the conversion?
What's the maximum number of bytes per character?
What byte boundary should the stream align to before
calling writeBytes?  For instance, a fixed width
encoding with 2 bytes per char in a stream which
doesn't encapsulate the char's bytes should align
on a 2 byte boundary.  (Ex:  UTF16 in GIOP1.1)
Note: This has no effect on the converted bytes.  It
is just information available to the caller.
Get the resulting bytes.  Warning:  You must use getNumBytes()
to determine the end of the data in the byte array instead
of array.length!  The array may be used internally, so don't
In GIOP 1.1, interoperability can only be achieved with
fixed width encodings like UTF-16.  This is because wstrings
specified how many code points follow rather than specifying
the length in octets.
Called after getChars to determine the true size of the
Perform the conversion using length bytes from the given
input stream.  Warning:  You must use getNumChars() to
determine the correct length of the resulting array.
The same array may be used internally over multiple
nio.Charset.CharsetEncoder actually does the work here
have to use it directly rather than through String's interface
because we want to know when errors occur during the conversion.
Proper alignment for this type of converter.  For instance,
ASCII has alignment of 1 (1 byte per char) but UTF16 has
alignment of 2 (2 bytes per char)
Char buffer to hold the input.
How many bytes are generated from the conversion?
How many characters were converted (temporary variable
for cross method communication)
ByteBuffer holding the converted input.  This is necessary
since we have to do calculations that require the conversion
before writing the array to the stream.
What code set are we using?
This can only happen if one of our Entries has
an invalid name.
This can only happen if one of our Entries has
an unsupported name.
The CharToByteConverter only takes a char[]
Try to save a memory allocation if possible.  Usual
space/time trade off.  If we could get the char[] out of
the String without copying, that would be great, but
it's forbidden since String is immutable.
Note that you can't use buffer.length since the buffer might
be larger than the actual number of converted bytes depending
on the encoding.
Possible optimization of directly converting into the CDR buffer.
However, that means the CDR code would have to reserve
a 4 byte string length ahead of time, and we'd need a
confusing partial conversion scheme for when we couldn't
fit everything in the buffer but needed to know the
converted length before proceeding due to fragmentation.
Then there's the issue of the chunking code.
For right now, this is less messy and basic tests don't
show more than a 1 ms penalty worst case.  Less than a
factor of 2 increase.
Convert the characters
ByteBuffer returned by the encoder will set its limit
to byte immediately after the last written byte.
an encoding operation is already in progress
There were illegal Unicode char pairs
A character doesn't map to the desired code set
CORBA formal 00-11-03.
If this happens, then some other encoding error occured
Using this constructor, we will always write a BOM
Using this constructor, we don't use a BOM and use the
byte order specified
Obtain a Decoder
Should only be called if isFixedWidthEncoding is true
IMPORTANT: This calls OSFCodeSetRegistry.Entry, not
Possible optimization of reading directly from the CDR
byte buffer.  The sun.io converter supposedly can handle
incremental conversions in which a char is broken across
two convert calls.
Basic tests didn't show more than a 1 ms increase
worst case.  It's less than a factor of 2 increase.
Also makes the interface more difficult.
CharBuffer returned by the decoder will set its limit
to byte immediately after the last written byte.
IMPORTANT - It's possible the underlying char[] in the
CharBuffer returned by btc.decode(byteBuf)
is longer in length than the number of characters
decoded. Hence, the check below to ensure the
char[] returned contains all the chars that have
been decoded and no more.
There were a decoding operation already in progress
There were illegal Unicode char pairs
A character doesn't map to the desired code set.
CORBA formal 00-11-03.
If this happens, then a character decoding error occured.
This can only happen if one of our charset entries has
an illegal name.
When there isn't a byte order marker, used the byte
If there aren't enough bytes to represent the marker and data,
Use the getConverter method from our superclass.
UCS2 doesn't have byte order markers, and we're encoding it
as UTF-16 since UCS2 isn't available in all Java platforms.
They should be identical with only minor differences in
We can write UTF-16 with or without a byte order marker.
Everything else uses the generic JavaCTBConverter.
Variable width encodings are aligned on 1 byte boundaries.
A fixed width encoding with a max. of 4 bytes/char should
align on a 4 byte boundary.  Note that UTF-16 is a special
case because of the optional byte order marker, so it's
This doesn't matter for GIOP 1.2 wchars and wstrings
since the encoded bytes are treated as an encapsulation.
A "null" value for the server's nativeCodeSet means that
the server desired not to indicate one.  We'll take that
to mean that it wants the first thing in its conversion list.
If it's conversion list is empty, too, then use the fallback
Best case -- client and server don't have to convert
Is this client capable of converting to the server's
native code set?
The client will convert to the server's
native code set.
Is the server capable of converting to the client's
native code set?
The server will convert to the client's
native code set.
See if there are any code sets that both the server and client
support (giving preference to the server).  The order
of conversion sets is from most to least desired.
Before using the fallback codesets, the spec calls for a
compatibility check on the native code sets.  It doesn't make
sense because loss free communication is always possible with
UTF8 and UTF16, the fall back code sets.  It's also a lot
of work to implement.  In the case of incompatibility, the
spec says to throw a CODESET_INCOMPATIBLE exception.
Use the fallback
No one should instantiate a CodeSetConversion but the singleton
Number used internally to indicate the fallback code
Provides a thread local cache for the sun.io
for RANGE or NRANGE
Why? -- In many cases,
this.ranges has few elements.
Index of writing point
Index of processing point
res:    o-o    o-o
Reuse src(=right res)
this.ranges is sorted and compacted.
Reuse the rest of src1
Reuse the rest of src1
this.ranges is sorted and compacted.
32 is the number of bits in `int'.
s&0x1f : 0-31
Copyright (c) 1995-96 by Cisco Systems, Inc.
Handles out of memory.
re-process the request.
HANDLING INFORM REQUESTS LIST AND INFORM RESPONSES LIST
If the adaptor is not ONLINE, stop adding requests.
deleteRequest can be called from destroySnmpSession.
In such a case remove is done in cancelAllRequest method.
The current ImageInputStream source.
True if the file header including stream metadata has been read.
Global metadata, read once per input setting.
The current image index
Metadata for image at 'currIndex', or null.
A List of Longs indicating the stream positions of the
start of the metadata for each image.  Entries are added
Length of metadata for image at 'currIndex', valid only if
imageMetadata != null.
The number of images in the stream, if known, otherwise -1.
Variables used by the LZW decoding process
32-bit lookahead buffer
Try if the end of the data blocks has been found,
and we are simply draining the 32-bit buffer
The image to be written.
The image's tile.
The image dimensions (from the stream).
The pixel currently being decoded (in the stream's coordinates).
The number of rows decoded
The current interlace pass, starting with 0.
End per-stream settings
Constants used to control interlacing.
Take input from an ImageInputStream
Clear all values based on the previous stream contents
Throw an IndexOutOfBoundsException if index < minIndex,
and bump minIndex if required.
We don't check all parameters as ImageTypeSpecifier.createIndexed do
since this method is private and we pass consistent data here
Some files erroneously have a transparent color index
of 255 even though there are fewer than 256 colors.
no color table, the spec allows to use any palette.
Normalize color table length to 2^1, 2^2, 2^4, or 2^8
Bump from 3 to 4 bits
Bump to 8 bits
Entries from length + 1 to lutLength - 1 will be 0
BEGIN LZW STUFF
Load a block (1-255 bytes) at a time, and maintain
a 32-bit lookahead buffer that is filled from the left
and extracted from the right.
When the last block is found, we continue to
No more data available
Shift in a byte of new data at a time
Check if current block is out of bytes
Get next block size
Fill in the entire table for robustness against
Used only if IIOReadUpdateListeners are present
Clip against ImageReadParam
Update IIOReadUpdateListeners, if any
updateYStep will have been initialized if
updateListeners is non-null
Inform IIOReadUpdateListeners of end of pass
Determine whether pixels from this row will
be written to the destination
END LZW STUFF
Create an object to store the stream metadata
Found position of metadata for image 0
Stream must be at the beginning of an image descriptor
Skip color table if any
Find closest known index
Seek to that position
Skip images until at desired index or last image found
Read blocks of 1-255 bytes, stop at a 0-length block
Stream must be positioned at start of metadata for 'currIndex'
Create an object to store the image metadata
Read color table if any
Record length of this metadata block
Now positioned at start of LZW-compressed pixels
Graphics Control Extension
Plain text extension
read available data
Init lists if necessary
Skip over unknown extension blocks
Initialized updateMinY and updateYStep
Inform IIOReadUpdateListeners of new pass
A null ImageReadParam means we use the default
Initialize the destination image
Get source region, taking subsampling offsets into account,
and clipping against the true source bounds
Inform IIOReadProgressListeners of start of image
Read and decode the image data, fill in theImage
Read first data block
Init 32-bit buffer
Inform IIOReadProgressListeners of end of image
Inform IIOReadProgressListeners of end of image
code == tableIndex
warning - code out of sequence
possibly data corruption
No need to reinitialize 'block'
Class name of server's main class.
class path used to run the server.
??? check for null?
read and discard the repository ID
write the repository ID
Methods unique to this class
org.w3c.dom.NodeList API follows
BMH API and internals
for some type signatures, there exist pre-defined concrete BMH classes
Use known fast path.
there is a default binder in the super class, for 'L' types only
largest convenient BMH field count
largest convenient BMH expression count
if there is no BMH constraint, then use the null constraint
concrete BMH classes required to close bootstrap loops
make it private to force users to access the enclosing class first
BMH species meta-data
Bootstrapping requires circular relations MH -> BMH -> SpeciesData -> MH
Therefore, we need a non-final link in the chain.  Use array elements.
only one ctor
set after <clinit> finishes...
SpeciesData instantiation may throw VirtualMachineError because of
code cache overflow...
CHM.computeIfAbsent ensures only one SpeciesData will be set
successfully on the concrete BMH class if ever
the concrete BMH class is published via SpeciesData instance
returned here only after it's SPECIES_DATA field is set
Pre-fill the BMH species-data cache with EMPTY and all BMH's inner subclasses.
check that all static SpeciesData instances have been initialized
Note:  Do not simplify this, because INIT_DONE must not be
a compile-time constant during bootstrapping.
CHM.computeIfAbsent ensures generateConcreteBMHClass is called
only once per key.
emit static types and SPECIES_DATA fields
emit bound argument fields
i counts the arguments, j counts corresponding argument slots
parameters start at 3
adjust argument register access
emit implementation of speciesData()
emit implementation of fieldCount()
emit make()  ...factory method wrapping constructor
load mt, lf
load factory method arguments
i counts the arguments, j counts corresponding argument slots
parameters start at 3
adjust argument register access
finally, invoke the constructor and return
load mt, lf
put fields on the stack
finally, invoke the constructor and return
for each type, emit copyWithExtendT()
return SPECIES_DATA.extendWith(t).constructor().invokeBasic(mt, lf, argL0, ..., narg)
load mt, lf
put fields on the stack
put narg on stack
finally, invoke the constructor and return
Getter MH generation.
hack for empty BMH species
Override AbstractSet version to avoid calling size()
Override AbstractSet version to avoid unnecessary call to size()
Support for resetting map in clone
check to see if primary is valid
check to see if sub is valid
We sum up the hash codes for all of the strings. This
way, the order of the strings is irrelevant
neither character is present, so treat it
as an error
we have a ';' (and therefore a parameter list),
but no '/' indicating a sub type is present
we have a primary and sub type but no parameter list
we have all three items in the proper sequence
we have a ';' lexically before a '/' which means we have a primary type
& a parameter list but no sub type
now validate the primary and sub types
check to see if primary is valid
check to see if sub is valid
contains ASCII chars only
one-to-one correspondence between ASCII char and byte in UTF string
65535 is max length of UTF string
long mime type
below here be scary parsing related things
name of the group
target namespace of the group
public id of the notation
system id of the notation
The namespace schema information item corresponding to the target namespace
of the notation declaration, if it is globally declared; or null otherwise.
ret.next is null.
Need not to call setSource() because
a caller can not access this match instance.
Need not to call setSource() because
a caller can not access this match instance.
dx value is either 1 or -1
Saves current position to avoid zero-width repeats.
handle recursive operations
exhausted all the operations
Internal use only.
The @ always matches line beginnings.
switch anchor type
Need not to call setSource() because
a caller can not access this match instance.
We do not check for duplicates, caller is responsible for that
This pattern has a fixed string of which length is more than one.
Legacy word characters
serialVersionUID not constant
Serialization compatibility stuff:
Two serial forms are supported in this class. The selected form depends
on system property "jmx.serial.form":
- "1.0" for JMX 1.0
- any other value for JMX 1.1 and higher
Serial version for old serial form
Serial version for new serial form
Serializable fields in old serial form
Serializable fields in new serial form
Actual serial version and serial form
form may be null
OK: No compat with 1.0
END Serialization compatibility stuff
parse xmlstring into structures
create dummy descriptor: should have same size
as number of fields in xmlstring
loop through structures and put them in descriptor
loop through tokens
want kw=value, eg, name="myname" value="myvalue"
xml parse exception
xml parse exception
setField will throw an exception if a fieldName is be null.
the fieldName and fieldValue will be validated in setField.
illegal if no = or is first character
= is not in last character
Implementation of the Descriptor interface
field name cannot be null or empty
Since we do not remove any existing entry with this name,
the field will preserve whatever case it had, ignoring
any difference there might be in fieldName.
if fieldNames == null return all values
if fieldNames is String[0] return no values
Note: this Javadoc is copied from javax.management.Descriptor
due to 6369229.
Note: this Javadoc is copied from javax.management.Descriptor
due to 6369229.
descriptorMap is sorted with a comparator that ignores cases.
verify that the descriptor is valid, by iterating over each field...
null descriptor, not valid
must have a name and descriptor type field
According to the descriptor type we validate the fields contained
validate the field valued...
fell through, all fields OK
worker routine for isValid()
name is not null
descriptorType is not null
getMethod and setMethod are not null
persistPeriod is numeric
currencyTimeLimit is numeric
lastUpdatedTimeStamp is numeric
visibility is 1-4
severity is 0-6
log is T or F
role is not null
class is not null
lastReturnedTimeStamp is numeric
default to true, it is a field we aren't validating (user etc.)
OK: we'll pretend the constructor is there
too bad if it's not: we'll find out when we try to
reconstruct the DescriptorSupport
compatibility: old code didn't include class name
utility to convert to int, returns -2 if bogus.
Interceptor type list.  If additional interceptors are needed,
add additional types in numerical order (do not skip numbers),
and update NUM_INTERCEPTOR_TYPES and classTypes accordingly.
NUM_INTERCEPTOR_TYPES represents the number of interceptor
types, so we know how many lists to maintain.
Array of class types for interceptors.  This is used to create the
appropriate array type for each interceptor type.  These must
match the indices of the constants declared above.
True if no further interceptors may be registered with this list.
List of interceptors currently registered.  There are
NUM_INTERCEPTOR_TYPES lists of registered interceptors.
For example, interceptors[INTERCEPTOR_TYPE_CLIENT] contains an array
of objects of type ClientRequestInterceptor.
Create empty interceptors arrays for each type:
If locked, deny any further addition of interceptors.
Cache interceptor name:
If this is not an anonymous interceptor,
search for an interceptor of the same name in this category:
An O(n) search will suffice because register_interceptor is not
likely to be called often.
Create a zero-length array for each type:
Create new array to replace the old one.  The new array will be
one element larger but have the same type as the old one.
Get fresh sorting bins for each non empty type.
not synchronized like we want.
Let the RuntimeExceptions thrown by sort
(i.e., ClassCastException and UnsupportedOperationException)
flow back to the user.
-- resolution and relativization --
-- watchable --
-- Iterable --
-- compareTo/equals/hashCode --
Copyright (c) 1995-96 by Cisco Systems, Inc.
this order reflects the overriding order
read system properties or jaxp.properties
Left null as long as possible, then
created and re-used in the getAction function.
we get the effective mask. i.e., the "and" of this and that.
They must be equal to that.mask for implies to return true.
Use object identity comparison against known-interned strings for
performance benefit (these values are used heavily within the JDK).
check for the known strings
make sure we didn't just match the tail of a word
like "ackbarfaccept".  Also, skip to the comma.
point i at the location of the comma minus one (or -1).
Write out the actions. The superclass takes care of the name
call getActions to make sure actions field is initialized
Read in the action, then initialize the rest
No sync access; OK for this to be stale.
Capacity for default policy
short circuit if the "*" Permission was added
Check for full match first. Then work our way up the
name looking for matches on a.b.*
we have a direct hit!
work our way up the tree...
we don't have to check for "*" as it was already checked
at the top (all_allowed), so we just return false
Convert Iterator of Map values into an Enumeration
Need to maintain serialization interoperability with earlier releases,
which had the serializable field:
Table of permissions.
Don't call out.defaultWriteObject()
Copy perms into a Hashtable
Write out serializable fields
Don't call defaultReadObject()
Read in serialized fields
Class -> Registry
The following two methods expose functionality from
sun.misc.Service.  If that class is made public, they may be
The sun.misc.ServiceConfigurationError class may also be
exposed, in which case the references to 'an
<code>Error</code>' below should be changed to 'a
Provider Objects organized by partial ordering
Class -> Provider Object of that class
Swap operator array
begin AccessibleContext implementation ...
... end AccessibleContext implementation
begin AccessibleComponent implementation ...
Handle table caption as a special case since it's the
only table child that is not a table row.
TIGER - 4856191
set the caret position to the start of this component
fire a AccessibleState.FOCUSED property change event
don't fire property change event
... end AccessibleComponent implementation
... end HTMLAccessibleContext
begin AccessibleText implementation ...
begin AccessibleIcon implementation ...
... end AccessibleIconImplementation
Handle captions as a special case since all other
children are table rows.
Determine the max row/col count.
begin AccessibleTable implementation ...
return the role of the object
begin AccessibleExtendedTable implementation -------------
end of AccessibleExtendedTable implementation ------------
Header information is modeled as a Hashtable of
ArrayLists where each Hashtable entry represents
a row containing one or more headers.
... end AccessibleHeadersTable
One of our children changed.
Event beyond our offsets. We may have represented this,
that is the remove may have removed one of our child
Elements that represented this, so, we should foward
to last element.
If at a boundary, forward the event to the previous
A remove may result in empty elements.
The check for isValid is here as in the process of
forwarding update our child may invalidate us.
handle the document change
find a working Spi or KeyPairGenerator subclass
empty, overridden in Delegate
This does nothing, because either
1. the implementation object returned by getInstance() is an
instance of KeyPairGenerator which has its own
initialize(keysize, random) method, so the application would
be calling that method directly, or
2. the implementation returned by getInstance() is an instance
of Delegate, in which case initialize(keysize, random) is
overridden to call the corresponding SPI method.
(This is a special case, because the API and SPI method have the
This does nothing, because either
1. the implementation object returned by getInstance() is an
instance of KeyPairGenerator which has its own
initialize(params, random) method, so the application would
be calling that method directly, or
2. the implementation returned by getInstance() is an instance
of Delegate, in which case initialize(params, random) is
overridden to call the corresponding SPI method.
(This is a special case, because the API and SPI method have the
This does nothing (except returning null), because either:
1. the implementation object returned by getInstance() is an
instance of KeyPairGenerator which has its own implementation
of generateKeyPair (overriding this one), so the application
would be calling that method directly, or
2. the implementation returned by getInstance() is an instance
of Delegate, in which case generateKeyPair is
overridden to invoke the corresponding SPI method.
(This is a special case, because in JDK 1.1.x the generateKeyPair
method was used both as an API and a SPI method.)
error failover notes:
. we failover if the implementation throws an error during init
by retrying the init on other providers
. we also failover if the init succeeded but the subsequent call
to generateKeyPair() fails. In order for this to work, we need
to remember the parameters to the last successful call to init
and initialize() the next spi using them.
. although not specified, KeyPairGenerators could be thread safe,
so we make sure we do not interfere with that
. failover is not available, if:
. getInstance(algorithm, provider) was used
. a provider extends KeyPairGenerator rather than
KeyPairGeneratorSpi (JDK 1.1 style)
. once getProvider() is called
The provider implementation (delegate)
somebody else did a failover concurrently
try that spi now
must be an InvalidAlgorithmParameterException
Resolver.java - Represents an extension of OASIS Open Catalog files.
Otherwise, look in the subordinate catalogs
I don't care about the character set or subtype
If there's a SYSTEM entry in this catalog, use it
Otherwise, look in the subordinate catalogs
If there are SYSTEM entries in this catalog, start with them
Then look in the subordinate catalogs
Ok, now what are we supposed to call here?
Only find one DOCTYPE resolution
Only find one DOCUMENT resolution
Only find one ENTITY resolution
Only find one NOTATION resolution
Only find one PUBLIC resolution
Implements java.util.ResourceBundle.handleGetObject; inherits javadoc specification.
Reflection. To allow this to compile with both Xerces1 and Xerces2, which
require very different methods and objects, we need to avoid static
references to those APIs. So until Xerces2 is pervasive and we're willing
to make it a prerequisite, we will rely upon relection.
Xerces2 pull control object
Xerces2 pull control method
Xerces2 initialization method
Xerces2 initialization method
Xerces2 initialization method
Xerces2 initialization method
Both Xerces1 and Xerces2, but diff. signatures
Xerces-2 incremental parsing support (as of Beta 3)
ContentHandlers still get set on fIncrementalParser (to get
conversion from XNI events to SAX events), but
_control_ for incremental parsing must be exercised via the config.
At this time there's no way to read the existing config, only
to assert a new one... and only when creating a brand-new parser.
Reflection is used to allow us to continue to compile against
Xerces1. If/when we can abandon the older versions of the parser,
this will simplify significantly.
If we can't get the magic constructor, no need to look further.
Build the parser configuration object. StandardParserConfiguration
happens to implement XMLPullParserConfiguration, which is the API
we're going to want to use.
Preload all the needed the configuration methods... I want to know they're
all here before we commit to trying to use them, just in case the
API changes again.
Fallback if this fails (implemented in createIncrementalSAXSource) is
to attempt Xerces-1 incremental setup. Can't do tail-call in
constructor, so create new, copy Xerces-1 initialization,
then throw it away... Ugh.
Reflection is used to allow us to compile against
Xerces2. If/when we can abandon the older versions of the parser,
this constructor will simply have to fail until/unless the
Xerces2 incremental support is made available on previously
constructed SAXParser instances.
Fallback if this fails (implemented in createIncrementalSAXSource) is
to use IncrementalSAXSource_Filter rather than Xerces-specific code.
Xerces version mismatch; neither Xerces1 nor Xerces2 succeeded.
Fall back on filtering solution.
Xerces version mismatch; neither Xerces1 nor Xerces2 succeeded.
Fall back on filtering solution.
Register handler directly with the incremental parser
Typecast required in Xerces2; SAXParser doesn't inheret XMLReader
%OPT% Cast at asignment?
Register handler directly with the incremental parser
Not supported by all SAX2 parsers but should work in Xerces:
Typecast required in Xerces2; SAXParser doesn't inheret XMLReader
%OPT% Cast at asignment?
Nothing we can do about it
Nothing we can do about it
Register handler directly with the incremental parser
Typecast required in Xerces2; SAXParser doesn't inheret XMLReader
%OPT% Cast at asignment?
Private methods -- conveniences to hide the reflection details
Obtain input from SAX inputSource object, construct XNI version of
that object. Logic adapted from Xerces2.
Bugzilla5272 patch suggested by Sandy Gao.
Has to be reflection to run with Xerces2
after compilation against Xerces1. or vice
versa, due to return type mismatches.
%REVIEW% Do first pull. Should we instead just return true?
Would null work???
Take next parsing step, return false iff parsing complete:
Use a serializer as our sample output
Tell coroutine to begin parsing, run while parsing is in progress
Special test: Terminate parsing early.
Proclaim serial compatibility with 1.1 FCS
just enough fields for a reasonable distribution
calendar.equivalentTo(other.calendar)  THIS API DOESN'T EXIST YET!
Proclaim serial compatibility with 1.4 FCS
table of all instances in this class, used by readResolve
Maps from Calendar constant (such as Calendar.ERA) to Field
constant (such as Field.ERA).
See Errata E24
no target found
Target found, but need to check if ancestor matches from
Have we found ancestor matching from?
If no target found then pass the empty list
See Errata E24
The character is not a '-' or a '.' or a digit
then return NaN because something is wrong.
In order to handle the 'all' semantics of
nodeset comparisons, we always call the
If at least one object to be compared is a boolean, then each object
to be compared is converted to a boolean as if by applying the
Otherwise, if at least one object to be compared is a number, then each object
to be compared is converted to a number as if by applying the number function.
Otherwise, both objects to be compared are converted to strings as
if by applying the string function.
In order to handle the 'all' semantics of
nodeset comparisons, we always call the
%REVIEW%  Like it says, @since 1.2. Doesn't exist in earlier
versions of Java, hence we can't yet shell out to it. We can implement
it as character-by-character compare, but doing so efficiently
is likely to be (ahem) interesting.
However, since nobody is actually _using_ this method yet:
Note: toffset might be near -1>>>1.
%REVIEW% Make an FSB here?
Take the easy way out for now.
Serialization version ID
this order reflects the overriding order
only update if it shall override
only update if it shall override
internally, ordinal is used as index
invalid setting ignored
the authentication status
username, password, and JNDI context
the user (assume it is a UnixPrincipal)
Unchecked warning from (Map<String, Object>)sharedState is safe
since javax.security.auth.login.LoginContext passes a raw HashMap.
Unchecked warnings from options.get(String) are safe since we are
passing known keys.
initialize any configured options
attempt the authentication
attempt the authentication by getting the
username and password from shared state
authentication failed -- try again below by prompting
attempt the authentication by getting the
username and password from shared state
attempt the authentication by prompting for the username and pwd
add Principals to the Subject
in any case, clean out state
Clean out state
overall authentication succeeded and commit succeeded,
but someone else's commit failed
clean out state
first get the username and password
get the user's passwd entry from the user provider URL
get the password
this module works only if the LDAP directory server
is configured to permit read access to the userPassword
attribute. The directory administrator need to grant
A workaround would be to make the server do authentication
by setting the Context.SECURITY_PRINCIPAL
and Context.SECURITY_CREDENTIALS property.
However, this would make it not work with systems that
don't do authentication at the server (like NIS).
Setting the SECURITY_* properties and using "simple"
authentication for LDAP is recommended only for secure
channels. For nonsecure channels, SSL is recommended.
check the password
save input as shared state only if
create the user principal
get the UID
get the GID
get the supplementary groups from the group provider URL
password stored in incorrect format
use the password saved by the first module in the stack
prompt for a username and password
print debugging information
cannot happen, but return false just to be safe
The default factories are always registered first,
any factory specified in the properties file and supporting
the same method will override the default factory.
End of file.
Create and register the factory for the Object Reference Template
Create and register the factory for the Object Reference Factory
stupid signed bytes
Used only in the implementation: no client of this class ever needs these
OK : We don't do AccessController.doPrivileged, but we don't
stop the user from creating an MLet just because they
can't read the MLET_LIB_DIR or java.io.tmpdir properties
Check that the list of MLets is not empty
Walk through the list of MLets
Initialize local variables
Display debug information
Load classes from JAR files
Check which is the codebase to be used for loading the jar file.
If we are using the base MLet implementation then it will be
always the remote server but if the service has been extended in
order to support caching and versioning then this method will
return the appropriate one.
Appends the specified JAR file URL to the list of
URLs to search for classes and resources.
OK : Ignore jar file if its name provokes the
URL to be an invalid one.
Instantiate the class specified in the
CODE or OBJECT section of the MLet tag
Initialize local pointer to the MBean server
If no name is specified return a default name for the MLet
Try looking in the JAR:
if we are not called from the ClassLoaderRepository
Try the classloader repository:
The loadClassBefore method never returns null.
If the class is not found we get an exception.
Get the platform-specific string representing a native library.
See if the native library is accessible as a resource through the JAR file.
First try to locate the library in the JAR file using only
the native library name.  e.g. if user requested a load
for "foo" on Solaris SPARC 5.7 we try to load "libfoo.so"
from the JAR file.
Next try to locate it using the native library name and
the architecture-specific path name.  e.g. if user
requested a load for "foo" on Solaris SPARC 5.7 we try to
load "SunOS/sparc/5.7/lib/libfoo.so" from the JAR file.
All paths exhausted, library not found in JAR file.
Let the VM search the library along the path
specified as the java.library.path property.
JDK < 1.4
Try to guess the system temporary dir...
check if it is a primitive type
--- CharacterIterator methods -------------------------------------
--- CharSequence methods -------------------------------------
read and discard the repository ID
write the repository ID
non top level menus have HOT state instead of PUSHED
Use superclass method for the old Windows LAF,
for submenus, and for XP toplevel if selected or pressed
Draw a lowered bevel border
Only paint rollover if no other menu on menubar is selected
Uses protected field.
Draw a raised bevel border
Only paint rollover if no other menu on menubar is selected
Uses protected field.
Note: When toolbar containers (rebars) are implemented, only do
this if the JMenuBar is not in a rebar (i.e. ignore the desktop
property win.menu.height if in a rebar.)
initial set of grammar constants that some configurations will recognize;user
components which create and/or recognize other types of grammars may
certainly use their own constants in place of these (so long as
their Grammar objects implement this interface).
Initialize the configuration parameters.
Force the initialization of the default at construction time,
rather than delaying it to the first time createServerSocket()
Check if all the cipher suites and protocol versions to enable
are supported by the underlying SSL/TLS implementation and if
true create lists from arrays.
We use a static field because:
SSLSocketFactory.getDefault() always returns the same object
(at least on Sun's implementation), and we want to make sure
that the Javadoc & the implementation stay in sync.
If someone needs to have different SslRMIServerSocketFactory
factories with different underlying SSLSocketFactory objects
using different keystores and truststores, he/she can always
use the constructor that takes an SSLContext as input.
For now we set owner to null. In the future, it may be passed
as an argument.
get union of all GC bounds
if portion of dialog is not within the gc boundary
put in the center relative to parent frame/dialog
a bit bogus
* Set the SourceLocator on the expression object.
* @param l the SourceLocator on the expression object, which may be null.
public void setLocator(SourceLocator l)
Note potential hazards -- l may not be serializable, or may be changed
after being assigned here.
defensive, should never happen.
defensive, should never happen.
defensive, should never happen.
defensive, should never happen.
TO DO: Need to get stylesheet Locator from here.
convert a String to Float form, we have to take care of cases specified in spec like INF, -INF and NaN
Can't call Float#compareTo method, because it's introduced in jdk 1.2
distinguishes between identity and equality for float datatype
0.0 is equal but not identical to -0.0
NOTE: we don't distinguish 0.0 from -0.0
This check is necessary because floatToIntBits(+0) != floatToIntBits(-0)
NOTE: 0.0 is equal but not identical to -0.0
this < other
this > other
this == other
NOTE: we don't distinguish 0.0 from -0.0
one of the 2 values or both is/are NaN(s)
this = NaN = other
this is NaN <> other
other is NaN <> this
NOTE: we don't distinguish 0.0 from -0.0
REVISIT: use the java algorithm for now, because we
don't know what to output for 1.1f (which is no
if it contains 'E', then it should be a valid schema
at most 3 longer: E, -, 9
expected decimal point position
for non-zero integer part
decimal point position
move the digits: ddd.d --> d.ddd
trim trailing zeros: d00.0 --> d.000 --> d.
add the last zero if necessary: d. --> d.0
append E: d.dd --> d.ddE
how far we shifted the decimal point
append the exponent --> d.ddEd
the exponent is at most 7
non-zero digit point
skip zeros: 0.003
put the first non-zero digit to the left of '.'
move other digits (non-zero) to the right of '.'
adjust the length
append 0 if nessary: 0.03 --> 3. --> 3.0
append E-: d.dd --> d.ddE-
how far we shifted the decimal point
append the exponent --> d.ddEd
the exponent is at most 3
package-private to prevent explicit instantiation
NOTE: The constructor depends on the initial context size
being at least 1. -Ac
copy declaration in the context
reset namespace and context info
bind "xml" prefix to the XML uri
bind "xmlns" prefix to the XMLNS uri
extend the array, if necessary
ignore "xml" and "xmlns" prefixes
see if prefix already exists in current context
REVISIT: [Q] Should the new binding override the
previously declared binding or should it
it be ignored? -Ac
NOTE:    The SAX2 "NamespaceSupport" helper allows
re-bindings with the new binding overwriting
the previous binding. -Ac
resize array, if needed
bind prefix to uri in current context
find prefix in current context
prefix not found
find uri in current context
uri not found
resize prefix array
resize prefix array
find prefix in context
prefix not found
find prefix in current context
prefix not found
Expected format is: "protocol-version implementation-name"
can be removed only by a JMXConnectionNotification listener
Loop to close all clients
Notification buffer is lazily created when the first client connects
XXX This creates a dependendcy on the implementation
of the CosNaming service provider.
XXX log exception at FINE
Not for this StateFactory
Wrong kind of context, so just give up and let another StateFactory
try to satisfy getStateToBind.
XXX log at FINE level?
Wrong sort of object: just return null to allow another StateFactory
to handle this.  This can happen easily because this StateFactory
is specified for the application, not the service context provider.
XXX log at FINE level?
Wrong sort of object: just return null to allow another StateFactory
to handle this call.
ignore RemoteException because stub might have already
This is necessary because the _orb field is package private in
com.sun.jndi.cosnaming.CNCtx.  This is not an ideal solution.
The best solution for our ORB is to change the CosNaming provider
to use the StubAdapter.  But this has problems as well, because
other vendors may use the CosNaming provider with a different ORB
XXX log this exception at FINE level
ignore the exception and return null.
Note that the exception may be because ctx
is not a CosNaming context.
Message keys used by the serializer
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The localname is the portion after the optional colon; the message indicates
that there is a problem with that part of the QNAME.
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The prefix is the portion before the optional colon; the message indicates
that there is a problem with that part of the QNAME.
Common UI methods
nothing to return
(version >= 6.0) implies Vista or greater.
sun.net.useExclusiveBind is true
Override methods in SocketImpl that access impl's fields.
Override methods in AbstractPlainSocketImpl that access impl's fields.
set fd to delegate's fd to be compatible with older releases
pass in the real impl not the wrapper.
set fd to delegate's fd to be compatible with older releases
set fd to delegate's fd to be compatible with older releases
set fd to delegate's fd to be compatible with older releases
Override methods in AbstractPlainSocketImpl that need to be implemented.
seems to be the best check here...
This restriction will prevent people from using this class to
experiment w/ new HTTP methods using java.  But it should
be placed for security - the request String could be
deviation from RFC 2616 - don't reject status line
if SP Reason-Phrase is not included.
REMIND: do we want all these??
Others not here that we do want??
this order reflects the overriding order
read system properties or jaxp.properties
if it's explicitly set, it's treated as yes no matter the value
only update if it shall override
internally, ordinal is used as index
special property to return entity count info
if system property is not found, try the older form if any
Array list to store printed warnings for each SAX parser used
read and discard the repository ID
write the repository ID
We are in ComboBox
if no menu is active, we try activating the menubar
It might happen that the altRelease event is processed
with a reasonable delay since it has been generated.
Here we check the last deactivation time of the containing
window. If this time appears to be greater than the altRelease
event time the event is skipped to avoid unexpected menu
activation. See 7121442.
Also we must ensure that original source of key event belongs
to the same window object as winAncestor. See 8001633.
mnemonic combination, it's consumed, but we need
set altKeyPressed to false, otherwise after selection
component by mnemonic combination a menu will be open
construct an ID datatype validator
Check if is valid key-[81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*
Sep 14, 2000:
Fixed problem with namespace handling. Contributed by
David Blondeau <blondeau@intalio.com>
Sep 14, 2000:
Fixed serializer to report IO exception directly, instead at
the end of document processing.
Reported by Patrick Higgins <phiggins@transzap.com>
Aug 21, 2000:
Fixed bug in startDocument not calling prepare.
Reported by Mikael Staldal <d96-mst-ingen-reklam@d.kth.se>
Aug 21, 2000:
Added ability to omit DOCTYPE declaration.
DOM Level 3 implementation: variables intialized in DOMSerializerImpl
SAX content handler serializing methods
If this is the root element handle it differently.
If the first root element in the document, serialize
the document's DOCTYPE. Space preserving defaults
to that of the output format.
For any other element, if first in parent, then
close parent's opening tag and use the parnet's
Must leave CData section first
Indent this element on a new line if the first
content of the parent element or immediately
following an element or a comment
We remove the namespaces from the attributes list so that they will
be in _prefixes
Do not change the current element state yet.
This only happens in endElement().
For each attribute print it's name and value as one part,
separated with a space so the element can be broken on
If the attribute xml:space exists, determine whether
to preserve spaces in this and child nodes based on
The prefixes map uses the URI value as key.
and prefix name as value
Now it's time to enter a new element state
with the tag name and space preserving.
We still do not change the curent element state.
Works much like content() with additions for closing
an element. Note the different checks for the closed
element's state and the parent element's state.
Must leave CData section first
This element is not empty and that last content was
another element, so print a line break before that
last element and this element's closing tag.
Leave the element state and update that of the parent
(if we're not root) to not empty and after element.
SAX document handler serializing methods
If this is the root element handle it differently.
If the first root element in the document, serialize
the document's DOCTYPE. Space preserving defaults
to that of the output format.
For any other element, if first in parent, then
close parent's opening tag and use the parnet's
Must leave CData section first
Indent this element on a new line if the first
content of the parent element or immediately
following an element.
Do not change the current element state yet.
This only happens in endElement().
For each attribute print it's name and value as one part,
separated with a space so the element can be broken on
If the attribute xml:space exists, determine whether
to preserve spaces in this and child nodes based on
Now it's time to enter a new element state
with the tag name and space preserving.
We still do not change the curent element state.
Generic node serializing methods methods
Serialize the document declaration appreaing at the head
of very XML document (unless asked not to).
System identifier must be specified to print DOCTYPE.
If public identifier is specified print 'PUBLIC
<public> <system>', if not, print 'SYSTEM <system>'.
If we accumulated any DTD contents while printing.
this would be the place to print it.
Always serialize these, even if not te first root element.
local binder stores namespace declaration
that has been printed out during namespace fixup of
the current element
add new namespace context
If this is the root element handle it differently.
If the first root element in the document, serialize
the document's DOCTYPE. Space preserving defaults
to that of the output format.
For any other element, if first in parent, then
close parent's opening tag and use the parent's
Must leave CData section first
Indent this element on a new line if the first
content of the parent element or immediately
following an element.
Do not change the current element state yet.
This only happens in endElement().
no namespace fixup should be performed
serialize element name
For each attribute print it's name and value as one part,
separated with a space so the element can be broken on
do namespace fixup
REVISIT: some optimization could probably be done to avoid traversing
record all valid namespace declarations
before attempting to fix element's namespace
check if attribute is a namespace decl
stop the namespace fixup and validation
record valid decl
REVISIT: issue error on invalid declarations
xmlns:foo = ""
empty prefix is always bound ("" or some string)
end-else: valid declaration
end-if: namespace declaration
get element uri/prefix
output element name
REVISIT: this could be removed if we always convert empty string to null
for the namespaces.
uri is an empty string and element has some prefix
the namespace alg later will fix up the namespace attributes
remove element prefix
Fix up namespaces for element: per DOM L3
Need to consider the following cases:
case 1: <foo:elem xmlns:ns1="myURI" xmlns="default"/>
Assume "foo", "ns1" are declared on the parent. We should not miss
redeclaration for both "ns1" and default namespace. To solve this
we add a local binder that stores declaration only for current element.
This way we avoid outputing duplicate declarations for the same element
as well as we are not omitting redeclarations.
case 2: <elem xmlns="" xmlns="default"/>
We need to bind default namespace to empty string, to be able to
omit duplicate declarations for the same element
case 3: <xsl:stylesheet xmlns:xsl="http:xsl">
We create another element body bound to the "http:xsl" namespace
as well as namespace attribute rebounding xsl to another namespace.
Need to make sure that the new namespace decl value is changed to
check if prefix/namespace is correct for current element
Element has a namespace
The xmlns:prefix=namespace or xmlns="default" was declared at parent.
The binder always stores mapping of empty prefix to "".
(NOTE: local binder does not store this kind of binding!)
Thus the case where element was declared with uri="" (with or without a prefix)
will be covered here.
the prefix is either undeclared
conflict: the prefix is bound to another URI
Element has no namespace
DOM Level 1 node!
REVISIT: should we terminate upon request?
uri=null and no colon (DOM L2 node)
there is a default namespace decl that is bound to
non-zero length uri, output xmlns=""
Fix up namespaces for attributes: per DOM L3
check if prefix/namespace is correct the attributes
Fix attribute that was declared with a prefix and namespace=""
we must remove prefix for this attribute
make sure that value is never null.
attribute has namespace !=null
print namespace declarations namespace declarations
check if we need to output this declaration
local prefix mapping
declaration was not printed while fixing element namespace binding
If the DOM Level 3 namespace-prefixes feature is set to false
do not print xmlns attributes
case 4: <elem xmlns:xx="foo" xx:attr=""/>
where attribute is bound to "bar".
If the xmlns:xx is output here first, later we should not
redeclare "xx" prefix. Instead we would pick up different prefix
for the attribute.
final: <elem xmlns:xx="foo" NS1:attr="" xmlns:NS1="bar"/>
REVISIT: issue error on invalid declarations
xmlns:foo = ""
empty prefix is always bound ("" or some string)
declaration was not printed while fixing element namespace binding
case 4 does not apply here since attributes can't use
find if for this prefix a URI was already declared
attribute has no prefix (default namespace decl does not apply to attributes)
attribute prefix is not declared
conflict: attr URI does not match the prefix in scope
Find if any prefix for attributes namespace URI is available
in the scope
use the prefix that was found
the current prefix is not null and it has no in scope declaration
use this prefix
find a prefix following the pattern "NS" +index (starting at 1)
make sure this prefix is not declared in the current scope.
add declaration for the new prefix
change prefix for this attribute
attribute uri == null
stop the namespace fixup and validation
uri=null and no colon
no fix up is needed: default namespace decl does not
apply to attributes
end loop for attributes
end namespace fixup algorithm
If element has children, then serialize them, otherwise
serialize en empty tag.
Enter an element state, and serialize the children
one by one. Finally, end the element.
After element but parent element is no longer empty.
If the attribute xml:space exists, determine whether
to preserve spaces in this and child nodes based on
Encode special XML characters into the equivalent character references.
These five are defined by default for all XML documents.
We have to exclude the namespaces declarations from the attributes
Append only when the feature http:xml.org/sax/features/namespace-prefixes"
Printing attribute value
escape NL, CR, TAB
character sequence "]]>" can't appear in content, therefore
we should escape '>'
Preserving spaces: the text must print exactly as it is,
without breaking when spaces appear in the text and without
consolidating spaces. If a line terminator is used, a line
break will occur.
check if it is surrogate
Not preserving spaces: print one part at a time, and
use spaces between parts to break them into different
lines. Spaces at beginning of line will be stripped
by printing mechanism. Line terminator is treated
no different than other text part.
check if it is surrogate
Preserving spaces: the text must print exactly as it is,
without breaking when spaces appear in the text and without
consolidating spaces. If a line terminator is used, a line
break will occur.
check if it is surrogate
Not preserving spaces: print one part at a time, and
use spaces between parts to break them into different
lines. Spaces at beginning of line will be stripped
by printing mechanism. Line terminator is treated
no different than other text part.
check if it is surrogate
If a NamespaceURI is not declared for the current
node's prefix, raise a fatal error.
during serialization always have a mapping to empty string
so we assume there is a declaration.
end of private variables
/ End of package-access variables
Supports standard format
and a native format
No other formats
But if we are stream metadata, adjust the variables
The first three bytes should be FF, SOI, FF
Next byte should be the ff before a marker
Either JFIF, JFXX, or unknown APP0
tag, length, id
Leave newGuy null
Read a dummy to skip the segment
newGuy remains null
Either an ICC profile or unknown APP2
tag, length, id
newGuy remains null
Either Adobe or unknown APP14
tag, length, id
Just skip it
Now that we've read up to the EOI, we need to push back
whatever is left in the buffer, so that the next read
in the native code will work.
Ignore the destination type.
The only progressive mode that makes sense here is MODE_DEFAULT
the param may not be one of ours, so it may return false.
If so, the following would throw an exception
If the param has them, metadata shouldn't
Progressive forces optimized, regardless of param setting
so consult the param re optimized only if not progressive
compression quality should determine the q tables.  Note that this
will be ignored if we already decided not to create any.
Again, the param may not be one of ours, so we must check that it
supports compression settings
We are done with the param, now for the image types
e.g. K or alpha
Not alpha, so must be K
with or without alpha
Everything else is not subsampled, gets no special marker,
and component ids are 1 - N
with or without alpha
without alpha we just accept the JFIF defaults
e.g. K or alpha
then it must be K
Everything else is not subsampled, gets no special marker,
and component ids are 0 - N
do we want an ICC profile?
Now step through the markers, consulting our variables.
Can't happen here
Default progression scans are done in the writer
End of constructors
Utilities for dealing with the marker sequence.
The first ones have package access for access from the writer.
Implement Cloneable, but restrict access
JFIF must be first, so this skips it
Standard tree node methods
Unless we find otherwise
Colorspace type - follow the rules in the spec
First get the SOF marker segment, if there is one
No image, so no chroma
get the number of channels
is there a JFIF marker segment?
How about an Adobe marker segment?
Neither marker.  Check components
Check against the letters
Finally, 3-channel subsampled are YCbCr, unsubsampled are RGB
4-channel subsampled are YCbCrA, unsubsampled are CMYK
Not subsampled.  numChannels < 3 is taken care of above
Lossless - false
NumProgressiveScans - count sos segments
If we have a JFIF marker segment, we know a little
otherwise all we know is the orientation, which is always normal
Aspect Ratio is width of pixel / height of pixel
In this case they just encode aspect ratio directly
They are true densities (e.g. dpi) and must be inverted
1 == dpi, 2 == dpc
Add a text entry for each COM Marker Segment
Avoid cloning twice
JPEGvariety and markerSequence
is there already a jfif marker segment?
Add it as the first element in the list.
First collect any existing DQT nodes into a local list
First collect any existing DQT nodes into a local list
JFIF is always 0
JFIF is always 0
JFIF is always 0
ColorSpaceType can change the target colorspace for compression
This must take any transparency node into account as well, as
that affects the number of channels (if alpha is present).  If
a transparency node is dealt with here, set a flag to indicate
this to the transparency processor below.  If we discover that
the nodes are not in order, throw an exception as the tree is
If there is no ColorSpaceType node, we have nothing to do
We can't handle them, so don't modify any metadata
out of for
If the metadata specifies progressive, then the number of channels
must match, so that we can modify all the existing SOS marker segments.
If they don't match, we don't know what to do with SOS so we can't do
the merge.  We then just return silently.
An exception would not be appropriate.  A warning might, but we have
nowhere to send it to.
JFIF header might be removed
Now add a JFIF if we do want one, but only if it isn't stream metadata
Adobe header might be removed or the transform modified, if it isn't
Keep the old componentSpecs array
SOF might be modified
Now replace the SOF with a new one; it might be the same, but
this is easier.
we never need extended
Now suss out if subsampling changed and set the boolean for
updating the q tables
if the old componentSpec q table selectors don't match
the new ones, update the qtables.  The new selectors are already
in place in the new SOF segment above.
if the component ids are different, update all the existing scans
ignore Huffman tables
update the ids in each SOS marker segment
Find the position in the old componentSpecs array
of the old component with the old selector
and replace the component selector with the
new id at the same position, as these match
the new component specs array in the SOF created
htables - if the old htable selectors don't match the new ones,
update the tables.
Might be the same as the old one, but this is easier.
should be stream metadata if there isn't an SOF, but check it anyway
update tables - routines below check if it's really necessary
If there are no tables, don't add them, as the metadata encodes an
If we are not subsampling, we just need one, so don't do anything
Is it really necessary?  There should be at least 2 tables.
If there is only one, assume it's a scaled "standard"
luminance table, extract the scaling factor, and generate a
scaled "standard" chrominance table.
Find the table with selector 1.
find the table with selector 0.  There should be one.
Assuming that the table with id 0 is a luminance table,
compute a new chrominance table of the same quality and
add it to the last DQT segment
If there are no tables, don't add them, as the metadata encodes an
If we are not subsampling, we just need one, so don't do anything
Is it really necessary?  There should be at least 2 dc and 2 ac
tables.  If there is only one, add a
"standard " chrominance table.
find a table with selector 1. AC/DC is irrelevant
Create new standard dc and ac chrominance tables and add them
to the last DHT segment
Alpha must be first if present
NumProgressiveScans is ignored.  Progression must be enabled on the
Pixel Aspect Ratio or pixel size can be incorporated if there is,
or can be, a JFIF segment
Can there be one?
SOF must be present with 1 or 3 channels, (stream metadata fails this)
Component ids must be JFIF compatible.
remaining tests are negative
if Adobe present, transform = ADOBE_UNKNOWN for 1-channel,
ADOBE_YCC for 3-channel.
If so, create one and insert it into the sequence.  Note that
default is just pixel ratio at 1:1
Convert from mm/dot to dots/cm
Convert from mm/dot to dots/cm
Deal with min case
Deal with max case
Remember if we invert
not close enough
Increment y and compute a new x
Convert to comments.  For the moment ignore the encoding issue.
Ignore keywords, language, and encoding (for the moment).
If compression tag is present, use only entries with "none".
This might indicate that an alpha channel is being added or removed.
The nodes must appear in order, and a Chroma node will process any
transparency, so process it here only if there was no Chroma node
Do nothing for stream metadata
do we have alpha already?  If the number of channels is 2 or 4,
we do, as we don't support CMYK, nor can we add alpha to it
The number of channels can be determined from the SOF
We can do nothing for progressive, as we don't know how to
modify the scans.
Do we already have alpha?  We can tell by the number of channels
We must have an sof, or we can't do anything further
proceed only if the old state and the new state differ
If an adobe marker is present, transform must be UNKNOWN
Add a component spec with appropriate parameters to SOF
Add a component spec with appropriate parameters to SOS
Remove a component spec from SOF
Remove a component spec from SOS
In this case a reset followed by a merge is correct
Build a whole new marker sequence from the tree
JPEGvariety and markerSequence
for all the children, add a marker segment
SOF numBands = total scan bands
No SOS is OK
If JFIF is present, component ids are 1-3, bands are 1 or 3
If both JFIF and Adobe are present,
Adobe transform == unknown for gray,
YCC for 3-chan.
stream can't have jfif, adobe, sof, or sos
Write a default JFIF segment, including thumbnails
This won't be duplicated below because forceJFIF will be
set only if there is no JFIF present already.
Not compatible, so ignore Adobe.
Iterate over each MarkerSegment
Otherwise ignore it, as requested
If adobe isn't JFIF compatible, ignore it
Otherwise ignore it, as requested
End of writer support
Otherwise no need to reset
last printable character for Unicode-compatible encodings
unicode-compliant encodings; can express plane 0
default (Java) encoding if none supplied:
note that the size of this Map
therefore it poses no static mutability risk.
need to convert it to upper case:
see if the encoding passed in is a Java encoding name.
is it known to be unicode-compliant?
have to create one...
is it known to be unicode-compliant?
ARGHH!!  JAXP Uses Xerces without setting the namespace processing to ON!
* Constructor AttList
* @param attrs List of attributes this will contain
public AttList(NamedNodeMap attrs)
for the moment
for the moment
for the moment
DeclHandler.java - Optional handler for DTD declaration events.
Public Domain: no warranty.
$Id: DeclHandler.java,v 1.2 2004/11/03 22:49:08 jsuttor Exp $
end of DeclHandler.java
Type-specific CORBA::Object operations
navigate to the next frame
navigate to the previous frame
If framesCache is dirty, then recreate it.
Maintain navigation traversal order until an
external stack change, such as a click on a frame.
For Windows MDI fidelity.
Maintain the same error semantics as Class.forName()
It would be nice to bypass JDKClassLoader's attempts completely
if it's known that the latest user defined ClassLoader will
Otherwise, we end up calling Class.forName here as well as in
the next step in JDKBridge.  That can take a long time depending
on the length of the classpath.
Note: Looking at the only place in JDKBridge where this code
is invoked, it is clear that aClass will always be null.
See createKey for a description of what's involved
Loading this class with the call stack
loader isn't known to fail, so try
to load it.
Record that we failed to find the class
with this particular loader.  This way, we won't
waste time looking with this loader, again.
JDKClassLoader couldn't find the class with the located
ClassLoader.  Note this in our cache so JDKClassLoader
can abort early next time.
Factory for a key (CacheKey is an implementation detail
A key currently consists of the class name as well as
the latest user defined class loader, so it's fairly
expensive to create.
Determine whether or not this combination of class name
and ClassLoader is known to fail.
Cache result used to mark the caches when there is
no way JDKClassLoader could succeed with the given
Key consisting of the class name and the latest
user defined class loader
Try to incorporate both class name and loader
into the hashcode
WeakHashMap may compare null keys
I've made a decision to actually compare the
loader references.  I don't want a case when
two loader instances override their equals
methods and only compare code base.
This way, at worst, our performance will
be slower, but we know we'll do the correct
both time and date
Check the separator character between Date and Time
validate and normalize
REVISIT: do we need SchemaDateTimeException?
save unnormalized values
If drawDashedFocusIndicator is true, the following are used.
To avoid invoking new methods from the constructor, the
inited field is first checked. If inited is false, the constructor
has not run and there is no point in checking the value. As
all look and feels have a non-null value for these properties,
a null value means the developer has specifically set it to
null. As such, if the value is null, this does not reset the
Strive to return a non-null value, otherwise the html support
will typically pick up the wrong font in certain situations.
Strings get interned...
don't initialize yet
Clone environment since caller owns it.
Put connect controls into environment.  Copy them first since
caller owns the array.
set version to LDAPv3
Initialize with updated environment
Most Javadoc is deferred to the LdapContext interface.
The next two methods allow creation of BufferManagers based on GIOP version.
We may want more criteria to be involved in this decision.
These are only used for sending messages (so could be fragmenting)
REVISIT - On the reading side, shouldn't we monitor the incoming
fragments on a given connection to determine what fragment size
they're using, then use that ourselves?
The stream reader can handle fragmented and
non fragmented messages
REVISIT - what is appropriate?
True if all attributes of this LRE are unique, i.e. they all have
different names. This flag is set to false if some attribute
names are not known at compile time.
Check if the parent has a declaration for this namespace
Check if we have any declared namespaces
Check if this node has a declaration for this namespace
Break up the QName and get prefix:localname strings
Treat default namespace as "" and not null
Check if we must translate the prefix
Get the namespace this prefix refers to
Register the namespace as accessed
Construct the new name for the element (may be unchanged)
Type-check all attributes
Check if in a literal element context
Process all attributes and register all namespaces they use
Handle xsl:use-attribute-sets. Attribute sets are placed first
in the vector or attributes to make sure that later local
attributes can override an attributes in the set.
Ignore special attributes (e.g. xmlns:prefix and xmlns)
Handle all other literal attributes
Register all namespaces that are in scope, except for those that
are listed in the xsl:stylesheet element's *-prefixes attributes
Process all attributes and register all namespaces they use
Check whether all attributes are unique.
Compile code to emit element start tag
duplicate these 2 args for endElement
The value of an attribute may depend on a (sibling) variable
Compile code to emit namespace attributes
Output all attributes
Compile code to emit attributes and child elements
Compile code to emit element end tag
Cannot add an attribute to an element after children have been added to it.
We can safely return false when the instruction can produce an output node.
In general, there is no way to check whether <xsl:call-template> or
<xsl:apply-templates> can produce attribute nodes. <xsl:copy> and
<xsl:copy-of> can also copy attribute nodes to an element. Return
true in those cases to be safe.
PUBLIC METHODS from SnmpMibRequest
Implements the method defined in SnmpMibRequest interface.
See SnmpMibRequest for the java doc.
Implements the method defined in SnmpMibRequest interface.
See SnmpMibRequest for the java doc.
Implements the method defined in SnmpMibRequest interface.
See SnmpMibRequest for the java doc.
Implements the method defined in SnmpMibRequest interface.
See SnmpMibRequest for the java doc.
Implements the method defined in SnmpMibRequest interface.
See SnmpMibRequest for the java doc.
Implements the method defined in SnmpMibRequest interface.
See SnmpMibRequest for the java doc.
Implements the method defined in SnmpMibRequest interface.
See SnmpMibRequest for the java doc.
Implements the method defined in SnmpMibRequest interface.
See SnmpMibRequest for the java doc.
Implements the method defined in SnmpMibRequest interface.
See SnmpMibRequest for the java doc.
Allow to pass the request tree built during the check() phase
to the set() method. Note: the if the tree is `null', then the
set() method will rebuild a new tree identical to the tree built
in the check() method.
Passing this tree in the SnmpMibRequestImpl object allows to
optimize the SET requests.
Returns the SnmpRequestTree object built in the first operation
phase for two-phase SNMP requests (like SET).
Returns the underlying vector of SNMP varbinds (used for algorithm
Ideally these variables should be declared final but it makes
the jdk1.1.x compiler complain (seems to be a compiler bug, jdk1.2
Non final variable.
Common UI methods
These message should be read from a locale-specific resource bundle
Make sure the value is not null
Makes sure the key is not already in the hashtable.
Rehash the table if the threshold is exceeded
Creates the new entry.
See Errata E24
%HZ%:  Is this the best way of finding the root?  Is it better to check
See Errata E24
%HZ%:  Is this the best way of finding the root?  Is it better to check
fields don't want to have multiple lines.  We may provide a field-specific
model in the future in which case the filtering logic here will no longer
a line was removed
Check for the composed text element
Inserts the composed text of an input method. The line element
where the composed text is inserted into becomes an branch element
which contains leaf elements of the composed text and the text
The JTable that is delegating the painting to this UI.
Listeners that are attached to the JTable
Helper class for keyboard actions
add the lead item to the selection without changing lead or anchor
toggle the selected state of the lead item and move the anchor to it
extend the selection to the lead item
move the anchor to the lead and ensure only that item is selected
give focus to the JTableHeader, if one exists
horizontally, forwards always means right,
regardless of component orientation
Actions spcifying true for "inSelection" are
fairly sensitive to bad parameter values. They require
that one of dx and dy be 0 and the other be -1 or 1.
Bogus parameter values could cause an infinite loop.
To prevent any problems we massage the params here
and complain if we get something we can't deal with.
look at the sign of dx and dy only
make sure one is zero, but not both
Note: The Actions constructor ensures that only one of
dx and dy is 0, and the other is either -1 or 1
find out how many items the table is showing as selected
and the range of items to navigate through
both column and row selection
row selection only
column selection only
no selection allowed
A bogus assignment to stop javac from complaining
about unitialized values. In this case, these
won't even be used.
For some cases, there is no point in trying to stay within the
selected area. Instead, move outside the selection, wrapping at
the table boundaries. The cases are:
- nothing selected
- one item selected, and the lead is already selected
the mins are calculated like this in case the max is -1
the algorithm below isn't prepared to deal with -1 lead/anchor
so massage appropriately here first
In cases where the lead is not within the search range,
we need to bring it within one cell for the the search
to work properly. Check these here.
find the next position, possibly looping until it is selected
scroll by at least one cell
scroll by at least one cell
Unfortunately, this strategy introduces bugs because
of the asynchronous nature of requestFocus() call below.
Introducing a delay with invokeLater() makes this work
in the typical case though race conditions then allow
focus to disappear altogether. The right solution appears
to be to fix requestFocus() so that it queues a request
for the focus regardless of who owns the focus at the
time the call to requestFocus() is made. The optimisation
to ignore the call to requestFocus() when the component
already has focus may ligitimately be made as the
request focus event is dequeued, not before.
boolean wasEditingWithFocus = table.isEditing() &&
casting should be safe since the action is only enabled
casting should be safe since the action is only enabled
bail - don't try to move selection on an empty table
this is the only way we have to set both the lead
and the anchor without changing the selection
Set the header's selected column to match the table.
Then give the header the focus.
discontinuous selection actions are only enabled for
discontinuous selection actions are only enabled for
This action is typically bound to SPACE.
If the table is already in an editing mode, SPACE should
simply enter a space character into the table, and not
select a cell. Likewise, if the lead cell is already selected
then hitting SPACE should just enter a space character
into the cell and begin editing. In both of these cases
this action will be disabled.
The Table's Key listener
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
The Table's focus listener
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
The Table's mouse and mouse motion listeners
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
We register all actions using ANCESTOR_OF_FOCUSED_COMPONENT
which means that we might perform the appropriate action
in the table and then forward it to the editor if the editor
had focus. Make sure this doesn't happen by checking our
The AWT seems to generate an unconsumed \r event when
ENTER (\n) is pressed.
Forwarding events this way seems to put the component
in a state where it believes it has focus. In reality
the table retains focus - though it is difficult for
a user to tell, since the caret is visible and flashing.
Calling table.requestFocus() here, to get the focus back to
the table, seems to have no effect.
Component receiving mouse events during editing.
May not be editorComponent.
Check for isEditing() in case another event has
caused the editor to be removed. See bug #4306499.
The row and column where the press occurred and the
press event itself
Whether or not the mouse press (which is being considered as part
of a drag sequence) also caused the selection change to be fully
Set to true when a drag gesture has been fully recognized and DnD
begins. Use this to ignore further mouse events which could be
delivered if DnD is cancelled (via ESCAPE for example)
Whether or not we should start the editing timer on release
To cache the return value of pointOutsidePrefSize since we use
it multiple times.
Used to delay the start of editing.
if this is a single selection table
do nothing for control - will be handled on release
or when drag starts
clicking on something that's already selected
and need to make it the lead now
could be a drag initiating event - don't grab focus
When drag can't happen, mouse drags might change the selection in the table
so we want the isAdjusting flag to be set
Fix for 4835633
If shift is down in multi-select, we should just return.
For single select or non-shift-click, clear the selection
The autoscroller can generate drag events outside the
This may appear completely odd, but must be done for backward
compatibility reasons. Developers have been known to rely on
a call to shouldSelectCell after editing has begun.
Until we support drag-selection, dragging should not change
the selection (act like single-select).
The autoscroller can generate drag events outside the
Factory methods for the Listeners
The installation/uninstall procedures and support
JTable's original row height is 16.  To correctly display the
contents on Linux we should have set it to 18, Windows 19 and
Solaris 20.  As these values vary so much it's too hard to
be backward compatable and try to update the row height, we're
therefor NOT going to adjust the row height based on font.  If the
developer changes the font, it's there responsability to update
the row height.
install the scrollpane border
should be viewport
should be the scrollpane
default TransferHandler doesn't support drop
so we don't want drop handling
IMPORTANT: There is a very close coupling between the parameters
passed to the Actions constructor. Only certain parameter
combinations are supported. For example, the following Action would
not work as expected:
new Actions(Actions.NEXT_ROW_CELL, 1, 4, false, true)
Actions which move within the selection only (having a true
inSelection parameter) require that one of dx or dy be
zero and the other be -1 or 1. The point of this warning is
that you should be very careful about making sure a particular
combination of parameters is supported before changing or
adding anything here.
Width is always positive. The call to abs() is a workaround for
a bug in the 1.1.6 JIT on Windows.
Paint methods and support
account for the fact that the graphics has already been translated
into the table's bounds
this check prevents us from painting the entire table
when the clip doesn't intersect our bounds at all
This should never happen (as long as our bounds intersect the clip,
which is why we bail above if that is the case).
If the table does not have enough rows to fill the view we'll get -1.
(We could also get -1 if our bounds don't intersect the clip,
which is why we bail above if that is the case).
Replace this with the index of the last row.
This should never happen.
If the table does not have enough columns to fill the view we'll get -1.
Replace this with the index of the last column.
Paint the grid.
Paint the cells.
Paint the dragged column if we are dragging.
Remove any renderers that may be left in the rendererPane.
Paint a gray well in place of the moving column.
Move to the where the cell has been dragged.
Fill the background.
Paint the vertical grid lines if necessary.
Render the cell value
Paint the (lower) horizontal grid line if necessary.
we want a newline at the end of each line and not a tab
remove the last newline
End of Class BasicTableUI
If not then can split otherwise cannot
might trigger more elements
Use the estimate of the wrapped spliterator
Note this may not be accurate if there are filter/flatMap
operations filtering or adding elements to the stream
Get the characteristics from the pipeline
Mask off the size and uniform characteristics and replace with
those of the spliterator
Note that a non-uniform spliterator can change from something
with an exact size to an estimate for a sub-split, for example
with HashSet where the size is known at the top level spliterator
but for sub-splits only an estimate is known
The start index of the slice
One past the last index of the slice
The spliterator to slice
current (absolute) index, modified on advance/split
one past last (absolute) index or sliceFence, which ever is smaller
Keep splitting until the left and right splits intersect with the slice
thereby ensuring the size estimate decreases.
This also avoids creating empty spliterators which can result in
existing and additionally created F/J tasks that perform
redundant work on no elements.
The left split does not intersect with, and is to the left of, the slice
The right split does intersect
Discard the left split and split further with the right split
The right split does not intersect with, and is to the right of, the slice
The left split does intersect
Discard the right split and split further with the left split
The left split is contained within the slice, return the underlying left split
Right split is contained within or intersects with the slice
The left split intersects with the slice
Right split is contained within or intersects with the slice
The spliterator is contained within the slice
The spliterator intersects with the slice
Traverse elements up to the fence
The spliterator is contained within the slice
The spliterator intersects with the slice
Traverse elements up to the fence
The spliterator to slice
permits never increase, and don't decrease below zero
Stop splitting when there are no more limit permits
Optimistically traverse elements up to a threshold of CHUNK_SIZE
Must be UNLIMITED; let 'er rip
Optimistically traverse elements up to a threshold of CHUNK_SIZE
Must be UNLIMITED; let 'er rip
The value to represent null in the ConcurrentHashMap
The underlying spliterator
ConcurrentHashMap holding distinct elements as keys
Temporary element, only used with tryAdvance
Adjust attributes of existing runs
Add new string
Add the last AttributedCharacterIterator if necessary
Draw the pressd button
Draw a rollover button
hardcoded margin for JLF requirements.
default margin so replace
Margin which has been explicitly set by the user.
leave room for default visual
Ideally we'd have an interface defined for classes which
support margins (to avoid this hackery), but we've
decided against it for simplicity
This is needed for the space between the divider and end of
The only tricky part with this border is that the divider is
not positioned at the top (for horizontal) or left (for vert),
so this border draws to where the divider is:
|x     ---     x|
|x     | |     x|
|x     |D|     x|
|x     | |     x|
|x     ---     x|
The above shows (rather excessively) what this looks like for
a horizontal orientation. This border then draws the x's, with
the SplitPaneDividerBorder drawing its own border.
This is needed for the space between the divider and end of
read and discard the repository ID
write the repository ID
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of FormattedTextFieldPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of FormattedTextFieldPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
bind initial name
Type-specific CORBA::Object operations
Unable to resolve prefix with null prefix resolver.
If the resolver is null, create a dummy prefix resolver
Need to pass back exception code DOMException.NAMESPACE_ERR also.
Error found in DOM Level 3 XPath Test Suite.
The required DTD URI for exported preferences
The actual DTD corresponding to the URI
Get bottom-up list of nodes from p to root, excluding root
Node is locked to export its contents and get a
copy of children, then lock is released,
and, if subTree = true, recursive calls are made on children
Check if this node was concurrently removed. If yes
remove it from XML Document and return.
Put map in xml element
NEXT STATEMENT THROWS NULL PTR EXC INSTEAD OF ASSERT FAIL
Recurse if appropriate
Ignore the IAE. Should not fail the writeout even the
transformer provider does not support "indent-number".
Transformer resets the "indent" info if the "result" is a StreamResult with
an OutputStream object embedded, creating a Writer object on top of that
OutputStream object however works.
If removed, return silently
Import any preferences at this node
Get involved children
unlocked the node
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of OptionPaneMessageAreaOptionPaneLabelPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of OptionPaneMessageAreaOptionPaneLabelPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
Re-declares fields and methods that are in class MBeanOperationInfo of JMX 1.0
(fields and methods will be removed when MBeanOperationInfo is made a parent interface of this interface)
Now declares methods that are specific to open MBeans
open MBean specific method
private objects to cache the locale and resource bundle
memorize the most-recent locale
Always call the superclass detach last!
Do not access the location path itterator during this operation!
A negative predicate index seems to occur with
Count 'em all
Tell if this is being called from within a predicate.
And get how many total predicates are part of this step.
If we have already calculated the length, and the current predicate
is the first predicate, then return the length.  We don't cache
the anything but the length of the list to the first predicate.
The provider implementation (delegate)
StAX event source
Main Work Starts Here.
remembers the nest level of elements to know when we are done.
that gets the one we peeked at
that really gets the next one
Handle the prolog: http:www.w3.org/TR/REC-xml/#NT-prolog
Process the (document) element
These are all of the events listed in the javadoc for
The spec only really describes 11 of them.
Handle the Misc (http:www.w3.org/TR/REC-xml/#NT-Misc) that can follow the document element
construct prefix:localName from qName
end namespace bindings
true for default namespace
start namespace bindings
true for default namespace
in SAX, namespace declarations are not part of attributes by default.
(there's a property to control that, but as far as we are concerned
we don't use it.) So don't add xmlns:* to attributes.
gather non-namespace attrs
namespace events don't normally occur outside of a startElement
attribute events don't normally occur outside of a startElement
it seems like we need to pass this info along, but how?
this event is listed in the javadoc, but not in the spec.
this event is listed in the javadoc, but not in the spec.
this event is listed in the javadoc, but not in the spec.
this event is listed in the javadoc, but not in the spec.
Bounds check for 'b' will be performed automatically
Bounds check for 'b' will be performed automatically
Bounds check for 'b' will be performed automatically
Bounds check for 'b' will be performed automatically
Bounds check for 'b' will be performed automatically
Bounds check for 'b' will be performed automatically
Bounds check for 'b' will be performed automatically
Bounds check for 'b' will be performed automatically
Differentiate hash code from other ComponentSampleModel subclasses
-- This file was mechanically generated: Do not edit! --
Cached unsafe-access object
Cached array base offset
Cached unaligned-access capability
Base address, used in all indexing calculations
NOTE: moved up to Buffer.java for speed in JNI GetDirectBufferAddress
An object attached to this buffer. If this buffer is a view of another
buffer then we use this field to keep a reference to that buffer to
ensure that its memory isn't freed before we are done with it.
For duplicates and slices
PENDING(jeff) - need to provide a specification for
how Mac/OS2/BeOS/etc file systems can modify FileSystemView
to handle their particular type of file system.
FileSystemView was destroyed
Shortcuts to directories are treated as not being file system objects,
so that they are never returned by JFileChooser.
Don't cache this array, because filesystem might change
Providing default implementations for the remaining methods
because most OS file systems will likely be able to use this
code. If a given OS can't, override these methods in its
add all files in dir
Not a valid file (wouldn't show in native file chooser)
Not a valid file (wouldn't show in native file chooser)
This could be a node under "Network Neighborhood".
We're mostly after the exists() override for windows below.
Unix - using OpenWindows' default folder name. Can't find one for Motif/CDE.
Could be looking at the path for Solaris, but wouldn't be reliable.
Path is relative to the root of parent's drive
Using NT's default folder name
Check for missing backslash after drive letter such as "C:" or "C:filename"
Problem: Removable drives on Windows return false on f.exists()
Workaround: Override exists() to always return true.
Using NT's default folder name
What I want is "Find first clear bit". That doesn't exist.
JDK1.2 added "find last set bit", but that doesn't help now.
%TBD% -- Declare? Encapsulate? Ignore? Or
dance widdershins about the instruction cache?
We expect these values to be overwritten during the notify()/wait()
periods, as other coroutines in this set get their opportunity to run.
%TBD% -- Declare? Encapsulate? Ignore? Or
dance deasil about the program counter?
Pass it along
And inform this coroutine that its partners are Going Away
%REVIEW% Should this throw/return something more useful?
We expect these values to be overwritten during the notify()/wait()
periods, as other coroutines in this set get their opportunity to run.
Node name, followed by description
Node name + "/" + AttributeName, followed by description
All AWTEvents that are wrapped in SequencedEvents are (at
least currently) implicitly generated by the system
getFirstWithContext can dispose this
Wake myself up
Wake up waiting threads
Confirm that the object identifier is correct
canFilterIndexColorModel indicates whether or not it is acceptable
to apply the color filtering of the filterRGB method to the color
table entries of an IndexColorModel object in lieu of pixel by pixel
Use NTSC conversion formula.
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of ToolBarPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of ToolBarPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
Hand off to setNodeValue for code-reuse reasons (mutation
events, readonly protection, synchronizing, etc.)
Find all keys in props that start with propertyName
Convert the list into an array of the proper type.
An Object[] as a result does NOT work.  Also report
any errors carefully, as errors here or in parsers that
use this Operation often show up at ORB.init().
Do a quick check on the keystore
maybe caller did not call hasNext()
Find the next entry that contains a certificate and return it.
In particular, this skips over entries containing symmetric keys.
Determine Windows Version.
nothing to return
(version >= 6.0) implies Vista or greater.
sun.net.useExclusiveBind is true
add default recognized features
WARN_ON_DUPLICATE_ATTDEF,      from XMLDTDScannerImpl
WARN_ON_UNDECLARED_ELEMDEF,    from XMLDTDScannerImpl
ALLOW_JAVA_ENCODINGS,          from XMLEntityManager
LOAD_EXTERNAL_DTD,     from XMLDTDScannerImpl
NOTIFY_BUILTIN_REFS,   from XMLDocumentFragmentScannerImpl
NOTIFY_CHAR_REFS,          from XMLDocumentFragmentScannerImpl
WARN_ON_DUPLICATE_ENTITYDEF    from XMLEntityManager
set state for default features
setFeature(WARN_ON_DUPLICATE_ATTDEF, false);   from XMLDTDScannerImpl
setFeature(WARN_ON_UNDECLARED_ELEMDEF, false);     from XMLDTDScannerImpl
setFeature(ALLOW_JAVA_ENCODINGS, false);       from XMLEntityManager
setFeature(LOAD_EXTERNAL_DTD, true);       from XMLDTDScannerImpl
setFeature(NOTIFY_BUILTIN_REFS, false);    from XMLDocumentFragmentScannerImpl
setFeature(NOTIFY_CHAR_REFS, false);       from XMLDocumentFragmentScannerImpl
setFeature(WARN_ON_DUPLICATE_ENTITYDEF, false);    from XMLEntityManager
add default recognized properties
this configuration delays creation of the scanner
till it is known if namespace processing should be performed
add message formatters
REVISIT: What is the right thing to do? -Ac
make this feature special
REVISIT: this method used to reset all the components and
construct the pipeline. Now reset() is called
in parse (boolean) just before we parse the document
Should this method still throw exceptions..?
reset and configure pipeline and set InputSource.
resets and sets the pipeline.
REVISIT - need to add new error message
close all streams opened by xerces
configure the pipeline and initialize the components
create appropriate scanner
and register it as one of the components.
setup dtd pipeline
features and properties
Allows the parser to validate a document only when it
contains a grammar. Validation is turned on/off based
on each document instance, automatically.
End of file.
NOTE: this uses setOpaque vs LookAndFeel.installProperty as there
is NO reason for the RootPane not to be opaque. For painting to
work the contentPane must be opaque, therefor the RootPane can
also be opaque.
This needs to match the checkExit call in
FIXME:  [[[WDW - should also return ICONIFIED and ICONIFIABLE
if we can ever figure these out]]]
inner class AccessibleJFrame
when set, add will throw an exception.
Use fast-path for double result if that works
============== Locale Stuff =====================
just enough fields for a reasonable distribution
Didn't have additional int fields, reassign to use them.
Constants used by factory methods to specify a style of format.
invariant, >= minFractionDigits
new fields for 1.2.  byte is too small for integer digits.
invariant, >= minFractionDigits
Removed "implements Cloneable" clause.  Needs to update serialization
ID for backward compatibility.
class for AttributedCharacterIterator attributes
Proclaim serial compatibility with 1.4 FCS
table of all instances in this class, used by readResolve
Maps requestId to an OutCallDesc.
The waiter is removed in releaseReply in the same
way as a normal request.
Wait for the reply from the server.
The ReaderThread reads in the reply IIOP message
and signals us.
REVISIT -- exceptions from unmarshaling code will
go up through this client thread!
On fragmented streams the header MUST be unmarshaled here
(in the client thread) in case it blocks.
If the header was already unmarshaled, this won't
REVISIT: cast - need interface method.
This is an interesting case.  It could mean that someone sent us a
reply message, but we don't know what request it was for.  That
would probably call for an error.  However, there's another case
that's normal and we should think about --
If the unmarshaling thread does all of its work inbetween the time
the ReaderThread gives it the last fragment and gets to the
Set the reply InputObject and signal the client thread
that the reply has been received.
The thread signalled will remove outcall descriptor if appropriate.
Otherwise, it'll be removed when last fragment for it has been put on
anything waiting for BufferManagerRead's fragment queue
needs to be cancelled
IMPORTANT: If inputObject is null, then no need to tell
BufferManagerRead to cancel request processing.
attempt to wake up waiting threads in all cases
This can happen when getting early reply fragments for a
request which has completed (e.g., client marshaling error).
End of file.
read and discard the repository ID
write the repository ID
initialize to default values
validate and normalize
save unnormalized values
Initializes components and anys representation
from the Any representation
This typeCode is of kind tk_array.
_REVISIT_ Could use read_xxx_array() methods on InputStream for efficiency
but only for primitive types
Creates the appropriate subtype without copying the Any
Initializes components and anys representation
from the internal TypeCode information with default values.
This is not done recursively, only one level.
More levels are initialized lazily, on demand.
This typeCode is of kind tk_array.
DynArray interface methods
Initializes the elements of the array.
If value does not contain the same number of elements as the array dimension,
the operation raises InvalidValue.
If one or more elements have a type that is inconsistent with the DynArrays TypeCode,
the operation raises TypeMismatch.
This operation does not change the current position.
deleted for the time being.
redirect out and err streams
check modifiers: public static
check return type and exceptions
determine the class loader to be used for loading the class
since ServerMain is going to be in JDK and we need to have this
class to load application classes, this is required here.
determine the main class
determine the main class, try loading with current class loader
eat the exception and try to load using SystemClassLoader
get the main method
This piece of code is required, to verify the server definition
without launching it.
verify the server
build args to the main and call it
NOTE: Very important to pass this property, otherwise the
Persistent Server registration will be unsucessfull.
shutdown the ORB and wait for completion
NON-NLS: the property name
can be null
without is null => just behave as loadClass
We must try to load the class without the given loader.
bootstrap class loader
OK: continue with next class
Check if we have such a current search
Add an entry
Retrieve the search.
install the content
build the event and element structure
update bidi (possibly)
notify the listeners
install the content
Nothing to insert, bail.
create event and build the element structure
update bidi (possibly)
notify the listeners
element includes the last "\n" character, needs special handling
last "\n" must not be removed
preceding leaf ends with "\n", remove it
do not leave empty branch elements
can only happen if the element structure is severely broken
preceding leaf element should be extended to cover orphaned "\n"
do not fire UndoabeEdit event for composed text edit (unsupported)
split elements that need it
PENDING(prinz) - this isn't a very efficient way to iterate
offset + length beyond length of document, bail.
PENDING(prinz) - this assumes a particular element structure
--- local methods -------------------------------------------------
Paragraph attributes should come from point after insertion.
You really only notice this when inserting at a paragraph
Character attributes should come from actual insertion point.
Check if the previous character was a newline.
Inserting after a newline.
If not inserting after a new line, pull the attributes for
new paragraphs from the paragraph under the insertion point.
Check for join previous of first content.
Do a join fracture/next for last start spec if necessary.
Join to the fracture if NOT inserting at the end
(fracture only happens when not inserting at end of
Join to next if parent of pParagraph has another
element after pParagraph, and it isn't a leaf.
Do a JoinNext for last spec if it is content, it doesn't
already have a direction set, no new paragraphs have been
inserted or a new paragraph has been inserted and its join
direction isn't originate, and the element at endOffset
is a leaf.
Don't try joining to a branch!
If not inserting at boundary and there is going to be a
fracture, then can join next on last content if cattr
matches the new attributes.
Check for the composed text element. If it is, merge the character attributes
into this element as well.
Assure that the composed text element is named properly
and doesn't have the CR attribute defined.
Need to find the common parent of pParagraph and paragraph.
The simple (and common) case that pParagraph and
paragraph have the same parent.
Will only happen for text with more than 2 levels.
Find the common parent of a paragraph and pParagraph
e identifies the common parent.
Build the ends.
And the starts.
If there are right parents, then we generated starts
down the right subtree and there will be an element to
No right subtree, e.getElement(endOffset) is a
leaf. There will be a facture.
else: Could throw an exception here, but should never get here!
grabs a write-lock for this initialization and
abandon it during initialization so in normal
operation we can detect an illegitimate attempt
to mutate attributes.
Only propagate change updated if have content
lazily create a ChangeUpdateRunnable
We may get a whole batch of these at once, so only
queue the runnable if it is not already pending
Reinstall style listeners.
--- member variables -----------------------------------------------------------
Nothing was inserted, no structure change.
PENDING(prinz) this needs to be fixed to create a new
root element as well, but requires changes to the
DocumentEvent to inform the views that there is a new
Recreate the ending fake element to have the correct offsets.
Reset the root elements attributes.
fold in the specified subtree
pop the remaining path
push the path
Build a copy of the original path.
Haven't created the fracture yet.
Insert the first content.
fold in the specified subtree
Fracture, if we haven't yet.
pop the remaining path
Offset the last index if necessary.
Make sure an edit is going to be created for each of the
original path items that have a change.
PENDING(sky): Do I need to worry about order here?
An insert at 0 with an initial end implies some elements
will have no children (the bottomost leaf would have length 0)
this will find what element need to be removed and remove it.
need to do the other end
push the path
make sure there is something to do... if the
offset is already at a boundary then there is
nothing to do.
we need to split, now see if the other end is within
the same parent.
it's a range split in the same parent
it's a three-way split
end is already on a boundary
split the first location
pick up things in the middle
if we pushed a branch element that didn't get
used, make sure its not marked as having been added.
Don't create a new element, use the existing one
at the specified location.
This happens if inserting into a leaf, followed
by a join next where next sibling is not a leaf.
Not really a fracture, but need to treat it like
one so that content join next will work correctly.
We can do this because there will never be a join
next followed by a join fracture.
Should always be something on the stack!
If parent isn't a fracture, fracture will be
Parent is a fracture, use 1st element.
JoinNext on tail is only applicable if last element
and attributes come from that of first element.
With a little extra testing it would be possible
to NOT due this again, as more than likely fracture()
created this element.
Parent was fractured element.
update path for changes
if the range is contained by one element,
we just forward the request
Element totally removed.
the removal range spans elements.  If we can join
the two endpoints, do it.  Otherwise we remove the
interior and forward to the endpoints.
remove and join
remove interior and forward
start element completely consumed
end element not touched
Return true if we no longer have any children.
Don't join a leaf to a branch.
Only join leaves if the attributes match, otherwise
style information will be lost.
Only join non-leafs if the names are equal. This may result
in loss of style information, but this is typically acceptable
Both names null, treat as equal.
join two branch elements.  This copies the children before
the removal range on the left element, and after the removal
range on the right element.  The two elements on the edge
are joined if possible and needed.
transfer the left
transfer the join/middle
transfer the right
install the children
Use childAltered to determine when a child has been altered,
that is the point of insertion is less than the element count.
Determine where to start recreating from.
Start at - 2, as first one is indicated by recreateLeafs and
Recreate all children to right of parent starting
Recreate the element representing the inserted index.
Recreate all the elements to the right of the
Create the newChild, a duplicate of the elment at
index. This isn't done if isEnd and offsetLastIndex are true
indicating a join previous was done.
Determine the child to duplicate, won't have to duplicate
if at end of fracture, or offseting index.
Recreate the remaining children (there may be none).
Last part of fracture.
Last leaf, need to recreate part of it.
Not a leaf
Split the bottommost leaf. It will be recreated elsewhere.
Inserts at offset 0 do not need to recreate child (it would
have a length of 0!).
Create the left split part containing new content.
Remainder will be created later.
else Inserted at end, and is total length.
Update index incase something added/removed.
Recreate the first element, its offset will have
Recreate the second, merge part. We do no checking
to see if JoinNextDirection is valid here!
else nothin to do.
PENDING: if !isOnlyContent could raise here!
Inserted into middle, need to recreate split left
new content, and split right.
Signals need to recreate right split later.
If not replacing, it may be more efficient to only copy the
AttributeSet containing additional entries, must be non-mutable!
Copy of the AttributeSet the Element contained.
true if all the attributes in the element were removed first.
this line contains the composed text.
no selection, or it is invisible
the structure of this element changed.
should damge a little more intelligently.
update font metrics which may be used by the child views
--- TabExpander methods ------------------------------------------
--- View methods -------------------------------------
superclass paints the children
invalidate the view itself since the desired widths
of the children will be based upon this views width.
--- variables -------------------------------------------
We have been initially set to MAX_VALUE, but we don't
want this as our preferred.
PENDING(prinz) implement bias properly
above the area covered by this icon, so the the position
is assumed to be the start of the coverage for this view.
below the area covered by this icon, so the the position
is assumed to be the end of the coverage for this view.
positioned within the coverage of this view vertically,
so we figure out which line the point corresponds to.
if the line is greater than the number of lines contained, then
simply use the last line as it represents the last possible place
we can position to.
point is to the left of the line
point is to the right of the line
Determine the offset into the text
have to repaint any views after the receiver.
Cache was GC'ed, so rebuild it
do not use cache if there's only one line
we have 2+ lines, and the cache is not big enough
we try to estimate total number of lines
check if the cache is too big
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of ScrollBarPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of ScrollBarPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
private constructor defined to "hide" the default public constructor
read and discard the repository ID
write the repository ID
* Cast result object to a nodelist.
* @return null
public DTMIterator iter()
fisrt (h - 1) scans
Figure out the #banks and the largest band offset
fisrt (h - 1) scans
we couldn't do anything special - do the generic thing
we couldn't do anything special - do the generic thing
Note: the SampleModel for the child Raster should have the same
width and height as that for the parent, since it represents
the physical layout of the pixel data.  The child Raster's width
and height represent a "virtual" view of the pixel data, so
they may be different than those of the SampleModel.
should not happen as this class is cloneable
from an earlier version of the JMX API
cached SocketPermission used for matchLocation
for generating cert paths
Copy the supplied certs
Copy the supplied signers
objects types must be equal
URLs must match
if location is null, then cs.location must be null as well
if location is not null, then it must equal cs.location
certs must match
Convert the code signers to certs
Convert the certs to code signers
match any key
both have signers
both have certs
Matches the directory and (recursively) all files
and subdirectories contained in that directory.
For example, "/a/b/-" implies anything that starts with
Matches the directory and all the files contained in that
For example, "/a/b/*" implies anything that starts with
"/a/b/" but has no further slashes
Exact matches only.
For example, "/a/b" and "/a/b/" both imply "/a/b/"
Serialize the array of certs
write out the total number of certs
write out each cert, including its type
Serialize the array of code signers (if any)
process any new-style certs in the stream (if present)
we know of 3 different cert types: X.509, PGP, SDSI, which
could all be present in the stream at the same time
read the certificate type, and instantiate a certificate
factory of that type (reuse existing factory if possible)
reuse certificate factory
create new certificate factory
store the certificate factory so we can reuse it later
parse the certificate
Deserialize array of code signers (if any)
no signers present
Initialize certificate factory
Iterate through all the certificates
first cert is an end-entity cert
Extract chain of certificates
(loop while certs are not end-entity certs)
TODO - may be better to throw an ex. here
Proprietary, built in functions
clac expanded size
create tmp buffers
extract src image alpha channel and inverse and offset
create color image with shadow color and greyscale image as alpha
reinstantiate Mac object to work around bug in JDK
this shouldn't occur, but if it does, restore previous Mac
add to ArrayList
ignore; shouldn't happen
??? should throw illegal argument exception
ignore; shouldn't happen for composite name
ignore; shouldn't happen for empty composite name
??? should check for null?
No factory. This most likely indicates the parent view
has changed out from under us, bail!
--- View methods ---------------------------------------------
make sure an array exists
update parent reference on removed views
in FlowView.java view might be referenced
from two super-views as a child. see logicalView
update the array
need to grow the array
patch the existing array
update parent reference on added views
We are likely invalid, fail.
Range contained in one view
Straddles some views.
Views may not be in same order as model.
v0 or v1 may be null if there is a gap in the range this
Views entirely covered by range.
point is before the range represented
point is after the range represented.
NOTE: this could actually use end offset with backward.
locate the child and pass along the request
--- local methods ----------------------------------------------------
get the bounds, hopefully without allocating
a new rectangle.  The Shape argument should
not be modified... we copy it into the
Since version 1.1 doesn't have scaling and assumes
a pixel is equal to a point, we just cast the point
sizes to integers.
---- member variables ---------------------------------------------
-- This file was mechanically generated: Do not edit! --
Cached unsafe-access object
Cached array base offset
Cached unaligned-access capability
Base address, used in all indexing calculations
NOTE: moved up to Buffer.java for speed in JNI GetDirectBufferAddress
An object attached to this buffer. If this buffer is a view of another
buffer then we use this field to keep a reference to that buffer to
ensure that its memory isn't freed before we are done with it.
For duplicates and slices
check if caName is formatted correctly
validate DER encoding
Exception is thrown as convenience for callers that are
typed to throw an NPE.
Search for the component, removing any flushed references
along the way.
WeakReference has gone away, remove the WeakReference
4735514, 4886944: The method createNonRolloverToggleBorder() is
private in BasicToolBarUI so we can't override it. We still need
to call super from this method so that it can save away the
original border and then we install ours.
Before calling super we get a handle to the old border, because
super will install a non-UIResource border that we can't
distinguish from one provided by an application.
The menubar we previously touched has changed, force it
No longer used. Cannot remove for compatibility reasons
No longer used. Cannot remove for compatibility reasons
end class MetalDockingListener
This is only used when the giopDebug flag is
(encodingVersion == 0x00) implies CDR encoding,
(encodingVersion >  0x00) implies Java serialization version.
Since this is executed in debug mode only the overhead of
using a View Buffer is not an issue. We'll also use a
read-only View Buffer so we don't disturb the state of
If Magic is incorrect, it is an error.
ACTION : send MessageError and close the connection.
Extract the encoding version from the request GIOP Version,
if it contains an encoding, and set GIOP version appropriately.
For Java serialization, we use GIOP Version 1.2 message format.
Entering this block means the request is using Java encoding,
and the encoding version is <= this ORB's Java encoding version.
For requests, sending ORB should use the version info
published in the IOR or may choose to use a <= version
for requests. If the version is greater than published version,
it is an error.
For replies, the ORB should always receive a version it supports
or less, but never greater (except for MessageError)
ACTION : Send back a MessageError() with the the highest version
the server ORB supports, and close the connection.
create appropriate messages types
REVISIT a MessageError  may contain the highest version server
can support. In such a case, a new request may be made with the
correct version or the connection be simply closed. Note the
connection may have been closed by the server.
not possible (error checking done already)
unknown message type ?
ACTION : send MessageError and close the connection
Initialize the generic GIOP header instance variables.
'request partitioning' not supported on GIOP version 1.0
so just use the default thread pool, 0.
1.1 & 1.2
IMPORTANT: For 'request partitioning', the thread pool to use
information is stored in the leading 6 bits of byte 6.
IMPORTANT: Request partitioning is a PROPRIETARY EXTENSION !!!
NOTE: Bitwise operators will promote a byte to an int before
performing a bitwise operation and bytes, ints, longs, etc
are signed types in Java. Thus, the need for the
Since this is executed in debug mode only the overhead of
using a View Buffer is not an issue. We'll also use a
read-only View Buffer so we don't disturb the state of
For debugging purposes, save the 12 bytes of the header
REVISIT: is giopHeader still used?
Note: Currently we use response_expected flag to decide if the
call is oneway or not. Ideally, it is possible to expect a
response on a oneway call too, but we do not support it now.
object key will be used for target addressing
only object_key based target addressing is allowed for
GIOP 1.0 & 1.1
Note: Currently we use response_expected flag to decide if the
call is oneway or not. Ideally, it is possible to expect a
response on a oneway call too, but we do not support it now.
iop profile will be used
ior will be used
invalid target addressing disposition value
add request partitioning thread pool to use info
This method is not currently used.
New fragment messages are always created from existing messages.
Creating a FragmentMessage from InputStream is done in
XXX log this exception
This exception is thrown if any exceptions are raised while
extracting the object key or if the object key is empty.
this cannot happen
There is no need for a explicit exception, since the
TargetAddressHelper.read() would have raised a BAD_OPERATION
exception by now.
This exception is thrown if any exceptions are raised while
extracting the object key from the TargetAddress or if all the
the valid TargetAddress::AddressingDispositions are empty.
mouse over editable ComboBox does not switch rollover
for the arrow button
we can not do it in installListeners because arrowButton
is initialized after installListeners is invoked
button glyph for LTR and RTL combobox might differ
On vista for READNLY ComboBox
color for currentValue is the same as for any other item
mostly copied from javax.swing.plaf.basic.BasicComboBoxUI.paintCurrentValue
store current border in client property if needed
DeleteOnExitHook must be the last shutdown hook to be invoked.
Application shutdown hooks may add the first file to the
delete on exit list and cause the DeleteOnExitHook to be
registered during shutdown in progress. So set the
registerShutdownInProgress parameter to true.
DeleteOnExitHook is running. Too late to add a file
reverse the list to maintain previous jdk deletion order.
Last in first deleted.
name of the group
target namespace of the group
model group of the group
The namespace schema information item corresponding to the target namespace
of the model group definition, if it is globally declared; or null otherwise.
initialize the AccessibleRelationSets for the JScrollPane
set the relation set for the scroll bar
set the relation set for the scroll pane
Get the name of the node to copy and save for later
Get the length of the node name and save for later
Ignore attribute sets if current node is ROOT. DOM.shallowCopy()
returns "" for ROOT, so skip attribute sets if length == 0
Copy in attribute sets if specified
If the parent of this element will result in an element being
output then we know that it is safe to copy out the attributes
If not we have to check to see if the copy will result in an
element being output.
check if element; if not skip to translate body
length != 0 -> element -> do attribute sets
not an element; root
Instantiate body of xsl:copy
Call the output handler's endElement() if we copied an element
(The DOM.shallowCopy() method calls startElement().)
Have to override just to update the javadoc
p is last node
Successful CAS is the linearization point
for e to become an element of this queue,
and for newNode to become "live".
hop two nodes at a time
Failure is OK.
Lost CAS race to another thread; re-read next
We have fallen off list.  If tail is unchanged, it
will also be off-list, in which case we need to
jump to head, from which all live nodes are always
reachable.  Else the new tail is a better bet.
Check for tail updates after two hops.
Successful CAS is the linearization point
for item to be removed from this queue.
hop two nodes at a time
Collection.size() spec says to max out
As historically specified in AbstractQueue#addAll
Copy c into a private chain of Nodes
Atomically append the chain at the tail of this collection
p is last node
Successful CAS is the linearization point
for all elements to be added to this queue.
Try a little harder to update tail,
since we may be adding many elements.
Lost CAS race to another thread; re-read next
We have fallen off list.  If tail is unchanged, it
will also be off-list, in which case we need to
jump to head, from which all live nodes are always
reachable.  Else the new tail is a better bet.
Check for tail updates after two hops.
Use ArrayList to deal with resizing.
try to use sent-in array
If won't fit, use ArrayList version
skip over nulls
rely on a future traversal to relink.
Write out any hidden stuff
Write out all elements in the proper order.
Use trailing null as sentinel
Read in elements until trailing null sentinel found
current node; null until initialized
batch size for splits
true when no more nodes
assert !policies.retainServants() && policies.useServantManager()
Try - finally is J2EE requirement.
------------------------- JDBC 4.1 -----------------------------------
index to local variable containg the return address
May set wide as side effect
Including the wide byte
FIXME: rethink 'copyWith' protocol; it is too low-level for use on all MHs
no need for an indirection
No pre-action needed.
the invoker is the target itself
overwrite this MH with next MH
Type-specific CORBA::Object operations
Reduce this pattern
Is this pattern fully reduced?
Ignore following patterns
Returned cached value if already compiled
If not patterns, then return handle for default template
Init handle to jump when all patterns failed
Compile all patterns in reverse order
Patterns expect current node on top of stack
Apply the test-code compiled for the pattern
Make a copy of the instruction list for backpatching
On success branch to the template code
Next pattern's 'fail' target is this pattern's first instruction
Append existing instruction list to the end of this one
Set current instruction list to be this one
No Surrogates in sun java
No Surrogates in sun java
No Surrogates in sun java
Fix 4467608: read([B,I,I) works incorrectly if len<=0
check if we're already at/past EOF i.e.
no more bytes left to read from cache
guaranteed by now that bytesLeftInCache > 0 && len > 0
and so the rest of the error checking is done by cache.read()
NOTE that alot of error checking is duplicated
this will call checkClosed() for us
this will call checkClosed() for us
this will call checkClosed() for us
do not fallback if given classloader can't find the class, throw exception
Append a two digit number.
Append the time and date in ISO 8601 format
Append to the given StringBuilder an escaped version of the
given text string where XML special characters have been escaped.
For a null string we append "<null>"
Format the message string and its accompanying parameters.
If the message is being localized, output the key, resource
bundle name, and params.
The message is not in the catalog.  Drop through.
Check to see if the parameter was not a messagetext format
or was not null or empty
Report on the state of the throwable.
Check for a line number.
Figure out the default encoding.
Try to map the encoding name to a canonical name.
We hit problems finding a canonical name.
Just use the raw encoding name.
This is the only information we can provide in a pipeline.
[2] Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] |
[#xE000-#xFFFD] | [#x10000-#x10FFFF]
[3] S ::= (#x20 | #x9 | #xD | #xA)+
[4] NameChar ::= Letter | Digit | '.' | '-' | '_' | ':' |
CombiningChar | Extender
'-' and '.'
[5] Name ::= (Letter | '_' | ':') (NameChar)*
':' and '_'
[13] PubidChar ::= #x20 | 0xD | 0xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]
[84] Letter ::= BaseChar | Ideographic
[87] CombiningChar ::= ...
[88] Digit ::= ...
[89] Extender ::= ...
SpecialChar ::= '<', '&', '\n', '\r', ']'
set valid characters
remove special characters
set space characters
set name start characters
set name characters
remove ':' from allowable MASK_NCNAME_START and MASK_NCNAME chars
set Pubid characters
Public static methods
End of file.
-- Begin Closure interface --------------------
Only one reference per variable
-- End Closure interface ----------------------
Add a new private field to this class
Get a reference to the newly added field
Check if field is initialized (runtime)
Create an instance of DefaultNodeCounter
Store the node counter in the field
Get NodeCounter._iterator and store locally
'this' pointer on stack
Get NodeCounter._translet and store locally
'this' pointer on stack
Get NodeCounter._document and store locally
'this' pointer on stack
Make sure we have the correct DOM type on the stack!!!
Add a new instance variable for each var in closure
Add a single constructor to the class
Push an instance of the newly created class
Initialize closure variables
Store variable in new closure
Push "this" for the call to characters()
Using java.lang.Math.floor(number + 0.5) to return a double value
Call setValue on the node counter
Call getCounter() with or without args
Output the resulting string to the handler
Transform from RFC1779 to RFC2253
Transform from RFC1779 to RFC2253
if empty string
for name component
only normalize if value is a String
the following char is defined at 4.Relationship with RFC1779 and LDAPv2 inrfc2253
65 (A) 97 (a)
only for the end of a space character occurring at the end of the string from rfc2253
do actual painting
this is kept for backwards compatibility but isn't really needed
with the current BasicTreeUI implementation.
ActionListener (for Timer).
One click to edit.
Save the realEditor, if its Serializable.
Prefer the parent containers font if our font is a
If not font has been set, prefer the renderers height.
This should not be used. It will be removed when new API is
Then the icon.
Border selection color
To make sure the icon position matches that of the
renderer, use the same algorithm as JLabel
Make sure width is at least 100.
do not instantiate
Other notes to implementors:
No stable mapping is promised between the single-method interface and
the implementation class C.  Over time, several implementation
classes might be used for the same type.
If the implementation is able
to prove that a wrapper of the required type
has already been created for a given
method handle, or for another method handle with the
same behavior, the implementation may return that wrapper in place of
a new wrapper.
This method is designed to apply to common use cases
where a single method handle must interoperate with
an interface that implements a function-like
API.  Additional variations, such as single-abstract-method classes with
private constructors, or interfaces with multiple but related
entry points, must be covered by hand-written or automatically
generated adapter classes.
avoid use of BCP
make throw WMT
sun.invoke.WrapperInstance is a restricted interface not accessible
by any non-null class loader.
too many abstract methods
-- This file was mechanically generated: Do not edit! --
For duplicates and slices
-- This file was mechanically generated: Do not edit! --
these declarations are here as documentation
set the source of this handler
return the source from which this handler derives its events
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of InternalFrameTitlePaneMenuButtonPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of InternalFrameTitlePaneMenuButtonPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
SNMP runtime import
Need a reference on SnmpAdaptorServer for getNext & getBulk,
in case of oid equality (mib overlapping).
Trace the input packet
Let's build the response packet
Trace the output packet
Send the response packet if any
Transform the request packet into a request SnmpMessage
Make the response SnmpMessage if any
Try to transform the response SnmpMessage into response packet.
NOTE: we overwrite the request packet.
Transform the request message into a request pdu
Make the response pdu if any
Try to transform the response pdu into a response message if any
if the PDU is too small, why should we try to do
we can not go any further in trying to
reduce the message !
end of loop
reqPdu is accepted by ACLs
reqPdu is rejected by ACLs
respPdu contains the error response to be sent.
We send this response only if authResEnabled is true.
No response should be sent
A trap must be sent
Generates a response packet, filling the values in the
varbindlist with one of endOfMibView, noSuchObject, noSuchInstance
according to the value of <code>status</code>
Generates an appropriate response when no mib is registered in
<li>If the version is V1:</li>
<ul><li>Generates a NoSuchName error V1 response PDU</li></ul>
<li>If the version is V2:</li>
<ul><li>If the request is a GET, fills the varbind list with
<li>If the request is a GET-NEXT/GET-BULK, fills the varbind
list with EndOfMibView's</li>
<li>If the request is a SET, generates a NoAccess error V2
There is no agent registered
Version 1: => NoSuchName
Version 2: => depends on PDU type
SET request => NoAccess
GET request => NoSuchObject
GET-NEXT or GET-BULK => EndOfMibView
Something wrong here: => snmpRspGenErr
Create the trhead group specific for handling sub-requests
associated to the current request. Use the invoke id
Nice idea to use a thread group on a request basis.
However the impact on performance is terrible !
theGroup= new ThreadGroup(thread.getThreadGroup(),
Let's build the varBindList for the response pdu
Good ! Let's make a full response pdu.
First we need to split the request into subrequests
Execute all the subrequests resulting from the split of the
It means that an error occurred. The error is already
formatted by the executeSubRequest
So far so good. So we need to concatenate all the answers.
If it's a set request, we must first check any varBind
Indicate to the sub request that a check must be invoked ...
OK we should have defined out own tag for that !
No point to go any further.
end processing check operation for a set PDU.
Let's start the sub-requests.
No point to go any further.
everything is ok
Indicate to the sub request that a check must be invoked ...
OK we should have defined out own tag for that !
Check the error status.
No point to go any further.
process the operation
No point to go any further.
So far so good. So we need to concatenate all the answers.
RFC 1905, Section 4.2.3, p14
Good ! Let's make a full response pdu.
Split the request into subrequests.
Now we remove useless trailing endOfMibView.
respVarBindList[m2] item and next are going to be removed
Trivial, of course...
Good ! Let's make a full response pdu.
We check the pdu type and create an error response if
the check failed.
If the response is not null, this means the pdu is rejected.
So let's update the statistics.
This should not occur because decodeIncomingRequest has normally
been successfully called before.
Reduction can be attempted only on bulk response
We're going to reduce the varbind list.
First determine which items should be removed.
Next duplicate and replace the existing list by the reduced one.
acceptedVbCount is the number of varbind which have been
successfully encoded before reaching bufferSize:
* when it is >= 2, we split the varbindlist at this
position (-1 to be safe),
* when it is 1, we only put one (big?) item in the varbindlist
* when it is 0 (in fact, acceptedVbCount is not available),
we split the varbindlist by 2.
acceptedCount == 0 ie it is unknown
Take all the oids contained in the request and
For the get next operation we are going to send the varbind list
to all agents
We need to create the sub request handler and update
Update the translation table within the subrequest
Send the getBulk to all agents
Go through the list of subrequests and concatenate.
Hopefully, by now all the sub-requests should be finished
Go through the list of subrequests and concatenate.
Hopefully, by now all the sub-requests should be finished
In v1 make sure there is no endOfMibView ...
So far so good ...
Let's allocate the array for storing the result
Go through the list of subrequests and concatenate.
Hopefully, by now all the sub-requests should be finished
only day, hour, minute, and second should have values
if the property java.time.zone.DefaultZoneRulesProvider is
set then its value is the class name of the default provider
ignore the security exception, try the next provider
CopyOnWriteList could be slow if lots of providers and each added individually
Normalize the coordinates compared to the ellipse
having a center at 0,0 and a radius of 0.5.
Normalize the rectangular coordinates compared to the ellipse
having a center at 0,0 and a radius of 0.5.
find nearest x (left edge, right edge, 0.0)
find nearest y (top edge, bottom edge, 0.0)
if nearest x,y is inside circle of radius 0.5, then intersects
center to left of X extents
center to right of X extents
center above Y extents
center below Y extents
These message should be read from a locale-specific resource bundle
The order is important ...
The two vectors have the same length.
Compare each single element ...
There is no more element in the index
Access the element ...
$$jb 08.20.99:  If the strings in the info object aren't
set, then Netscape (using jdk1.1.5) tends to throw
NPE's when doing some string manipulation.  This is
probably not the best fix, but is solves the problem
of the NPE in Netscape using local classes
$$jb 11.01.99: Replacing this patch.
$$fb if looking for default mixer, and not found yet, add a round of looking
start from 0 to last device (do not reverse this order)
this is not a good default device :)
$$fb 2002-11-26: fix for 4757930: DOC: AudioSystem.getTarget/SourceLineInfo() is ambiguous
1: try from default mixer for this line class
must not happen... but better to catch it here,
if plug-ins are badly written
2: if that doesn't work, try to find any mixing mixer
see if this is an appropriate mixer which can mix
must not happen... but better to catch it here,
if plug-ins are badly written
3: if that didn't work, try to find any non-mixing mixer
see if this is an appropriate mixer which can mix
must not happen... but better to catch it here,
if plug-ins are badly written
if this line was supported but was not available, throw the last
LineUnavailableException we got (??).
otherwise, the requested line was not supported, so throw
an Illegal argument exception
$$fb 2002-04-12: fix for 4662082: behavior of AudioSystem.getTargetEncodings() methods doesn't match the spec
gather from all the codecs
$$fb 2002-04-12: fix for 4662082: behavior of AudioSystem.getTargetEncodings() methods doesn't match the spec
gather from all the codecs
now build a new array
we ran out of options, throw an exception
gather from all the codecs
now build a new array
we ran out of options...
thrown if this provider cannot write the sequence, try the next
thrown if this provider cannot write the sequence, try the next
METHODS FOR INTERNAL IMPLEMENTATION USE
for all mixers
a larg(ish) prime to use for a symbol table to be shared
potentially man parsers.  Start one as close to 2K (20
times larger than normal) and see what happens...
the static symbol table to be shared amongst parsers
the Grammar Pool to be shared similarly
schema full checking constant
variables needed for caching schema grammars.
the DTD grammar loader
REVISIT:  may need to add some features/properties
specific to this configuration at some point...
add default recognized features
set state for default features
add default recognized properties
create and register missing components
and set up the DTD loader too:
by default, make all XMLGrammarPoolImpl's schema grammars available to fSchemaHandler
don't know this grammar...
parseGrammar(String, XMLInputSource):  Grammar
Should check whether the grammar with this namespace is already in
the grammar resolver. But since we don't know the target namespace
of the document here, we leave such check to XSDHandler
by default, hand it off to the grammar pool
parseXMLSchema(XMLInputSource) :  SchemaGrammar
Should check whether the grammar with this namespace is already in
the grammar resolver. But since we don't know the target namespace
of the document here, we leave such check to the application...
by default, hand it off to the grammar pool
parseXMLDTD(XMLInputSource) :  DTDGrammar
call super constructor to export the object
load group's class
NOTE: don't set currSystem to null since it may be needed
Center the image
Tile the image
Constrain the insets to the size of the image
Constrain the insets to the size of the region we're painting
Bogus location, nothing to paint
PENDING: is this necessary, will G2D do it for me?
Bogus location, nothing to paint
read and discard the repository ID
write the repository ID
Load the Resource Bundle - the default is the English resource bundle.
To load another resource bundle, call I18n.init(...) before calling this
Bind the default prefixes
Set the default Transforms
Set the default signature algorithms
Set the default JCE algorithms
Set the default c14n algorithms
Register the default resolvers
Register the default key resolvers
REVISIT: Identical to ContactInfo method.  Refactor into base interface.
REVISIT: Identical to ContactInfo method.  Refactor into base interface.
Usage dictates implementation equals and hashCode.
End of file.
General Attribute Checking will have been done on icElem by caller
check for <annotation> and get selector
General Attribute Checking on sElem
first child could be an annotation
if no more children report an error
must be <selector>
make sure <selector>'s content is fine:
traverse annotation if any
put back attr values...
put back attr values...
General Attribute Checking
and make sure <field>'s content is fine:
put back attr values...
put back attr values...
This table is used to prevent expensive shift operations
(These operations are inexpensive on CPUs but very expensive on JVMs.)
Return last node if position we're looking for is the same
Start from beginning of position we're looking for is before
the point where we left off the last time.
Scan through the bit array - skip integers that have no bits set
Any bits set?
The index where first set bit is
The _INTEGER INDEX_ where last set bit is
Take other array's bits if we have node set
Only merge if other array has any bits set
Merge these bits into other array if other array is larger
Merge other bits into this array if this arrai is large/equal.
super constructor checks that space is TYPE_RGB
check here that min/max are all 0.0/1.0
Note that getNormalizedComponents returns non-premultiplied values
now range of c is 0-255 or 0-65535, depending on lRGBprecision
REMIND: maybe more efficient not to use int array for
DataBuffer.TYPE_USHORT and DataBuffer.TYPE_INT
force component calculations below
fix 4412670 - see comment below
Need to convert the color
fix 4412670 - see comment below
fix 4412670 - for components of 24 or more bits
some calculations done above with float precision
may lose enough precision that the integer result
overflows nBits, so we need to clamp.
Must mean that we are currently not premultiplied so
multiply by alpha
We are premultiplied and want to divide it out
Return a new color model
Set the private fields
REMIND: Get rid of these from the native code
read and discard the repository ID
write the repository ID
A Unicode nonchar
Use lookahead if available
Must be in OUT_EXPR at the end of parsing
consume other delimiter
StringBuffer is on the stack
Read a single byte of compressed data
Read and compress (deflate) input data bytes
Read data from the input stream
End of the input stream reached
Compress the input data, filling the read buffer
Skip bytes by repeatedly decompressing small blocks
Read a small block of uncompressed bytes
Operation not supported
Text node methods
The rtype and ptypes fields define the structural identity of the method type:
The remaining fields are caches of various sorts:
erased form, plus cached data about primitives
alternative wrapped/unwrapped version
cache of handy higher-order adapters
cache for toMethodDescriptorString
defensively copy the array passed in by the user
this is mandated by the JVM spec.
Issue:  Should we allow MH.invokeWithArguments to go to the full 255?
deduct one for mh receiver
deduct one more for invoker
MAX_JVM_ARITY must be power of 2 minus 1 for following code trick to work:
random List impl. could return evil ptypes array
sanity check the size before the toArray call, since size might be huge
promote the object to the Real Thing, and reprobe
cache it here also!
nothing to change
nothing to change
no leading arguments to preserve; go generic
arguments check out; no change
drop all parameters
drop initial parameter(s)
drop trailing parameter(s)
fill in lazily
fill in lazily
type has no wrappers or prims at all
my reference parameters are all Object
same parameter count, same primitive/object mix
Somewhat complicated test to avoid a loop of 2 or more trips.
If either type has only Object parameters, we know we can convert.
Could be a prim/prim conversion, where casting is a strict superset.
Or a boxing conversion, which is always to an exact wrapper class.
Unboxing behavior is different between MHs.eCA & MH.asType (see 3b).
R->R always works, but we have to avoid a check-cast to an interface.
short-circuit a few cases:
the remainder of this logic is documented in MethodHandle.asType
can force void to an explicit null, a la reflect.Method.invoke
can also force void to a primitive zero, by analogy
P->P must widen
P->R must box and widen
any value can be dropped
R->P must be able to unbox (from a dynamically chosen type) and widen
Byte/Number/Comparable/Object -> dw:Byte -> byte.
Character/Comparable/Object -> dw:Character -> char
Boolean/Comparable/Object -> dw:Boolean -> boolean
This means that dw must be cast-compatible with src.
The above does not work if the source reference is strongly typed
to a wrapper whose primitive must be widened.  For example:
Byte -> unbox:byte -> short/int/long/float/double
Character -> unbox:char -> int/long/float/double
can unbox from src and then widen to dst
We have already covered cases which arise due to runtime unboxing
of a reference type which covers several wrapper types:
Object -> cast:Integer -> unbox:int -> long/float/double
Serializable -> cast:Byte -> unbox:byte -> byte/short/int/long/float/double
An marginal case is Number -> dw:Character -> char, which would be OK if there were a
subclass of Number which wraps a value that can convert to char.
Since there is none, we don't need an extra check here to cover char or boolean.
R->R always works, since null is always valid dynamically
/ Queries which have to do with the bytecode architecture
force a range check
also generates NPE if needed
requires serialPersistentFields to be an empty array
requires serialPersistentFields to be an empty array
Probably this object will never escape, but let's check
the field values now, just to be sure.
make sure it is unshared
In order to communicate these values to readResolve, we must
store them into the implementation-specific final fields.
Support for resetting final fields while deserializing
Do not use a trusted path for deserialization:
Verify all operands, and make sure ptypes is unshared:
Playing double race here, and so spinloop is required.
First race is with two concurrent updaters.
Second race is with GC purging weak ref under our feet.
Hopefully, we almost always end up with a single pass.
Metal desktop icons can not be resized.  Their dimensions should
always be the minimum size.  See getMinimumSize(JComponent c).
For the metal desktop icon we will use the layout maanger to
determine the correct height of the component, but we want to keep
the width consistent according to the jlf spec.
Metal desktop icons can not be resized.  Their dimensions should
always be the minimum size.  See getMinimumSize(JComponent c).
Return a copy so the caller can't change the fields.
proxy classes are never externalizable
serial bug 7; the serialPersistentFields were not
being read and stored as Accessible bit was not set
serial bug 7; need to find if the field is of type
For each declared persistent field, look for an actual
reflected Field. If there is one, make sure it's the correct
type and cache it in the ObjectStreamClass_1_3_1 for that field.
Nothing to do
Lookup special Serializable members using reflection.
proxy classes always have serialVersionUID of 0L
SerialBug 5:  static final SUID should be read
get rid of native code
SerialBug 2: should be computed after writeObject
SerialBug 2: should be computed after writeObject
SerialBug 2: should be computed after writeObject
Method must be private and non-static
Method must be private and non-static
Compute the structural UID.  This must be done after the
calculation for writeObject.  Fixed 4/20/2000, eea1
SerialBug 2: to have correct value in RepId
Get SUID of parent
SerialBug 1; acc. to spec the one for
should be computed and put
&& (parent != java.lang.Object.class))
Must make sure that the Field array we allocate
below is exactly the right size.  Bug fix for
if (Modifier.isTransient(m) || Modifier.isStatic(m))
spec reference 00-01-06.pdf, 1.3.5.6, states non-static
non-transient, public fields are mapped to Java IDL.
Here's the quote from the first paragraph:
Java non-static non-transient public fields are mapped to
OMG IDL public data members, and other Java fields are
if (Modifier.isTransient(m) || Modifier.isStatic(m))
SerialBug 3: SHA computation is wrong; for loop reversed
for (int i = minimum; i > 0; i--)
This entry has been cleared,  unlink it
Make sure not already present
cached parameter signature
is a Method.
some SAX source doesn't provide a locator,
in which case we assume no line information is available
and use a dummy locator. With this, downstream components
can always assume that they will get a non-null Locator.
if naemspace processing is turned off, local could be "".
in that case, treat everything to be in the no namespace.
XNI uses null whereas SAX uses the empty string
with my patch
Notify in case remaining images are "done".
Notify in case remaining images are "done".
Notify in case remaining images are "done".
basic Policy definition
Insure that its one of the types we require
Store the node and init any data that needs it
Package, final methods
Package, inherited methods
For debugging purposes, make sure we got rid of all non '*'
repetitions. Otherwise, '*' style nodes are always nullable.
Protected, inherited methods
Its just based on our child node's first pos
Its just based on our child node's last pos
Private data members
This is the reference to the one child that we have for this
Because of the method signature of dateFilter/numberFilter/regexFilter
we can NEVER add a method to RowFilter that returns M,I. If we were
to do so it would be possible to get a ClassCastException during normal
NON-NLS: default prefix
NON-NLS: default postfix
Note: If the value, order, or number of these constants change,
please update the REPLY_MESSAGE_TO_PI_REPLY_STATUS table in PIHandlerImpl.
Never contended, but necessary for visibility
Basic linking and unlinking operations, called only while holding lock
Don't mess with x's links.  They may still be in use by
In this order, in case add() throws.
* Adds all of the elements in the specified collection to this
* queue.  Attempts to addAll of a queue to itself result in
* this operation is undefined if the specified collection is
* modified while the operation is in progress.
* @param c collection containing elements to be added to this queue
* @throws IllegalStateException if this deque is full
* @see #add(Object)
if (c == null)
if (c == this)
for (E e : c)
set to initial position
Chains of deleted nodes ending in null or self-links
are possible if multiple interior nodes are removed.
current node; null until initialized
batch size for splits
true when no more nodes
Write out capacity and any hidden stuff
Write out all elements in the proper order.
Use trailing null as sentinel
Read in all elements and place in queue
parent must be an element in this scheme
for annotation support:
now the current node added, becomes the parent
set the attributes
check if array needs to be resized
store the current parent
add the current node as child of parent
the parent of current parent node becomes the parent
for the next node.
note that this will only be called within appinfo/documentation
note that this will only be called within appinfo/documentation
note that this will only be called within appinfo/documentation
escape characters if necessary
character sequence "]]>" cannot appear in content,
therefore we should escape '>'.
If CR is part of the document's content, it
must not be printed as a literal otherwise
it would be normalized to LF when the document
note that this will only be called within appinfo/documentation
apparently, there is no sensible way of resetting these things
note that this is always called after endElement on <annotation>'s
child and before endElement on annotation.
hence, we must make this the child of the current
parent's only child.
apparently, there is no sensible way of resetting
capturing character calls
help out the garbage collector
this returns a parent node, known to be an ElementImpl
commence the serialization of an annotation
attributes are a bit of a pain.  To get this right, we have to keep track
of the namespaces we've seen declared, then examine the namespace context
for other namespaces so that we can also include them.
optimized for simplicity and the case that not many
namespaces are declared on this annotation...
if it's xmlns:* or xmlns, must be a namespace decl
now we have to look through currently in-scope namespaces to see what
wasn't declared here
have to declare this one
normally, nothing will happen
Must escape 0x09, 0x0A and 0x0D if they appear in attribute
value so that they may be round-tripped. They would otherwise
be transformed to a 0x20 during attribute value normalization.
See bugs 4916766 and 4936203
We intend to create new threads in a reliable thread group.
This avoids problems if the application/applet
creates a thread group, makes JavaIDL calls which create a new
connection and ReaderThread, and then destroys the thread
group. If our ReaderThreads were to be part of such destroyed thread
group then it might get killed and cause other invoking threads
sharing the same connection to get a non-restartable
CommunicationFailure. We'd like to avoid that.
Our solution is to create all of our threads in the highest thread
group that we have access to, given our own security clearance.
try to get a thread group that's as high in the threadgroup
parent-child hierarchy, as we can get to.
this will prevent an ORB thread created during applet-init from
being killed when an applet dies.
Discontinue going higher on a security exception.
something wrong, we go back to the original code
FIXME: This method is not used, but should be fixed once
nio select starts working and we start using ThreadPoolChooser
FIXME: This method is not used, but should be fixed once
nio select starts working and we start using ThreadPoolChooser
FIXME: This method is not used, but should be fixed once
nio select starts working and we start using ThreadPoolChooser
FIXME: This method is not used, but should be fixed once
nio select starts working and we start using ThreadPoolChooser
End of file.
Loader is null when context class loader is set to null
and no loader has been provided in map.
com.sun.jmx.remote.util.Service class extracted from j2se
provider search algorithm doesn't handle well null classloader.
pkgs may not contain an empty element
We have just proved that this cast is correct
REVISIT: After Merlin to see if we can get rid of this Thread and
make the registration of PNameService for INS and BootStrap neat.
start Name Service
name of the attribute group
target namespace of the attribute group
number of attribute uses included by this attribute group
attribute uses included by this attribute group
attribute wildcard included by this attribute group
whether there is an attribute use whose type is or is derived from ID.
The namespace schema information item corresponding to the target namespace
of the attribute group definition, if it is globally declared; or null otherwise.
add an attribute use
if the type is derived from ID, but there is already another attribute
otherwise, return null
if this attribute use is prohibited, then don't check whether it's
of type ID
if there is already an attribute use of type ID,
return its name (and don't add it to the list, to avoid
interruption to instance validation.
Remove all prohibited attributes.
Do not remove attributes that have the same name as the prohibited
ones, because they are specified at the same level. Prohibited
attributes are only to remove attributes from the base type in a
if (fAttributeUses[i].fUse == SchemaSymbols.USE_PROHIBITED)
if (fAttributeUses[i].fAttrDecl.fName == pUses[fAttrUseNum-pCount].fAttrDecl.fName &&
Look for a match in the base
derivation-ok-restriction.  Constraint 2.1.1
if this attribute is prohibited in the derived type, don't
need to check any of the following constraints.
derivation-ok-restriction.  Constraint 2.1.1
derivation-ok-restriction.  Constraint 2.1.3
check the values are the same.
No matching attribute in base - there should be a matching wildcard
derivation-ok-restriction.  Constraint 2.2
Check that any REQUIRED attributes in the base have matching attributes
in this group
derivation-ok-restriction.  Constraint 3
Look for a match in this group
Now, check wildcards
derivation-ok-restriction.  Constraint 4
reset the attribute group declaration
reset attribute uses
-- Interruption machinery --
-- sun.misc.SharedSecrets --
One could put alternate logic in here to
instantiate another object that implements the
InEncoding interface. For example if the JRE is 1.4 or up
we could have an object that uses JRE 1.4 methods
One could put alternate logic in here to
instantiate another object that implements the
InEncoding interface. For example if the JRE is 1.4 or up
we could have an object that uses JRE 1.4 methods
The unicode value is before the range
that we explictly manage, so we delegate the answer.
If we don't have an m_before object to delegate to, make one.
The unicode value is after the range
that we explictly manage, so we delegate the answer.
If we don't have an m_after object to delegate to, make one.
The unicode value is in the range we explitly handle
If we already know the answer, just return it.
We don't know the answer, so find out,
which may be expensive, then cache the answer
The unicode value is before the range
that we explictly manage, so we delegate the answer.
If we don't have an m_before object to delegate to, make one.
The unicode value is after the range
that we explictly manage, so we delegate the answer.
If we don't have an m_after object to delegate to, make one.
The unicode value is in the range we explitly handle
If we already know the answer, just return it.
We don't know the answer, so find out,
which may be expensive, then cache the answer
This object will answer whether any unicode value
is in the encoding, it handles values 0 through Integer.MAX_VALUE
Set the range of unicode values that this object manages
either explicitly or implicitly.
Set the range of unicode values that this object
explicitly manages. Align the explicitly managed values
to RANGE so multiple EncodingImpl objects dont manage the same
This particular EncodingImpl explicitly handles
characters in the low range.
Not only does this EncodingImpl object explicitly
handle chracters in the low range, it is
also one that we know something about, without
needing to call inEncoding(char ch, String encoding)
for this low range
By initializing the table ahead of time
for these low values, we prevent the expensive
inEncoding(char ch, String encoding)
from being called, at least for these common
Construct a String from the char
Encode the String into a sequence of bytes
using the given, named charset.
If for some reason the encoding is null, e.g.
for a temporary result tree, we should just
say that every character is in the encoding.
Construct a String from the char
Encode the String into a sequence of bytes
using the given, named charset.
If the string written out as data is not in the encoding,
the output is not specified according to the documentation
on the String.getBytes(encoding) method,
but we do our best here.
We don't know for sure, but it looks like it is in the encoding
this shouldn't happen, since we are Cloneable
order-relation on duration is a partial order. The dates below are used to
for comparison of 2 durations, based on the fact that
duration x and y is x<=y iff s+x<=s+y
see 3.2.6 duration W3C schema datatype specs
at least one number and designator must be seen after P
scan hours, minutes, seconds
REVISIT: can any item include a decimal fraction or only seconds?
no additional data shouls appear after last item
P1Y1M1DT is illigal value as well
REVISIT: this is unoptimazed vs of comparing 2 durations
Algorithm is described in 3.2.6.2 W3C Schema Datatype specs
add constA to both durations
try and see if the objects are equal
long comparison algorithm is required
REVISIT: some code could be shared between normalize() and this method,
however is it worth moving it? The structures are different...
add months (may be modified additionaly below)
add years (may be modified additionaly below)
original duration was negative
use serialVersionUID from JDK 1.2.2 for interoperability
private objects to cache the locale and resource bundle
memorize the most-recent locale
Was the Node inserted from the Range or the Document
If one boundary-point of a Range is set to have a root container
than the current one for the Range, the Range should be collapsed to
the new position.
The start position of a Range should never be after the end position.
If one boundary-point of a Range is set to have a root container
than the current one for the Range, the Range should be collapsed to
the new position.
The start position of a Range should never be after the end position.
If one boundary-point of a Range is set to have a root container
than the current one for the Range, the Range should be collapsed to
the new position.
The start position of a Range should never be after the end position.
If one boundary-point of a Range is set to have a root container
than the current one for the Range, the Range should be collapsed to
the new position.
The start position of a Range should never be after the end position.
If one boundary-point of a Range is set to have a root container
than the current one for the Range, the Range should be collapsed to
the new position.
The start position of a Range should never be after the end position.
If one boundary-point of a Range is set to have a root container
than the current one for the Range, the Range should be collapsed to
the new position.
The start position of a Range should never be after the end position.
REVIST: what to do if it IS null?
WRONG_DOCUMENT_ERR: Raised if the two Ranges are not in the same Document or DocumentFragment.
The DOM Spec outlines four cases that need to be tested
to compare two range boundary points:
case 1: same container
case 2: Child C of container A is ancestor of B
case 3: Child C of container B is ancestor of A
case 4: preorder traversal of context tree.
case 1: same container
case 2: Child C of container A is ancestor of B
This can be quickly tested by walking the parent chain of B
case 3: Child C of container B is ancestor of A
This can be quickly tested by walking the parent chain of A
case 4: preorder traversal of context tree.
Instead of literally walking the context tree in pre-order,
we use relative node depth walking which is usually faster
holds number of kids before insertion
split text node: results is 3 nodes..
update ranges after the insertion
endContainer is the new Node created
endContainer was not a text Node.
endOffset + = number_of_children_added
signal other Ranges to update their start/end containers/offsets
need to remember number of kids
update fEndOffset. ex:<body><p/></body>. Range(start;end): body,0; body,1
insert <h1>: <body></h1><p/></body>. Range(start;end): body,0; body,2
update fEndOffset if not 0
fStartContainer is not a TextNode
find a first node within a range, specified by fStartOffset
look into all kids of the Range
Offsets are adjusted in Range.insertNode
startContainer or endContainer or both is/are the ancestor(s) of the Node to be deleted
parameters for traverseContents(int)
REVIST: use boolean, since there are only 2 now...
REVIST: Throw exception?
Check for a detached range.
case 1: same container
case 2: Child C of start container is ancestor of end container
This can be quickly tested by walking the parent chain of
case 3: Child C of container B is ancestor of A
This can be quickly tested by walking the parent chain of A
case 4: There is a common ancestor container.  Find the
ancestor siblings that are children of that container.
ascend the ancestor hierarchy until we have a common parent.
If selection is empty, just return the fragment
Text node needs special case handling
get the substring
set the original text node to its new value
Nothing is partially selected, so collapse to start point
Copy nodes between the start/end offsets.
Nothing is partially selected, so collapse to start point
Collapse to just before the endAncestor, which
is partially selected.
Collapse to just before the endAncestor, which
is partially selected.
Because we already traversed it....
should never occur
should never occur
TBD: This should be a HIERARCHY_REQUEST_ERR
If the node contains text, ensure that the
offset of the range is <= to the length of the text
Since the node is not text, ensure that the offset
is valid with respect to the number of child nodes
if hasSibling, return sibling
return parent's 1st sibling.
end of list, return null
This case is an important convenience for
adjust the values to be reasonable
XXX: This relies on setSpan always being called with 0 for
the minimum (which is currently true).
Synchronously notify the listeners so that they are
guaranteed to be up-to-date with the Adjustable before
it is mutated again.
If the DOM implementation is DOM Level 2
then a NoSuchMethodError will be thrown.
Just ignore it.
There was a failure for some other reason
Ignore it as well.
The system shutdown hooks are registered with a predefined slot.
The list of shutdown hooks is as follows:
(0) Console restore hook
(1) Application hooks
(2) DeleteOnExit hook
the index of the currently running shutdown hook to the hooks array
acquire the lock to make sure the hook registered during
shutdown is visible here.
read and discard the repository ID
write the repository ID
sign: 0 for absent; 1 for positive values; -1 for negative values (except in case of INF, -INF)
total digits. >= 1
integer digits when sign != 0
fraction digits when sign != 0
the string representing the integer part
the string representing the fraction part
these 4 variables are used to indicate where the integre/fraction
Deal with leading sign symbol if present
skip '+', so intStart should be 1
skip leading zeroes in integer part
Find the ending position of the integer part
Not reached the end yet
the remaining part is not ".DDD" or "EDDD" or "eDDD", error
fraction part starts after '.', and ends at the end of the input
find location of E or e (if present)
Find the ending position of the fracion part
no integer part, no fraction part, error.
ignore trailing zeroes in fraction part
check whether there is non-digit characters in the fraction part
Construct a canonical String representation of this number
for the purpose of deriving a hashCode value compliant with
The toString representation will be:
NaN for NaN, INF for +infinity, -INF for -infinity, 0 for zero,
and [1-9].[0-9]*[1-9]?(E[1-9][0-9]*)? for other numbers.
There's nothing else we can use easily, because equals could
return true for widely different representation of the
same number - and we don't have any canonical representation.
The problem here is that we must ensure that if two numbers
are equals then their hash code must also be equals.
hashCode for 1.01E1 should be the same as hashCode for 0.101E2
So we call cannonicalToStringForHashCode - which implements an
algorithm that invents a normalized string representation
for this number, and we return a hash for that.
INF is greater than everything and equal to itself
-INF is smaller than everything and equal itself
To enable comparison - the exponent part of the decimal will be limited
to the max value of int.
otherwise the 2 combined values are the same
REVISIT: to be determined by working group
-- This file was mechanically generated: Do not edit! --
check m and rp
convert rp into ks
check m and ks
convert ks into rp
no need to compare rp here since ks and rp
should be equivalent
no need to involve ks here since ks and rp
should be equivalent.
SAX locator interface for document events.
No warranty; no copyright -- use this as you will.
$Id: Locator.java,v 1.2 2004/11/03 22:55:32 jsuttor Exp $
end of Locator.java
*  PUBLIC CONSTANTS
Some special Xalan keys.
*  PRIVATE CONSTANTS
*  PRIVATE STATIC FIELDS
This Class was introduced in JDK 1.2. With the re-architecture of
security mechanism ( starting in JDK 1.2 ), we have option of
giving privileges to certain part of code using doPrivileged block.
In JDK1.1.X applications won't be having security manager and if
there is security manager ( in applets ), code need to be signed
and trusted for having access to resources.
User may be using older JDK ( JDK <1.2 ). Allow him/her to use it.
But don't try to use doPrivileged
According to this article : Double-check locking does not work
TODO: Calculate res file from name.
wrap these cached defaultProperties in a new Property object just so
that the caller of this method can't modify the default values
This static method should eventually be moved to a thread-specific class
so that we can cache the ContextClassLoader and bottleneck all properties file
loading throughout Xalan.
User may be using older JDK ( JDK < 1.2 )
Repeat IOException handling for sandbox/applet case -sc
Note that we're working at the HashTable level here,
and not at the Properties level!  This is important
because we don't want to modify the default properties.
NB: If fixupPropertyString ends up changing the property
name or value, we need to remove the old key and re-add
with the new key and value.  However, then our Enumeration
could lose its place in the HashTable.  So, we first
clone the HashTable and enumerate over that since the
clone will not change.  When we migrate to Collections,
this code should be revisited and cleaned up to use
an Iterator which may (or may not) alleviate the need for
the clone.  Many thanks to Padraig O'hIceadha
<padraig@gradient.ie> for finding this problem.  Bugzilla 2000.
Now check if the given key was specified as a
System property. If so, the system property
overides the default value in the propery file.
No-op for sandbox/applet case, leave null -sc
No-op for sandbox/applet case, leave null -sc
Now start the TimerQueue thread.
If the Timer is already in the queue, then ignore the add.
have timer post an event
Allow run other threads on systems without kernel threads
Shouldn't ignore InterruptedExceptions here, so AppContext
is disposed gracefully, see 6799345 for details
Mark all the timers we contain as not being queued.
most of it copied from
compare zero ONLY if same object
build the ASN.1 BER encoding
write_longdouble not supported by IDL/Java mapping
Following is expensive but we only call this method to determine
if an exception is due to an incompatible parameter type.
Plain old c.isInstance doesn't work for primitive types.
used to adjust values between Windows and java epoch
Use of date constructor.
Use of date methods
Comparison and hashing
Implementation Note: SimpleEntry and SimpleImmutableEntry
are distinct unrelated classes, even though they share
some code. Since you can't add or subtract final-ness
of a field in a subclass, they can't share representations,
and the amount of duplicated code is too small to warrant
exposing a common abstract class.
5 for 32 bit words,  6 for 64 bit words ...
Make various attempts to interpret the parameter as a properties
file or resource file, as follows:
1) attempt to load .properties file using ResourceBundle
2) try using the class loader to find the specified file a resource
3) try treating the resource a URI
Load entity property files by using PropertyResourceBundle,
cause of security issure for applets
Load user specified resource file by using URL loading, it
requires a valid URI as parameter
Fix Bugzilla#4000: force reading in UTF-8
This creates the de facto standard that Xalan's resource
files must be encoded in UTF-8. This should work in all
%REVIEW% KNOWN ISSUE: IT FAILS IN MICROSOFT VJ++, which
didn't implement the UTF-8 encoding. Theoretically, we should
simply let it fail in that case, since the JVM is obviously
broken if it doesn't support such a basic standard.  But
since there are still some users attempting to use VJ++ for
development, we have dropped in a fallback which makes a
second attempt using the platform's default encoding. In VJ++
this is apparently ASCII, which is subset of UTF-8... and
since the strings we'll be reading here are also primarily
limited to the 7-bit ASCII range (at least, in English
versions of Xalan), this should work well enough to keep us
on the air until we're ready to officially decommit from
initialize the array with a cache of the BitSet values
for performance try the values in the boolean array first,
this is faster access than the BitSet for common ASCII values
rather than java.util.BitSet, our private
implementation is faster (and less general).
for performance try the values in the boolean array first,
this is faster access than the BitSet for common ASCII values
rather than java.util.BitSet, our private
implementation is faster (and less general).
this word is used
for optimization purposes.
an optimization here, ... a quick test to see
if this integer is beyond any of the words in use
0L for 64 bit words
record if there are any entities other than
quot, amp, lt, gt  (probably user defined)
other entity in range 0 to 127
This could change the preferred size of the Component.
REMIND: remove when filtering is done at lower level
HeadlessException will be thrown by TextComponent's readObject
Make sure the state we just read in for columns has legal values
Read in listeners, if any
skip value for unrecognized key
Length of the buffer used for readFully(type[], int, int)
REMIND: Once 6277756 is fixed, we should do a bulk read of all 8
bytes here as we do in readShort() and readInt() for even better
performance (see 6347575 for details).
Fix 4494369: method ImageInputStreamImpl.readUTF()
does not work as specified (it should always assume
network byte order).
Restore the old byte order even if an exception occurs
Fix 4430357 - if off + len < 0, overflow occurred
Fix 4430357 - if off + len < 0, overflow occurred
Fix 4430357 - if off + len < 0, overflow occurred
Fix 4430357 - if off + len < 0, overflow occurred
Fix 4430357 - if off + len < 0, overflow occurred
Fix 4430357 - if off + len < 0, overflow occurred
Fix 4430357 - if off + len < 0, overflow occurred
Compute final bit offset before we call read() and seek()
Move byte position back if in the middle of a byte
Shift the bit to be read to the rightmost position
Have to read additional bits on the left equal to the bit offset
Compute final bit offset before we call read() and seek()
Read a byte at a time, accumulate
Move byte position back if in the middle of a byte
Shift away unwanted bits on the right.
Negative of bitsToRead == extra bits read
Mask out unwanted bits on the left
This test also covers pos < 0
Invariant: flushedPos >= 0
XXX Do we need _get_codebase?
The actual DynamicProxy for this stub.
XXX Should probably only allow this once.
XXX log this
End of file.
Xalan is available
Some problem was encountered in fixing up the Xalan FunctionTable so fall back to the
Have the XObject return its result as a NodeSetDTM.
Return the first node, or null
Execute the XPath, and have it return the result
Have the XObject return its result as a NodeSetDTM.
Execute the XPath, and have it return the result
Return a NodeList.
Since we don't have a XML Parser involved here, install some default support
for things like namespaces, etc.
because XPathContext is weak in a number of areas... perhaps
XPathContext should be done away with.)
Create an object to resolve namespace prefixes.
XPath namespaces are resolved from the input context node's document element
if it is a root node, or else the current context node (for lack of a better
resolution space, given the simplicity of this sample code).
Create the XPath object.
Execute the XPath, and have it return the result
Since we don't have a XML Parser involved here, install some default support
for things like namespaces, etc.
because XPathContext is weak in a number of areas... perhaps
XPathContext should be done away with.)
Create the XPath object.
Execute the XPath, and have it return the result
Length of instruction in bytes
Common for all instructions
"Constant" instruction, no need to duplicate
Read next opcode after wide byte
Used predefined immutable object, if available
If a class by that name does not exist, the opcode is illegal.
Note that IMPDEP1, IMPDEP2, BREAKPOINT are also illegal in a sense.
Do further initializations, if any
Byte code offset set in InstructionList
protect against bad ZoneRules
protect against bad ZoneRules
/ TODO: Generics replacement Risk!
TODO: ZDT uses ofLenient()
$$kk: 04.09.99: need to implement!!
Accessor methods (RequestMessage interface)
this will raise a MARSHAL exception upon errors.
REVISIT Should we throw an exception or return null ?
this does AddressingDisposition check
CORBA formal 00-11-0 15.4.2.2 GIOP 1.2 body must be
aligned on an 8 octet boundary.
Ensures that the first read operation called from the stub code,
during body deconstruction, would skip the header padding, that was
inserted to ensure that the body was aligned on an 8-octet boundary.
CORBA formal 00-11-0 15.4.2.2 GIOP 1.2 body must be
aligned on an 8 octet boundary.
Ensures that the first write operation called from the stub code,
during body construction, would insert a header padding, such that
the body is aligned on an 8-octet boundary.
used by the DTD validator to tell other components that it has a
cached DTD in hand so there's no reason to
scan external subset or entity decls.
name of the element
target namespace of the element
type of the element
misc flag of the element: nillable/abstract/fixed
enclosing complex type, when the scope is local
block set (disallowed substitutions) of the element
final set (substitution group exclusions) of the element
value constraint value
the substitution group affiliation of the element
The namespace schema information item corresponding to the target namespace
of the element declaration, if it is globally declared; or null otherwise.
methods to get/set misc flag
first clear the bits
then set the proper one
reset identity constraints
REVISIT: SCAPI: what's the proper representation
Status byte defines
System common messages
System real-time messages
Channel voice message upper nibble defines
Default message data: NOTE_ON on Channel 0 with max volume
can throw InvalidMidiDataException
can throw InvalidMidiDataException
$$fb this should throw an Exception in case of an illegal message!
$$fb this may set an invalid message.
Can't correct without compromising compatibility
check for valid values
can throw InvalidMidiDataException
check for valid values
can throw InvalidMidiDataException
set the length
re-allocate array if ShortMessage(byte[]) constructor gave array with fewer elements
set the data
check for valid values
<=> (channel<0 || channel>15)
this returns 0 if an invalid message is set
this returns 0 if an invalid message is set
system common and system real-time messages
System real-time messages
MTC Quarter Frame
Song Position Pointer
channel voice and mode messages
Call toString() to throw an NPE in case the argument is null
Remove the empty SoftReference
Initialize the fields from the ResourceBundle for locale.
Avoid any potential recursions
JRE and CLDR use different keys
JRE: Eras, short.Eras and narrow.Eras
CLDR: long.Eras, Eras and narrow.Eras
Day of week names are stored in a 1-based array.
Put dfs in the cache
Replace the empty SoftReference with ref.
If the bundle's locale isn't the target locale, put another cache
entry for the bundle's locale.
Copy the field values from dfs to this instance.
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of ArrowButtonPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of ArrowButtonPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
Set a larger buffer size for Solaris
setup to use Unsafe.compareAndSwapInt for updates
Pass principal in for salt
add default recognized properties
If the XInclude handler was not in the pipeline insert it.
add XInclude component
configure DTD pipeline
configure XML document pipeline: insert after DTDValidator and
before XML Schema validator
we don't have to worry about fSchemaValidator being null, since
super.configurePipeline() instantiated it if the feature was set
Otherwise, insert after the last component in the pipeline
If the XInclude handler was not in the pipeline insert it.
add XInclude component
configure XML 1.1. DTD pipeline
configure XML document pipeline: insert after DTDValidator and
before XML Schema validator
we don't have to worry about fSchemaValidator being null, since
super.configurePipeline() instantiated it if the feature was set
Otherwise, insert after the last component in the pipeline
Datetime formats (era and zone handled separately).
Format for date and time.
Must also include offset from UTF.
Get the offset (in milliseconds).
If there is no offset, we have "Coordinated
Convert milliseconds to hours and minutes
In a few cases, the time zone may be +/-hh:30.
The datetime() function returns the zone on the datetime string.  If we
append it, we get the zone substring duplicated.
Fix for JIRA 2013
AD (Common Era -- empty leader)
'+' is implicit , not allowed
No zone information.
Try the allowed formats, from longest to shortest.
from longest to shortest.
Get the timezone information if it was supplied and modify the
dateTime so that SimpleDateFormat will understand it.
Need to adjust it since SimpleDateFormat requires GMT+hh:mm but
we have +hh:mm.
Assume local time.
Leave off the timezone since SimpleDateFormat will assume local
time if time zone is not included.
Try the time format first. We need to do this to prevent
SimpleDateFormat from interpreting a time as a year. i.e we just need
to check if it's a time before we check it's a year.
Try the right truncated formats.
Now try the left truncated ones. The Java format() function doesn't
return the correct strings in this case. We strip any pattern
symbols that shouldn't be output so that they are not defaulted to
inappropriate values in the output.
Assume it's an openening quote so simply copy the quoted
text to the result. There is nothing to strip here.
The char needs to be stripped.
If length == 0, leave it null
If length == 0, leave it null
If length == 0, leave it null
If length == 0, leave it null
If length == 0, leave it null
If length == 0, leave it null
out of for
true for transfer types short, float, double
false for byte, ushort, int
REMIND: there is potential to accelerate sRGB, LinearRGB,
LinearGray, ICCGray, and non-ICC Gray spaces with non-standard
scaling, if that becomes important
NOTE: The is_xxx_stdScale and nonStdScale booleans are provisionally
set here when this method is called at construction time.  These
variables may be set again when initScale is called later.
When setupLUTs returns, nonStdScale is true if (the transferType
is not float or double) AND (some minimum ColorSpace component
value is not 0.0 OR some maximum ColorSpace component value
is not 1.0).  This is correct for the calls to
getNormalizedComponents(Object, float[], int) from initScale().
initScale() may change the value nonStdScale based on the
return value of getNormalizedComponents() - this will only
happen if getNormalizedComponents() has been overridden by a
subclass to make the mapping of min/max pixel sample values
something different from min/max color component values.
Note that the built-in Linear RGB space has a normalized
range of 0.0 - 1.0 for each coordinate.  Usage of these
LUTs makes that assumption.
Note that a normalized range of 0.0 - 1.0 for the gray
component is required, because usage of these LUTs makes
if transferType is byte, ushort, int, or short and we
don't already know the ColorSpace has minVlaue == 0.0f and
maxValue == 1.0f for all components, we need to check that
now and setup the min[] and diffMinMax[] arrays if necessary.
This method is called the first time any method which uses
pixel sample value to color component value scaling information
is called if the transferType supports non-standard scaling
as defined above (byte, ushort, int, and short), unless the
method is getNormalizedComponents(Object, float[], int) (that
method must be overridden to use non-standard scaling).  This
method also sets up the noUnnorm boolean variable for these
transferTypes.  After this method is called, the nonStdScale
variable will be true if getNormalizedComponents() maps a
sample value of 0 to anything other than 0.0f OR maps a
sample value of 2^^n - 1 (2^^15 - 1 for short transferType)
to anything other than 1.0f.  Note that this can be independent
of the colorSpace min/max component values, if the
getNormalizedComponents() method has been overridden for some
reason, e.g. to provide greater dynamic range in the sample
values than in the color component values.  Unfortunately,
this method can't be called at construction time, since a
subclass may still have uninitialized state that would cause
getNormalizedComponents() to return an incorrect result.
only needs to called once
The unnormalized form is only supported for unsigned
transferTypes and when the ColorSpace min/max values
are 0.0/1.0.  When this method is called nonStdScale is
true if the latter condition does not hold.  In addition,
the unnormalized form requires that the full range of
the pixel sample values map to the full 0.0 - 1.0 range
of color component values.  That condition is checked
later in this method.
to keep the compiler from complaining
Since there is only 1 component, there is no alpha
Normalize the pixel in order to convert it
Extract component idx from inData.  The precision argument
should be either 8 or 16.  If it's 8, this method will return
an 8-bit value.  If it's 16, this method will return a 16-bit
value for transferTypes other than TYPE_BYTE.  For TYPE_BYTE,
an 8-bit value will be returned.
This method maps the input value corresponding to a
normalized ColorSpace component value of 0.0 to 0, and the
input value corresponding to a normalized ColorSpace
component value of 1.0 to 2^n - 1 (where n is 8 or 16), so
it is appropriate only for ColorSpaces with min/max component
values of 0.0/1.0.  This will be true for sRGB, the built-in
Linear RGB and Linear Gray spaces, and any other ICC grayscale
spaces for which we have precomputed LUTs.
Note: we do no clamping of the pixel data here - we
assume that the data is scaled properly
Not CS_sRGB, CS_LINEAR_RGB, or any TYPE_GRAY ICC_ColorSpace
Note that getNormalizedComponents returns non-premultiplied values
Red sRGB component should equal
green and blue components
Note that getNormalizedComponents returns non-premult values
REMIND: Use rendering hints?
Handle SHORT, FLOAT, & DOUBLE here
REMIND: need to analyze whether this
clamping is necessary
Handle BYTE, USHORT, & INT here
REMIND: maybe more efficient not to use int array for
DataBuffer.TYPE_USHORT and DataBuffer.TYPE_INT
force component calculations below
Need to convert the color
REMIND: need to analyze whether this
clamping is necessary
fix 4412670 - for components of 24 or more bits
some calculations done above with float precision
may lose enough precision that the integer result
overflows nBits, so we need to clamp.
REMIND: need to analyze whether this
clamping is necessary
Normally (i.e. when this class is not subclassed to override
this method), the test (min != null) will be equivalent to
the test (nonStdScale).  However, there is an unlikely, but
possible case, in which this method is overridden, nonStdScale
is set true by initScale(), the subclass method for some
reason calls this superclass method, but the min and
diffMinMax arrays were never initialized by setupLUTs().  In
that case, the right thing to do is follow the intended
semantics of this method, and rescale the color components
only if the ColorSpace min/max were detected to be other
than 0.0/1.0 by setupLUTs().  Note that this implies the
transferType is byte, ushort, int, or short - i.e. components
derived from float and double pixel data are never rescaled.
Nothing to do
We are premultiplied and want to divide it out
Return a new color model
Must have the same number of components
Log wrapper class for Sun private system exceptions in group ORBUTIL
Generated by MC.java version 1.0, DO NOT EDIT BY HAND!
Generated from input file c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/corba/src/share/classes/com/sun/corba/se/spi/logging/data/ORBUtil.mc on Fri Jul 21 21:58:45 PDT 2017
Should be type string
The old namespace for Java extension
The new namespace for Java extension
See Errata E24
Gather all ancestors that do not match from pattern
Create an array of counters
Increment array of counters according to semantics
Count the node itself
Create the model
use the group model instead
inner class AccessibleJToggleButton
XMLFilterImpl.java - base SAX2 filter implementation.
Written by David Megginson
NO WARRANTY!  This class is in the Public Domain.
$Id: XMLFilterImpl.java,v 1.3 2004/11/03 22:53:09 jsuttor Exp $
Implementation of org.xml.sax.XMLFilter.
Implementation of org.xml.sax.XMLReader.
Implementation of org.xml.sax.EntityResolver.
Implementation of org.xml.sax.DTDHandler.
Implementation of org.xml.sax.ContentHandler.
Implementation of org.xml.sax.ErrorHandler.
end of XMLFilterImpl.java
SAXCatalogReader.java - Read XML Catalog files
Create an instance of the parser
FIXME: there must be a better way
Implement the SAX ContentHandler interface
NOTE: We have to prefix the field XPath with "./" in
order to handle selectors such as "@attr" that
select the attribute because the fields could be
relative to the selector element. -Ac
Unless xpath starts with a descendant node -Achille Fokoue
... or a / or a . - NG
verify that only one attribute is selected per branch
once we've stored the value for this field, we set the mayMatch
member to false so that, in the same scope, we don't match any more
values (and throw an error instead).
the content must be simpleType content
XXX this should be divided into more states.
<book type="hard"> reading attribute name 'type'
<book type="hard"> reading attribute value.
<book type="hard">foo</book> reading </book>
recognized features and properties
is the element empty
track if we are reading attributes, this is usefule while
there is a callback
xxx do we need to create an extra XMLString object... look for using fTempString for collecting all the data values
STAX related properties
skip element algorithm
create a elemnet array of length equal to ELEMENT_ARRAY_LENGTH
pointer location where last element was skipped
2D array to store pointer info
keep dispatching "events"
fDocumentHandler.startDocument(fEntityManager.getEntityScanner(),fEntityManager.getEntityScanner().getVersion(),fNamespaceContext,null); not able to get
check if getCharacterData() is the right function to retrieve ignorableWhitespace information.
entity reference callback are given in startEntity
all DTD related callbacks are handled in DTDScanner.
1. Stax doesn't define DTD states as it does for XML Document.
xxx: check if CDATA values comes from getCharacterData() function
do not give callback here.
this callback is given in scanEndElement function.
xxx: external entities are supported in Xerces
it would be good to define feature for this case
JAXP 1.5 features and properties
if fIsCoalesce is set to true, set the value of fReplaceEntityReferences to true,
if fIsCoalesce is set to false, take the value of fReplaceEntityReferences as set by application
we dont need to do this -- nb.
JAXP 1.5 features and properties
JAXP 1.5 properties
keep track of this entity before fEntityDepth is increased
WFC:  entity declared in external subset in standalone doc
make sure markup is properly balanced
Driver factory methods
/xxx see where its used.. this is not used anywhere. it may be useful for entity to store this information
but this information is only related with Document Entity.
set encoding on reader, only if encoding was not specified by the application explicitly
XXX: why not this function behave as per the state of the parser?
set the PI target and values
getTextCharacters can also be called for reading comments
xxx value returned by this function may not remain valid if another event is scanned.
storing element raw name in a linear list of array
storing elemnetPointer for particular element depth
store pointer information only when element depth is less MAX_DEPTH_LIMIT
identity comparison shouldn't take much time and we can rely on this
since its guaranteed to have same object id for same string.
reset the things and return.
returns column information at which pointer was stored.
Stores element pointer locations at particular depth , only 4 pointer locations
are stored at particular depth for now.
pointer was not stored because we reached the limit
colum = 0 , means first element at particular depth
column = 1, means second element at particular depth
calle should make sure that it doesn't call for value outside allowed co-ordinates
colum = 0 , means first element at particular depth
column = 1, means second element at particular depth
calle should make sure that it doesn't call for value outside allowed co-ordinates
this function assumes that string passed is not null and skips
the following string from the buffer this makes sure
If the start element was completely skipped we should encounter either ' '(space),
or '/' (in case of empty element)  or '>'
if this character is still valid element name -- this means string can't match
Look at the next element stored in the array list.. we might just get a match.
reset it back to zero... we haven't got the correct subset yet.
xxx: we can put some logic here as from what column it should start looking
for now we always start at 0
fallback to tolerant algorithm, it would look for differnt element stored at different
depth and get us the pointer location.
start of the column at which it should try searching
fElementQName will have the details of element just read..
fAttributes will have the details of all the attributes.
when skipping is true and no more elements should be added
get the stored element -- if everything goes right this should match the
token in the buffer
Be conservative -- if skipping fails -- stop.
if skipping fails reposition the stack or fallback to normal way of processing
we are still at the stage of adding elements
the elements were not matched or
fSkip is not set to true
get the next element from the stack
when the elements are being added , we need to check if we are set for skipping the elements
this sets the value of fAdd variable
xxx: We dont need another pointer, fCurrentElement, we can use fElementQName
decrease the markup depth..
check that this element was opened in the same entity
We should not be popping out the context here in endELement becaause the namespace context is still
valid when parser is at the endElement state.
pop the element off the stack..
complete element and attributes are traversed in this function so we can send a callback
<strong>we shouldn't be sending callback in scanDocument()</strong>
Second chance. Check if this character is a high
surrogate of a valid name start character.
REVISIT: one more case needs to be included: external PE and standalone is no
fTempString would store attribute value
/fTempString2 would store attribute non-normalized value
this function doesn't use 'attIndex'. We are adding the attribute later
after we have figured out that current attribute is not namespace declaration
since scanAttributeValue doesn't use attIndex parameter therefore we
can safely add the attribute later..
if the attribute name already exists.. new value is replaced with old value
WFC: Unique Att Spec
attributes count will be same if the current attribute  name already exists for this element name.
this means there are two duplicate attributes.
tmpString contains attribute value
we are passing null as the attribute value
/xxx: nonNormalizedValue is not being set as it is not required by SAX & DOM
It makes things easy if this functions takes XMLStringBuffer as parameter..
this function appends the data to the buffer.
set the fTempString length to 0 before passing it on to scanContent
scanContent sets the correct co-ordinates as per the content read
xxx: We know the next chracter.. we should just skip it and add ']' directlry
xxx: We know the next chracter.. we should just skip it and add ']' directlry
remember where we are in case we get an endEntity before we
could flush the buffer out - this happens when we're parsing an
entity which ends with a ]
We work on a single character basis to handle cases such as:
']]]>' which we might otherwise miss.
scanData will fill the contentBuffer
scan surrogates if any....
by this time we have also read surrogate contents if any...
Take advantage of the fact that next string _should_ be "fElementQName.rawName",
In scanners most of the time is consumed on checks done for XML characters, we can
optimize on it and avoid the checks done for endElement,
we will also avoid symbol table lookup - neeraj.bajaj@sun.com
this should work both for namespace processing true or false...
REVISIT: if the string is not the same as expected.. we need to do better error handling..
We can skip this for now... In any case if the string doesn't match -- document is not well formed.
we have increased the depth for two markup "<" characters
check that this element was opened in the same entity
We should not be popping out the context here in endELement becaause the namespace context is still
valid when parser is at the endElement state.
end element is scanned in this function so we can send a callback
<strong>we shouldn't be sending callback in scanDocument()</strong>
xxx: How do we deal with this - how to return charReferenceValues
now this is being commented because this is taken care in scanDocument()
handle built-in entities
1. if the entity is external and support to external entities is not required
2. or entities should not be replaced
3. or if it is built in entity reference.
start general entity
SUPPORT_DTD=false && ReplaceEntityReferences should throw exception
REVISIT: one more case needs to be included: external PE and standalone is no
we are starting the entity even if the entity was not declared
if that was the case it its taken care in XMLEntityManager.startEntity()
we immediately call the endEntity. Application gets to know if there was
any entity that was not declared.
set the scaner state to content.. parser will automatically revive itself at any point of time.
return the cached name
raw name stored as characters
total number of elements
Mark refers to the position
last depth is the depth when last elemnt was pushed
if last depth is greater than current depth
mark this position
decrease the depth by 1 as arrays are 0 based
we found the match and from next element skipping will start, add 1
Once we get match decrease the count -- this was increased by nextElement()
store the last depth
if number of elements becomes equal to the length of array -- stop the skipping
xxx: this is not correct, we are returning the last element
this wont make any difference since flag has been set to 'false'
when position reaches number of elements in the list..
set the position back to mark,  making it a circular linked list.
total number of elements
Mark refers to the position
XXX: THIS FUNCTION IS NOT USED
when position reaches number of elements in the list..
set the position back to mark,  making it a circular linked list.
store the position of last opened tag at particular depth
last depth is the depth when last elemnt was pushed
if last depth is greater than current depth
mark this position
decrease the depth by 1 as arrays are 0 based
we found the match
Once we get match decrease the count -- this was increased by nextElement()
store the position for the current depth
when we are adding the elements, when skipping
starts even then this should be tracked ie. when
from next element skipping will start, add 1
sicne fInt[fDepth] contains pointer to the element array which are 0 based.
if number of elements becomes equal to the length of array -- stop the skipping
xxx: should we do "fCount == fInt.length"
reposition the stack -- it seems to be too complex document and there is no symmerty in structure
store the last depth
boundary checks are done in matchElement()
return the same object that was pushed -- this would avoid
setting the values for every end element.
STRONG: this object is read only -- this object reference shouldn't be stored.
XMLEvent.ENTITY_REFERENCE ); SCANNER_STATE_REFERENCE
element content is there..
decide the actual sub state of the scanner.For more information refer to the javadoc of
XMLEvent.ENTITY_REFERENCE ); SCANNER_STATE_REFERENCE
element content is there..
end of switch
do some special handling if isCoalesce is set to true.
if the last section was character data
if we dont encounter any CDATA or ENITY REFERENCE and current state is also not SCANNER_STATE_CHARACTER_DATA
return the last scanned charactrer data.
if last section was CDATA or ENTITY REFERENCE
xxx: there might be another entity reference or CDATA after this
<foo>blah blah &amp;&lt;<![CDATA[[aa]]>blah blah</foo>
and current state is not SCANNER_STATE_CHARACTER_DATA
or SCANNER_STATE_CDATA or SCANNER_STATE_REFERENCE
this means there is nothing more to be coalesced.
return the CHARACTERS event.
xxx this function returns true when element is empty.. can be linked to end element event.
returns true if the element is empty
if the element is empty the next event is "end element"
set the next possible state
if last section was either entity reference or cdata or character data we should be using buffer
When coalesce is set to true and last state was REFERENCE or CDATA or CHARACTER_DATA, buffer should not be cleared.
clear the buffer
set the fTempString length to 0 before passing it on to scanContent
scanContent sets the correct co-ordinates as per the content read
check if we have reached end of element
increase the mark up depth
check if its start of new element
there can be cdata ahead if coalesce is true we should call again
in case last section was either entity reference or cdata or character data -- we should be using buffer
xxx: We know the next chracter.. we should just skip it and add ']' directlry
xxx: We know the next chracter.. we should just skip it and add ']' directlry
remember where we are in case we get an endEntity before we
could flush the buffer out - this happens when we're parsing an
entity which ends with a ]
We work on a single character basis to handle cases such as:
']]]>' which we might otherwise miss.
xxx: we should be using only one buffer..
xxx what should be the behavior if entity reference is present in the content ?
/xxx since this part is also characters, it should be merged...
special case: surrogates
xxx: scanContent also gives character callback.
we should not be iterating again if fIsCoalesce is not set to true
if fIsCoalesce is true there might be more data so call fDriver.next()
set it back to false.
check the case when there is comment after single element document
<foo/> and some comment after this
It is last element of the document
if element depth is zero , it indicates the end of the document
the state shouldn't be set, because it is set by elementDepthIsZeroHook() function
xxx understand this point once again..
clear the buffer first
xxx: which buffer should be passed. Ideally we shouldn't have
more than two buffers --
xxx: where should we add the switch for buffering.
xxx: What if CDATA is the first event
we should not clear the buffer only when the last state was either SCANNER_STATE_REFERENCE or
SCANNER_STATE_CHARACTER_DATA or SCANNER_STATE_REFERENCE
if we dont need to coalesce clear the buffer
CDATA section is completely read in all the case.
1. if fIsCoalesce is set to true we set the variable fLastSectionWasCData to true
and just call fDispatche.next(). Since we have set the scanner state to
SCANNER_STATE_CONTENT (super state) parser will automatically recover and
behave appropriately. When isCoalesce is set to true we dont need to reportCDATA event
2. Check if application has set for reporting CDATA event
3. if the application has neither set the fIsCoalesce to true nor fReportCdataEvent
return the cdata event as characters.
there might be more data to coalesce.
we should not clear the buffer only when the last state was either CDATA or
SCANNER_STATE_CHARACTER_DATA or SCANNER_STATE_REFERENCE
fLastSectionWasEntityReference or fLastSectionWasCData are only
used when fIsCoalesce is set to true.
if we dont need to coalesce clear the buffer
take care of character reference
this function also starts new entity
if there was built-in entity reference & coalesce is not true
if there was a text declaration, call next() it will be taken care.
Skip the entity reference, we don't care
Wether it was character reference, entity reference or built-in entity
set the next possible state to SCANNER_STATE_CONTENT
scan text decl
NOTE: special case where entity starts with a PI
whose name starts with "xml" (e.g. "xmlfoo")
standard text declaration
xxx: this function gives callback
now that we've straightened out the readers, we can read in chunks:
xxx: we don't return any state, so how do we get to know about TEXT declarations.
it seems we have to careful when to allow function issue a callback
and when to allow adapter issue a callback.
rest would be taken care by fTrailingMiscDriver set by scanRootElementHook
premature end of file
NOTE: These hook methods are added so that the full document
scanner can share the majority of code with this class.
NOTE: An end of file is only only an error if we were
in the middle of scanning some markup. -Ac
If you are reading attributes and you got a callback
cache available attributes.
since fTempString directly matches to the underlying main buffer
store the data into buffer
clear the XMLString so that data can't be added again.
%REVIEW% If it's a DTM which may contain multiple Result Tree
Fragments, we can't discard it unless we know not only that it
is empty, but that the XPathContext itself is going away. So do
_not_ accept the request. (May want to do it as part of
These couldn't be disposed of earlier (see comments in release()); zap them now.
drop our references too
================ VarStack ===================
================ SourceTreeManager ===================
SECTION: Execution context state tracking
SECTION: Current TreeWalker contexts (for internal use)
SECTION: Implementation of ExpressionContext interface
for now... this might ought to be an empty iterator.
%REVIEW% You can't get much uglier than this...
%REVIEW% You can't get much uglier than this...
We probably should _NOT_ be applying whitespace filtering at this stage!
Some magic has been applied in DTMManagerDefault to recognize this set of options
and generate an instance of DTM which can contain multiple documents
(SAX2RTFDTM). Perhaps not the optimal way of achieving that result, but
I didn't want to change the manager API at this time, or expose
too many dependencies on its internals. (Ideally, I'd like to move
isTreeIncomplete all the way up to DTM, so we wouldn't need to explicitly
specify the subclass here.)
If it doesn't exist, or if the one already existing is in the middle of
being constructed, we need to obtain a new DTM to write into. I'm not sure
the latter will ever arise, but I'd rather be just a bit paranoid..
We probably should _NOT_ be applying whitespace filtering at this stage!
Some magic has been applied in DTMManagerDefault to recognize this set of options
and generate an instance of DTM which can contain multiple documents
(SAX2RTFDTM). Perhaps not the optimal way of achieving that result, but
I didn't want to change the manager API at this time, or expose
too many dependencies on its internals. (Ideally, I'd like to move
isTreeIncomplete all the way up to DTM, so we wouldn't need to explicitly
specify the subclass here.)
It might already be under construction -- the classic example would be
an xsl:variable which uses xsl:call-template as part of its value. To
handle this recursion, we have to start a new RTF DTM, pushing the old
one onto a stack so we can return to it. This is not as uncommon a case
as we might wish, unfortunately, as some folks insist on coding XSLT
as if it were a procedural language...
guard against none-active
Empty each DTM before popping, so it's ready for reuse
_DON'T_ pop the previous, since it's still open (which is why we
stacked up more of these) and did not receive a mark.
Can't replace buf if there was an async close.
Note: This would need to be changed if fill()
is ever made accessible to multiple threads.
But for now, the only way CAS can fail is via close.
Check for closed stream
if not closed but no bytes available, return
Check for closed stream
If no mark position set then don't keep in buffer
Fill in buffer to save bytes for reset
Cause exception if closed
Else retry in case a new buf was CASed in fill()
BasicInternalFrameUI creates an action with the same name, we override
it as Metal frames do not have system menus.
this should be deprecated - jcs
end class MetalPropertyChangeHandler
/ End BorderListener Class
read and discard the repository ID
write the repository ID
Added serialVersionUID to preserve binary compatibility
last entry of localsMap is count of allocated local slots
Create an array to map name indexes to locals indexes.
Create an array to map name indexes to locals indexes.
for counting constant placeholders
insert placeholder in CP and remember the patch
TODO check if aready in the constant pool
The first few bytes:
Make sure the class is initialized; VM might complain.
in place of Opcodes.T_OBJECT
boxing/unboxing handled by caller
nothing to do
type info is already present
type info can be improved
local to write back result
this cast was already performed
This guy gets used more than once.
Expects MethodHandle on the stack and actual receiver MethodHandle in slot #0
Suppress this method in backtraces displayed to the user.
Mark this method as a compiled LambdaForm
Force inlining of this invoker method.
Since LambdaForm is customized for a particular MethodHandle, it's safe to substitute
receiver MethodHandle (at slot #0) with an embedded constant and use it instead.
It enables more efficient code generation in some situations, since embedded constants
are compile-time constants for JIT compiler.
expects MethodHandle on top of the stack
iterate over the form's names, generating bytecode instructions for each
start iterating at the first name following the arguments
unless otherwise modified below
skip MH.invokeBasic of the selectAlternative result
Jump to the end of GWC idiom
no intrinsic associated
should use the static path for these
TODO more to come
Sample classes from each package we are willing to bind to statically:
MethodHandle.class already covered
inner class of some sort
not on BCP
FIXME: switch to supported API once it is added
in java.lang.invoke package
int[].class, for example
FIXME: switch to supported API once it is added
could use VerifyAccess.isClassAccessible but the following is a safe approximation
in order to pass the verifier, we need to convert this to invokevirtual in all cases
Methods from Object declared in an interface can be resolved by JVM to invokevirtual kind.
Need to convert it back to invokeinterface to pass verification and make the invocation works as expected.
Issue a type assertion for the result, so we can avoid casts later.
The array will be a constant.
the array is left on the stack
must have MH argument
must have MH argument
load test result
get 2nd argument of selectAlternative
store the MH in the receiver slot
get 3rd argument of selectAlternative
store the MH in the receiver slot
for now do not bother to merge typestate; just reset to the dominator state
return what's on stack
skip 1st argument: method handle
Check exception's type
load exception class
skip 1st argument: method handle
non-void: actually assign
it doesn't matter what rclass is; the JVM will discard any value
put return value on the stack if it is not already there
generate actual return statement
-   indicates forbidden
<-> indicates implicit
to ----> boolean  byte     short    char     int      long     float    double
from boolean    <->        -        -        -        -        -        -        -
byte        -       <->       i2s      i2c      <->      i2l      i2f      i2d
short       -       i2b       <->      i2c      <->      i2l      i2f      i2d
char        -       i2b       i2s      <->      <->      i2l      i2f      i2d
int         -       i2b       i2s      i2c      <->      i2l      i2f      i2d
long        -     l2i,i2b   l2i,i2s  l2i,i2c    l2i      <->      l2f      l2d
float       -     f2i,i2b   f2i,i2s  f2i,i2c    f2i      f2l      <->      f2d
double      -     d2i,i2b   d2i,i2s  d2i,i2c    d2i      d2l      d2f      <->
no cast required, should be dead code anyway
targets other than int require another conversion
For compatibility with ValueConversions and explicitCastArguments:
sig includes leading argument
Suppress this method in backtraces displayed to the user.
Don't inline the interpreter entry.
create parameter array
fill parameter array
box if primitive type
swap form and array; avoid local variable
Suppress this method in backtraces displayed to the user.
Force inlining of this invoker method.
Load arguments from array
narrow subword from int
Box primitive types
widen subword to int
boolean casts not allowed
If the return type is void we return a null reference.
NOTE: NamedFunction invokers always return a reference value.
javadoc inherited from Throwable.java
SNMP Runtime import
PrincipalImpl() take the current host as entry
Read the file content
overwrite the cache
we need to infer the name
This is used to support read_Object.
orbos 98-01-18: Objects By Value -- begin
TypeCodeFactory interface methods.
Keeping track of type codes by repository id.
To enable read_Object.
To enable read_Object.
To enable read_Object.
Always use our latest ORB version (latest fixes, etc)
NOTE: REMOVE THIS METHOD ONCE WE HAVE A ORT BASED ORBD
NOTE: REMOVE THIS METHOD ONCE WE HAVE A ORT BASED ORBD
End of file.
%%% check syntax too?
number of components
construct an IDREF datatype validator
Check if is valid key-[81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*
Message keys used by the serializer
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The localname is the portion after the optional colon; the message indicates
that there is a problem with that part of the QNAME.
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The prefix is the portion before the optional colon; the message indicates
that there is a problem with that part of the QNAME.
-- This file was mechanically generated: Do not edit! --
Common UI methods
check for potential overflow (see bug 4801285)
loads the resource bundle if necessary
returns the localized string
Just return so toDisplayString() returns the
I *think* I can get away with a shallow clone here?
Adding one here to the stack of frame positions will allow us always
to look one under without having to check if we're at zero.
(As long as the caller doesn't screw up link/unlink.)
Lazy execution of variables.
Lazy execution of variables.
Lazy execution of variables.
Lazy execution of variables.
J2SE does not support Xalan interpretive
Update first and last change indices
Set the state at this index and update all relevant state.
Update minimum and maximum indices
Clear the state at this index and update all relevant state.
Update minimum and maximum indices
The unassigned state.
The unassigned state.
reset to empty
End of file.
If the tileIcon failed loading, paint as gray.
If a tileIcon is set, then it may contain transparent bits
-- This file was mechanically generated: Do not edit! --
--- Methods to support CharSequence ---
create a bootstrap server
REVISIT: see ORBConfigurator. use factory in TransportDefault.
See Bug 4396928 for more information about why we are initializing
the ORBClass to PIORB (now ORBImpl, but should check the bugid).
parse the args and try setting the values for these
orbd is being run the first time
The following two lines start the Persistent NameService
determine the ORB db directory
create the db and the logs directories
create Initial Name Service object
create Repository object
create Locator and Activator objects
start Name Service
if (TypeCodeImpl.debug) System.out.println("Getting tc " + (TypeCodeImpl)typeMap.get(new Integer(position)) +
WrapperInputStream has no enclosure
WrapperInputStream has no enclosure
if (TypeCodeImpl.debug) System.out.println("WrapperInputStream.getTopLevelPosition " +
"returning getPosition " + getPosition() + " - startPos " + startPos +
This is never actually called on a WrapperInputStream, but
exists to satisfy the interface requirement.
Removes the focus.
It was selected and was the last component on the desktop.
In turn calls deiconifyFrame in the desktop manager.
That method will handle the maximization of the frame.
Set the maximized frame as selected.
If the frame was an icon restore it back to an icon.
we must validate the hierarchy to not break the hw/lw mixing
If we are maximized we already have the normal bounds recorded
don't try to re-record them, otherwise we incorrectly set the
normal bounds to maximized state.
The icon is the last frame.
If the frame is to be restored to a maximized state make
sure it still fills the whole desktop.
fix for bug: 4162443
If the frame is not in parent, its icon maybe, check it
we only need to keep track of the currentActive InternalFrame, if any
if not the same frame as the current active
we deactivate the current
Work around for 6635462, see comment in dragFrame()
we must validate the hierarchy to not break the hw/lw mixing
Get the icon for this internal frame and its preferred size
Get the parent bounds and child components.
Iterate through valid default icon locations and return the
first one that does not intersect any other icons.
Get the icon for this component
If this icon intersects the current location, get next location.
Find the JDesktopPane
=========== stuff for faster frame dragging ===================
move the frame
Only initiate cleanup if we have actually done a drag.
We reset the danger field as until now we haven't actually
moved the internal frame so we don't need to initiate repaint.
since we couldn't blit we just redraw as fast as possible
the isDragging mucking is to avoid activating emergency
fake out the repaint manager.  We'll take care of everything
compute the minimal newly exposed area
if the rects intersect then we use computeDifference.  Otherwise
we'll repaint the entire previous bounds
Fix the damage
new areas of blit were exposed
update window if it's non-opaque
XMLReader.java - read an XML document.
Written by David Megginson
NO WARRANTY!  This class is in the Public Domain.
$Id: XMLReader.java,v 1.3 2004/11/03 22:55:32 jsuttor Exp $
---- character constants -----------------------------------
--- character attribute accessors ---------------------------
Level 0 is base level (non-embedded) left-to-right
--- paragraph attribute accessors ----------------------------
PENDING: should this return a default?
--- privates ---------------------------------------------
fix for 6242148 : API method java.awt.BorderLayout.getConstraints(null) should return null
this will call checkClosed() for us
this will call checkClosed() for us
this closes the RandomAccessFile
Empty finalizer: for performance reasons we instead use the
Disposer mechanism for ensuring that the underlying
RandomAccessFile is closed prior to garbage collection
fill in the array
fall through to unsupported
fall through to unsupported
--- richer subclass flavors ----------------------------------------------
--- html flavors ----------------------------------------------------------
--- plain text flavors ----------------------------------------------------
--- string flavorss --------------------------------------------------------
Notes about the class.
Assumptions, the ByteBuffer's position is set by the constructor's
index variable and the ByteBuffer's limit points to the end of the
data. Also, since the index variable tracks the current empty
position in the buffer, the ByteBuffer's position is updated
any time there's a call to this class's position().
Although, a ByteBuffer's length is it's capacity(), the context in
which length is used in this object, this.buflen is actually the
REVISIT - index should eventually be replaced with byteBuffer.position()
Current empty position in buffer.
REVISIT - CHANGE THESE TO PRIVATE
Total length of buffer.  Unnecessary...
How many more bytes are needed on overflow.
Did the overflow operation fragment?
Right now, EncapsOutputStream's do not use pooled byte buffers.
EncapsOutputStream's is the only one that does not use pooled
byte buffers. Hence, the reason for the boolean 'usePooledByteBuffers'.
See EncapsOutputStream for additional information.
print address of ByteBuffer gotten from pool
don't allocate from pool, allocate non-direct ByteBuffer
Shallow copy constructor
So IIOPOutputStream seems more intuitive
accessor to buflen
get position in this buffer
REVISIT - This should be changed to return the
value of byteBuffer.position() rather
than this.index. But, byteBuffer.position
is manipulated via ByteBuffer writes, reads,
gets and puts. These locations need to be
investigated and updated before
byteBuffer.position() can be returned here.
set position in this buffer
REVISIT - This should be changed to set only the
value of byteBuffer.position rather
than this.index. This change should be made
in conjunction with the change to this.position().
mutator to buflen
Grow byteBuffer to a size larger than position() + needed
This code used to live directly in CDROutputStream.grow.
Recall that the byteBuffer size is 'really' the limit or
print address of ByteBuffer just gotten
return 'old' byteBuffer reference to the ByteBuffer pool
print address of ByteBuffer being released
update the byteBuffer with a larger ByteBuffer
limit and buflen must be set to newLength.
for annotation types
Setting this static field introduces an acceptable
initialization dependency on a few java.util classes.
Guard against malicious overrides of Throwable.equals by
using a Set with identity equality semantics.
Print our stack trace
Print suppressed exceptions, if any
Print cause, if any
Compute number of frames in common between this and enclosing trace
Print our stack trace
Print suppressed exceptions, if any
Print cause, if any
Initialize stack trace field with information from
backtrace if this is the first call to this method
Test for out of protocol state
read in all fields
Use the sentinel for a zero-length list
Copy Throwables to new list
Enforce constraints on suppressed exceptions in
case of corrupt or malicious stream.
else a null suppressedExceptions field remains null
Check for the marker of an immutable stack trace
Verify stack trace elements are non-null.
A null stackTrace field in the serial form can result
from an exception serialized without that field in
older JDK releases; treat such exceptions as having
empty stack traces.
Ensure that the stackTrace field is initialized to a
non-null value, if appropriate.  As of JDK 7, a null stack
trace field is a valid value indicating the stack trace
should not be set.
Suppressed exceptions not recorded
Have to use (T)this rather than mbeanInterface.cast(this)
because mbeanInterface might be null.
From the DynamicMBean interface.
From the DynamicMBean interface.
From the DynamicMBean interface.
From the DynamicMBean interface.
From the DynamicMBean interface.
Replace immutableInfo as the underlying MBean/MXBean
could already implement NotificationBroadcaster and
return immutableInfo=true in its MBeanInfo.
Build the custom MBeanConstructorInfo[]
Build the custom MBeanOperationInfo[]
Build the custom MBeanAttributeInfo[]
should not happen
OK: this class doesn't override it
Check for "void cacheMBeanInfo(MBeanInfo)" method.
Check for "MBeanInfo getCachedMBeanInfo()" method.
Check for "MBeanInfo getMBeanInfo()" method.
Check for "MBeanNotificationInfo[] getNotificationInfo()"
This method is taken into account for the MBeanInfo
immutability checks if and only if the given subclass is
StandardEmitterMBean itself or can be assigned to
any frameSize that is not well-defined will
cause that this stream will be read in bytes
we have a weird situation if read(byte[]) returns 0!
make sure we don't read fractions of a frame.
don't try to read beyond our own set length in frames
if we've bytes left from last call to read(),
use them first
copy everything we got from the beginning of the frame
to our pushback buffer
make sure to update our framePos
make sure not to skip fractional frames
don't skip more than our set length in frames.
if no error, update our position.
Throw an IOException if we've skipped a fractional number of frames
don't return greater than our set length in frames
remember the pushback buffer
re-create the pushback buffer
$$fb 2001-07-16: added this method to correctly close the underlying TargetDataLine.
fixes bug 4479984
the line needs to be flushed and stopped to avoid a dead lock...
Probably related to bugs 4417527, 4334868, 4383457
BEGIN: Keys needed for exception messages of  JAXP 1.3 XPath API implementation
END: Keys needed for exception messages of  JAXP 1.3 XPath API implementation
Note to translators:  A relative location path is a form of XPath expression.
The message indicates that such an expression was expected following the
characters '/' or '', but was not found.
Note to translators:  A location path is a form of XPath expression.
The message indicates that syntactically such an expression was expected,but
the characters specified by the substitution text were encountered instead.
Note to translators:  A location path is a form of XPath expression.
The message indicates that syntactically such a subexpression was expected,
but no more characters were found in the expression.
Note to translators:  A location step is part of an XPath expression.
The message indicates that syntactically such an expression was expected
following the specified characters.
Note to translators:  A node test is part of an XPath expression that is
used to test for particular kinds of nodes.  In this case, a node test that
consists of an NCName followed by a colon and an asterisk or that consists
of a QName was expected, but was not found.
Note to translators:  A step pattern is part of an XPath expression.
The message indicates that syntactically such an expression was expected,
but the specified character was found in the expression instead.
Note to translators: A relative path pattern is part of an XPath expression.
The message indicates that syntactically such an expression was expected,
but was not found.
Note to translators:  The substitution text is the name of a data type.  The
message indicates that a value of a particular type could not be converted
to a value of type boolean.
Note to translators: Do not translate ANY_UNORDERED_NODE_TYPE and
Note to translators: Do not translate UNORDERED_NODE_SNAPSHOT_TYPE and
Note to translators: This message indicates that the document being operated
upon changed, so the iterator object that was being used to traverse the
document has now become invalid.
Note to translators:  The substitution text is the name of a data type.  The
message indicates that a value of a particular type could not be converted
to a value of type string.
Note to translators: Do not translate snapshotItem,
UNORDERED_NODE_SNAPSHOT_TYPE and ORDERED_NODE_SNAPSHOT_TYPE.
Note to translators:  XPathEvaluator is a Java interface name.  An
XPathEvaluator is created with respect to a particular XML document, and in
this case the expression represented by this object was being evaluated with
respect to a context node from a different document.
Note to translators:  The XPath expression cannot be evaluated with respect
to this type of node.
BEGIN:  Definitions of error keys used  in exception messages of  JAXP 1.3 XPath API implementation
END:  Definitions of error keys used  in exception messages of  JAXP 1.3 XPath API implementation
Other miscellaneous text used inside the code...
================= INFRASTRUCTURE ======================
These maps are used for all stylesheets
These maps are used for some stylesheets
The null-namespace cannot be excluded
Create a new map of exlcuded URIs if none exists
Register the namespace URI
-- This file was mechanically generated: Do not edit! --
these declarations are here as documentation
Initialization is incomplete
Register built-in Chronologies
Register Chronologies from the ServiceLoader
Log the attempt to replace an existing Chronology
finally, register IsoChronology to mark initialization is complete
Not pre-defined; lookup by the type
If not found, do the initialization (once) and repeat the lookup
Look for a Chronology using ServiceLoader of the Thread's ContextClassLoader
Application provided Chronologies must not be cached
If not found, do the initialization (once) and repeat the lookup
Look for a Chronology using ServiceLoader of the Thread's ContextClassLoader
Application provided Chronologies must not be cached
/ Add in Chronologies from the ServiceLoader configuration
check epoch-day before inventing era
fix proleptic month before inventing era
invent era if necessary to resolve year-of-era
first day-of-month is likely to be safest for setting proleptic-month
cannot add to year zero, as not all chronologies have a year zero
do not invent era if strict
reinstate the field removed earlier, no cross-check issues
smart is same as strict
check first for better error message
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of MenuItemPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of MenuItemPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
Type check all the predicates (e -> position() = e)
Analyze context cases
Create an instance of Step to do the translation
Need to allow for long jumps here
Need to allow for long jumps here
context node is on the stack
Need to allow for long jumps here
Push current node on the stack
Overwrite current node with matching node
If pattern not reduced then check kernel
Compile the expressions within the predicates
Backpatch true list and restore current iterator/node
Backpatch false list and restore current iterator/node
True list falls through
Store matching node into a local variable
If pattern not reduced then check kernel
Push current iterator and current node on the stack
Create a new matching iterator using the matching node
Backwards branches are prohibited if an uninitialized object is
on the stack by section 4.9.4 of the JVM Specification, 2nd Ed.
We don't know whether this code might contain backwards branches,
so we mustn't create the new object until after we've created
the suspect arguments to its constructor.  Instead we calculate
the values of the arguments to the constructor first, store them
in temporary variables, create the object and reload the
arguments from the temporaries to avoid the problem.
Get the parent of the matching node
Start the iterator with the parent
Overwrite current iterator and current node
Translate the expression of the predicate
Backpatch true list and restore current iterator/node
Backpatch false list and restore current iterator/node
True list falls through
Store node on the stack into a local variable
Create a new local to store the iterator
Add a new private field if this is the main class
Compile the step created at type checking time
If in the main class update the field too
If class is not external, start of range for iter variable was
Get the parent of the node on the stack
Initialize the iterator with the parent
true list falls through
read and discard the repository ID
write the repository ID
not predicate => ContextNode == CurrentNode
skip the id, we already checked it
Clone the list with a deep copy
Just one chunk
none of the attributes are required
Clip if necessary and get the data in thumbData
approx. every 5%
All others write as separate JFXX segments
Just the header without any thumbnail
We never write a palette image into the header
So if it's the only one, we need to write the header first
Expand to RGB
Handles clipping if needed
As part of the header
If this is the only one, write the header first
Handles clipping if needed
As part of the header
If this is the only one, write the header first
Handles clipping if needed
Could put reason codes in here to be parsed in writeJFXXSegment
in order to provide more meaningful warnings.
skip the id, we already checked it
following constructors handle bufAvail
Now the child
Should never happen
Save the thumbnail pos when reading
Save the stream position for reading the thumbnail later
Now skip the thumbnail data
not used when writing
width and height
read the palette
width and height
Write the palette (must be 768 bytes)
Compressed image data, for writing
Compute the final stream position
Set the stream back to the start of the thumbnail
and read its metadata (but don't decode the image)
Set the stream to the computed final position
Clear the now invalid buffer
get default metadata for the thumb
Remove the jfif segment, which should be there.
Now check that the size is OK
approx. every 5%
spec says it's null-terminated
Null-terminate the string
The complete profile when it's fully read
May remain null when writing
gets whole segment or fills the buffer
Skip the id
get the chunk number
get the total number of chunks
if there are no more chunks, set up the data
reduce the stored length by the two chunk numbering bytes
If we store them away, include the chunk numbering bytes
Now reduce the stored length by the
two chunk numbering bytes
May be null
skip the tag
Get the length, but not in length
Don't include length itself
skip the id
Skip the id
get the chunk number
get the number of chunks, which should match
create an array for the whole thing
copy the existing chunks, releasing them
Note that they may be out of order
defensive to fix a bug that Sanjiva reported.
defensive to fix a bug that Sanjiva reported.
Duplicate, suppress insert
This needs to do a binary search, but a binary search
is somewhat tough because the sequence test involves
Duplicate, suppress insert
end addNodeInDocOrder(Vector v, Object obj)
end addNodeInDocOrder(Vector v, Object obj)
HACK: I think this is a bit of a hack.  -sb
used to indicate what triggered the call
REVISIT: write description of these fields
fNamespace == null
If the proxy class defined by the given loader implementing
otherwise, it will create the proxy class via the ProxyClassFactory
the most frequent
prefix for all proxy class names
next number to use for generation of unique proxy class names
package to define proxy class in
if no non-public proxy interfaces, use com.sun.proxy package
do permission check if the caller is in a different runtime package
of the proxy class
Methods from Node
Siblings, can be null.
N.B.: O.K. if refChild == null
insertBefore will increment numChildren
Methods from Element
Name must be valid unicode chars
If we get here, the attribute doesn't exist
Methods from NodeList
Start of dummy methods for DOM L3.
End of dummy methods for DOM L3.
REVISIT - these needs to be an interface-based impl.
End of file.
anySimpleType doesn't allow any facet, not even whiteSpace
These message should be read from a locale-specific resource bundle
Make BoxLayout recalculate cached preferred sizes
for backwards compatibility --
createLoginContext is deprecated in favor of createLoginContext.*
for backwards compatibility --
createLoginContext is deprecated in favor of createLoginContext.*
TODO: how should we handle system id here?
Cache of the most-recently-returned charsets,
along with the names that were used to find them
"Level 1" cache
"Level 2" cache
Creates an iterator that walks over the available providers, ignoring
those whose lookup or instantiation causes a security exception to be
thrown.  Should be invoked with full privileges.
Ignore security exceptions
Thread-local gate to prevent recursive provider lookups
The runtime startup sequence looks up standard charsets as a
consequence of the VM's invocation of System.initializeSystemClass
in order to, e.g., set system properties and encode filenames.  At
that point the application class loader has not been initialized,
however, so we can't look for providers because doing so will cause
that loader to be prematurely initialized with incomplete
Avoid recursive provider lookups
returns ExtendedProvider, if installed
Extended charsets not available
(charsets.jar not present)
We expect most programs to use one Charset repeatedly.
We convey a hint to this effect to the VM by putting the
level 1 cache miss code in a separate method.
Fold charsets from the given iterator into the given map, ignoring
charsets whose names already have entries in the map.
tickles a bug in oldjavac
tickles a bug in oldjavac
for the latest specification of Unicode Blocks.
0000..007F; Basic Latin
0080..00FF; Latin-1 Supplement
0100..017F; Latin Extended-A
0180..024F; Latin Extended-B
0250..02AF; IPA Extensions
02B0..02FF; Spacing Modifier Letters
0300..036F; Combining Diacritical Marks
0370..03FF; Greek and Coptic
0500..052F; Cyrillic Supplement
0750..077F; Arabic Supplement
08A0..08FF; Arabic Extended-A
1100..11FF; Hangul Jamo
1380..139F; Ethiopic Supplement
1400..167F; Unified Canadian Aboriginal Syllabics
18B0..18FF; Unified Canadian Aboriginal Syllabics Extended
1950..197F; Tai Le
1980..19DF; New Tai Lue
19E0..19FF; Khmer Symbols
1A20..1AAF; Tai Tham
1C50..1C7F; Ol Chiki
1CC0..1CCF; Sundanese Supplement
1CD0..1CFF; Vedic Extensions
1D00..1D7F; Phonetic Extensions
1D80..1DBF; Phonetic Extensions Supplement
1DC0..1DFF; Combining Diacritical Marks Supplement
1E00..1EFF; Latin Extended Additional
1F00..1FFF; Greek Extended
2000..206F; General Punctuation
2070..209F; Superscripts and Subscripts
20A0..20CF; Currency Symbols
20D0..20FF; Combining Diacritical Marks for Symbols
2100..214F; Letterlike Symbols
2150..218F; Number Forms
2200..22FF; Mathematical Operators
2300..23FF; Miscellaneous Technical
2400..243F; Control Pictures
2440..245F; Optical Character Recognition
2460..24FF; Enclosed Alphanumerics
2500..257F; Box Drawing
2580..259F; Block Elements
25A0..25FF; Geometric Shapes
2600..26FF; Miscellaneous Symbols
27C0..27EF; Miscellaneous Mathematical Symbols-A
27F0..27FF; Supplemental Arrows-A
2800..28FF; Braille Patterns
2900..297F; Supplemental Arrows-B
2980..29FF; Miscellaneous Mathematical Symbols-B
2A00..2AFF; Supplemental Mathematical Operators
2B00..2BFF; Miscellaneous Symbols and Arrows
2C60..2C7F; Latin Extended-C
2D00..2D2F; Georgian Supplement
2D80..2DDF; Ethiopic Extended
2DE0..2DFF; Cyrillic Extended-A
2E00..2E7F; Supplemental Punctuation
2E80..2EFF; CJK Radicals Supplement
2F00..2FDF; Kangxi Radicals
2FF0..2FFF; Ideographic Description Characters
3000..303F; CJK Symbols and Punctuation
3130..318F; Hangul Compatibility Jamo
31A0..31BF; Bopomofo Extended
31C0..31EF; CJK Strokes
31F0..31FF; Katakana Phonetic Extensions
3200..32FF; Enclosed CJK Letters and Months
3300..33FF; CJK Compatibility
3400..4DBF; CJK Unified Ideographs Extension A
4DC0..4DFF; Yijing Hexagram Symbols
4E00..9FFF; CJK Unified Ideographs
A000..A48F; Yi Syllables
A490..A4CF; Yi Radicals
A640..A69F; Cyrillic Extended-B
A700..A71F; Modifier Tone Letters
A720..A7FF; Latin Extended-D
A800..A82F; Syloti Nagri
A830..A83F; Common Indic Number Forms
A8E0..A8FF; Devanagari Extended
A900..A92F; Kayah Li
A960..A97F; Hangul Jamo Extended-A
AA60..AA7F; Myanmar Extended-A
AA80..AADF; Tai Viet
AAE0..AAFF; Meetei Mayek Extensions
AB00..AB2F; Ethiopic Extended-A
ABC0..ABFF; Meetei Mayek
AC00..D7AF; Hangul Syllables
D7B0..D7FF; Hangul Jamo Extended-B
D800..DB7F; High Surrogates
DB80..DBFF; High Private Use Surrogates
DC00..DFFF; Low Surrogates
E000..F8FF; Private Use Area
F900..FAFF; CJK Compatibility Ideographs
FB00..FB4F; Alphabetic Presentation Forms
FB50..FDFF; Arabic Presentation Forms-A
FE00..FE0F; Variation Selectors
FE10..FE1F; Vertical Forms
FE20..FE2F; Combining Half Marks
FE30..FE4F; CJK Compatibility Forms
FE50..FE6F; Small Form Variants
FE70..FEFF; Arabic Presentation Forms-B
FF00..FFEF; Halfwidth and Fullwidth Forms
10000..1007F; Linear B Syllabary
10080..100FF; Linear B Ideograms
10100..1013F; Aegean Numbers
10140..1018F; Ancient Greek Numbers
10190..101CF; Ancient Symbols
101D0..101FF; Phaistos Disc
10300..1032F; Old Italic
103A0..103DF; Old Persian
10800..1083F; Cypriot Syllabary
10840..1085F; Imperial Aramaic
10980..1099F; Meroitic Hieroglyphs
109A0..109FF; Meroitic Cursive
10A60..10A7F; Old South Arabian
10B40..10B5F; Inscriptional Parthian
10B60..10B7F; Inscriptional Pahlavi
10C00..10C4F; Old Turkic
10E60..10E7F; Rumi Numeral Symbols
110D0..110FF; Sora Sompeng
12400..1247F; Cuneiform Numbers and Punctuation
13000..1342F; Egyptian Hieroglyphs
16800..16A3F; Bamum Supplement
1B000..1B0FF; Kana Supplement
1D000..1D0FF; Byzantine Musical Symbols
1D100..1D1FF; Musical Symbols
1D200..1D24F; Ancient Greek Musical Notation
1D300..1D35F; Tai Xuan Jing Symbols
1D360..1D37F; Counting Rod Numerals
1D400..1D7FF; Mathematical Alphanumeric Symbols
1EE00..1EEFF; Arabic Mathematical Alphabetic Symbols
1F000..1F02F; Mahjong Tiles
1F030..1F09F; Domino Tiles
1F0A0..1F0FF; Playing Cards
1F100..1F1FF; Enclosed Alphanumeric Supplement
1F200..1F2FF; Enclosed Ideographic Supplement
1F300..1F5FF; Miscellaneous Symbols And Pictographs
1F680..1F6FF; Transport And Map Symbols
1F700..1F77F; Alchemical Symbols
20000..2A6DF; CJK Unified Ideographs Extension B
2A700..2B73F; CJK Unified Ideographs Extension C
2B740..2B81F; CJK Unified Ideographs Extension D
2F800..2FA1F; CJK Compatibility Ideographs Supplement
E0100..E01EF; Variation Selectors Supplement
F0000..FFFFF; Supplementary Private Use Area-A
100000..10FFFF; Supplementary Private Use Area-B
invariant: top > current >= bottom && codePoint >= unicodeBlockStarts[bottom]
it appears we don't have the KATAKANA_OR_HIRAGANA
leave SURROGATE and PRIVATE_USE for table lookup
Optimized form of:
codePoint >= MIN_CODE_POINT && codePoint <= MAX_CODE_POINT
Optimized form of:
codePoint >= MIN_VALUE && codePoint <= MAX_VALUE
We consistently use logical shift (>>>) to facilitate
additional runtime optimizations.
Help VM constant-fold; MAX_HIGH_SURROGATE + 1 == MIN_LOW_SURROGATE
Optimized form of:
return ((high - MIN_HIGH_SURROGATE) << 10)
+ (low - MIN_LOW_SURROGATE)
throws ArrayIndexOutOfBoundsException if index out of bounds
throws ArrayIndexOutOfBoundsException if index-1 out of bounds
We write elements "backwards" to guarantee all-or-nothing
Optimized form of:
(codePoint >= 0x00 && codePoint <= 0x1F) ||
As of Unicode 6.0, 1:M uppercasings only happen in the BMP.
should never come here
Uses protected field.
we don't allow instantiation
no return keep working
if the document element has no xmlns definition, we add xmlns=""
we iterate over all siblings of the context node because eventually,
the text is "polluted" with pi's or comments
Continue searching to find duplicates
no child, this node is done.
close node processing, get sibling
no more siblings, get parent, all children
of parent are processed.
close parent node processing (processed node now)
no child, this node is done.
close node processing, get sibling
no more siblings, get parent, all children
of parent are processed.
close parent node processing (processed node now)
Copyright (c) 1995-96 by Cisco Systems, Inc.
ASN1 Type definitions.
do not fallback if given classloader can't find the class, throw exception
nothing to write
_REVISIT_ As soon as the java-rtf adds digits and scale parameters to
OutputStream, this check will be unnecessary
Unspecified for Java
Nothing to read
_REVISIT_ As soon as the java-rtf adds digits and scale parameters to
InputStream, this check will be unnecessary
Unspecified for Java
1.1 has no fragment header and so no request_id
Shared focus engine logger
Toolkit must be fully initialized, otherwise
_clearGlobalFocusOwner will crash or throw an exception
Check to see if key already maps to another traversal
Okay to return Set directly because it is an unmodifiable view
ATTN: component has a strong reference to window via chain
of Component.parent fields.  Since WeakHasMap refers to its
values strongly, we need to break the strong link from the
value (component) back to its key (window).
Also clear temporary lost component stored in Window
Not a duplicate request
Focus transfers from a lightweight child back to the
heavyweight Container should be treated like lightweight
'heavyweight' owns the native focus and there are no pending
requests. 'heavyweight' must be a Container and
'descendant' must not be the focus owner. Otherwise,
we would never have gotten this far.
Focus transfers from a lightweight child back to the
heavyweight Container should be treated like lightweight
'heavyweight' owns the native focus and there are no pending
requests. 'heavyweight' must be a Container and
'descendant' must not be the focus owner. Otherwise,
we would never have gotten this far.
Fix 5028014. Rolled out.
Fix 5028014. Rolled out.
'heavyweight' doesn't have the native focus right now, but
if all pending requests were completed, it would. Add
descendant to the heavyweight's list of pending
lightweight focus transfers.
For purposes of computing oldFocusedWindow, we should look at
the second to last HeavyweightFocusRequest on the queue iff the
last HeavyweightFocusRequest is CLEAR_GLOBAL_FOCUS_OWNER. If
there is no second to last HeavyweightFocusRequest, null is an
need to call this out of synchronized block to avoid possible deadlock
The current app context differs from the app context of a focus
owner (and all pending lightweight requests), so we do nothing
now and wait for a next event.
Any other case represents a failure condition which we did
not expect. We need to clearFocusRequestList() and patch up
the event as best as possible.
if source w/o peer and
if source is equal to first lightweight
then we should correct source and nativeSource
source is heavuweight itself
Focus change as a result of a known call to requestFocus(),
or known click on a peer focusable heavyweight Component.
'opposite' will be fixed by
Special case for FOCUS_GAINED in top-levels
If it arrives as the result of activation we should skip it
This event will not have appropriate request record and
on arrival there will be already some focus owner set.
Call to KeyboardFocusManager.clearGlobalFocusOwner()
Otherwise, fall through to failure case below
Focus leaving application
Focus change as a result of a known call to requestFocus(),
or click on a peer focusable heavyweight Component.
If a focus transfer is made across top-levels, then the
FOCUS_LOST event is always temporary, and the FOCUS_GAINED
event is always permanent. Otherwise, the stored temporary
value is honored.
If top-level changed there might be no focus request in a list
But we know the opposite, we now it is temporary - dispatch the event.
Create copy of the event with only difference in temporary parameter.
Fix for 4799136 - clear type-ahead markers if requests queue is empty
We do it here because this method is called only when problems happen
Fix for 4799136 - clear type-ahead markers if requests queue is empty
We do it here because this method is called only when problems happen
Accessor to private field isProxyActive of KeyEvent
Returns the value of this KeyEvent's field isProxyActive
Checks if this KeyboardFocusManager instance is the current KFM,
or otherwise checks if the calling thread has "replaceKeyboardFocusManager"
permission. Here's the reasoning to do so:
A system KFM instance (which is the current KFM by default) may have no
"replaceKFM" permission when a client code is on the call stack beneath,
but still it should be able to execute the methods protected by this check
due to the system KFM is trusted (and so it does like "privileged").
If this KFM instance is not the current KFM but the client code has all
permissions we can't throw SecurityException because it would contradict
the security concepts. In this case the trusted client code is responsible
for calling the secured methods from KFM instance which is not current.
These message should be read from a locale-specific resource bundle
add new namespace context
search for new namespace bindings
when it's of form xmlns="..." or xmlns:prefix="...",
it's a namespace declaration. but prefix:xmlns="..." isn't.
get the internalized value of this attribute
1. "xmlns" can't be bound to any namespace
2. the namespace for "xmlns" can't be bound to any prefix
3. "xml" can't be bound to any other namespace than it's own
4. the namespace for "xml" can't be bound to any other prefix
We should only report an error if there is a prefix,
that is, the local part is not "xmlns". -SG
declare prefix in context
bind the element
bind the attributes
verify that duplicate attributes don't exist
Example: <foo xmlns:a='NS' xmlns:b='NS' a:attr='v1' b:attr='v2'/>
default is false
default is no timeout
default is no limit
default is no limit
default fetch direction
could be transient?
allocate the listeners collection
cmd equal to null or
cmd with length 0 (implies url =="")
are not independent events.
"unbind" any parameters from any previous command.
Changed the condition checking to the below as there were two
conditions that had to be checked
1. RowSet is TYPE_FORWARD_ONLY and direction is not FETCH_FORWARD
2. Direction is not one of the valid values
Added the following code to throw a
SQL Exception if the fetchDir is not
set properly.Bug id:4914155
This checking is not necessary!
Added this checking as maxRows can be 0 when this function is called
maxRows = 0 means rowset can hold any number of rows, os this checking
is needed to take care of this condition.
setter methods for setting the parameters in a <code>RowSet</code> object's command
The parameters may be set in random order
but all must be set, check to verify all
have been set till the last parameter
else throw exception.
Gets the parser configuration. We'll create and initialize a new one, if we
haven't created one before or if the previous one was garbage collected.
If settings have changed on the component manager, refresh the error handler and entity resolver.
prepare for parse
add message formatters
Default Implementation of the Interface
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
End of class AbstractTableModel
check data parameter
ok, no fraction of millisecond
ok, divides into one second without remainder
true if a custom (not AUTH_POLICY) system-wide policy object is set
all non-null policy objects are assumed to be custom
check if custom policy has been set using auth.policy.provider prop
Copyright (c) 1995-96 by Cisco Systems, Inc.
These are predefined values for SNMP V2 variables
FindBugs will issue a warning here, because super.clone()
is not called. But this is actually OK because we construct
a brand new object.
just parse the element.
this flag is set to true after EOF has reached for
get flag first, we need check EFS.
get the entry name and create the ZipEntry first
Force to use UTF-8 if the EFS bit is ON, even the cs is NOT UTF-8
now get the remaining fields for the entry
no EXTSIG present
no EXTSIG present
Need to break the association w/ original kids
if we have an owner, ownerNode is our parent, otherwise it's
our ownerDocument and we don't have a parent
if we have an owner, ownerNode is our parent, otherwise it's
our ownerDocument and we don't have a parent
if we are the firstChild, previousSibling actually refers to our
parent's lastChild, but we hide that
if we are the firstChild, previousSibling actually refers to our
parent's lastChild, but we hide that
Stub class generated by rmic, do not edit.
Contents subject to change without notice.
methods from remote interfaces
implementation of addNotificationListener(ObjectName, ObjectName, MarshalledObject, MarshalledObject, Subject)
implementation of addNotificationListeners(ObjectName[], MarshalledObject[], Subject[])
implementation of close()
implementation of createMBean(String, ObjectName, MarshalledObject, String[], Subject)
implementation of createMBean(String, ObjectName, ObjectName, MarshalledObject, String[], Subject)
implementation of createMBean(String, ObjectName, ObjectName, Subject)
implementation of createMBean(String, ObjectName, Subject)
implementation of fetchNotifications(long, int, long)
implementation of getAttribute(ObjectName, String, Subject)
implementation of getAttributes(ObjectName, String[], Subject)
implementation of getConnectionId()
implementation of getDefaultDomain(Subject)
implementation of getDomains(Subject)
implementation of getMBeanCount(Subject)
implementation of getMBeanInfo(ObjectName, Subject)
implementation of getObjectInstance(ObjectName, Subject)
implementation of invoke(ObjectName, String, MarshalledObject, String[], Subject)
implementation of isInstanceOf(ObjectName, String, Subject)
implementation of isRegistered(ObjectName, Subject)
implementation of queryMBeans(ObjectName, MarshalledObject, Subject)
implementation of queryNames(ObjectName, MarshalledObject, Subject)
implementation of removeNotificationListener(ObjectName, ObjectName, MarshalledObject, MarshalledObject, Subject)
implementation of removeNotificationListener(ObjectName, ObjectName, Subject)
implementation of removeNotificationListeners(ObjectName, Integer[], Subject)
implementation of setAttribute(ObjectName, MarshalledObject, Subject)
implementation of setAttributes(ObjectName, MarshalledObject, Subject)
implementation of unregisterMBean(ObjectName, Subject)
General shape-based node creation methods
Reference-based node methods
Parallel evaluation of pipelines to nodes
Parallel flattening of nodes
Avoid creation of special accessor
Avoid creation of special accessor
Avoid creation of special accessor
The Node count will be required when the Node spliterator is
obtained and it is cheaper to aggressively calculate bottom up
as the tree is built rather than later on from the top down
traversing the tree
Cast to int is safe since it is the callers responsibility to
ensure that there is sufficient room in the array
Cast to int is safe since it is the callers responsibility to
ensure that there is sufficient room in the array
Node we are pointing to
null if full traversal has occurred
next child of curNode to consume
The spliterator of the curNode if that node is last and has no children.
This spliterator will be delegated to for splitting and traversing.
null if curNode has children
spliterator used while traversing with tryAdvance
null if no partial traversal has occurred
node stack used when traversing to search and find leaf nodes
null if no partial traversal has occurred
Bias size to the case where leaf nodes are close to this node
8 is the minimum initial capacity for the ArrayDeque implementation
Initiate the node stack
A non-empty leaf node was not found
No elements to traverse
Cannot split if fully or partially traversed
Will not reflect the effects of partial traversal.
This is compliant with the specification
Advance to the spliterator of the next non-empty leaf node
Since the node is not-empty the spliterator can be advanced
No more elements to traverse
Advance to the spliterator of the next non-empty leaf node
Since the node is not-empty the spliterator can be advanced
No more elements to traverse
Avoid creation of special accessor
Avoid creation of special accessor
Avoid creation of special accessor
Avoid creation of special accessor
For Sink implementation
Casts to int are safe since absolute size is verified to be within
bounds when the root concrete SizedCollectorTask is constructed
with the shared array
Called by subclass
CatalogReader.java - An interface for reading catalog files
Node name, followed by description
Node name + "/" + AttributeName, followed by description
/** True if the nodes will be found in document order */
Catching the filtered list here is only OK because
FilterExprWalker#isDocOrdered() did the right thing.
* NEEDSDOC Method canBeWalkedInNaturalDocOrder
* NEEDSDOC (canBeWalkedInNaturalDocOrder) @return
if (null != m_firstWalker)
for(int i = 0; null != walker; i++)
boolean isSimpleDownAxis = ((axis == Axis.CHILD)
|| (axis == Axis.SELF)
Catching the filtered list here is only OK because
FilterExprWalker#isDocOrdered() did the right thing.
if(isSimpleDownAxis || (axis == -1))
if(walker.isDocOrdered() && (axis == Axis.DESCENDANT ||
axis == Axis.DESCENDANTORSELF || axis == Axis.DESCENDANTSFROMROOT
|| axis == Axis.DESCENDANTSORSELFFROMROOT) || (axis == Axis.ATTRIBUTE))
System.out.println("Setting natural doc order to false: "+
-- This file was mechanically generated: Do not edit! --
An initial `=' indicates a magic Windows variable name -- OK
We can't use String.compareToIgnoreCase since it
canonicalizes to lower case, while Windows
canonicalizes to upper case!  For example, "_" should
sort *after* "Z", not before.
No overflow because of numeric promotion
Allow `=' as first char in name, e.g. =C:=C:\DIR
An initial `=' indicates a magic Windows variable name -- OK
Ignore corrupted environment strings.
Only for use by System.getenv(String)
The original implementation used a native call to _wgetenv,
but it turns out that _wgetenv is only consistent with
GetEnvironmentStringsW (for non-ASCII) if `wmain' is used
instead of `main', even in a process created using
CREATE_UNICODE_ENVIRONMENT.  Instead we perform the
case-insensitive comparison ourselves.  At least this
guarantees that System.getenv().get(String) will be
consistent with System.getenv(String).
Only for use by System.getenv()
Only for use by ProcessBuilder.environment()
Only for use by ProcessBuilder.environment(String[] envp)
Only for use by ProcessImpl.start()
Sort Unicode-case-insensitively by name
Some versions of MSVCRT.DLL require SystemRoot to be set.
So, we make sure that it is always set, even if not provided
by the caller.
Not set, so add it here
Got to end of list and still not found
Environment was empty and SystemRoot not set in parent
Block is double NUL terminated
add the environment variable to the child, if it exists in parent
Log wrapper class for Sun private system exceptions in group NAMING
Generated by MC.java version 1.0, DO NOT EDIT BY HAND!
Generated from input file c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/corba/src/share/classes/com/sun/corba/se/spi/logging/data/Naming.mc on Fri Jul 21 21:58:44 PDT 2017
REVISIT - only used on sendCancelRequest.
Used in SharedCDR (i.e., must be grow).
Used in msgtypes test.
Used on sendCancelRequest.
Used for needs addressing mode.
Header should only be in message mediator.
Another possibility: merge header and message mediator.
REVISIT - make protected once all encoding together
Update the GIOP MessageHeader size field.
return new XIIOPInputStream(orb(), getByteBuffer(), getIndex(),
REVISIT - only set when doing sendCancelRequest.
XREVISIT - If CDROutputObject doesn't live in the iiop
package, it will need this, here, to give package access
REVISIT - make protected once all encoding together
REVISIT - make protected once all encoding together
If the connection doesn't have its negotiated
code sets by now, fall back on the defaults defined
If the connection doesn't have its negotiated
code sets by now, we have to throw an exception.
See CORBA formal 00-11-03 13.9.2.6.
For GIOP 1.2, we can put byte order markers if we want to, and
use the default of big endian otherwise.  (See issue 3405b)
For GIOP 1.1, we don't use BOMs and use the endianness of
In the normal case, let the converter system handle it
If we're local and don't have a Connection, use the
local code sets, otherwise get them from the connection.
If the connection doesn't have negotiated code sets
yet, then we use ISO8859-1 for char/string and wchar/wstring
End of file.
A Vector of XPointerParts
The current XPointerPart
Has the fXPointerPart resolved successfully
The XPointer Error reporter
The XPointer Error Handler
XPointerFramework symbol table
Has the XPointer resolved the subresource
Fixup xml:base and xml:lang attributes
fErrorReporter = errorReporter;  The XInclude ErrorReporter
Implementation of the XPointerProcessor interface.
scan the XPointer expression
The shortHand name
Retreive the local name and prefix to form the scheme name
The next character should be an open parenthesis
can not have more than one ShortHand Pointer
followed by zero or more ( and  the schemeData
followed by the same number of )
check if the number of open parenthesis are equal to the number of close parenthesis
Perform scheme specific parsing of the pointer part
If an exception occurs while parsing the element() scheme expression
ignore it and move on to the next pointer part
Re-throw the XPointer element() scheme syntax error.
The result of the first pointer part whose evaluation identifies
one or more subresources is reported by the XPointer processor as the
result of the pointer as a whole, and evaluation stops.
In our implementation, typically the first xpointer scheme that
matches an element is the document is considered.
If the pointer part resolved then use it, else search for the fragment
using next pointer part from lef-right.
for each element, attempt to resolve it against each pointer part
in the XPointer expression until a matching element is found.
Current token position
invalid XML character
one of "\t\n\r " (0x09, 0x0A, 0x0D, 0x20)
'0'-'9' (0x30 to 0x39)
'A'-'Z' or 'a'-'z' (0x41 to 0x5A and 0x61 to 0x7A)
Non-ASCII Unicode codepoint (>= 0x80)
save pool and tokens
[1]    Pointer      ::=    Shorthand | SchemeBased
[2]    Shorthand    ::=    NCName
[3]    SchemeBased  ::=    PointerPart (S? PointerPart)*
[4]    PointerPart  ::=    SchemeName '(' SchemeData ')'
[5]    SchemeName   ::=    QName
[6]    SchemeData   ::=    EscapedData*
[7]    EscapedData  ::=    NormalChar | '^(' | '^)' | '^^' | '(' SchemeData ')'
[8]    NormalChar   ::=    UnicodeChar - [()^]
[9]    UnicodeChar  ::=    [#x0-#x10FFFF]
[?]    QName        ::=    (NCName ':')? NCName
[?]    NCName       ::=    (Letter | '_') (NCNameChar)*
[?]    NCNameChar   ::=    Letter | Digit | '.' | '-' | '_'  (ascii subset of 'NCNameChar')
[?]    Letter       ::=    [A-Za-z]                              (ascii subset of 'Letter')
[?]    Digit        ::=    [0-9]                                  (ascii subset of 'Digit')
Scanning SchemeName | Shorthand
The name is a QName => a SchemeName
NCName => Shorthand
reset open/close paren for the next pointer part
reset open/close paren for the next pointer part
Should we throw an exception with a more suitable message instead??
Overridden XMLDocumentHandler methods
xml:base and xml:lang processing
set the context invalid if the element till an element from the result infoset is included
xml:base and xml:lang processing
no need to restore restoreBaseURI() for xml:base and xml:lang processing
set the context invalid if the element till an element from the result infoset is included
no need to restore restoreBaseURI() for xml:base and xml:lang processing
Overridden XMLComponent methods
As the javadoc states, this class maintains a mapping between
a CSS selector (such as p.bar) and a Style.
This consists of a number of parts:
. Each selector is broken down into its constituent simple selectors,
and stored in an inverted graph, for example:
results in the graph:
each node (an instance of SelectorMapping) has an associated
specificity and potentially a Style.
. Every rule that is asked for (either by way of getRule(String) or
getRule(HTML.Tag, Element)) results in a unique instance of
ResolvedStyle. ResolvedStyles contain the AttributeSets from the
. When a new rule is created it is inserted into the graph, and
the AttributeSets of each ResolvedStyles are updated appropriately.
. This class creates special AttributeSets, LargeConversionSet and
SmallConversionSet, that maintain a mapping between StyleConstants
and CSS so that developers that wish to use the StyleConstants
methods can do so.
. When one of the AttributeSets is mutated by way of a
StyleConstants key, all the associated CSS keys are removed. This is
done so that the two representations don't get out of sync. For
example, if the developer adds StyleConsants.BOLD, FALSE to an
AttributeSet that contains HTML.Tag.B, the HTML.Tag.B entry will
Build an array of all the parent elements.
Build a fully qualified selector.
>= 1 as the HTML.Tag for the 0th element is passed in.
For leafs, we use the second tier attributes.
tweaks to control display properties
The following is used to import style sheets.
on error we simply have no styles... the html
will look mighty wrong but still function.
---- Conversion functionality ---------------------------------
supers constructor will call this before returning,
and we need to make sure CSS is non null.
PENDING: Should really be doing something similar to
removeHTMLTags here, but it is rather expensive to have to
known to be converted.
in most cases, there are no StyleConstants attributes
so we iterate the collection of keys to avoid creating
a new set.
we really need to do a conversion, iterate again
building a new set.
convert the StyleConstants attribute if possible
---- Resource handling ----------------------------------------
Notice how the rule is first created, and it not part of
the synchronized block. It is done like this as creating
a new rule will fire a ChangeEvent. We do not want to be
holding the lock when calling to other objects, it can
result in deadlock.
The following gaggle of methods is used in maintaining the rules from
It was fine.
Remove last space.
NOTE: This is not synchronized, and the caller of this does
not synchronize. There is the chance for one of the callers to
overwrite the existing resolved parent, but it is quite rare.
The reason this is left like this is because setResolveParent
will fire a ChangeEvent. It is really, REALLY bad for us to
hold a lock when calling outside of us, it may cause a deadlock.
Avoid desending the same mapping twice.
Determine all the Styles that are appropriate, placing them
Create a new Style that will delegate to all the matching
Get the AttributeSet from linked style sheets.
Build three arrays, one for tags, one for class's, and one for
For leafs, we use the second tier attributes.
Will contain the tags, ids, and classes, in that order.
Create the tag, id, and class arrays.
A set of temporary variables that can be used in whatever way.
PENDING(prinz) implement real rendering... which would
do full set of border and background capabilities.
BevelBorder does not support border width
Bitmask, used to indicate what margins are relative:
bit 0 for top, 1 for bottom, 2 for left and 3 for right.
Only draw something if the View is a list item. This won't
be the case for comments.
deside on what side draw bullets, etc.
How the list indicator is aligned is not specified, it is
left up to the UA. IE and NS differ on this behavior.
This is closer to NS where we align to the first line of text.
If the child is not text we draw the indicator at the
set the color of a decoration
Align to bottom of icon.
Align to bottom of shape.
-1 because item is 1 based.
bit mask: 0 for repeat x, 1 for repeat y, 2 for horiz relative,
3 for vert relative
These are used when painting, updatePaintCoordinates updates them.
Determine the position.
Determine any repeating values.
Constrain the clip so that images don't draw outside the
PENDING(prinz) fix this up to be a more realistic
--- AttributeSet methods ----------------------------
didn't find it... try parent if it's a css attribute
that is inherited.
PENDING(sky): Decide what to do with this. Either make it
contain a SimpleAttributeSet that modify methods are delegated to,
or change getRule to return an AttributeSet and then don't make this
Selector has a '.', which indicates name must match it,
or if the '.' starts the selector than name must have
the same class (doesn't matter what element name).
Has to fully match.
Selector has a '#', which indicates name must match it,
or if the '#' starts the selector than name must have
the same id (doesn't matter what element name).
Has to fully match.
Receiver references a class, just check element name.
Receiver references an id, just check element name.
Fail through, no classes or ides, just check string.
class (.) 100
id (#)    10000
---- Variables ---------------------------------------------
CSSParserCallback methods, public to implement the interface.
class and index selectors are case sensitive
There is currently no mechanism to determine real
base that style sheet was loaded from. For the time
being, this maps for LIST_STYLE_IMAGE, which appear
to be the only one that currently matters. A more
general mechanism is definately needed.
Data related to the construction of object references and
supporting the Object Reference Template.
This calls acceptors which create profiles and may
add tagged components to those profiles.
This runs the IORInterceptors.
Note that all current subclasses share the same implementation of this method,
but overriding it would make sense for OAs that use a different InvocationInfo.
TODO - bug 4296691 - remove this check
TODO - bug 4296691 - remove this check
pix > line > band
pix > band > line
band > pix > line
line > pix > band
line > band > pix
band > line > pix
make sure we make room for negative offsets...
Bounds check for 'b' will be performed automatically
Bounds check for 'b' will be performed automatically
Bounds check for 'b' will be performed automatically
Bounds check for 'b' will be performed automatically
Bounds check for 'b' will be performed automatically
Bounds check for 'b' will be performed automatically
Bounds check for 'b' will be performed automatically
Bounds check for 'b' will be performed automatically
If we implement equals() we must also implement hashCode
implementors should override this method
convert file to appropriate URI, f.toURI().toASCIIString()
converts the URI to string as per rule specified in
loop through the array until indices cross
if the indexes have not crossed, swap
We ned to get the next index ...
Use an implementation of the JAVA API for XML Parsing 1.0 to
create a DOM Document node to contain the result.
Default return value, if there is no defined ordering
Optimize for most common case
then we know they are siblings
If both parents are null, ordering is not defined.
We're returning a value in lieu of throwing an exception.
Not a case we expect to arise in XPath, but beware if you
try to reuse this method.
We can just fall through in this case, which allows us
to hit the debugging code at the end of the function.
General strategy: Figure out the lengths of the two
ancestor chains, reconcile the lengths, and look for
the lowest common ancestor. If that ancestor is one of
the nodes being compared, it comes before the other.
Otherwise perform a sibling compare.
NOTE: If no common ancestor is found, ordering is undefined
and we return the default value of isNodeAfter.
Count parents in each ancestor chain
include node & parent obtained above
Initially assume scan for common ancestor starts with
the input nodes.
If one ancestor chain is longer, adjust its start point
so we're comparing at the same depths
Adjust startNode2 to depth of startNode1
adjust startNode1 to depth of startNode2
so we can "back up"
Loop up the ancestor chain looking for common parent
first time in loop?
Edge condition: one is the ancestor of the other.
from while loop
Compare ancestors below lowest-common as siblings
from while loop
end if(startNode1 == startNode2)
Move up one level and try again
end while(parents exist to examine)
end big else (not immediate siblings)
WARNING: The following diagnostic won't report the early
"same node" case. Fix if/when needed.
end isNodeAfter(Node node1, Node node2)
always sort attributes before non-attributes.
always sort attributes before non-attributes.
Count from the start until we find one or the other.
TODO: Check performance of alternate solution:
There are two choices here: Count from the start of
the document until we find one or the other, or count
from one until we find or fail to find the other.
Either can wind up scanning all the siblings in the worst
case, which on a wide document can be a lot of work but
is more typically is a short list.
Scanning from the start involves two tests per iteration,
but it isn't clear that scanning from the middle doesn't
yield more iterations on average.
We should run some testcases.
end isNodeAfterSibling(Node parent, Node child1, Node child2)
SECTION: Namespace resolution
Hardcoded, per Namespace spec
Hardcoded in the DOM spec, expected to be adopted by
Namespace spec. NOTE: Namespace declarations _must_ use
the xmlns: prefix; other prefixes declared as belonging
to this namespace will not be recognized and should
probably be rejected by parsers as erroneous declarations.
Attribute name for this prefix's declaration
Scan until we run out of Elements or have resolved the namespace
Look for the appropriate Namespace Declaration attribute,
either "xmlns:prefix" or (if prefix is "") "xmlns".
TODO: This does not handle "implicit declarations"
which may be created when the DOM is edited. DOM Level
3 will define how those should be interpreted. But
this issue won't arise in freshly-parsed DOMs.
NOTE: declname is set earlier, outside the loop.
Attributes don't use the default namespace, so if
there isn't a prefix, we're done.
SECTION: DOM Helper Functions
TODO: I can probably do something to figure out if this
space is ignorable from just the information in
the DOM tree.
-- You need to be able to distinguish whitespace
that is #PCDATA from whitespace that isn't.  That requires
DTD support, which won't be standardized until DOM Level 3.
Given how expensive the tree walk may be, we should first ask
whether this DOM can answer the question for us. The additional
test does slow down Level 1 DOMs slightly. DOMHelper2, which
is currently specialized for Xerces, assumes it can use the
Level 2 solution. We might want to have an intermediate stage,
which would assume DOM Level 2 but not assume Xerces.
(Shouldn't have to check whether impl is null in a compliant DOM,
but let's be paranoid for a moment...)
DOM Level 1 solution, as fallback. Hugely expensive.
if((Node.DOCUMENT_NODE != nodeType) && (null == parent))
then it's unparsed
The draft says: "The XSLT processor may use the public
identifier to generate a URI for the entity instead of the URI
specified in the system identifier. If the XSLT processor does
not use the public identifier to generate the URI, it must use
the system identifier; if the system identifier is a relative
URI, it must be resolved into an absolute URI using the URI of
the resource containing the entity declaration as the base
So I'm falling a bit short here.
This should be resolved to an absolute URL, but that's hard
to do from here.
This should only be called for Level 1 DOMs, so we don't have to
worry about namespace issues. In later levels, it's possible
for a DOM to have two Attrs with the same NodeName but
different namespaces, and we'd need to get getAttributeNodeNS...
but later levels also have Attr.getOwnerElement.
Handy constants for conversion methods
To maintain full signature compatibility with 1.5, and to improve the
clarity of the generated javadoc (see 6287639: Abstract methods in
enum classes should not be listed as abstract), method convert
etc. are not declared abstract but otherwise act as abstract methods.
iterator = new FilterIterator(getAxisIterator(axis),
"Error: typed iterator for axis "
"Error: iterator for axis '" + Axis.names[axis]
%REVIEW% We could opt to share _nodeType and setNodeType() as
well, and simply ignore them in iterators which don't use them.
But Scott's worried about the overhead involved in cloning
these, and wants them to have as few fields as possible. Note
that we can't create a TypedInternalAxisIteratorBase because
those are often based on the untyped versions and Java doesn't
support multiple inheritance. <sigh/>
end of InternalAxisIteratorBase
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
end of ChildrenIterator
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
end of ParentIterator
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
end of TypedChildrenIterator
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
end of NamespaceChildrenIterator
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
end of NamespaceIterator
end of TypedNamespaceIterator
end of RootIterator
end of TypedRootIterator
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
end of NamespaceAttributeIterator
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
end of FollowingSiblingIterator
end of TypedFollowingSiblingIterator
assumes caller will pass element nodes
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
end of AttributeIterator
assumes caller will pass element nodes
singleton iterator, since there can only be one attribute of
a given type.
end of TypedAttributeIterator
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
Be careful to handle the Document node properly
end of PrecedingSiblingIterator
end of TypedPrecedingSiblingIterator
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
iterator is not a clone
Pop actual root node (if not start) back off the stack
Last parent before root node
Bugzilla 8324: We were forgetting to skip Attrs and NS nodes.
Also recoded the loop controls for clarity and to flatten out
redefine DTMAxisIteratorBase's reset
end of PrecedingIterator
end of TypedPrecedingIterator
easier for now
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
find rightmost descendant (or self)
_currentNode precedes possible following(node) nodes
end of FollowingIterator
end of TypedFollowingIterator
must set to false for any clone
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
end of AncestorIterator
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
end of TypedAncestorIterator
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
end of DescendantIterator
end of TypedDescendantIterator
I'm not exactly clear yet what this is doing... -sb
end of NthDescendantIterator
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
end of SingletonIterator
end of TypedSingletonIterator
Methods for accessing results by column index
Methods for accessing results by column label
Getters and Setters
-------------------------- JDBC 3.0 ----------------------------------------
------------------------- JDBC 4.0 -----------------------------------
------------------------- JDBC 4.1 -----------------------------------
------------------------- JDBC 4.2 -----------------------------------
hide the implicit break at the end of the document
--- java.awt.TextArea methods ---------------------------------
--- Component methods -----------------------------------------
--- Scrollable methods ----------------------------------------
--- variables -------------------------------------------------
The keystore type
The provider implementation
Has this keystore been initialized (loaded)?
maximum times to try the callbackhandler if the password is wrong
when using a CallbackHandler,
reprompt if the password is wrong
when using a CallbackHandler,
reprompt if the password is wrong
<p>we are trying to make this XMLGrammarPool work for all kinds of
grammars, so we have a parameter "grammarType" for each of the
Ocean specific stuff.
Size of images to create. For vertical gradients this is the width,
otherwise it's the height.
Render to the VolatileImage
Render to the screen
Coefficients are from the sRGB color space:
the "built-in" grammar loaders
Map holding our loaders
those are all the basic properties...
got one; just instantiate it...
were given one
registerPreparser(String, XMLGrammarLoader):  boolean
make sure gl's been set up with all the "basic" properties:
potentially, not all will support this one...
preparseGrammar(String, XMLInputSource):  Grammar
it's possible the application may want access to a certain loader to do
some custom work.
set a feature.  This method tries to set it on all
registered loaders; it eats any resulting exceptions.  If
an app needs to know if a particular feature is supported
by a grammar loader of a particular type, it will have
to retrieve that loader and use the loader's setFeature method.
eat it up...
since our error reporter is a property we set later,
make sure features it understands are also set.
set a property.  This method tries to set it on all
registered loaders; it eats any resulting exceptions.  If
an app needs to know if a particular property is supported
by a grammar loader of a particular type, it will have
to retrieve that loader and use the loader's setProperty method.
<p> <strong>An application should use the explicit method
in this class to set "standard" properties like error handler etc.</strong>
eat it up...
get status of feature in a particular loader.  This
catches no exceptions--including NPE's--so the application had
better make sure the loader exists and knows about this feature.
getFeature (String, String):  boolean
get status of property in a particular loader.  This
catches no exceptions--including NPE's--so the application had
better make sure the loader exists and knows about this property.
<strong>For standard properties--that will be supported
by all loaders--the specific methods should be queried!</strong>
getProperty(String, String):  Object
revisit: may want to set the value in ownerDocument.
Default behavior, overridden in some subclasses
keep old value for document notification
The read-only check is done by deleteData()
specifically by aggregating DOMAttrModified and
DOMSubtreeModified. But mutation events are
underspecified; I don't feel compelled
to deal with it right now.
keep old value for document notification
index to constant pool
out of for
firstly we try to use classloader used for loading
the IIOMetadata implemantation for this plugin.
we failed to load IIOMetadataFormat class by
using IIOMetadata classloader.Next try is to
use thread context classloader.
finally we try to use system classloader in case
if we failed to load IIOMetadataFormat implementation
no need to sync in the future
public and system ids
we don't want to generate any event for this so turn them off
no need to synchronize again
create new node maps
fill node maps
internal, external, and unparsed entities
NOTE: Should never get here! -Ac
set mutation events flag back to its original value
set entities and notations read_only per DOM spec
REVISIT: this is GIOP specific.
End of file.
===== privates =====
Parsing a pattern into a list of PatternEntries....
skip whitespace TODO use Character
We re-use these objects in order to improve performance
the official serial version ID which says cryptically
which version we're compatible with
the internal serial version which says which version was written
- 0 (default) for version up to JDK 1.1.3
- 1 for version from JDK 1.1.4, which includes a new field
For time zones that have no names, use strings GMT+minutes and
GMT-minutes. For instance, in France the time zone is GMT+60.
Verify and compile the given pattern.
The format object must be constructed using the symbols for this zone.
However, the calendar should use the current default TimeZone.
If this is not contained in the locale zone strings, then the zone
will be formatted using generic GMT+/-H:MM nomenclature.
'' is treated as a single quote regardless of being
in a quoted section.
In most cases, c would be a delimiter, such as ':'.
Take any contiguous non-ASCII alphabet characters and
put them in a single TAG_QUOTE_CHARS.
Copy the compiled pattern to a char array
Called from Format after creating a FieldDelegate
Convert input date to time field list
Map index into pattern character string to Calendar field number
Pseudo Calendar field
Pseudo Calendar field
Map index into pattern character string to DateFormat field number
Maps from DecimalFormatSymbols index to Field constant
use calendar year 'y' instead
Note: zeroPaddingNumber() assumes that maxDigits is either
2 or maxIntCount. If we make any changes to this,
zeroPaddingNumber() must be fixed.
clip 1996 to 96
'M' (context seinsive)
'k' 1-based.  eg, 23:59 + 1 hour =>> 24:59
count < 4, use abbreviated form if exists
'h' 1-based.  eg, 11PM + 1 hour =>> 12 AM
Use the short name
'Z' ("-/+hhmm" form)
case PATTERN_DAY_OF_MONTH:          'd'
case PATTERN_HOUR_OF_DAY0:          'H' 0-based.  eg, 23:59 + 1 hour =>> 00:59
case PATTERN_MINUTE:                'm'
case PATTERN_SECOND:                's'
case PATTERN_MILLISECOND:           'S'
case PATTERN_DAY_OF_YEAR:           'D'
case PATTERN_DAY_OF_WEEK_IN_MONTH:  'F'
case PATTERN_WEEK_OF_YEAR:          'w'
case PATTERN_WEEK_OF_MONTH:         'W'
case PATTERN_HOUR0:                 'K' eg, 11PM + 1 hour =>> 0 AM
case PATTERN_ISO_DAY_OF_WEEK:       'u' pseudo field, Monday = 1, ..., Sunday = 7
Optimization for 1, 2 and 4 digit numbers. This should
cover most cases of formatting date/time related items.
Note: This optimization code assumes that maxDigits is
either 2 or Integer.MAX_VALUE (maxIntCount in format()).
Peek the next pattern to determine if we need to
obey the number of pattern letters for
parsing. It's required when parsing contiguous
digit text (e.g., "20010704") with a pattern which
has no delimiters between fields, like "yyyyMMdd".
In Arabic, a minus sign for a negative number is put after
the number. Even in another locale, a minus sign can be
put after a number using DateFormat.setNumberFormat().
If both the minus sign and the field-delimiter are '-',
subParse() needs to determine whether a '-' after a number
in the given text is a delimiter or is a minus sign for the
preceding number. We give subParse() a clue based on the
information in compiledPattern.
At this point the fields of Calendar have been set.  Calendar
will fill in default values for missing fields when the time
If the year value is ambiguous,
then the two-digit year == the default start year
An IllegalArgumentException will be thrown by Calendar.getTime()
if any fields are out of range, e.g., MONTH == 17.
There may be multiple strings in the data[] array which begin with
the same prefix (e.g., Cerven and Cervenec (June and July) in Czech).
We keep track of the longest match, and return that.  Note that this
unfortunately requires us to test all array elements.
Always compare if we have no match yet; otherwise only compare
against potentially better matches (longer strings).
TODO: make this default when it's in the spec.
Checking long and short zones [1 & 2],
and long and short daylight [3 & 4].
true if standard and daylight time use the same abbreviation.
At this point, check for named time zones by looking through
the locale data from the TimeZoneNames strings.
Want to be able to parse both short and long forms.
Check if the standard name (abbr) and the daylight name are the same.
Matched any ?
If the time zone matched uses the same name
(abbreviation) for both standard and daylight time,
let the time zone in the Calendar decide which one.
Also if tz.getDSTSaving() returns 0 for DST, use tz to
determine the local time. (6645292)
If no colon in RFC 822 or 'X' (ISO), two digits are
Proceed with parsing mm
-(index - 1)
use calendar year 'y' instead
If there are any spaces here, skip over them.  If we hit the end
of the string, then fail.
Remember the actual start index
We handle a few special cases here where we need to parse
a number value.  We handle further, more generic cases below.  We need
to handle some of them here because some fields require extra processing on
the parsed value.
It would be good to unify this with the obeyCount logic below,
but that's going to be difficult.
calendar might have text representations for year values,
such as "\u5143" in JapaneseImperialCalendar.
If there are 3 or more YEAR pattern characters, this indicates
that the year value is to be treated literally, without any
two-digit year adjustments (e.g., from "01" to 2001).  Otherwise
we made adjustments to place the 2-digit year in the proper
century, for parsed strings from "00" to "99".  Any other string
is treated literally:  "2250", "-1", "1", "002".
Assume for example that the defaultCenturyStart is 6/18/1903.
This means that two-digit years will be forced into the range
6/18/1903 to 6/17/2003.  As a result, years 00, 01, and 02
correspond to 2000, 2001, and 2002.  Years 04, 05, etc. correspond
to 1904, 1905, etc.  If the year is 03, then it is 2003 if the
other fields specify a date before 6/18, or 1903 if they specify a
date afterwards.  As a result, 03 is an ambiguous year.  All other
two-digit years are unambiguous.
i.e., M or MM.
Don't want to parse the month if it is a string
while pattern uses numeric style: M or MM.
[We computed 'value' above.]
count >= 3  i.e., MMM or MMMM
Want to be able to parse both short and long forms.
Try count == 4 first:
count == 4 failed, now try count == 3
'k' 1-based.  eg, 23:59 + 1 hour =>> 24:59
Validate the hour value in non-lenient
[We computed 'value' above.]
Want to be able to parse both short and long forms.
Try count == 4 (DDDD) first:
DDDD failed, now try DDD
'h' 1-based.  eg, 11PM + 1 hour =>> 12 AM
Validate the hour value in non-lenient
[We computed 'value' above.]
Try parsing a custom time zone "GMT+hh:mm" or "GMT".
Parse the rest as "hh:mm"
Try parsing the text as a time zone
name or abbreviation.
Parse the rest as "hhmm" (RFC 822)
parse text as "+/-hh[[:]mm]" based on count
case PATTERN_DAY_OF_MONTH:          'd'
case PATTERN_HOUR_OF_DAY0:          'H' 0-based.  eg, 23:59 + 1 hour =>> 00:59
case PATTERN_MINUTE:                'm'
case PATTERN_SECOND:                's'
case PATTERN_MILLISECOND:           'S'
case PATTERN_DAY_OF_YEAR:           'D'
case PATTERN_DAY_OF_WEEK_IN_MONTH:  'F'
case PATTERN_WEEK_OF_YEAR:          'w'
case PATTERN_WEEK_OF_MONTH:         'W'
case PATTERN_HOUR0:                 'K' 0-based.  eg, 11PM + 1 hour =>> 0 AM
Handle "generic" fields
patternChars is longer than localPatternChars due
to serialization compatibility. The pattern letters
unsupported by localPatternChars pass through.
just enough fields for a reasonable distribution
super does class check
Get all SHORT and LONG styles (avoid NARROW styles).
didn't have defaultCenturyStart field
fill in dependent transient field
If the deserialized object has a SimpleTimeZone, try
to replace it with a ZoneInfo equivalent in order to
be compatible with the SimpleTimeZone-based
implementation as much as possible.
If the negative subpattern is not absent, we have to analayze
it in order to check if it has a following minus sign.
private objects to cache the locale and resource bundle
memorize the most-recent locale
do not fallback if given classloader can't find the class, throw exception
do not fallback if given classloader can't find the class, throw exception
NOTE: if there is more than one interest op this does not
allow discrimination between different ops and how threading
REVISIT: need base class with two derived.
End of file.
Import general CORBA classes
Get org.omg.CosNaming Types
Get base implementation
Get a hash table
There is only one POA used for both TransientNamingContext and
If there are more elements get the next element
Return empty but marshalable binding
Remove the object from the Active Object Map.
Common UI methods
Make sure the awt toolkit is loaded so we have access to native
look for cached image
Note that stealData() requires a markDirty() afterwards
since we modify the data in it.
name of current class
Methods to print
file to write to
Both cases have a field default_offset in common
Print switch indices in first row (and default)
Print target and default indices in second row
Print switch indices in first row (and default)
Print target and default indices in second row
Special treatment needed
Get signature, i.e., types
Attach return type
Either branch or index
Look for local variables and their range
Get target addresses from GOTO, JSR, TABLESWITCH, etc.
bytes.readByte();  Skip already read byte
Both cases have a field default_offset in common
bytes.readByte();  Skip already read byte
bytes.readByte();  Skip already read byte
Get raw signature
Get array of strings containing the argument types
Get return type string
Get method name
Get method's access flags
Get the method's attributes, the Code Attribute in particular
No code, an abstract method, e.g.
Print the byte code
Mark last line, may be targetted from Attributes window
Height/width to use before we know the real size, these should at least
the size of <code>sMissingImageIcon</code> and
Size of the border, the insets contains this valid. For example, if
the HSPACE attribute was 4 and BORDER 2, leftInset would be 6.
Insets, obtained from the painter.
PENDING: This needs to be changed to support the CSS versions
when conversion from ALIGN to VERTICAL_ALIGN is complete.
Assume the worst.
No pixels yet, use the default
Draw the image
Paint the view representing the alt text, if its non-null
Assume layout along the y direction
If the attributes specified a width/height, always use it!
does not check parents!
clear out width/height/realoadimage flag and set loading flag
Load the image
And update the size params
Clear out state in case someone threw an exception.
Force the image to be loaded by using an ImageIcon.
Get the width/height and set the state ivar before calling
anything that might cause the image to be loaded, and thus the
ImageHandler to be called.
Make sure the image starts loading:
If imageloading failed, other thread may have called
ImageLoader which will null out image, hence we check
Only reset if this thread determined image is null
This can come on any thread. If we are in the process of reloading
the image and determining our state (loading == true) we don't fire
preference changed, or repaint, we just reset the fWidth/fHeight as
necessary and return. This is ok as we know when loading finishes
it will pick up the new height/width, if necessary.
Bail out if there was an error:
Be sure image hasn't changed since we don't
No need to resize or repaint, still in the process
Resize image if necessary:
No need to resize or repaint, still in the process of
May need to resize myself, asynchronously:
Repaint when done or when new pixels arrive:
Don't use supers paint, otherwise selection will be wrong
as our start/end offsets are fake.
Don't allow a break
Cannot be instantiated.
Even though volatile, hotspot doesn't need a write barrier here.
Hotspot implementation via intrinsics API
Special Handling of Notifications -------------------------------------
If there's no grammar pool then either we haven't created one
yet or the garbage collector has already cleaned out the previous one.
set horizontal alignment
Get the width/height
Offset by the margins so that pref/min/max return the
If it's the last paragraph and not editable, it shouldn't
cached for speed
implementors should override this method
End of file.
Top Level Information Items have [included] property in infoset
used for adding [base URI] attributes
used for adding [language] attributes
we go into this state after a successful include (thus we ignore the children
of the include) or after a fallback
we go into this state after a failed include.  If we don't encounter a fallback
before we reach the end include tag, it's a fatal error
recognized features and properties
for buffer size in XIncludeTextReader
It "feels wrong" to store this value here.  However,
calculating it can be time consuming, so we cache it.
It's never going to change in the lifetime of this XIncludeHandler
we cache the child parser configuration, so we don't have to re-create
the objects when the parser is re-used
The cached child parser configuration, may contain a
XInclude or XPointer Handler.  Cache both these
these are needed for text include processing
these are needed for XML Base processing
these are needed for Language Fixup
used for passing features on to child XIncludeHandler objects
The current element depth.  We start at depth 0 (before we've reached any elements).
The first element is at depth 1.
The current element depth of the result infoset.
this value must be at least 1
Used to ensure that fallbacks are always children of include elements,
and that include elements are never children of other include elements.
An index contains true if the ancestor of the current element which resides
at that depth was an include element.
Ensures that only one fallback element can be at a single depth.
An index contains true if we have seen any fallback elements at that depth,
and it is only reset to false when the end tag of the parent is encountered.
The state of the processor at each given depth.
buffering the necessary DTD events
flags which control whether base URI or language fixup is performed.
for SAX compatibility.
Has the value of the ALLOW_UE_AND_NOTATION_EVENTS feature
track the version of the document being parsed
track whether a DTD is being parsed
track whether the root element of the result infoset has been processed
track whether the child config needs its features refreshed
REVISIT: Find a better method for maintaining
the state of the XInclude processor. These arrays
can potentially grow quite large. Cleaning them
out on reset may be very time consuming. -- mrglavas
clear the previous settings from the arrays
if parser settings have not changed return.
parser settings changed. Need to refresh features on child config.
Get symbol table.
Get error reporter.
Get entity resolver.
Get security manager.
Get buffer size.
Reset XML 1.0 text reader.
Reset XML 1.1 text reader.
We don't want a schema validator on the new pipeline,
so if it was enabled, we set the feature to false. If
the validation feature was also enabled we turn on
dynamic validation, so that DTD validation is performed
on the included documents only if they have a DOCTYPE.
This is consistent with the behaviour on the main pipeline.
Don't reset fChildConfig -- we don't want it to share the same components.
It will be reset when it is actually used to parse something.
Reset XML 1.0 text reader.
Reset XML 1.1 text reader.
we do this to ensure that the proper location is reported in errors
otherwise, the locator from the root document would always be used
initialize the current base URI
initialize the current language
we need to change the depth like this so that modifyAugmentations() works
If the last two states were fallback then this must be a descendant of an include
child which isn't a fallback. The specification says we should ignore such elements
and their children.
we process the xml:base and xml:lang attributes regardless
of what type of element it is.
If the last two states were fallback then this must be a descendant of an include
child which isn't a fallback. The specification says we should ignore such elements
and their children.
we process the xml:base and xml:lang attributes regardless
of what type of element it is.
reset the out of scope stack elements
check if an xml:base has gone out of scope
pop the values from the stack
if we're ending an include element, and we were expecting a fallback
we check to see if the children of this include element contained a fallback
the state would have been set to normal processing if we were expecting the fallback element
now that we're done processing it, we should ignore all the other children of the include element
reset the out of scope stack elements
check if an xml:base has gone out of scope
pop the values from the stack
check if an xml:lang has gone out of scope
pop the language from the stack
we need to change the depth like this so that modifyAugmentations() works
We are only interested in the notation and unparsed entity declarations,
the rest we just pass on
this ensures the proper location is displayed in error messages
Either the state is STATE_EXPECT_FALLBACK or it's STATE_IGNORE.
If we're ignoring, we want to stay ignoring. But if we're expecting this fallback element,
we want to signal that we should process the children.
TODO: does Java use IURIs by default?
[Definition: An internationalized URI reference, or IURI, is a URI reference that directly uses [Unicode] characters.]
TODO: figure out what section 4.1.1 of the XInclude spec is talking about
has to do with disallowed ASCII character escaping
this ties in with the above IURI section, but I suspect Java already does it
When parse="xml" and an xpointer is specified treat
all absences of the href attribute as a resource error.
Check whether href is correct and perform escaping as per section 4.1.1 of the XInclude spec.
Report fatal error if the href value contains a fragment identifier or if the value after
escaping is a syntactically invalid URI or IRI.
Verify that if an accept and/or an accept-language attribute exist
that the value(s) don't contain disallowed characters.
setup an HTTPInputSource if either of the content negotation attributes were specified.
Instead of always creating a new configuration, the first one can be reused
use the same symbol table, error reporter, entity resolver, security manager and buffer size.
features must be copied to child configuration
use the same namespace context
If the xpointer attribute is present
If an xpointer attribute is present
Parse the XPointer expression
report the XPointer error as a resource error
set all features on parserConfig to match this parser configuration
necessary to make sure proper location is reported in errors
If the xpointer attribute is present
and it was not resolved
use the fallback
necessary to make sure proper location is reported in errors
necessary to make sure proper location is reported in errors
An IOException indicates that we had trouble reading the file, not
that it was an invalid XML file.  So we send a resource error, not a
we only care about encoding for parse="text"
Setup the appropriate text reader.
REVISIT: The namespace of this element should be bound
already. Why are we looking it up from the namespace
context? -- mrglavas
REVISIT: should we use File#sameFile() ?
I think the benefit of using it is that it resolves host names
instead of just doing a string comparison.
TODO: [base URI] is still an open issue with the working group.
They're deciding if xml:base should be added if the [base URI] is different in terms
of resolving relative references, or if it should be added if they are different at all.
Revisit this after a final decision has been made.
The decision also affects whether we output the file name of the URI, or just the path.
Technically, this doesn't check if the parent was a fallback, it also
would return true if any of the parent's sibling elements were fallbacks.
However, this doesn't matter, since we will always be ignoring elements
whose parent's siblings were fallbacks.
Modify attributes to fix the base URI (spec 4.5.5).
We only do it to top level included elements, which have a different
base URI than their include parent.
This causes errors with schema validation, if the schema doesn't
specify that these elements can have an xml:base attribute
this shouldn't ever happen, since by definition, we had to traverse
the same URIs to even get to this place
Modify attributes to perform language-fixup (spec 4.5.6).
We only do it to top level included elements, which have a different
[language] than their include parent.
Modify attributes of included items to do namespace-fixup. (spec 4.5.4)
Need to re-declare this prefix in the current context
in order for the SAX parser to report the appropriate
start and end prefix mapping events. -- mrglavas
Need to re-declare this prefix in the current context
in order for the SAX parser to report the appropriate
start and end prefix mapping events. -- mrglavas
4.5.1 - Unparsed Entities
4.5.2 - Notations
We don't start at fDepth, since it is either the top level included item,
or an include element, when this method is called.
This technically might not always return the first non-include/fallback
element that it comes to, since sawFallback() returns true if a fallback
was ever encountered at that depth.  However, if a fallback was encountered
at that depth, and it wasn't the direct descendant of the current element
then we can't be in a situation where we're calling this method (because
we'll always be in STATE_IGNORE)
shouldn't get here, since depth 0 should never have an include element or
a fallback element
we won't worry about when error reporter is null, since there should always be
at least the default error reporter
used to know whether to pass declarations to the document handler
first check the notation of the unparsed entity
There is no unparsed entity with the same name that we have sent.
Calling unparsedEntityDecl() will add the entity to our local store,
and also send the unparsed entity to the DTDHandler
There is no notation with the same name that we have sent.
It would be nice if we didn't have to repeat code like this, but there's no interface that has
setFeature() and addRecognizedFeatures() that the objects have in common.
componentManager doesn't support this feature,
so we won't worry about it
componentManager doesn't support this feature,
so we won't worry about it
This is a storage class to hold information about the notations.
We're not using XMLNotationDecl because we don't want to lose the augmentations.
equals() returns true if two Notations have the same name.
Useful for searching Vectors for notations with the same name
Notation items with the same [name], [system identifier],
[public identifier], and [declaration base URI] are considered
to be duplicate. An application may also be able to detect that
notations are duplicate through other means. For instance, the URI
resulting from combining the system identifier and the declaration
base URI is the same.
This is a storage class to hold information about the unparsed entities.
We're not using XMLEntityDecl because we don't want to lose the augmentations.
equals() returns true if two UnparsedEntities have the same name.
Useful for searching Vectors for entities with the same name
Unparsed entity items with the same [name], [system identifier],
[public identifier], [declaration base URI], [notation name], and
[notation] are considered to be duplicate. An application may also
be able to detect that unparsed entities are duplicate through other
means. For instance, the URI resulting from combining the system
identifier and the declaration base URI is the same.
The following methods are used for XML Base processing
The following methods are used for language processing
The literal system id at the location given by "start" is *in focus* at
the given depth. So we need to adjust it to the next scope, so that we
only process out of focus literal system ids
If that is the last system id, then we don't need a relative URI
We need to find two consecutive elements in the scope stack,
such that the first is lower than 'depth' (or equal), and the
second is higher.
we should never get here, because 0 was put on the stack in startDocument()
we should never get here, because 0 was put on the stack in startDocument()
push the new values on the stack
REVISIT: throw error here
which ASCII characters need to be escaped
the first hex character if a character needs to be escaped
the second hex character if a character needs to be escaped
initialize the above 3 arrays
Escape an href value according to (4.1.1):
To convert the value of the href attribute to an IRI reference, the following characters must be escaped:
the delimiters < #x3C, > #x3E and " #x22
To convert an IRI reference to a URI reference, the following characters must also be escaped:
the Unicode plane 0 characters #xA0 - #xD7FF, #xF900-#xFDCF, #xFDF0-#xFFEF
the Unicode plane 1-14 characters #x10000-#x1FFFD ... #xE0000-#xEFFFD
for each character in the href
if it's not an ASCII character (excluding 0x7F), break here, and use UTF-8 encoding
abort: href does not allow this character
we saw some non-ascii character
check if remainder of href contains any illegal characters before proceeding
abort: href does not allow this character
get UTF-8 bytes for the remaining sub-string
should never happen
for each byte
for non-ascii character: make it positive, then escape
otherwise, return the orginal one.
the content of the annotation node, including all children, along
with any non-schema attributes from its parent
the grammar which owns this annotation; we get parsers
from here when we need them
nothing must go wrong with this parse...
this should never happen!
REVISIT:  what to do with this?; should really not
ditto with above
Release the reference to the user's ContentHandler.
this creates the new Annotation element as the first child
of the Node
this should never happen!
REVISIT:  what to do with this?; should really not
ditto with above
adoptNode will return null when the DOM implementations are not compatible.
the result is now stored in srcPixels due to the 2nd pass
the result is now stored in srcPixels due to the 2nd pass
Get/Set Pixels helper methods
Unmanages the image
Unmanages the image
Returns the graphics configuration for the primary screen
Copyright (c) 1995-96 by Cisco Systems, Inc.
import debug stuff
This boolean is used to stop handling requests while the corresponding SnmpQManager
is being destroyed.
Wait until the thread die.
This is not good but Netscape does kill all threads when
the pagecontext changes.
wait to be signaled by the an active request.
Fire all requests as independent requests.
Fire all requests as independent requests.
where results are stored
Get iterator of Map values (which are lists of permissions)
Need to maintain serialization interoperability with earlier releases,
which had the serializable field:
private Hashtable permissions;  keyed on type
Don't call out.defaultWriteObject()
Copy perms into a Hashtable
Convert each entry (List) into a Vector
Convert list into Vector
Add to Hashtable being serialized
Write out serializable fields
Don't call defaultReadObject()
Read in serialized fields
writeObject writes a Hashtable<String, Vector<UnresolvedPermission>>
for the permissions key, so this cast is safe, unless the data is corrupt.
Convert each entry (Vector) into a List
Convert Vector into ArrayList
Add to Hashtable being serialized
End of interface StateEditable
Be very careful: com.sun.corba imports must not depend on
PEORB internal classes in ways that prevent portability to
other vendor's ORBs.
cached hash code
write the IOR to an OutputStream and get an InputStream
read the IOR components back from the stream
write the IOR components to an org.omg.CORBA.portable.OutputStream
read the IOR back from the stream
read the IOR from the ObjectInputStream
write the IOR to the ObjectOutputStream
compute the hash code
Common UI methods
%%% clone it??
Will be used only during internal subsets.
for appending data.
Remember, that the XML version has explicitly been set,
so that XMLStreamReader.getVersion() can find that out.
indicates that the operation is for detecting XML version
set buffer size:
REVISIT: Buffer size passed to entity scanner
was not being kept in synch with the actual size
of the buffers in each scanned entity. If any
of the buffers were actually resized, it was possible
that the parser would throw an ArrayIndexOutOfBoundsException
for documents which contained names which are longer than
the current buffer size. Conceivably the buffer size passed
to entity scanner could be used to determine a minimum size
for resizing, if doubling its size is smaller than this
minimum. -- mrglavas
/ Locator methods start.
if the entity is closed, we should return -1
xxx at first place why such call should be there...
if the entity is closed, we should return -1
xxx at first place why such call should be there...
/ Locator methods finished.
if the encoding is the same, don't change the reader and
re-use the original reader used by the OneCharReader
NOTE: Besides saving an object, this overcomes deficiencies
in the UTF-16 reader supplied with the standard Java
distribution (up to and including 1.3). The UTF-16
decoder buffers 8K blocks even when only asked to read
a single char! -Ac
UTF-16 is a bit of a special case.  If the encoding is UTF-16,
and we know the endian-ness, we shouldn't change readers.
If it's ISO-10646-UCS-(2|4), then we'll have to deduce
the endian-ness from the encoding we presently have.
wrap a new reader around the input stream, changing
load more characters, if needed
peek at character
return peeked character
load more characters, if needed
return character that was scanned
load more characters, if needed
bad luck we have to resize our buffer
load more characters, if needed
load more characters, if needed
scan qualified name
making a check if if the specified character is a valid name start character
as defined by production [5] in the XML 1.0 specification.
Name ::= (Letter | '_' | ':') (NameChar)*
adding into symbol table.
XXX We are trying to add single character in SymbolTable??????
check prefix before further read
check the result: prefix
check the result: localpart
check the result: localpart
no qualified name found
check limit before loading more data
bad luck we have to resize our buffer
load more characters, if needed
CHANGED: dont replace the value.. append to the buffer. This gives control to the callee
on buffering the data..
CHANGED: dont replace the value.. append to the buffer. This gives control to the callee
on buffering the data..
return next character
REVISIT: Does this need to be updated to fix the
#x0D ^#x0A newline normalization problem? -Ac
load more characters, if needed
scan literal value
return next character
NOTE: We don't want to accidentally signal the
end of the literal if we're expanding an
entity appearing in the literal. -Ac
load more characters, if needed
something must be wrong with the input:  e.g., file ends in an unterminated comment
iterate over buffer looking for delimiter
looks like we just hit the delimiter
return true if string was skipped
load more characters, if needed
character was not skipped
load more characters, if needed
we are doing this check only in skipSpace() because it is called by
fMiscDispatcher and we want the parser to exit gracefully when document
it is possible that end of document is reached and
fCurrentEntity becomes null
nothing was read so entity changed  'false' should be returned.
the load change the position to be 1,
need to restore it when entity not changed
REVISIT: Does this need to be updated to fix the
#x0D ^#x0A newline normalization problem? -Ac
If this is a general entity, spaces within a start element should be counted
load more characters, if needed
we are doing this check only in skipSpace() because it is called by
fMiscDispatcher and we want the parser to exit gracefully when document
it is possible that end of document is reached and
fCurrentEntity becomes null
nothing was read so entity changed  'false' should be returned.
no spaces were found
check if the capacity is availble in the current buffer
count is no. of characters in the buffer   [x][m][l]
position is '0' based
load more characters -- this function shouldn't change the entity
load changes the position.. set it back to the point where we started.
after loading check again.
first make sure that required capacity is avaible
s.charAt() indexes are 0 to 'Length -1' based.
check from reverse
first make sure that required capacity is avaible
maintaing the count till last load
reset count and position
record the last count
end of this entity
notify the entity manager about the end of entity
return if the current entity becomes null
handle the trailing edges
normalize encoding name
try to use an optimized reader
sould never happen with this encoding...
check for valid name
NOTE: AndyH suggested that, on failure, we use ISO Latin 1
because every byte is a valid ISO Latin 1 character.
It may not translate correctly but if we failed on
the encoding anyway, then we're expecting the content
of the document to be bad. This will just prevent an
invalid UTF-8 sequence to be detected. This is only
important when continue-after-fatal-error is turned
try to use a Java reader
see comment above.
createReader(InputStream,String, Boolean): Reader
UTF-16, with BOM
default to UTF-8 if we don't have enough bytes to make a
good determination of the encoding
UTF-8 with a BOM
default to UTF-8 if we don't have enough bytes to make a
good determination of the encoding
UCS-4, big endian (1234)
UCS-4, little endian (4321)
UCS-4, unusual octet order (2143)
REVISIT: What should this be?
UCS-4, unusual octect order (3412)
REVISIT: What should this be?
UTF-16, big-endian, no BOM
(or could turn out to be UCS-2...
REVISIT: What should this be?
UTF-16, little-endian, no BOM
(or could turn out to be UCS-2...
a la xerces1, return CP037 instead of EBCDIC here
load more characters, if needed
the load change the position to be 1,
need to restore it when entity not changed
REVISIT: Does this need to be updated to fix the
#x0D ^#x0A newline normalization problem? -Ac
load more characters, if needed
no spaces were found
Query the class loader ...
enforcing strict uri?
the scanner we use to actually read the DTD
the entity manager the scanner needs.
what's our Locale?
Add XML message formatter if there isn't one.
init(SymbolTable, XMLGrammarPool, XMLErrorReporter, XMLEntityResolver)
Add XML message formatter if there isn't one.
First chance checking strict URI
no reason to use grammar bucket's "put" method--we
know which grammar it is, and we don't know the root name anyway...
actually start the parsing!
Close all streams opened by the parser.
process internal subset
To get the DTD scanner to end at the right place we have to fool
it into thinking that it reached the end of the internal subset
in a real document.
process external subset
Close all streams opened by the parser.
loadGrammarWithContext(XMLDTDValidator, String, String, String, String, String)
reset all the components that we rely upon
createDTDScanner(SymbolTable, XMLErrorReporter, XMLEntityManager) : XMLDTDScannerImpl
getScannerVersion() : short
Type-specific CORBA::Object operations
-- This file was mechanically generated: Do not edit! --
these declarations are here as documentation
add this message to fix bug 21478
Earlier (JDK 1.4 XALAN 2.2-D11) at key code '204' the key name was ER_PRIORITY_NOT_PARSABLE
In latest Xalan code base key name is  ER_VALUE_SHOULD_BE_NUMBER. This should also be taken care
in locale specific files like XSLTErrorResources_de.java, XSLTErrorResources_fr.java etc.
NOTE: Not only the key name but message has also been changed.
Note to translators:  The following message should not normally be displayed
to users.  It describes a situation in which the processor has detected
an internal consistency problem in itself, and it provides this message
for the developer to help diagnose the problem.  The name
'ElemTemplateElement' is the name of a class, and should not be
Note to translators:  The following message should not normally be displayed
to users.  It describes a situation in which the processor has detected
an internal consistency problem in itself, and it provides this message
for the developer to help diagnose the problem.  The substitution text
provides further information in order to diagnose the problem.  The name
'RedundentExprEliminator' is the name of a class, and should not be
This code is shared with warning codes.
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "QNAME" is the XML data-type of
The following codes are shared with the warning codes...
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "ENUM" is the XML data-type of
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "NMTOKEN" is the XML data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "NCNAME" is the XML data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "boolean" is the XSLT data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "number" is the XSLT data-type
End of shared codes...
Note to translators:  A "match pattern" is a special form of XPath expression
that is used for matching patterns.  The substitution text is the name of
a function.  The message indicates that when this function is referenced in
a match pattern, its argument must be a string literal (or constant.)
ER_ARG_LITERAL - new error message for bugzilla 5202
Note to translators:  The following message indicates that two definitions of
a variable.  A "global variable" is a variable that is accessible everywher
in the stylesheet.
ER_DUPLICATE_GLOBAL_VAR - new error message for bugzilla #790
Note to translators:  The following message indicates that two definitions of
a variable were encountered.
ER_DUPLICATE_VAR - new error message for bugzilla #790
Note to translators:  "xsl:template, "name" and "match" are XSLT keywords
which must not be translated.
ER_TEMPLATE_NAME_MATCH - new error message for bugzilla #789
Note to translators:  "exclude-result-prefixes" is an XSLT keyword which
should not be translated.  The message indicates that a namespace prefix
encountered as part of the value of the exclude-result-prefixes attribute
was in error.
ER_INVALID_PREFIX - new error message for bugzilla #788
Note to translators:  An "attribute set" is a set of attributes that can
be added to an element in the output document as a group.  The message
was never defined.
ER_NO_ATTRIB_SET - new error message for bugzilla #782
Note to translators:  This message indicates that there was a reference
Note to translators:  This message indicates that the XSLT instruction
instructions (content) or a "select" attribute.  The word "select" is
an XSLT keyword in this case and must not be translated.
Note to translators:  This message indicates that the value argument
of setParameter must be a valid Java Object.
Following are the new WARNING keys added in XALAN code base after Jdk 1.4 (Xalan 2.2-D11)
Note to translators:  "name" and "xsl:processing-instruction" are keywords
and must not be translated.
Note to translators:  "name" and "xsl:processing-instruction" are keywords
and must not be translated.  "NCName" is an XML data-type and must not be
Note to translators:  This message is reported if the stylesheet that is
being processed attempted to construct an XML document with an attribute in a
place other than on an element.  The substitution text specifies the name of
Check: WHY THERE IS A GAP B/W NUMBERS in the XSLTErrorResources properties file?
Other miscellaneous text used inside the code...
Note to translators:  The following messages provide usage information
for the Xalan Process command line.  "Process" is the name of a Java class,
and should not be translated.
Note to translators: The option name and the parameter name do not need to
be translated. Only translate the messages in parentheses.  Note also that
leading whitespace in the messages is used to indent the usage information
for each option in the English messages.
Do not translate the keywords: XSLTC, SAX, DOM and DTM.
Following are the new options added in XSLTErrorResources.properties files after Jdk 1.4 (Xalan 2.2-D11)
Added by sboag/scurcuru; experimental
AddITIONAL  STRINGS that need L10n
Note to translators:  The following message describes usage of a particular
command-line option that is used to enable the "template inlining"
optimization.  The optimization involves making a copy of the code
generated for a template in another template that refers to it.
================= INFRASTRUCTURE ======================
/ PENDING(klobad) Who should be opaque in this component?
PENDING(klobad) Should this reparent the contentPane and MenuBar?
/ We are making sure the glassPane is on top.
Begin Inner Classes
This is silly, but should stop an overflow error
Note: This is laying out the children in the layeredPane,
technically, these are not our children.
inner class AccessibleJRootPane
Type-specific CORBA::Object operations
load more characters, if needed
peek at character
return peeked character
load more characters, if needed
return character that was scanned
load more characters, if needed
bad luck we have to resize our buffer
bad luck we have to resize our buffer
bad luck we have to resize our buffer
load more characters, if needed
load more characters, if needed
bad luck we have to resize our buffer
bad luck we have to resize our buffer
bad luck we have to resize our buffer
load more characters, if needed
scan qualified name
check prefix before further read
check the result: prefix
check the result: localpart
check the result: localpart
load more characters, if needed
inner loop, scanning for content
In internal entities control characters are allowed to appear unescaped.
return next character
REVISIT: Does this need to be updated to fix the
#x0D ^#x0A newline normalization problem? -Ac
load more characters, if needed
scan literal value
In internal entities control characters are allowed to appear unescaped.
return next character
NOTE: We don't want to accidentally signal the
end of the literal if we're expanding an
entity appearing in the literal. -Ac
load more characters, if needed
something must be wrong with the input:  e.g., file ends  an unterminated comment
iterate over buffer looking for delimiter
looks like we just hit the delimiter
In external entities control characters cannot appear
as literals so do not skip over them.
looks like we just hit the delimiter
Control characters are allowed to appear as literals
in internal entities.
return true if string was skipped
load more characters, if needed
character was not skipped
load more characters, if needed
we are doing this check only in skipSpace() because it is called by
fMiscDispatcher and we want the parser to exit gracefully when document
it is possible that end of document is reached and
fCurrentEntity becomes null
nothing was read so entity changed  'false' should be returned.
External --  Match: S + 0x85 + 0x2028, and perform end of line normalization
the load change the position to be 1,
need to restore it when entity not changed
REVISIT: Does this need to be updated to fix the
#x0D ^#x0A newline normalization problem? -Ac
If this is a general entity, spaces within a start element should be counted
load more characters, if needed
Internal -- Match: S (only)
the load change the position to be 1,
need to restore it when entity not changed
If this is a general entity, spaces within a start element should be counted
load more characters, if needed
no spaces were found
load more characters, if needed
REVISIT: Can a string to be skipped cross an
entity boundary? -Ac
If it's a Xerces DOM store type information for attributes, set idness, etc..
write type information to this attribute
write type information to this element
adjust current node reference
Disallow subsequent initCause
Disallow subsequent initCause
Disallow subsequent initCause
Imports for using codebase URL to load class
d11638 files in the same package, therefore remove their reference
Legal IDL Identifier characters (1 = legal). Note
that '.' (2E) is marked as legal even though it is
not legal in IDL. This allows us to treat a fully
qualified Java name with '.' package separators
uniformly, and is safe because that is the only
legal use of '.' in a Java name.
0 1 2 3  4 5 6 7  8 9 a b  c d e f
Repository ID fragments
Value tag utility methods and constants
Public, well known repository IDs
_REVISIT_ : A table structure with a good search routine for all of this
would be more efficient and easier to maintain...
Anita4: convert to uppercase
Remote (The empty string is used for java.rmi.Remote)
bug fix for 4328952; to eliminate possibility of overriding this
in a subclass.
Interface Rep ID Strings
Dummy arguments for getIdFromHelper method
To create a RepositoryID, use code similar to the following:
Special case for remote
fix where Attempting to obtain a FullValueDescription
for an RMI value type with a String field causes an exception.
default if not explicitly specified
we have a declared hash also
_REVISIT_ : Special case version failure ?
This method will return the classname from the typestring OR if the classname turns out to be
a special class "pseudo" name, then the matching real classname is returned.
This method calls getClazzFromType() and falls back to the repStrToClass
cache if no class was found.  It's used where any class matching the
given repid is an acceptable result.
to avoid race condition where multiple threads could be
accessing this method, and their access to the cache may
be interleaved giving unexpected results
We gotta convert. Have we already started?
No, so get set up...
Convert the character into the IDL escape syntax...
(X) or (?:X)
^ $ \b \B \< \> \A \Z \z
for RANGE or NRANGE
When this.child.getMaxLength() < 0,
this returns minus value
Ignore CHAR tokens.
Pi - initial quote
Pf - final quote
blockNames in UNICODE 3.1 that supported by XML Schema REC
missing Specials add manually
missing 2 private use add manually
ADD THOSE MANUALLY
F0000..FFFFD; "Private Use",
100000..10FFFD; "Private Use"
build table of Pi values
build table of Pf values
for all characters
REVISIT: do we really need to support block names as in Unicode 3.1
or we can just create all the names in IsBLOCKNAME format (XML Schema REC)?
System.out.println(n+" " +Integer.toHexString(rstart)
Lu Ll Lo
Lu Ll Lo Nd
hangul_medial and hangul_final
\PM + \pM*
This is CONCAT, and new child is CONCAT.
Replace previous token by STRING
Convert List to Vector
Write serialized fields
We have to read serialized fields first.
convert Vector back to List
Locator2.java - extended Locator
Public Domain: no warranty.
$Id: Locator2.java,v 1.2 2004/11/03 22:49:08 jsuttor Exp $
Alignment for the title, one of SwingConstants.(LEADING|TRAILING|CENTER)
Release link to systemMenu from the JInternalFrame
SynthInternalFrameTitlePane has no UI, we'll invoke paint on it.
Center text vertically.
String fit, align as necessary.
Changes for the internal frame
Leave room for three characters in the title.
Note that this method carefully constructs an array of the type
of the first result, rather than just using Object[], which is
not convertible into the correct type.  Also note that no tokens
results in a null result.
XXX Does this correctly handle array types?  It seems
that hetereogeneous arrays work this way, while
homogeneous arrays need to use Array.newInstance tricks.
exact type (sans leading taget MH) for the outgoing call
Cached adapter information:
Indexes into invokers:
MethodHandles.invoker (generic invocation)
double cache; not used significantly
Simulate a CAS, to avoid racy duplication of results.
This next one is called from LambdaForm.NamedFunction.<init>.
Cannot build a generic invoker here of type ginvoker.invoke(mh, a*[254]).
Instead, factor sinvoker.invoke(mh, a) into ainvoker.invoke(filter(mh), a)
where filter(mh) == mh.asSpreader(Object[], spreadArgCount)
can be nothing else
argument count to account for trailing "appendix value" (typically the mtype)
normalize Z to I, String to Object, etc.
maybe cache if mtype == mtype.basicType()
link with java.lang.invoke.MethodHandle.invokeBasic(MethodHandle,Object,Object)Object/invokeSpecial
might be last in-argument
else if isLinker, then MTYPE is passed in from the caller (e.g., the JVM)
Make the final call.  If isGeneric, then prepend the result of type checking.
mh.invokeExact(a*):R => checkExactType(mh, TYPEOF(a*:R)); mh.invokeBasic(a*)
mh.invokeGeneric(a*):R => checkGenericType(mh, TYPEOF(a*:R)).invokeBasic(a*)
JVM needs a real methodOop
FIXME: merge with JVM logic for throwing WMTE
skipCallSite is true if we are optimizing a ConstantCallSite
normalize Z to I, String to Object, etc.
link with java.lang.invoke.MethodHandle.invokeBasic(MethodHandle,Object,Object)Object/invokeSpecial
the last in-argument
result of getTarget
(site.)invokedynamic(a*):R => mh = site.getTarget(); mh.invokeBasic(a*)
prepend MH argument:
JVM needs a real methodOop
Local constant functions:
Each nf must be statically invocable or we get tied up in our bootstraps.
add this message to fix bug 21478
Earlier (JDK 1.4 XALAN 2.2-D11) at key code '204' the key name was ER_PRIORITY_NOT_PARSABLE
In latest Xalan code base key name is  ER_VALUE_SHOULD_BE_NUMBER. This should also be taken care
in locale specific files like XSLTErrorResources_de.java, XSLTErrorResources_fr.java etc.
NOTE: Not only the key name but message has also been changed.
Note to translators:  The following message should not normally be displayed
to users.  It describes a situation in which the processor has detected
an internal consistency problem in itself, and it provides this message
for the developer to help diagnose the problem.  The name
'ElemTemplateElement' is the name of a class, and should not be
Note to translators:  The following message should not normally be displayed
to users.  It describes a situation in which the processor has detected
an internal consistency problem in itself, and it provides this message
for the developer to help diagnose the problem.  The substitution text
provides further information in order to diagnose the problem.  The name
'RedundentExprEliminator' is the name of a class, and should not be
This code is shared with warning codes.
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "QNAME" is the XML data-type of
The following codes are shared with the warning codes...
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "ENUM" is the XML data-type of
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "NMTOKEN" is the XML data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "NCNAME" is the XML data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "boolean" is the XSLT data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "number" is the XSLT data-type
End of shared codes...
Note to translators:  A "match pattern" is a special form of XPath expression
that is used for matching patterns.  The substitution text is the name of
a function.  The message indicates that when this function is referenced in
a match pattern, its argument must be a string literal (or constant.)
ER_ARG_LITERAL - new error message for bugzilla 5202
Note to translators:  The following message indicates that two definitions of
a variable.  A "global variable" is a variable that is accessible everywher
in the stylesheet.
ER_DUPLICATE_GLOBAL_VAR - new error message for bugzilla #790
Note to translators:  The following message indicates that two definitions of
a variable were encountered.
ER_DUPLICATE_VAR - new error message for bugzilla #790
Note to translators:  "xsl:template, "name" and "match" are XSLT keywords
which must not be translated.
ER_TEMPLATE_NAME_MATCH - new error message for bugzilla #789
Note to translators:  "exclude-result-prefixes" is an XSLT keyword which
should not be translated.  The message indicates that a namespace prefix
encountered as part of the value of the exclude-result-prefixes attribute
was in error.
ER_INVALID_PREFIX - new error message for bugzilla #788
Note to translators:  An "attribute set" is a set of attributes that can
be added to an element in the output document as a group.  The message
was never defined.
ER_NO_ATTRIB_SET - new error message for bugzilla #782
Note to translators:  This message indicates that there was a reference
Note to translators:  This message indicates that the XSLT instruction
instructions (content) or a "select" attribute.  The word "select" is
an XSLT keyword in this case and must not be translated.
Note to translators:  This message indicates that the value argument
of setParameter must be a valid Java Object.
Following are the new WARNING keys added in XALAN code base after Jdk 1.4 (Xalan 2.2-D11)
Note to translators:  "name" and "xsl:processing-instruction" are keywords
and must not be translated.
Note to translators:  "name" and "xsl:processing-instruction" are keywords
and must not be translated.  "NCName" is an XML data-type and must not be
Note to translators:  This message is reported if the stylesheet that is
being processed attempted to construct an XML document with an attribute in a
place other than on an element.  The substitution text specifies the name of
Check: WHY THERE IS A GAP B/W NUMBERS in the XSLTErrorResources properties file?
Other miscellaneous text used inside the code...
Note to translators:  The following messages provide usage information
for the Xalan Process command line.  "Process" is the name of a Java class,
and should not be translated.
Note to translators: The option name and the parameter name do not need to
be translated. Only translate the messages in parentheses.  Note also that
leading whitespace in the messages is used to indent the usage information
for each option in the English messages.
Do not translate the keywords: XSLTC, SAX, DOM and DTM.
Following are the new options added in XSLTErrorResources.properties files after Jdk 1.4 (Xalan 2.2-D11)
Added by sboag/scurcuru; experimental
AddITIONAL  STRINGS that need L10n
Note to translators:  The following message describes usage of a particular
command-line option that is used to enable the "template inlining"
optimization.  The optimization involves making a copy of the code
generated for a template in another template that refers to it.
================= INFRASTRUCTURE ======================
This hides the fact that internally we use null instead of empty string
SAX requires the URI to be a string or an empty string
attribute value is always empty string
REVISIT: what should happen in this case?
invalid to have other types of nodes in attr value
invalid to have other types of nodes in attr value
no need to synchronize again
No Entity by this name, stop here.
If entity's definition exists, clone its kids
Recursively set kids
The Xerces parser invokes callbacks for startEnityReference
the parsed value of the entity EACH TIME, so it is actually
easier to create the nodes through the callbacks rather than
clone the Entity.
BMP Image types
read and check the magic marker
Read file size
skip the two reserved fields
Offset to the bitmap from the beginning
End File Header
As BMP always has 3 rgb bands, except for Version 5,
which is bgra
Windows 2.x and OS/2 1.x
Classify the image type
Read in the palette
Windows 3.x and Windows NT
8-bit RLE compression
4-bit RLE compression
Read in the palette
there is a palette
Windows 4.x BMP
rgb masks, valid only if comp is BI_BITFIELDS
Only supported for 32bpp BI_RGB argb
All the new fields are valid only for this case
Read in the palette
bottom up image
top down image
Reset Image Layout so there's only one tile.
Define the color space
the colorModel and sampleModel will be initialzed
by the  reader of embedded image
When number of bitsPerPixel is <= 8, we use IndexColorModel.
1 and 4 bit pixels can be stored in a packed format.
Create IndexColorModel from the palette.
The number of bands in the SampleModel is determined by
the length of the mask array passed in.
Reset to the start of bitmap; then jump to the
start of image data
If the destination band is set used it
If the destination is provided, then use it.  Otherwise, create new one
Get the image data.
buffer for byte data
buffer for short data
buffer for int data
the sampleModel can be null in case of embedded image
There should only be one tile.
1-bit images cannot be compressed.
24-bit images are not compressed
Deal with 1 Bit images using IndexColorModels
cache the values to avoid duplicated computation
get the bit and assign to the data buffer of the raster
Method to read a 4 bit BMP image data
Padding bytes at the end of each scanline
cache the values to avoid duplicated computation
get the bit and assign to the data buffer of the raster
Method to read 8 bit BMP image data
Padding bytes at the end of each scanline
get the bit and assign to the data buffer of the raster
Method to read 24 bit BMP image data
Padding bytes at the end of each scanline
width * bitsPerPixel should be divisible by 32
get the bit and assign to the data buffer of the raster
Padding bytes at the end of each scanline
width * bitsPerPixel should be divisible by 32
get the bit and assign to the data buffer of the raster
get the bit and assign to the data buffer of the raster
If imageSize field is not provided, calculate it.
If width is not 32 bit aligned, then while uncompressing each
scanline will have padding bytes, calculate the amount of padding
Read till we have the whole image
Since data is compressed, decompress it
delta or vector marker
Move to the position xoff, yoff down
Whenever end pixels can fit into odd number of bytes,
an extra padding byte will be present, so skip that.
If End-of-RLE data, then exit the while loop
If imageSize field is not specified, calculate it.
If width is not 32 byte aligned, then while uncompressing each
scanline will have padding bytes, calculate the amount of padding
Read till we have the whole image
Decompress the RLE4 compressed data.
delta or vector marker
Move to the position xoff, yoff down
When end is odd, the above for loop does not
increment count, so do it now.
Whenever end pixels can fit into odd number of bytes,
an extra padding byte will be present, so skip that.
If End-of-RLE data, then exit the while loop
long path: whether unc or local
device path or short unc notation
Type-specific CORBA::Object operations
again falls through - Padmaja Vedula
setup to use Unsafe.compareAndSwapLong for updates
Bit constants for addUniqueAttribute().
The attribute value contains no bad characters. A "bad" character is one which
is greater than 126 or it is one of '<', '>', '&' or '"'.
An HTML empty attribute (e.g. <OPTION selected>).
An HTML URL attribute
2^8 = 256
2^10 = 1k
REVISIT: do we need decl pool for group declarations, attribute group,
it seems like each schema would use a small number of those
components, so it probably is not worth keeping those components
in the pool.
$Id: JAXPExtensionsProvider.java,v 1.1.2.1 2005/08/01 01:30:17 jeffsuttor Exp $
Find the XPathFunction corresponding to namespace and funcName
Find the XPathFunction corresponding to namespace and funcName
JAXP 1.3 spec says When XMLConstants.FEATURE_SECURE_PROCESSING
feature is set then invocation of extension functions need to
Assuming user is passing all the needed parameters ( including
default values )
not using methodKey
XNodeSet object() returns NodeVector and not NodeList
Explicitly getting NodeList by using nodelist()
If we get XPathFunctionException then we want to terminate
further execution by throwing WrappedRuntimeException
JAXP 1.3 spec says  When XMLConstants.FEATURE_SECURE_PROCESSING
feature is set then invocation of extension functions need to
XNodeSet object() returns NodeVector and not NodeList
Explicitly getting NodeList by using nodelist()
If we get XPathFunctionException then we want to terminate
further execution by throwing WrappedRuntimeException
largest numerical value
These would not be used for EN. Only used for traditional numbering
chinese only ??
These only used for mutiplicative-additive numbering
field cannot be final because of clone method
Check tabularType is not null
Initialize this.tabularType (and indexNamesArray for convenience)
Since LinkedHashMap was introduced in SE 1.4, it's conceivable even
if very unlikely that we might be the server of a 1.3 client.  In
that case you'll need to set this property.  See CR 6334663.
Construct the empty contents HashMap
Check value is valid
Return its calculated index
if key is not an array of Object instances, return false
Check key is not null and valid with tabularType
(throws NullPointerException, InvalidKeyException)
Return the mapping stored in the parent HashMap
should be return internalPut(...); (5090566)
Check value is not null, value's type is the same as this instance's row type,
and calculate the value's index according to this instance's tabularType and
check it is not already used for a mapping in the parent HashMap
store the (key, value) mapping in the dataMap HashMap
Check key is not null and valid with tabularType
(throws NullPointerException, InvalidKeyException)
Removes the (key, value) mapping in the parent HashMap
if t is null or empty, just return
Convert the values in t into an array of <tt>CompositeData</tt>
Add the array of values
if values is null or empty, just return
create the list of indexes corresponding to each value
Check all elements in values and build index list
check value and calculate index
check index is different of those previously calculated
add to index list
store all (index, value) mappings in the dataMap HashMap
historical confusion about the return type
historical confusion about the return type
if obj is null, return false
if obj is not a TabularData, return false
Now, really test for equality between this TabularData implementation and the other:
their tabularType should be equal
their contents should be equal:
. same size
. values in this instance are in the other (we know there are no duplicate elements possible)
(row values comparison is enough, because keys are calculated according to tabularType)
All tests for equality were successfull
Check key is neither null nor empty
key[] should have the size expected for an index
each element in key[] should be a value for its corresponding open type specified in rowType
Check value is not null
if value's type is not the same as this instance's row type, throw InvalidOpenTypeException
Check value is valid
Calculate value's index according to this instance's tabularType
and check it is not already used for a mapping in the parent HashMap
The check is OK, so return the index
orbos 98-01-18: Objects By Value -- begin
REVISIT: should this configuration depend on the others
like DTD/Standard one?
use XML 1.0 datatype library
setup DTD pipeline
setup document pipeline
setup document pipeline
If schema validator was not in the pipeline insert it.
add schema component
add schema message formatter
slotCounter is used to keep track of ORBInitInfo.allocate_slot_id()
The ORB associated with this PICurrent object.
True if the orb is still initialzing and get_slot and set_slot are not
to be called.
ThreadLocal contains a stack of SlotTable which are used
As per ptc/00-08-06 if the ORB is still initializing, disallow
calls to get_slot and set_slot.  If an attempt is made to call,
throw a BAD_INV_ORDER.
As per ptc/00-08-06 if the ORB is still initializing, disallow
calls to get_slot and set_slot.  If an attempt is made to call,
throw a BAD_INV_ORDER.
BEGIN: Keys needed for exception messages of  JAXP 1.3 XPath API implementation
END: Keys needed for exception messages of  JAXP 1.3 XPath API implementation
Note to translators:  A relative location path is a form of XPath expression.
The message indicates that such an expression was expected following the
characters '/' or '', but was not found.
Note to translators:  A location path is a form of XPath expression.
The message indicates that syntactically such an expression was expected,but
the characters specified by the substitution text were encountered instead.
Note to translators:  A location path is a form of XPath expression.
The message indicates that syntactically such a subexpression was expected,
but no more characters were found in the expression.
Note to translators:  A location step is part of an XPath expression.
The message indicates that syntactically such an expression was expected
following the specified characters.
Note to translators:  A node test is part of an XPath expression that is
used to test for particular kinds of nodes.  In this case, a node test that
consists of an NCName followed by a colon and an asterisk or that consists
of a QName was expected, but was not found.
Note to translators:  A step pattern is part of an XPath expression.
The message indicates that syntactically such an expression was expected,
but the specified character was found in the expression instead.
Note to translators: A relative path pattern is part of an XPath expression.
The message indicates that syntactically such an expression was expected,
but was not found.
Note to translators:  The substitution text is the name of a data type.  The
message indicates that a value of a particular type could not be converted
to a value of type boolean.
Note to translators: Do not translate ANY_UNORDERED_NODE_TYPE and
Note to translators: Do not translate UNORDERED_NODE_SNAPSHOT_TYPE and
Note to translators: This message indicates that the document being operated
upon changed, so the iterator object that was being used to traverse the
document has now become invalid.
Note to translators:  The substitution text is the name of a data type.  The
message indicates that a value of a particular type could not be converted
to a value of type string.
Note to translators: Do not translate snapshotItem,
UNORDERED_NODE_SNAPSHOT_TYPE and ORDERED_NODE_SNAPSHOT_TYPE.
Note to translators:  XPathEvaluator is a Java interface name.  An
XPathEvaluator is created with respect to a particular XML document, and in
this case the expression represented by this object was being evaluated with
respect to a context node from a different document.
Note to translators:  The XPath expression cannot be evaluated with respect
to this type of node.
BEGIN:  Definitions of error keys used  in exception messages of  JAXP 1.3 XPath API implementation
END:  Definitions of error keys used  in exception messages of  JAXP 1.3 XPath API implementation
Other miscellaneous text used inside the code...
================= INFRASTRUCTURE ======================
Use id, not reference, to avoid garbage retention
ensures visibility of readHolds
(Note: if c != 0 and w == 0 then shared count != 0)
Releasing the read lock has no effect on readers,
but it may allow waiting writers to proceed if
both read and write locks are now free.
else we hold the exclusive lock; blocking here
would cause deadlock.
Make sure we're not acquiring read lock reentrantly
cache for release
While we must in general read state before owner,
we don't need to do so to check if current thread is owner
Methods relayed to outer class
Must read state before owner to ensure memory consistency
reset to unlocked state
writers can always barge
Instrumentation and status
should never happen.
pseudo field index
stamp[] (lower half) and field[] (upper half) combined
Use YEAR instead
Set the fields from the min stamp to the max stamp so that
the field resolution works in the Calendar.
adjust later for lenient mode
NOTE: DO NOT use this field directly, SynthScrollBarUI assumes you'll
call getMinimumThumbSize to access it.
delay in milli seconds
TODO this can be removed when incrGap/decrGap become protected
handle scaling for sizeVarients for special case components. The
key "JComponent.sizeVariant" scales for large/small/mini
components are based on Apples LAF
Force the children's enabled state to be updated.
paint the distance between the start of the track and top of the thumb
if left-to-right, fill the area between the start of the track and
the left edge of the thumb. If right-to-left, fill the area between
the end of the thumb and end of the track.
fill the area between the bottom of the thumb and the end of the track.
if left-to-right, fill the area between the right of the thumb and the
end of the track. If right-to-left, then fill the area to the left of
the thumb and the start of the track.
This is used primarily for GTK L&F, which expands the
thumb to fit the track when it would otherwise be hidden.
Other L&F's simply hide the thumb in this case.
This is used primarily for GTK L&F, which expands the
thumb to fit the track when it would otherwise be hidden.
Other L&F's simply hide the thumb in this case.
Once there is API to determine the mouse location this will need
to be changed.
This method is called from BasicScrollPaneUI to implement wheel
scrolling, and also from scrollByBlock().
Check for overflow.
This method is called from BasicScrollPaneUI to implement wheel
scrolling, as well as from scrollByUnit().
Check for overflow.
Clicked in the Thumb area?
Because we are handling both mousePressed and Actions
we need to make sure we don't fire under both conditions.
(keyfocus on scrollbars causes action without mousePress
not an unmodified left mouse button
Stop scrolling if the thumb catches up with the mouse
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
Don't use the BasicScrollBarUI.scrollByXXX methods as we
don't want to use an invokeLater to reset the trackHighlight
via an invokeLater
Common UI methods
Note: namespace processing is on by default
REVISIT - [Q] Why do we need this local variable? -- mrglavas
push element stack
Second chance. Check if this character is a high
surrogate of a valid name start character.
REVISIT: is it required? forbit xmlns prefix for element
bind the element
assign uri to the element
make sure that object in the element stack is updated as well
making sure that the object in the element stack is updated too.
bind attributes (xmlns are already bound bellow)
REVISIT: try removing the first "if" and see if it is faster.
decrease the markup depth..
check that this element was opened in the same entity
pop the element off the stack..
Note: namespace processing is on by default
Must skip spaces here because the DTD scanner
would consume them at the end of the external subset.
REVISIT - [Q] Why do we need this local variable? -- mrglavas
push element stack
Second chance. Check if this character is a high
surrogate of a valid name start character.
REVISIT: is it required? forbit xmlns prefix for element
bind the element
assign uri to the element
make sure that object in the element stack is updated as well
making sure that the object in the element stack is updated too.
bind attributes (xmlns are already bound bellow)
REVISIT: try removing the first "if" and see if it is faster.
decrease the markup depth..
check that this element was opened in the same entity
pop the element off the stack..
WFC: Unique Att Spec
REVISIT: one more case needs to be included: external PE and standalone is no
record namespace declarations if any.
get the internalized value of this attribute
1. "xmlns" can't be bound to any namespace
2. the namespace for "xmlns" can't be bound to any prefix
3. "xml" can't be bound to any other namespace than it's own
4. the namespace for "xml" can't be bound to any other prefix
Declare prefix in context. Removing the association between a prefix and a
namespace name is permitted in XML 1.1, so if the uri value is the empty string,
the prefix is being unbound. -- mrglavas
bind namespace attribute to a namespace
attempt to bind attribute
Take advantage of the fact that next string _should_ be "fElementQName.rawName",
In scanners most of the time is consumed on checks done for XML characters, we can
optimize on it and avoid the checks done for endElement,
we will also avoid symbol table lookup - neeraj.bajaj@sun.com
this should work both for namespace processing true or false...
REVISIT: if the string is not the same as expected.. we need to do better error handling..
We can skip this for now... In any case if the string doesn't match -- document is not well formed.
we have increased the depth for two markup "<" characters
check that this element was opened in the same entity
since namespace context should still be valid when the parser is at the end element state therefore
we pop the context only when next() has been called after the end element state was encountered. - nb.
As mentioned in the javadoc when using windowBlit a paint event
will be generated by the system if copyArea copies a non-visible
portion of the view (in other words, it copies garbage). We are
not guaranteed to receive the paint event before other mouse events,
so we can not be sure we haven't already copied garbage a bunch of
times to different parts of the view. For that reason when a blit
happens and the Component is obscured (the check for obscurity
is not supported on all platforms and is checked via ComponentPeer
methods) the ivar repaintAll is set to true. When paint is received
if repaintAll is true (we previously did a blit) it is set to
false, and if the clip region is smaller than the viewport
waitingForRepaint is set to true and a timer is started. When
the timer fires if waitingForRepaint is true, repaint is invoked.
In the mean time, if the view is asked to scroll and waitingForRepaint
is true, a blit will not happen, instead the non-backing store case
of scrolling will happen, which will reset waitingForRepaint.
waitingForRepaint is set to false in paint when the clip rect is
bigger (or equal) to the size of the viewport.
A Timer is used instead of just a repaint as it appeared to offer
If the view is not valid, validate. scrollRectToVisible
may fail if the view is not valid first, contentRect
could be bigger than invalid size.
Only constrain the location if the view is valid. If the
the view isn't valid, it typically indicates the view
isn't visible yet and most likely has a bogus size as will
we, and therefore we shouldn't constrain the scrolling
NOTE: How JViewport currently works with the
backing store is not foolproof. The sequence of
events when setViewPosition
(scrollRectToVisible) is called is to reset the
views bounds, which causes a repaint on the
visible region and sets an ivar indicating
scrolling (scrollUnderway). When
JViewport.paint is invoked if scrollUnderway is
true, the backing store is blitted.  This fails
if between the time setViewPosition is invoked
and paint is received another repaint is queued
indicating part of the view is invalid. There
is no way for JViewport to notice another
repaint has occurred and it ends up blitting
what is now a dirty region and the repaint is
It just so happens JTable encounters this
behavior by way of scrollRectToVisible, for
this reason scrollUnderway is set to false
here, which effectively disables the backing
Validate the root.
And let the RepaintManager it does not have to validate from
| --- |     No Change
---------   No Change
|   ----    ->   | ----|
|  --------  ->     |--------
----    |     ->   |---- |
-------- |      ->   --------|
We invoked paint as part of copyArea cleanup, let it through.
We really don't need to paint, a future repaint will
take care of it, but if we don't we get an ugly flicker.
Need a complete repaint before resetting waitingForRepaint
If the view is smaller than the viewport and we are not opaque
(that is, we won't paint our background), we should set the
clip. Otherwise, as the bounds of the view vary, we will
blit garbage into the exposed areas.
Backing store is enabled but this is the first call to paint.
Create the backing store, paint it and then copy to g.
The backing store image will be created with the size of
the viewport. We must make sure the clip region is the
same size, otherwise when scrolling the backing image
the region outside of the clipped region will not be painted,
and result in empty areas.
No scrolling happened: repaint required area via backing store.
The image was scrolled. Manipulate the backing store and flush it to g.
The image was either moved diagonally or
moved by more than the image size: paint normally.
Move the relevant part of the backing store.
We don't want to inherit the clip region when copying
bits, if it is inherited it will result in not moving
all of the image resulting in garbage appearing on
Paint the rest of the view; the part that has just been exposed.
Copy whole of the backing store to g.
Only fire a change if a view has been installed.
scrollUnderway will be true if this is invoked as the
result of a validate and setViewPosition was previously
The cast to JComponent will work, if view is not
a JComponent, isBlitting will return false.
Repaint the complete component if the blit succeeded
and needsRepaintAfterBlit returns true.
The visible region is dirty, no point in doing copyArea
This calls setBounds(), and then repaint().
we must validate the hierarchy to not break the hw/lw mixing
Following is used when doBlit is true.
Find the first heavy weight ancestor. isObscured and
canDetermineObscurity are only appropriate for heavy weights.
The peer says we aren't obscured, therefore we can assume
that we won't later be messaged to paint a portion that
we tried to blit that wasn't valid.
It is certainly possible that when we blited we were
obscured, and by the time this is invoked we aren't, but the
chances of that happening are pretty slim.
waitingForRepaint will be false if a paint came down
with the complete clip rect, in which case we don't
have to cause a repaint.
Only happens in 1.2
Only paint the dirty region if it is visible.
The image was scrolled. Manipulate the backing store and flush
it to g.
Prepare the rest of the view; the part that has just been
NOTE: the code below uses paintForceDoubleBuffered for historical
reasons.  If we're going to allow a blit we've already accounted for
everything that paintImmediately and _paintImmediately does, for that
reason we call into paintForceDoubleBuffered to diregard whether or
not setDoubleBuffered(true) was invoked on the view.
blitFrom/blitTo are in JViewport coordinates system
not the views coordinate space.
clip* are in the views coordinate space.
Shift the scrolled region
Paint the newly exposed region.
Graphics is relative to JViewport, need to map to view's
To avoid any problems that may result from the viewport being
bigger than the view we start painting from the viewport.
We're in the process of painting, don't blit. If we were
to blit we would draw on top of what we're already drawing,
Part of the scrollpane needs to be repainted too, don't blit.
No Window parent.
inner class AccessibleJViewport
SNMP Runtime imports
SENDING SNMP INFORMS STUFF
VARIABLES REQUIRED FOR IMPLEMENTING SNMP GROUP (MIBII)
If forceAcl is `true' and InetAddressAcl is null, then a default
SnmpAcl object is created.
Initialize the ACL implementation.
GETTERS AND SETTERS
GETTERS FOR SNMP GROUP (MIBII)
If null oid array, just add it to the mib.
SUBCLASSING OF COMMUNICATOR SERVER
Important to inform finalize() that the socket is closed...
Let's wait for something to be received.
Let's check if we have been interrupted by stop().
SENDING SNMP TRAPS STUFF
First, make an SNMP V1 trap pdu
If the local host cannot be determined, we put 0.0.0.0 in agentAddr
Next, send the pdu to all destinations defined in ACL
First, make an SNMP V1 trap pdu
If the local host cannot be determined, we put 0.0.0.0 in agentAddr
Next, send the pdu to the specified destination
First, make an SNMP V1 trap pdu
If the local host cannot be determined,
we put 0.0.0.0 in agentAddr
Next, send the pdu to the specified destination
First, make an SNMP V2 trap pdu
We clone varBindList and insert sysUpTime and snmpTrapOid
Next, send the pdu to all destinations defined in ACL
First, make an SNMP V2 trap pdu
We clone varBindList and insert sysUpTime and snmpTrapOid
Next, send the pdu to the specified destination
First, make an SNMP V2 trap pdu
We clone varBindList and insert sysUpTime and snmpTrapOid
Only difference with other
End of diff
Next, send the pdu to the specified destination
Make an SNMP message from the pdu
FIXME: is the right exception to throw ?
We could simply forward SnmpTooBigException ?
Now send the SNMP message to each destination
If there is no destination defined or if everything has failed
we tried to send the trap to the local host (as suggested by
mister Olivier Reisacher).
Make an SNMP message from the pdu
FIXME: is the right exception to throw ?
We could simply forward SnmpTooBigException ?
Now send the SNMP message to specified destination
SENDING SNMP INFORMS STUFF
First, make an SNMP inform pdu:
We clone varBindList and insert sysUpTime and snmpTrapOid variables.
Next, send the pdu to the specified destination
Now send the SNMP message to each destination
First, make an SNMP inform pdu:
We clone varBindList and insert sysUpTime and snmpTrapOid variables.
Next, send the pdu to the specified destination
Call the default deserialization of the object.
Call the specific initialization for the SnmpAdaptorServer service.
This is for transient structures to be initialized to specific
The default Agent is initialized with a SnmpErrorHandlerAgent agent.
For the trap time, use the time the agent started ...
Create the default message factory
NOTE: these next five variables are currently unused.
listen for slider fill
Use true for Ocean theme
Draw the track
Draw the fill
To compensate for the g.translate()
To compensate for the g.translate()
Translate to the origin of the painting rectangle
Width and height of the painting rectangle.
This strange calculation is here to keep the
track in proportion to the thumb.
-1==RELATIVE, means that column|row equals to previously added component,
since each next Component with gridx|gridy == RELATIVE starts from
previous position, so we should start from previous component which
already used in maximumArray[X|Y]Index calculation. We could just increase
maximum by 1 to handle situation when component with gridx=-1 was added.
gridwidth|gridheight may be equal to RELATIVE (-1) or REMAINDER (0)
in any case using 1 instead of 0 or -1 should be sufficient to for
correct maximumArraySizes calculation
for (components) loop
Must specify index++ to allocate well-working arrays.
Code below will address index curX+curWidth in the case of yMaxArray, weightY
( respectively curY+curHeight for xMaxArray, weightX ) where
curX in 0 to preInitMaximumArraySizes.y
Thus, the maximum index that could
be calculated in the following code is curX+curX.
EmpericMultier equals 2 because of this.
for (components) loop
Component positioned above the baseline.
To make the bottom edge of the component aligned
with the baseline the bottom inset is
added to the descent, the rest to the ascent.
Component positioned below the baseline.
To make the top edge of the component aligned
with the baseline the top inset is
added to the ascent, the rest to the descent.
Apply the padding to the component, then ask for the baseline.
Component has a baseline
Adjust the ascent and descent to include the insets.
Component has a baseline resize behavior of
CENTER_OFFSET, calculate centerPadding and
centerOffset (see the description of
CENTER_OFFSET in the enum for detais on this
Anchor to the bottom.
Baseline is at (cellY + cellHeight - maxDescent).
Bottom of component (maxY) is at baseline + descent
of component. We need to subtract the bottom inset here
as the descent in the constraints object includes the
Component not resizable, calculate y location
from maxY - height.
Component is resizable. As brb is constant descent,
can expand component to fill region above baseline.
Subtract out the top inset so that components insets
BRB is not constant_descent
baseline for the row, relative to cellY
Component baseline, includes insets.top
Mixed ascent/descent in same row, calculate position
Only ascents/unknown in this row, anchor to top
BRB is other, which means we can only determine
the baseline by asking for it again giving the
size we plan on using for the component.
Component has a baseline, pad with top inset
(this follows from calculateBaseline which
does the same).
Components baseline fits within rows baseline.
Make sure the descent fits within the space as well.
It fits, we're good.
Doesn't fit, but it's resizable.  Try
again assuming we'll get ascent again.
Doesn't fit, use min size and original ascent
Reset the components y location based on
components ascent and baseline for row. Because ascent
includes the baseline
Off by 1
Baseline for the row
Component is resizable. Top edge is offset by top
inset, bottom edge on baseline.
Added for serial backwards compatibility (4348425)
## javac bug?
write out the *-Version header first, if it exists
write out all attributes except for the version
we wrote out earlier
continuation of previous line
ParserAdapter.java - adapt a SAX1 Parser to a SAX2 XMLReader.
Written by David Megginson
NO WARRANTY!  This class is in the public domain.
$Id: ParserAdapter.java,v 1.3 2004/11/03 22:53:09 jsuttor Exp $
Implementation of org.xml.sax.XMLReader.
Internal constants for the sake of convenience.
Implementation of org.xml.sax.DocumentHandler.
These are exceptions from the
first pass; they should be
ignored if there's a second pass,
but reported otherwise.
If we're not doing Namespace
processing, dispatch this quickly.
OK, we're doing Namespace processing.
First pass:  handle NS decls
Could be a declaration...
XML namespaces spec doesn't discuss "xmlnsf:oo"
(and similarly named) attributes ... at most, warn
Second pass: copy all relevant
attributes into the SAX2 AttributeList
using updated prefix bindings
XML namespaces spec doesn't discuss "xmlnsf:oo"
(and similarly named) attributes ... ignore
Yes, decl:  report or prune
note funky case:  localname can be null
when declaring the default prefix, and
yet the uri isn't null.
Not a declaration -- report
now handle the deferred exception reports
OK, finally report the event.
If we're not doing Namespace
processing, dispatch this quickly.
Split the name.
Internal utility methods.
catch an illegal "nonsense" state.
Inner class to wrap an AttributeList when not doing NS proc.
end of ParserAdapter.java
Get the two hexadecimal digits and convert that into int
Convert the integer to ASCII
shouldn't happen, but assume corrupted properties file
provide access to sun implementation
get the appropriate constructor and instantiate it
get a new instance
if the class name is not specified, use the default one
can't create a new object of this class
General Attribute Checking for elmNode declared locally
ref should be here.
get global decl
index is a particle index.
no children other than "annotation?" are allowed
not empty group, not empty particle
create a particle to contain this model group
General Attribute Checking for elmNode declared globally
must have a name
Create the group defi up-front, so it can be passed
to the traversal methods
must have at least one child
add global group declaration to the grammar
Add group declaration to grammar
also add it to extended map
name attribute is not there, don't return this group.
store groups redefined by restriction in the grammar so
that we can get at them at full-schema-checking time.
store in grammar
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of TabbedPaneTabAreaPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of TabbedPaneTabAreaPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
-- This file was mechanically generated: Do not edit! --
Fall through to malformed-input case
Skip erroneous input either way
Ensure progress; n might be 0!
read and discard the repository ID
write the repository ID
SNMP Runtime import
Have the XObject return its result as a NodeSetDTM.
Return the first node, or null
Execute the XPath, and have it return the result
Have the XObject return its result as a NodeSetDTM.
Execute the XPath, and have it return the result
Return a NodeList.
Since we don't have a XML Parser involved here, install some default support
for things like namespaces, etc.
because XPathContext is weak in a number of areas... perhaps
XPathContext should be done away with.)
Create an object to resolve namespace prefixes.
XPath namespaces are resolved from the input context node's document element
if it is a root node, or else the current context node (for lack of a better
resolution space, given the simplicity of this sample code).
Create the XPath object.
Execute the XPath, and have it return the result
Since we don't have a XML Parser involved here, install some default support
for things like namespaces, etc.
because XPathContext is weak in a number of areas... perhaps
XPathContext should be done away with.)
Create the XPath object.
Execute the XPath, and have it return the result
read system properties or jaxp.properties
internally, ordinal is used as index
Create a compiler object
Print usage if arguments are incorrect
Loop through arguments, compiling each
Compile regular expression
Output program as a nice, formatted character array
Compile program for pattern
Number of columns in output
Loop through program
End of column?
Print character as padded hex number
End of program block
Avoid using the heavy-weight java.math.BigDecimal
sign: 0 for vlaue 0; 1 for positive values; -1 for negative values
total digits. >= 1
integer digits when sign != 0
fraction digits when sign != 0
the string representing the integer part
the string representing the fraction part
whether the canonical form contains decimal point
these 4 variables are used to indicate where the integre/fraction
Deal with leading sign symbol if present
skip '+', so intStart should be 1
keep '-', so intStart is stil 0
skip leading zeroes in integer part
Find the ending position of the integer part
Not reached the end yet
the remaining part is not ".DDD", error
fraction part starts after '.', and ends at the end of the input
no integer part, no fraction part, error.
ignore trailing zeroes in fraction part
check whether there is non-digit characters in the fraction part
".00", treat it as "0"
these 2 variables are used to indicate where the integre start/end.
Deal with leading sign symbol if present
skip '+', so intStart should be 1
keep '-', so intStart is stil 0
skip leading zeroes in integer part
Find the ending position of the integer part
Not reached the end yet, error
no integer part, error.
"00", treat it as "0"
for -0.1, total digits is 1, so we need 3 extra spots
If (indentLevel * indentSpace) becomes >= maxLineLength, this will
get incremened instead of indentLevel to avoid indenting going greater
than line length.
Should not get here, but if we do it means we could not
find a newline string, use \n in this case.
Only increment to a certain point.
We can not break string, just track if a newline
is in it.
We can break chars if the length exceeds maxLength.
Need to break chars, find a place to split chars at,
from lastIndex to endIndex,
or maxLength - lineLength whichever is smaller
Found a place to break at.
No where good to break.
find the next whitespace, or write out the
maxBreak will be negative if current line too
Loop through known flags
Should be sufficient
Skip `index' lines of code
Both cases have a field default_offset in common
Last byte is a reserved space
Is `/' on all systems, even DOS
If string starts with `prefix' and contains no further dots
void can't be a method argument
Read all declarations between for `(' and `)'
current string position
Should never occur
Read return type after `)'
Should never occur
Read all declarations between for `(' and `)'
current string position
Read return type after `)'
Should never occur
Tack off the extra ", "
May be an empty string
Guess what this does
`old' found in str
String start offset
While we have something to replace
Skip `old'.length chars
append rest of string
Should not occur
This is the default, read just one char like `B'
Full class name
Look for closing `;'
"Lblabla;" `L' and `;' are removed
Shadows global var
Count opening brackets and look for optional size argument
The rest of the string denotes a `<field_type>'
Should never occur
just one digit, prepend '0'
Normalize to unsigned
A-Z, g-z, _, $
Import general CORBA classes
Import org.omg.CosNaming types
Adding escape for the "."
This is the end of all the occurence of '/' and hence come
out of the loop
If the '/' is found, first check whether it is
preceded by escape '\'
If not then set theIndices and increment theIndicesIndex
and also set the index else just ignore the '/'
This is done for the last component
If any of the above is true, then we create an invalid Name
Component to indicate that it is an invalid name.
The format could be XYZ (Without kind)
The format is .XYZ (Without ID)
This check is for the Namecomponent which is just "." meaning Id
and Kinds are null
No more '.', which means there is no Kind
If there is a AlphaNumeric character after a \
then include slash, as it is not intended as an
Do no Escape for characters in this list
process per scanline
use 16-bit precision in CMM
process each scanline
convert src scanline
color convert srcLine to dstLine
convert dst scanline
process per pixel
process each pixel
process each pixel
get src scanline
X, Y, Z
The array to hold all data
Number of elements in this list
clear this object
Iterator state - current node and direction.
Note: The current node and direction are sufficient to implement
the desired behaviour of the current pointer being _between_
two nodes. The fCurrentNode is actually the last node returned,
direction is whether the pointer is in front or behind this node.
(usually akin to whether the node was returned via nextNode())
(eg fForward = true) or previousNode() (eg fForward = false).
Note also, if removing a Node, the fCurrentNode
can be placed on a Node which would not pass filters.
Implementation Note: Note that the iterator looks at whatToShow
and filter values at each call, and therefore one _could_ add
setters for these values and alter them while iterating!
if root is null there is no next node.
the next node has not been accepted.
if last direction is not forward, repeat node.
else get the next node via depth-first
REVIST: should direction be set forward before null check?
nothing in the list. return null.
does node pass the filters and whatToShow?
if so, then the node is the current node.
no nodes, or no accepted nodes.
if the root is null, or the current node is null, return null.
repeat last node.
get previous node in backwards depth first order.
we are going backwards
if the new previous node is null, we're at head or past the root,
so return null.
check if node passes filters and whatToShow.
if accepted, update the current node, and return it.
there are no nodes?
Additions and removals in the underlying data structure may occur
before any iterations, and in this case the reference_node is null.
check if the removed node is an _ancestor_ of the
only check children if we visit children.
if hasChildren, return 1st child.
if Root has no kids
if hasSibling, return sibling
return parent's 1st sibling.
end of list, return null
if we're at the root, return null.
if 1st sibling, return parent
if sibling has children, keep getting last child of child.
Implementation note: Fix-up means setting the current node properly
after a remove.
normal case: there _are_ nodes following this in the iterator.
the last node in the iterator is to be removed,
so we set the current node to be the previous one.
add default recognized properties
null indicates that the parser is called directly, initialize them
This int and the any value are kept in sync at all times
The current position of a DynEnum is always -1.
The any doesn't have to be initialized. We have a default value in this case.
_REVISIT_: Fix Me
Sets the current position to -1 and sets the value of the enumerator
to the first enumerator value indicated by the TypeCode.
DynAny interface methods
Returns always 0 for DynEnum
Calling current_component on a DynAny that cannot have components,
such as a DynEnum or an empty exception, raises TypeMismatch.
DynEnum interface methods
Returns the value of the DynEnum as an IDL identifier.
Sets the value of the DynEnum to the enumerated value
whose IDL identifier is passed in the value parameter.
If value contains a string that is not a valid IDL identifier
for the corresponding enumerated type, the operation raises InvalidValue.
Returns the value of the DynEnum as the enumerated values ordinal value.
Enumerators have ordinal values 0 to n-1,
as they appear from left to right in the corresponding IDL definition.
Sets the value of the DynEnum as the enumerated values ordinal value.
If value contains a value that is outside the range of ordinal values
for the corresponding enumerated type, the operation raises InvalidValue.
The system should always have the platform default
convert to external encoding before hex conversion
converting to use uppercase letter as part of
the hex value if ch is a letter.
There can be one or more Endpoint's in the URL, so the return value is
This method will return true only in CorbanameURL, It is provided because
corbaname: URL needs special handling.
A debug method, which is not required for normal operation
default constructor (need to set content handler ASAP !)
Close output document
Now is time to send the startElement event
we've sent the official SAX attributes on their way,
now we don't need them anymore.
Output closing bracket - "]]>"
There are no longer any calls made to
m_lexHandler.startCDATA() without a balancing call to
so we set m_cdataTagOpen to false to remember this.
Close any open elements etc.
the prefix mapping applies to the child element (one deeper)
the prefix mapping applies to the current element
hack for XSLTC attribset16 test
that maps ns1 prefix to "" URI
/ from XSLTC
We do the first two things in flushPending() but we don't
close any open CDATA calls.
We have made a call to m_lexHandler.startCDATA() with
no balancing call to m_lexHandler.endCDATA()
so we set m_cdataTagOpen true to remember this.
time to generate characters event
Pass the processing instruction to the SAX handler
we don't want to leave serializer to fire off this event,
so do it here.
We have made a call to m_lexHandler.startCDATA() with
no balancing call to m_lexHandler.endCDATA()
so we set m_cdataTagOpen true to remember this.
Handle document type declaration (for first element only)
ensurePrefixIsDeclared depends on the current depth, so
the previous increment is necessary where it is.
add the attributes to the collected ones
do we really need this CDATA section state?
Bugzilla1133: Generate attribute as well as namespace event.
SAX does expect both.
Initializing the Character Flag Array
Code generated by: XML11CharGenerator.
Fill 8 of value (byte) 17
Fill 2 of value (byte) 17
Fill 18 of value (byte) 17
Fill 5 of value (byte) 33
Fill 6 of value (byte) 33
Fill 2 of value (byte) -87
Fill 10 of value (byte) -87
Fill 4 of value (byte) 33
Fill 26 of value (byte) -19
Fill 2 of value (byte) 33
Fill 26 of value (byte) -19
Fill 4 of value (byte) 33
Fill 6 of value (byte) 17
Fill 26 of value (byte) 17
Fill 23 of value (byte) 33
Fill 8 of value (byte) 33
Fill 23 of value (byte) -19
Fill 31 of value (byte) -19
Fill 520 of value (byte) -19
Fill 112 of value (byte) -87
Fill 14 of value (byte) -19
Fill 7297 of value (byte) -19
Fill 12 of value (byte) 33
Fill 2 of value (byte) -19
Fill 26 of value (byte) 33
Fill 22 of value (byte) 33
Fill 2 of value (byte) -87
Fill 47 of value (byte) 33
Fill 288 of value (byte) -19
Fill 2672 of value (byte) 33
Fill 1008 of value (byte) -19
Fill 17 of value (byte) 33
Fill 43007 of value (byte) -19
Fill 6400 of value (byte) 33
Fill 1232 of value (byte) -19
Fill 32 of value (byte) 33
Fill 526 of value (byte) -19
Public static methods
For CIEXYZ, min = 0.0, max = ALMOST_TWO for all components
For CIEXYZ, min = 0.0, max = ALMOST_TWO for all components
X, Y, Z
in case getMinVal is overridden
in case getMaxVal is overridden
When the m_readers.get() method is called for the first time
on a thread, a new XMLReader will automatically be created.
If the cached reader for this thread is in use, construct a new
one; otherwise, return the cached reader unless it isn't an
instance of the class set in the 'org.xml.sax.driver' property
According to JAXP 1.2 specification, if a SAXSource
is created using a SAX InputSource the Transformer or
TransformerFactory creates a reader via the
XMLReaderFactory if setXMLReader is not used
If unable to create an instance, let's try to use
the XMLReader from JAXP
pass along pce
Try to carry on if we've got a parser that
doesn't know about namespace prefixes.
Cache the XMLReader if this is the first time we've created
a reader for this thread.
reader is cached, but this property might have been reset
If the reader that's being released is the cached reader
for this thread, remove it from the m_isUse list.
Documented in Enumerated
Documented in Enumerated
Initialize the mapping tables.
Do not delegate to Math.toRadians(angdeg) because
this method has the strictfp modifier.
Do not delegate to Math.toDegrees(angrad) because
this method has the strictfp modifier.
Else the argument is either an integral value already XOR it
has to be rounded to one.
preserve sign info
E_min <= ilogb(a) <= 51
restore original sign
Indicates whether language-level access checks are overridden
by this object. Initializes to "false". This field is used by
Field, Method, and Constructor.
NOTE: for security purposes, this field must not be visible
outside this package.
Reflection factory used by subclasses for creating field,
method, and constructor accessors. Note that this is called
very early in the bootstrapping process.
Only annotations on classes are inherited, for all other
objects getDeclaredAnnotation is the same as
Only annotations on classes are inherited, for all other
objects getDeclaredAnnotationsByType is the same as
Shared access checking logic.
For non-public members or members in package-private classes,
it is necessary to perform somewhat expensive security checks.
If the security check succeeds for a given class, it will
always succeed (it is not affected by the granting or revoking
of permissions); we speed up the check in the common case by
remembering the last Class for which the check succeeded.
The simple security check for Constructor is to see if
the caller has already been seen, verified, and cached.
(See also Class.newInstance(), which uses a similar method.)
A more complicated security check cache is needed for Method and Field
or a caller (with target implicitly equal to this.clazz).
In the 2-array case, the target is always different from the clazz.
ACCESS IS OK
ACCESS IS OK
(Test cache[1] first since range check for [1]
subsumes range check for [0].)
Non-protected case (or obj.class == this.clazz).
ACCESS IS OK
If no return, fall through to the slow path.
Keep all this slow stuff out of line:
Success: Update the cache.
Note:  The two cache elements are not volatile,
but they are effectively final.  The Java memory model
guarantees that the initializing stores for the cache
elements will occur before the volatile write.
Add four bytes for the encaps length, not another 4 for the byte order
which is included in getPosition().
System.out.println("TypeCodeOutputStream.getTopLevelPosition using getTopLevelPosition " +
" + getPosition() " + getPosition() +
(isEncapsulation ? " + encaps length 4" : "") +
System.out.println("TypeCodeOutputStream.getTopLevelPosition returning getPosition() = " +
if (TypeCodeImpl.debug) System.out.println("Getting position " + ((Integer)typeMap.get(id)).intValue() +
Writes this streams buffer to the given OutputStream
without byte order flag and length as is the case for encapsulations.
Make sure to align s to 4 byte boundaries.
Unfortunately we can't do just this:
So we have to take the first four bytes given in firstLong and write them
with a call to write_long which will trigger the alignment.
Then write the rest of the byte array.
get bytes from DirectByteBuffer
NOTE: Microbenchmarks are showing it is faster to do
a loop of ByteBuffer.get(int) than it is to do
a bulk ByteBuffer.get(byte[], offset, length)
first entry in an encapsulation is the endianess
if (TypeCodeImpl.debug) System.out.println("TypeCodeOutputStream.getRealIndex using getTopLevelPosition " +
Returns the buffer trimmed of the trailing zeros and without the
known _kind value at the beginning.
Micro-benchmarks show that DirectByteBuffer.get(int) is faster
than DirectByteBuffer.get(byte[], offset, length).
REVISIT - May want to check if buffer is direct or non-direct
and use array copy if ByteBuffer is non-direct.
not already marked
don't postpone errors
don't postpone errors
n is deleted
b is deleted
n is deleted
b is deleted
n is deleted
b is deleted
restart if lost race to replace value
else c < 0; fall through
restart if lost race to append to b
test highest and lowest bits
try to grow by one level
hold in array and later pick the one to use
lost race to add level
find insertion points and splice in
compare before deletion check avoids needing recheck
n is deleted
b is deleted
retry via findNode
try to set
try to backout
all b's successors are deleted; retry
n is deleted
b is deleted
retry via findNode
n is deleted
b is deleted
proceed as far across as possible without overshooting
Control values OR'ed as arguments to findNear
Actually checked as !LT
n is deleted
b is deleted
Track the current rightmost node at each level. Uses an
ArrayList to avoid committing to initial or maximum level.
Write out the Comparator and any hidden stuff
Write out keys and values (alternating)
Read in the Comparator and any hidden stuff
It would not be worth all of the overhead to directly
unlink from here. Using remove is fast enough.
Factory methods for iterators needed by ConcurrentSkipListSet etc
Using size() here would be a pessimization.
Lazily initialized view holders
pass by markers and headers
adjust relation for direction
Almost the same as getNearEntry, except for keys
adjust relation for direction
default Map method overrides
exclusive upper bound for keys, or null if to end
the level to split out
current traversal node; initialize at origin
factory method for KeySpliterator
ensure h corresponds to origin p
Almost the same as keySpliterator()
Adapt or create a key-based comparator
Almost the same as keySpliterator()
almost same as key version
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of InternalFrameTitlePaneCloseButtonPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of InternalFrameTitlePaneCloseButtonPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
if(!(node instanceof com.sun.org.apache.xerces.internal.dom.NodeImpl))
I guess I should use JAXP factory here... when it's legal.
if(null != m_entityResolver)
Assume first that the nodes are DTM nodes, since discovering node
order is massivly faster for the DTM.
isNodeAfter will return true if node is after countedNode
in document order. The base isNodeAfter is sloooow (relatively).
This implementation assumes the META-INF/MANIFEST.MF entry
should be either the first or the second entry (when preceded
by the dir META-INF/). It skips the META-INF/ and then
"consumes" the MANIFEST.MF to initialize the Manifest object.
At this point, we might have parsed all the meta-inf
entries and have nothing to verify. If we have
nothing to verify, get rid of the JarVerifier object.
If the given classloader is null, we check if an
system classloader is available and (if so)
use that instead.
Note that calls on the system class loader will
look in the bootstrap class loader first.
We're not allowed to access the system class loader.
Try to find a serialized object with this name
Drop through and try opening the class.  But remember
the exception in case we can't find the class either.
No serialized object, try just instantiating the class
There is no appropriate class.  If we earlier tried to
deserialize an object and got an IO exception, throw that,
otherwise rethrow the ClassNotFoundException.
We have to remap the exception to one in our signature.
But we pass extra information in the detail message.
Ok, if the result is an applet initialize it.
Figure our the codebase and docbase URLs.  We do this
by locating the URL for a known resource, and then
massaging the URL.
First find the "resource name" corresponding to the bean
itself.  So a serialzied bean "a.b.c" would imply a
resource name of "a/b/c.ser" and a classname of "x.y"
would imply a resource name of "x/y.class".
Now get the URL correponding to the resource name.
If we found a URL, we try to locate the docbase by taking
of the final path name component, and the code base by taking
of the complete resourceName.
So if we had a resourceName of "a/b/c.class" and we got an
objectURL of "file:bert/classes/a/b/c.class" then we would
want to set the codebase to "file:bert/classes/" and the
docbase to "file:bert/classes/a/b/"
Setup a default context and stub.
now, if there is a BeanContext, add the bean, if applicable.
If it was deserialized then it was already init-ed.
Otherwise we need to initialize it.
We need to set a reasonable initial size, as many
applets are unhappy if they are started without
having been explicitly sized.
We don't currently support audio clips in the Beans.instantiate
applet context, unless by some luck there exists a URL content
class that can generate an AudioClip from the audio URL.
Otherwise it must be an ImageProducer.
We do nothing.
We do nothing.
We do nothing.
We do nothing.
We do nothing.
We do nothing.
use the root directory of the applet's class-loader
use the directory where we found the class or serialized object.
we do nothing.
Namespace prefix-to-uri mapping stuff
Stack used to keep track of what whitespace text nodes are protected
by xml:space="preserve" attributes and which nodes that are not.
empty String for null attribute values
empty iterator to be returned when there are no children
The number of expanded names
Namespace related stuff
The initial size of the text buffer
Tracks which textnodes are not escaped
The URI to this document
The owner Document when the input source is DOMSource.
The Map for org.w3c.dom.Node to node id mapping.
This is only used when the input is a DOMSource and the
buildIdIndex flag is true.
True if the input source is a DOMSource.
Support for access/navigation through org.w3c.dom API
This method only has a function in DOM adapters
end of TypedNamespaceIterator
Is there a prefix?
Local part of name is after colon.  lastIndexOf returns -1 if
there is no colon, so lNameStartIdx will be zero in that case.
Distinguish attribute and element names.  Attribute has @ before
local part of name.
Extract local name
Delegate the work to getMapping2 if the document is not fully built.
Some of the processing has to be different in this case.
primitive types map to themselves
actual mapping of caller requested names
primitive types map to themselves
caller's types map into appropriate dom types
When the document is not fully built, the searchOnly
flag should be set to false. That means we should add
the type if it is not already in the expanded name table.
primitive types map to themselves
actual mapping of caller requested names
Initialize all entries to -1
Use a smaller size for the space stack if the blocksize is small
If the input source is DOMSource, set the _document field and
create the node2Ids table.
Resize the _dontEscape BitArray if necessary.
Look for any xml:space attributes
Depending on the implementation of attributes, this
might be faster than looping through all attributes. ILENE
Revert to strip/preserve-space setting from before this element
Check if the URI already exists before pushing on stack
Get the node type and make sure that it is within limits
Most common case handled first
Create a nested iterator that will select nodes of
the principal node kind for the selected axis.
For "attribute::p:*", the principal node kind is
This covers "namespace::p:*".  It is syntactically
correct, though it doesn't make much sense.
In all other cases, the principal node kind is
Return only nodes that are in the selected namespace
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
end of NamespaceChildrenIterator
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
end of NamespaceAttributeIterator
Start element definition
if(isChild) => not to copy any namespaces  from parents
else copy all namespaces in scope
Copy element children
Close element definition
Shallow copy of attribute to output handler
Special handling for DOM input
Common UI methods
time to fire off endElement event
time to fire off processing instruction event
time to fire off comment event
Close output document
Now is time to send the startElement event
Handle document type declaration (for first element only)
time to fire off endElement event
time to fire off characters event
Close any open element
no namespace support for HTML
hack for XSLTC with finding URI for default namespace
the elements URI is not known yet, and it
doesn't have a prefix, and we are currently
setting the uri for prefix "", so we have
the uri for the element... lets remember it
end of FSM.java
MSC.syncAll will trigger a NPE
might be null
Hold a safe copy of argv in this.options
hash command and ignore possibly expensive options
hash location, className, data, and env
but omit props (may be expensive)
insure output is written
cycle detected; bail
cycle detected; bail
Verify that the Component is recursively enabled. Disabling a
heavyweight Container disables its children, whereas disabling
a lightweight Container does not.
In case stream ended early
this will call checkClosed() for us
this resets the MemoryCache
Empty finalizer: for performance reasons we instead use the
Disposer mechanism for ensuring that the underlying
MemoryCache is reset prior to garbage collection
That is below this
This is below that
serialVersionUID is not constant
Serialization compatibility stuff:
Two serial forms are supported in this class. The selected form
depends on system property "jmx.serial.form":
- "1.0" for JMX 1.0
- any other value for JMX 1.1 and higher
Serial version for old serial form
Serial version for new serial form
Serializable fields in old serial form
Serializable fields in new serial form
Actual serial version and serial form
OK: No compat with 1.0
END Serialization compatibility stuff
Dead code. Should never happen.
New serial form ignores extra field "currClass"
Serializes this instance in the old serial form
Serializes this instance in the new serial form
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of ToggleButtonPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of ToggleButtonPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
BEGIN: Keys needed for exception messages of  JAXP 1.3 XPath API implementation
END: Keys needed for exception messages of  JAXP 1.3 XPath API implementation
Note to translators:  A relative location path is a form of XPath expression.
The message indicates that such an expression was expected following the
characters '/' or '', but was not found.
Note to translators:  A location path is a form of XPath expression.
The message indicates that syntactically such an expression was expected,but
the characters specified by the substitution text were encountered instead.
Note to translators:  A location path is a form of XPath expression.
The message indicates that syntactically such a subexpression was expected,
but no more characters were found in the expression.
Note to translators:  A location step is part of an XPath expression.
The message indicates that syntactically such an expression was expected
following the specified characters.
Note to translators:  A node test is part of an XPath expression that is
used to test for particular kinds of nodes.  In this case, a node test that
consists of an NCName followed by a colon and an asterisk or that consists
of a QName was expected, but was not found.
Note to translators:  A step pattern is part of an XPath expression.
The message indicates that syntactically such an expression was expected,
but the specified character was found in the expression instead.
Note to translators: A relative path pattern is part of an XPath expression.
The message indicates that syntactically such an expression was expected,
but was not found.
Note to translators:  The substitution text is the name of a data type.  The
message indicates that a value of a particular type could not be converted
to a value of type boolean.
Note to translators: Do not translate ANY_UNORDERED_NODE_TYPE and
Note to translators: Do not translate UNORDERED_NODE_SNAPSHOT_TYPE and
Note to translators: This message indicates that the document being operated
upon changed, so the iterator object that was being used to traverse the
document has now become invalid.
Note to translators:  The substitution text is the name of a data type.  The
message indicates that a value of a particular type could not be converted
to a value of type string.
Note to translators: Do not translate snapshotItem,
UNORDERED_NODE_SNAPSHOT_TYPE and ORDERED_NODE_SNAPSHOT_TYPE.
Note to translators:  XPathEvaluator is a Java interface name.  An
XPathEvaluator is created with respect to a particular XML document, and in
this case the expression represented by this object was being evaluated with
respect to a context node from a different document.
Note to translators:  The XPath expression cannot be evaluated with respect
to this type of node.
BEGIN:  Definitions of error keys used  in exception messages of  JAXP 1.3 XPath API implementation
END:  Definitions of error keys used  in exception messages of  JAXP 1.3 XPath API implementation
Other miscellaneous text used inside the code...
================= INFRASTRUCTURE ======================
The available constants for startingPointCall
The available constants for endingPointCall
The current retry request status.  True if this request is being
retried and this info object is to be reused, or false otherwise.
The number of times this info object has been (re)used.  This is
incremented every time a request is retried, and decremented every
time a request is complete.  When this reaches zero, the info object
is popped from the ClientRequestInfoImpl ThreadLocal stack in the ORB.
The RequestImpl is set when the call is DII based.
The DII query calls like ParameterList, ExceptionList,
ContextList will be delegated to RequestImpl.
Sources of client request information
key = Integer, value = IOP.ServiceContext.
key = Integer, value = IOP.ServiceContext.
key = Integer, value = TaggedComponent
Please keep these in the same order that they're declared above.
Do not reset entryCount because we need to know when to pop this
from the stack.
Clear cached attributes:
Method IDs for all methods in ClientRequestInfo.  This allows for a
convenient O(1) lookup for checkAccess().
ClientRequestInfo validity table (see ptc/00-08-06 table 21-1).
Note: These must be in the same order as specified in contants.
s_req = send_request     r_rep = receive_reply
s_pol = send_poll        r_exc = receive_exception
r_oth = receive_other
A true value indicates call is valid at specified point.
A false value indicates the call is invalid.
NOTE: If the order or number of columns change, update
access is currently valid for all states:
access is currently valid for all states:
Note: This is not necessarily the same as locatedIOR.
Reason: See the way we handle COMM_FAILURES in
REVISIT - get through chain like getLocatedIOR helper below.
access is currently valid for all states:
Good citizen: In the interest of efficiency, we assume interceptors
will not modify the returned TaggedProfile in any way so we need
not make a deep copy of it.
Good citizen: In the interest of efficiency, we assume interceptors
will not modify the returned Any in any way so we need
not make a deep copy of it.
Note: exception should never be null here since we will
throw a BAD_INV_ORDER if this is not called from
_REVISIT_ We need to be able to handle a UserException in the
DII case.  How do we extract the ID from a UserException?
Look in cache:
null could mean we cached null or not in cache.
Not in cache.  Get it from the profile:
As per ptc/00-08-06, section 21.3.13.6., If not found, raise
BAD_PARAM with minor code INVALID_COMPONENT_ID.
Good citizen: In the interest of efficiency, we will assume
interceptors will not modify the returned TaggedCompoent[], or
the TaggedComponents inside of it.  Otherwise, we would need to
clone the array and make a deep copy of its contents.
_REVISIT_ Our ORB is not policy-based at this time.
NOTE: When adding a method, be sure to:
1. Add a MID_* constant for that method
2. Call checkAccess at the start of the method
3. Define entries in the validCall[][] table for interception points.
access is currently valid for all states:
access is currently valid for all states:
If it is DII request then get the arguments from the DII req
and convert that into parameters.
Good citizen: In the interest of efficiency, we assume
interceptors will be "good citizens" in that they will not
modify the contents of the Parameter[] array.  We also assume
they will not change the values of the containing Anys.
Get the list of exceptions from DII request data, If there are
no exceptions raised then this method will return null.
Good citizen: In the interest of efficiency, we assume
interceptors will be "good citizens" in that they will not
modify the contents of the TypeCode[] array.  We also assume
they will not change the values of the containing TypeCodes.
Get the list of contexts from DII request data, If there are
no contexts then this method will return null.
Good citizen: In the interest of efficiency, we assume
interceptors will be "good citizens" in that they will not
modify the contents of the String[] array.
Get the list of contexts from DII request data, If there are
no contexts then this method will return null.
_REVISIT_ The API for get_values is not compliant with the spec,
Revisit this code once it's fixed.
_REVISIT_ Our ORB doesn't support Operation Context, This code
will not be excerscised until it's supported.
The first parameter in get_values is the start_scope which
if blank makes it as a global scope.
The second parameter is op_flags which is set to RESTRICT_SCOPE
As there is only one defined in the spec.
The Third param is the pattern which is '*' requiring it to
get all the contexts.
The String[] array will contain Name and Value for each
context and hence double the size in the array.
Good citizen: In the interest of efficiency, we assume
interceptors will be "good citizens" in that they will not
modify the contents of the String[] array.
Get the result from the DII request data.
Good citizen: In the interest of efficiency, we assume that
interceptors will not modify the contents of the result Any.
Otherwise, we would need to create a deep copy of the Any.
access is currently valid for all states:
Check to make sure we are in LOCATION_FORWARD
state as per ptc/00-08-06, table 21-1
Do not cache this value since if an interceptor raises
forward request then the next interceptor in the
list should see the new value.
REVISIT - this most likely causes reportRedirect to happen twice.
Once here and once inside the request dispatcher.
In the event this is called from a oneway, we will have no
In the event this is called after a IIOPConnection.purgeCalls,
we will have a response object, but that object will
not contain a header (which would hold the service context
container).  See bug 4624102.
REVISIT: this is the only thing used
from response at this time.  However, a more general solution
would avoid accessing other parts of response's header.
Instead of throwing a NullPointer, we will
"gracefully" handle these with a BAD_PARAM with minor code 25.
REVISIT how this is programmed - not what it does.
See purge calls test.  The waiter is woken up by the
call to purge calls - but there is no reply containing
Override RequestInfoImpl connection to work in framework.
REVISIT - so mediator can handle DII in subcontract.
Clear cached values:
Make sure currentPoint matches the appropriate index in the
Check the validCall table:
End of file.
octet strings with very first bit = 0 and length != 12 octets
Deal with address
No need to go further, no port.
Deal with port
No need to go further, no port.
No need to go further, no iana.
Deal with iana
No need to go further, no port.
Get the number of bits required to represent an int.
Convert an int value to WBMP multi-byte format.
default wbmp level
If the data are not formatted nominally then reformat.
If the data are not formatted nominally then reformat.
Check whether the image is white-is-zero.
Get the line stride, bytes per row, and data array.
Write WBMP header.
Write the data.
Write the entire image.
Write the image row-by-row.
White-is-zero: need to invert data.
do not fallback if given classloader can't find the class, throw exception
do not fallback if given classloader can't find the class, throw exception
return (upper << 32) + lower
Get 2 digits/iteration using longs until quotient fits into an int
Get 2 digits/iteration using ints
Fall thru to fast mode for smaller numbers
r = i2-(q2*10) ...
Requires positive x
Possible leading "+" or "-"
Cannot have lone "+" or "-"
Accumulating negatively avoids surprises near MAX_VALUE
Long.MAX_VALUE in Character.MAX_RADIX is 13 digits
Long.MAX_VALUE in base 10 is 19 digits
No need for range checks on len due to testing above.
Handle sign, if present
Handle radix specifier, if present
If number is Long.MIN_VALUE, we'll end up here. The next line
handles this case, and causes any genuine format error to be
Answer must be 0 or 1 depending on relative magnitude
of dividend and divisor.
Both inputs non-negative
Avoid explicit check for 0 divisor
HD, Figure 3-1
HD, Section 2-1
HD, Figure 5-6
HD, Figure 5-14
HD, Figure 5-14
HD, Figure 7-1
HD, Section 2-7
As this instance is immutable,
these two values need only be calculated once.
must prevent NPE here - we will throw IAE later on if
returnOpenType is null
must prevent NPE here - we will throw IAE later on if
returnOpenType is null
check parameters that should not be null or empty
(unfortunately it is not done in superclass :-( ! )
Converts an array of OpenMBeanParameterInfo objects extending
MBeanParameterInfo into an array of MBeanParameterInfo.
may throw an ArrayStoreException
Converts an array of MBeanParameterInfo objects implementing
OpenMBeanParameterInfo into an array of OpenMBeanParameterInfo.
may throw an ArrayStoreException
[JF]: should we add constructor with java.lang.reflect.Method
method parameter ?  would need to add consistency check between
OpenType<?> returnOpenType and method.getReturnType().
if obj is null, return false
if obj is not a OpenMBeanOperationInfo, return false
Now, really test for equality between this
OpenMBeanOperationInfo implementation and the other:
their Name should be equal
their Signatures should be equal
their return open types should be equal
their impacts should be equal
All tests for equality were successfull
Calculate the hash code value if it has not yet been done
(ie 1st call to hashCode())
return always the same hash code for this instance (immutable)
Calculate the hash code value if it has not yet been done
(ie 1st call to toString())
return always the same string representation for this
This constructor will construct the expected default Descriptor.
These message should be read from a locale-specific resource bundle
This should never happen.
REVISIT - this is done in SocketOrChannelConnectionImpl
End of file.
Use known fast path.
Commonly used strings
2-byte length reduces max to 65533
Format shared between image and stream formats
Just check if it appears in the format
Ordered Map keyed by args hash, ordered by most recent accessed entry.
Maximum number of pixels to cache, this is used if maxCount
Maximum cached image size in pxiels
The current number of pixels stored in the cache
Lock for concurrent access to map
Reference queue for tracking lost softreferences to images in the cache
8Mb of pixels
check reference has not been lost and the key truly matches, in case of false positive hash match
check if currently in map
clear out old
add new image to pixel count
clean out lost references if not enough space
remove old items till there is enough free space
finaly put new in map
remind - need a floating point version
methods associated with creation-time state
methods associated with the GlyphVector as a whole
general utility methods
GETTERS AND SETTERS
do not instantiate
handy shared exception makers (they simplify the common case code)
application shutdown hooks cannot be added if
shutdown is in progress.
XmlRootElement allows this class to be marshalled on its own
should be changed to package private, keeping original modifier to keep backwards compatibility
default constructor forbidden ...
should be private, keeping original modifier to keep backwards compatibility
private but necessary properties for databinding
attributes and elements are not private for performance reasons
(JAXB can bypass reflection)
--- View methods ---------------------------------------------
--- member variables ------------------------------------------------
Type-specific CORBA::Object operations
longest to shortest
Stand-alone isn't applicable to era names.
Narrow names may have duplicated names, such as "J" for January, Jun, July.
Get names one by one in that case.
Narrow names may have duplicated names, such as "S" for Sunday and Saturday.
Get names one by one in that case.
Stand-alone isn't applicable to AM/PM.
The order of keys must correspond to the TextStyle.values() order.
null marker for map
TODO: BUG: this has no effect
not parsable, try next style
Copyright (c) 1995-96 by Cisco Systems, Inc.
Handle the Object public methods.
Create this first to verify target/action are non-null
avoid use of BCP
serialVersionUID not constant
Serialization compatibility stuff:
Two serial forms are supported in this class. The selected form depends
on system property "jmx.serial.form":
- "1.0" for JMX 1.0
- any other value for JMX 1.1 and higher
Serial version for old serial form
Serial version for new serial form
Serializable fields in old serial form
Serializable fields in new serial form
Actual serial version and serial form
OK: No compat with 1.0
END Serialization compatibility stuff
Read an object serialized in the old serial form
Read an object serialized in the new serial form
Serializes this instance in the old serial form
Serializes this instance in the new serial form
Create a new IOR with the magic of INIT
If there is a location forward then you will need
to invoke again on the updated information.
Just calling this same routine with the same host/port
does not take the location forward info into account.
The only reason a null objref is passed is to get the version of
invoke used by streams.  Otherwise the PortableInterceptor
call stack will become unbalanced since the version of
invoke which only takes the stream does not call
PortableInterceptor ending points.
Note that the first parameter is ignored inside invoke.
XXX log this
NOTE: do note trap and ignore errors.
Let them flow out.
NOTE: do note trap and ignore errors.
Let them flow out.
length is 2 bytes
Raw segment data, used for unrecognized segments
Set to true if the tag is not recognized
tag plus length
JPEG length includes itself, we don't
Now that we know the true length, ensure that we've got it,
or at least a bufferful if length is too big.
The type of node should have been verified already.
get the attribute and assign it to the tag
get the user object and clone it to the data
This is really only called if we're using ocean.
This is really only called if we're using ocean.
Disabled rollover effect.
Ocean renders the focus in a different way, this
would be redundant.
This is here because of a bug in the compiler.
When a protected-inner-class-savvy compiler comes out we
should move this into MetalComboBoxLayoutManager.
These two methods were overloaded and made public. This was probably a
mistake in the implementation. The functionality that they used to
provide is no longer necessary and should be removed. However,
removing them will create an uncompatible API change.
This method was overloaded and made public. This was probably
mistake in the implementation. The functionality that they used to
provide is no longer necessary and should be removed. However,
removing them will create an uncompatible API change.
to avoid a compilation dependency.
override with covariant return type
override for return type
locBytes is null if no annotations
read in all fields
must have been a null object
locBytes is null if no annotations
if either is a ref to null, both must be
quick, easy test
!! There is talk about adding an array comparision method
!! at 1.2 -- if so, this should be rewritten.  -arnold
this flag is set to true after EOF has reached
XXX Needs to be turned into LocalObjectImpl.
Standard OMG operations.
Implementation operations used by POA package.
If is OK for the servant to be null.
This could happen if POAImpl.getServant is called but
POAImpl.internalGetServant throws an exception.
This is public so we can test the stack balance.
It is not a security hole since this same info can be obtained from
The completion status is maybe because this could happen
after the servant has been invoked.
Force this to be implemented.
public Object  getCellEditorValue()
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
$Id: XPathImpl.java,v 1.2 2005/08/16 22:41:08 jeffsuttor Exp $
By default Extension Functions are allowed in XPath Expressions. If
Secure Processing Feature is set on XPathFactory then the invocation of
extensions function need to throw XPathFunctionException
we'd really like to cache those DocumentBuilders, but we can't because:
1. thread safety. parsers are not thread-safe, so at least
we need one instance per a thread.
2. parsers are non-reentrant, so now we are looking at having a
pool of parsers.
3. then the class loading issue. The look-up procedure of
DocumentBuilderFactory.newInstance() depends on context class loader
and system properties, which may change during the execution of JVM.
so we really have to create a fresh DocumentBuilder every time we need one
this should never happen with a well-behaving JAXP implementation.
If item is null, then we will create a a Dummy contextNode
Checking if requested returnType is supported. returnType need to
be defined in XPathConstants
If VariableResolver returns null Or if we get
NullPointerException at this stage for some other reason
then we have to reurn XPathException
For any other exceptions we need to throw
XPathExpressionException ( as per spec )
XPathConstants.NODESET ---ORdered, UNOrdered???
Return the first node, or null
Can have errorListener
Checking validity of different parameters
Checking if requested returnType is supported.
returnType need to be defined in XPathConstants
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of TreeCellPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of TreeCellPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
As of 1.6 Swing handles scheduling of paint events from native code.
That is, SwingPaintEventDispatcher is invoked on the toolkit thread,
which in turn invokes nativeAddDirtyRegion.  Because this is invoked
from the native thread we can not invoke any public methods and so
we introduce these added maps.  So, any time nativeAddDirtyRegion is
invoked the region is added to hwDirtyComponents and a work request
is scheduled.  When the work request is processed all entries in
this map are pushed to the real map (dirtyComponents) and then
painted with the rest of the components.
List of Runnables that need to be processed before painting from AWT.
Support for both the standard and volatile offscreen buffers exists to
provide backwards compatibility for the [rare] programs which may be
calling getOffScreenBuffer() and not expecting to get a VolatileImage.
Swing internally is migrating to use *only* the volatile image buffer.
Support for standard offscreen buffer
Whether or not a VolatileImage should be used for double-buffered painting
The maximum number of times Swing will attempt to use the VolatileImage
buffer during a paint operation.
BufferStrategyPaintManager has the unique characteristic that it
must deal with the buffer being lost while painting to it.  For
example, if we paint a component and show it and the buffer has
become lost we must repaint the whole window.  To deal with that
the PaintManager calls into repaintRoot, and if we're still in
the process of painting the repaintRoot field is set to the JRootPane
and after the current JComponent.paintImmediately call finishes
paintImmediately will be invoked on the repaintRoot.  In this
way we don't try to show garbage to the screen.
Note: DisplayChangedRunnable passes in null as the component, so if
component is ever used to determine the current
RepaintManager, DisplayChangedRunnable will need to be modified
Because we can't know what a subclass is doing with the
volatile image we immediately punt in subclasses.  If this
poses a problem we'll need a more sophisticated detection algorithm,
If native doublebuffering is being used, do NOT use
Queue a Runnable to invoke paintDirtyRegions and
Component was already marked as dirty, region has been
extended, no need to continue.
Note: We can't synchronize around this, Frame.getExtendedState
is synchronized so that if we were to synchronize around this
it could lead to the possibility of getting locks out
of order and deadlocking.
Iconified frames are still visible!
In between last check and this check another thread
queued up runnable, can bail here.
Queue a Runnable to invoke paintDirtyRegions and
This is called from the toolkit thread when a native expose is
This is called from the toolkit thread when awt needs to run a
Runnable before we paint.
A non-null r implies c is already marked as dirty,
and that the parent is valid. Therefore we can
just union the rect and bail.
This'll only happen if a subclass isn't correctly dealing
swap for thread safety
Sometimes when RepaintManager is changed during the painting
we may get null here, see #6995769 for details
If the Graphics goes away, it means someone disposed of
the window, don't do anything.
If the repaintRoot has been set, service it now and
remove any components that are children of repaintRoot.
Only service repaintRoot once.
Find the highest parent which is dirty.  When we get out of this
rootDx and rootDy will contain the translation from the
rootDirtyComponent's coordinate system to the coordinates of the
original dirty component.  The tmp Rect is also used to compute the
visible portion of the dirtyRect.
System.out.println("Collect dirty component for bound " + tmp +
If we haven't seen this root before, then we need to add it to the
list of root dirty Views.
If the window is non-opaque, it's double-buffered at peer's level
If the window is non-opaque, it's double-buffered at peer's level
JComponent will inform us when it is no longer valid
(via removeNotify) we have no such hook to other components,
therefore we don't keep a ref to the Component
(indirectly through the Image) by stashing the image.
Clear out the VolatileImages
Paint methods.  You very, VERY rarely need to invoke these.
They are invoked directly from JComponent's painting code and
when painting happens outside the normal flow: DefaultDesktopManager
and JViewport.  If you end up needing these methods in other places be
careful that you don't get stuck in a paint loop.
We're painting to two threads at once.  PaintManager deals
with this a bit better than BufferStrategyPaintManager, use
it to avoid possible exceptions/corruption.
null case handled in setPaintManager
First attempt to use VolatileImage buffer for performance.
If this fails (which should rarely occur), fallback to a
standard Image buffer.
VolatileImage painting loop failed, fallback to regular
Empty non private constructor was added because access to this
class shouldn't be generated by the compiler using synthetic
To avoid threading problems, we notify each RepaintManager
on the thread it was created on.
If true, we're wainting on the EventQueue.
First pass, flush any heavy paint events into real paint
events.  If there are pending heavy weight requests this will
result in q'ing this request up one more time.  As
long as no other requests come in between now and the time
the second one is processed nothing will happen.  This is not
ideal, but the logic needed to suppress the second request is
more headache than it's worth.
Do the actual validation and painting.
XMLReaderFactory.java - factory for creating a new reader.
Written by David Megginson
and by David Brownell
NO WARRANTY!  This class is in the Public Domain.
$Id: XMLReaderFactory.java,v 1.2.2.1 2005/07/31 22:48:08 jeffsuttor Exp $
1. try the JVM-instance-wide system property
2. if that fails, try META-INF/services/
If no provider found then try the current ClassLoader
No Context ClassLoader, try the current ClassLoader
3. Distro-specific fallback
or a $JAVA_HOME/jre/lib/*properties setting...
do we know the XMLReader implementation class yet?
4. panic -- adapt any SAX1 parser
the locator containing line/column information
namespace context, needed for producing
representations of annotations
Reference to the current annotation element.
where an annotation element itself begins
-1 means not in an annotation's scope
-1 means not in the scope of either of the two elements.
The current element depth
Use to report the error when characters are not allowed.
fields for generate-synthetic annotations feature
To debug the DOM created uncomment the line below
when it's not within xs:appinfo or xs:documentation
and there is a non-whitespace character
the string we saw: starting from the first non-whitespace character.
report an error
don't call super.characters() when it's not within one of the 2
annotation elements: the traversers ignore them anyway. We can
save time/memory creating the text nodes.
when it's within either of the 2 elements, characters are allowed
and we need to store them.
while it is true that non-whitespace character data
may only occur in appInfo or documentation
elements, it's certainly legal for comments and PI's to
occur as children of annotation; we need
to account for these here.
avoid falling through; don't call startElement in this case
the order of events that occurs here is:
schemaDOM.startAnnotation/startAnnotationElement (if applicable)
schemaDOM.emptyElement  (basically the same as startElement then endElement)
schemaDOM.endAnnotationElement (if applicable)
the order of events that would occur if this was <element></element>:
schemaDOM.startAnnotation/startAnnotationElement (if applicable)
schemaDOM.endAnnotationElement (if applicable)
Thus, we can see that the order of events isn't the same.  However, it doesn't
seem to matter.  -- PJM
this is messed up, but a case to consider:
this is messed up, but a case to consider:
when we reach the endElement of xs:appinfo or xs:documentation,
change fInnerAnnotationDepth to -1
inside a child of annotation
not in an annotation at all
unlikely to be called, but you never know...
only deal with CDATA boundaries within an annotation.
only deal with CDATA boundaries within an annotation.
Since we implement Cloneable, this should never happen
Inner class FlipContents
Inner class FlipContents
Make sure class cannot be instantiated
This no longer will work right since the DTM.
First use reflection to try to load Which, which is a
better version of EnvironmentCheck
If reflection failed, fallback to our internal EnvironmentCheck
Use reflection to try to find xml-commons utility 'Which'
Fully qualify names since this is the only method they're used in
Call the method with our Hashtable, common options, and ignore return value
Create a parent to hold the report and append hash to it
Simply return null; no need to report error
Locked, MUST be power of two in current code
Debugging tip: Cranking lowbits down to 4 or so is a good
way to pound on the array addressing code.
How many bits address within chunks
Grow if needed
Check that the node at index "position" is not an ancestor
of the node at index "startPos". IF IT IS, DO NOT ACCEPT IT AND
RETURN -1. If position is NOT an ancestor, return position.
Special case: The Document node (position==0) is acceptable.
This test supports DTM.getNextPreceding.
We have to look all the way up the ancestor chain
to make sure we don't have an ancestor.
Get the node whose index == ancestor
Get that node's parent (Note that this assumes w[1]
is the parent node index. That's really a DTM feature
rather than a ChunkedIntArray feature.)
Grow if needed
Grow if needed
For now, just do a simple append.  A sorted insert only
makes sense if we're doing an binary search or some such.
$$fb 2002-04-12: fix for 4667258: behavior of Mixer.getMaxLines(Line.Info) method doesn't match the spec
Set up JavaIOFileDescriptorAccess in SharedSecrets
first caller gets to do this
HeadlessException will be thrown from MenuComponent's readObject
construct a string datatype validator
Unused at the moment
XML 1.0 components
XML 1.1 components
create a vector to hold all the components in use
XML 1.0 specialized components
XML 1.1 specialized components
Common components for XML 1.1. and XML 1.0
create table for features and properties
add default recognized features
set state for default features
add default recognized properties
add message formatters
REVISIT: What is the right thing to do? -Ac
REVISIT: this method used to reset all the components and
construct the pipeline. Now reset() is called
in parse (boolean) just before we parse the document
Should this method still throw exceptions..?
REVISIT: Should this be a property?
REVISIT - need to add new error message
close all streams opened by xerces
reset and configure pipeline and set InputSource.
mark configuration as fixed
resets and sets the pipeline.
make this feature special
forward to every XML 1.0 component
forward it to common components
forward to every XML 1.1 component
save state if noone "objects"
forward to every XML 1.0 component
forward it to every common Component
forward it to every XML 1.1 component
store value if noone "objects"
reset common components
reset every component
setup DTD pipeline
setup XML 1.1 document pipeline
non namespace document pipeline
use XML 1.0 datatype library
setup DTD pipeline
setup document pipeline
features and properties
Allows the parser to validate a document only when it
contains a grammar. Validation is turned on/off based
on each document instance, automatically.
special performance feature: only component manager is allowed to set it.
Value type: String
Get the literal string of characters associated with the
current event.  If the parser recognises and supports this
property but is not currently parsing text, it should return
null (this is a good way to check for availability before the
REVISIT - we should probably ask xml-dev for a precise
definition of what this is actually supposed to return, and
in exactly which circumstances.
don't add a component more than once
don't add a component more than once
don't add a component more than once
register component's recognized features
register component's recognized properties
set default values
Do not overwrite values already set on the configuration.
For newly added components who recognize this feature
but did not offer a default value, we need to make
sure these components will get an opportunity to read
the value before parsing begins.
Do not overwrite values already set on the configuration.
For newly added components who recognize this property
but did not offer a default value, we need to make
sure these components will get an opportunity to read
the value before parsing begins.
create datatype factory
setup XML 1.1 DTD pipeline
setup XML 1.1. document pipeline - namespace aware
Insert the default binding for xmlns.
put them rendered?
Put the number of namespace definitions in the stack.
There is no definition for the prefix(a bug?).
No need to render an entry already rendered.
Mark this entry as render.
Return the node for outputing.
If we have it previously defined. Don't keep working.
Creates and entry in the table for this new definition.
We have a previous definition store it for the pop.
Check if a previous definition(not the inmidiatly one) has been rendered.
Yes it is. Mark as rendered.
abs of index
Some standard tags
bugId 4641746: 0, 1, and 2 are legal values.
This is the byte array containing the encoding.
This is the index of the first byte of the encoding.
It is initialized to <CODE>bytes.length</CODE> and decrease each time
an value is put in the encoder.
This is the stack where end of sequences are kept.
A value is computed and pushed in it each time the <CODE>openSequence</CODE> method
A value is pulled and checked each time the <CODE>closeSequence</CODE> method is called.
--- FocusListener methods --------------------------
we already done selection for this
--- MouseListener methods -----------------------------------
mouse 1 behavior
mouse 2 behavior
paste system selection, if it exists
platform supports system selections, update it.
clipboard was unavailable
do nothing... there is no system clipboard
--- MouseMotionListener methods -------------------------
---- Caret methods ---------------------------------
We seem to have gotten out of sync and no longer
contain the right location, adjust accordingly.
Clip doesn't contain the old location, force it
to be repainted lest we leave a caret around.
This will potentially cause a repaint of something
we're already repainting, but without changing the
semantics of damage we can't really get around this.
see if we should paint a flag to indicate the bias
of the caret.
PENDING(prinz) this should be done through
protected methods so that alternative LAF
will show bidi information.
there are multiple directions present.
can't render I guess
if the component already has focus, it won't
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
focus lost notification can come in later after the
caret has been deinstalled, in which case the component
will be null.
repaint the caret
hmm... not legally positioned
---- Bidi methods (we could put these in a subclass)
don't allow selection on disabled components.
if p0 == p1 then there should be no highlight, remove it if necessary
otherwise, change or add the highlight
move dot, if it changed
The position (0,Backward) is out of range so disallow it.
There is an abiguous case here. That if your model looks like:
abAB with the cursor at abB]A (visual representation of
3 forward) deleting could either become abB] or
ab[B. I'ld actually prefer abB]. But, if I implement that
a delete at abBA] would result in aBA] vs a[BA which I
think is totally wrong. To get this right we need to know what
was deleted. And we could get this from the bidi structure
in the change event. So:
PENDING: base this off what was deleted.
---- local methods --------------------------------------------
repaint the old position and set the new value of
Make sure the caret is visible if this window has the focus.
notify listeners at the caret moved
We try to repaint the caret later, since things
may be unstable at the time this is called
(i.e. we don't want to depend upon notification
order or the fact that this might happen on
an unsafe thread).
determine the new location and scroll if
If there is no magic caret position, make one
repaint the new position
fix for 4793761
clipboard was unavailable
no need to provide error feedback to user since updating
the system selection is not a user invoked action
do nothing... there is no system clipboard
do nothing... there is no allowed system clipboard
Current location is bogus and filter likely vetoed the
change, force the reset without giving the filter a
chance at changing it.
Rectangle.contains returns false if passed a rect with a w or h == 0,
this won't (assuming X,Y are contained with this rectangle).
At least one of the dimensions is negative...
Note: if any dimension is zero, tests below must return false...
X+W overflowed or W was zero, return false if...
either original w or W was zero or
x+w did not overflow or
the overflowed x+w is smaller than the overflowed X+W
X+W did not overflow and W was not zero, return false if...
original w was zero or
x+w did not overflow and x+w is smaller than X+W
--- serialization ---------------------------------------------
---- member variables ------------------------------------------
package-private to avoid inner classes private member
--- ActionListener methods ----------------------------------
setVisible(true) will cause a scroll, only do this if the
new location is really valid.
--- DocumentListener methods --------------------------------
Due this test in case the filter vetoed the
change in which case this probably won't be
Due this test in case the filter vetoed the change
in which case this probably won't be valid either.
--- PropertyChangeListener methods -----------------------
SAX exception class.
No warranty; no copyright -- use this as you will.
$Id: SAXException.java,v 1.3 2004/11/03 22:55:32 jsuttor Exp $
Added serialVersionUID to preserve binary compatibility
end of SAXException.java
the object we are guarding
General Attribute Checking
create identity constraint
return this array back to pool
it's XSDElementTraverser's job to ensure that there's no
duplication (or if there is that restriction is involved
and there's identity).
If errors occurred in traversing the identity constraint, then don't
add it to the schema, to avoid errors when processing the instance.
and stuff this in the grammar
and fix up attributeChecker
REVISIT: maybe return void (or MessageMediator).
End of file.
Initialized to 1 to avoid divide by zero in averageTimeInQueue()
Name of the work queue
MonitoredObject for work queue
Setup monitoring for this workqueue
Package private method to get the monitored object for this
End of file.
-- This file was mechanically generated: Do not edit! --
These fields are declared here rather than in Heap-X-Buffer in order to
reduce the number of virtual method invocations needed to access these
values, which is especially costly when coding small buffers.
Non-null only for heap buffers
Valid only for heap buffers
Creates a new buffer with the given mark, position, limit, capacity,
backing array, and array offset
Creates a new buffer with the given mark, position, limit, and capacity
-- Singleton get/put methods --
-- Bulk get operations --
-- Bulk put operations --
-- Other stuff --
-- Other char stuff --
-- Other byte stuff: Access to binary data --
Unchecked accessors, for use by ByteBufferAs-X-Buffer classes
Name of this function call
Arguments to this function call (might not be any)
Empty argument list, used for certain functions
Valid namespaces for Java function-call extension
Namespace format constants
External Java function's class/method/signature
Encapsulates all unsupported external function calls
If FunctionCall is a external java constructor
If the java method is static
Legal conversions between internal and Java types.
Legal conversions between Java and internal types.
The mappings between EXSLT extension namespaces and implementation classes
Extension functions that are implemented in BasisLibrary
-- Internal to Java --------------------------------------------
Type.Int must be the same as Type.Real
Possible conversions between Java and internal types
Conversions from org.w3c.dom.Node/NodeList to internal NodeSet
Initialize the extension namespace table
Initialize the extension function table
Handle extension functions (they all have a namespace)
Constructor not found in this class
Try all constructors
Check if all parameters to this constructor can be converted
Convert from internal (translet) type to external (Java) type
no mapping available
check if function is a contructor 'new'
check if we are calling an instance method
use "Int" as "unknown"
Method not found in this class
Try all methods to identify the best fit
reset internal type
Check if all paramteters to this method can be converted
Convert from internal (translet) type to external (Java) type
no mapping available
Allow a Reference type to match any external (Java) type at
the moment. The real type checking is performed at runtime.
Check if the return type can be converted
Use this method if all parameters & return type match
It is an error if the chosen method is an instance menthod but we don't
have a this argument.
Translate calls to methods in the BasisLibrary
append "F" to the function's name
Special precautions for some method calls
Invoke the method in the basis library
Add call to BasisLibrary.unresolved_externalF() to generate
run-time error message for unsupported external functions
Backwards branches are prohibited if an uninitialized object is
on the stack by section 4.9.4 of the JVM Specification, 2nd Ed.
We don't know whether this code might contain backwards branches
so we mustn't create the new object until after we've created
the suspect arguments to its constructor.  Instead we calculate
the values of the arguments to the constructor first, store them
in temporary variables, create the object and reload the
arguments from the temporaries to avoid the problem.
Convert the argument to its Java type
Convert the return type back to our internal type
Invoke function calls that are handled in separate classes
Push "this" if it is an instance method
Convert the argument to its Java type
Convert the return type back to our internal type
Check if FSP and SM - only then proceed with loading
Is it public and same number of args ?
Is it public, static and same number of args ?
this shouldn't happen, since we are Cloneable
Used when calling an object's writeObject method
If using RMI-IIOP stream format version 2, this tells
the ORB stream (which must be a ValueOutputStream) to
begin a new valuetype to contain the optional data
of the writeObject method.
if (!checkSpecialClasses(obj) && !checkSubstitutableSpecialClasses(obj))
Required by the superclass.
XXX I18N, Logging needed.
XXX I18N, Logging needed.
XXX I18N, Logging needed.
XXX I18N, Logging needed.
INTERNAL UTILITY METHODS
XXX I18N, Logging needed.
XXX I18N, Logging needed.
Write format version
Write format version
XXX I18N, Logging needed.
What to do if it's null?
XXX I18N, Logging needed.
RMI Object reference...
IDL Object reference...
IDL Abstract Object reference...
XXX I18N, Logging needed.
XXX I18N, Logging needed.
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Unchecked warning from (Map<String, Object>)sharedState is safe
since javax.security.auth.login.LoginContext passes a raw HashMap.
get relevant alias and password info
log into KeyStore to retrieve data,
then clear passwords
No callback handler - check for alias and password options
Callback handler available - prompt for alias and passwords
only prompt for alias
prompt for alias and key store password
prompt for alias, key store password, and key password
if using protected auth path, keyStorePassword will be null
if token, privateKeyPassword will be null
impossible for LoginModule to be in AUTHENTICATED
assumption is that KeyStore.load did a login -
perform explicit logout if possible
save but continue below
attempt to destroy the private credential
even if the Subject is read-only
destroy the private credential
throw an exception because we can not remove
the principal and public credential from this
throw pending logout exception if there is one
we should switch to logging API
Normally initialized by VM (public constructor added in 1.5)
No need to wrap this in a doPrivileged as it's called from
Only include windows on Windows boxs.
GTK is not shipped on Windows.
Avoid reflection for the common case of metal.
May be set on Linux and Solaris boxs.
This can return null if the multiplexing look and feel
doesn't support a particular UI.
Ideally we would throw an exception here, but it's too late
InputStream has been buffered in Properties
No such file, or file is otherwise non-readable.
Check whether any properties were overridden at the
Don't care about return value.
No need to do catch the SecurityException here, this runs
in a doPrivileged.
Try to get default LAF from system property, then from AppContext
(6653395), then use cross-platform one by default.
Set any properties passed through AppContext (6653395).
Check for JRootPane which indicates that a swing toplevel
is coming, in which case a swing default focus policy
should be instatiated. See 7125044.
Install Swing's PaintEventDispatcher
Install a hook that will be invoked if no one consumes the
KeyEvent.  If the source isn't a JComponent this will process
key bindings, if the source is a JComponent it implies that
processKeyEvent was already invoked and thus no need to process
the bindings again, unless the Component is disabled, in which
case KeyEvents will no longer be dispatched to it so that we
handle it here.
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of ToolBarButtonPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of ToolBarButtonPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
Common UI methods
benchmarking (see test/src/ReplaceTest.java in the CVS Attic)
showed that this code is slower than the current code.
look for the first whitespace char.
no such whitespace. replace(text)==text.
we now know that we need to modify the text.
allocate a char array to do it.
most of the texts are already in the collapsed form.
so look for the first whitespace in the hope that we will
never see it.
the input happens to be already collapsed.
we now know that the input contains spaces.
let's sit down and do the collapsing normally.
skip this character
remove trailing whitespaces
whitespaces are already collapsed,
so all we have to do is to remove the last one character
if it's a whitespace.
most of the characters are non-control characters.
so check that first to quickly return false for most of the cases.
other than we have to do four comparisons.
most of the characters are non-control characters.
so check that first to quickly return false for most of the cases.
other than we have to do four comparisons.
wrap native call to allow instrumentation
-- This file was mechanically generated: Do not edit! --
For duplicates and slices
It's expected that some toolkits (Headless,
whatever besides SunToolkit) could also operate.
XToolkit: extra buttons are not reporting about their state correctly.
Being pressed they report the state=0 both on the press and on the release.
For 1-3 buttons the state value equals zero on press and non-zero on release.
Other modifiers like Shift, ALT etc seem report well with extra buttons.
The problem reveals as follows: one button is pressed and then another button is pressed and released.
So, the getModifiersEx() would not be zero due to a first button and we will skip this modifier.
This may have to be moved into the peer code instead if possible.
There is at least one more button in a pressed state.
TODO: add a toolkit field that holds a number of button on the mouse.
As the method getMouseModifiersText() is static and obtain
an integer as a parameter then we may not restrict this with the number
of buttons installed on the mouse.
It's a temporary solution. We need to somehow hold the number of buttons somewhere else.
1,2,3 buttons may already be there; so don't duplicate it.
remove trailing '+'
Using plain "modifiers" here does show an excluded extended buttons in the string event representation.
getModifiersEx() solves the problem.
used to store error code and error substitution arguments
These message should be read from a locale-specific resource bundle
Node name, followed by description
Node name + "/" + AttributeName, followed by description
At least one Transform element must be present. Bad.
Internal imports, not used in the interface to this package
End of file.
the certificate type
Default to -1
no need to sychronize again
get the node data
no need to synchronize again
_REVIST_ Could make this a subclass of DynArrayImpl
But that would mean that an object that implements DynSequence also implements DynArray
which the spec doesn't mention (it also doesn't forbid it).
Sets the current position to -1 and creates an empty sequence.
Initializes components and anys representation
from the Any representation
This typeCode is of kind tk_sequence.
_REVISIT_ Could use read_xxx_array() methods on InputStream for efficiency
but only for primitive types
Creates the appropriate subtype without copying the Any
Sets the current position to -1 and creates an empty sequence.
already done in the type code constructor
Collapses the whole DynAny hierarchys values into one single streamed Any
Writing the length first is the only difference to supers implementation
Not our implementation. Nothing we can do to prevent copying.
DynSequence interface methods
Returns the current length of the sequence
Sets the length of the sequence. Increasing the length of a sequence
adds new elements at the tail without affecting the values of already
existing elements. Newly added elements are default-initialized.
Increasing the length of a sequence sets the current position to the first
newly-added element if the previous current position was -1.
Otherwise, if the previous current position was not -1,
the current position is not affected.
Increasing the length of a bounded sequence to a value larger than the bound
Decreasing the length of a sequence removes elements from the tail
without affecting the value of those elements that remain.
The new current position after decreasing the length of a sequence is determined
?f the length of the sequence is set to zero, the current position is set to -1.
?f the current position is -1 before decreasing the length, it remains at -1.
?f the current position indicates a valid element and that element is not removed
when the length is decreased, the current position remains unaffected.
?f the current position indicates a valid element and that element is removed, the
current position is set to -1.
Newly added elements are default-initialized
Increasing the length of a sequence sets the current position to the first
newly-added element if the previous current position was -1.
It is probably right not to destroy the released component DynAnys.
Some other DynAny or a user variable might still hold onto them
and if not then the garbage collector will take care of it.
?f the length of the sequence is set to zero, the current position is set to -1.
?f the current position is -1 before decreasing the length, it remains at -1.
?f the current position indicates a valid element and that element is not removed
when the length is decreased, the current position remains unaffected.
?f the current position indicates a valid element and that element is removed,
the current position is set to -1.
Maybe components is now default initialized from type code
Initializes the elements of the sequence.
The length of the DynSequence is set to the length of value.
The current position is set to zero if value has non-zero length
and to -1 if value is a zero-length sequence.
If the length of value exceeds the bound of a bounded sequence,
the operation raises InvalidValue.
If value contains one or more elements whose TypeCode is not equivalent
to the element TypeCode of the DynSequence, the operation raises TypeMismatch.
Indicates whether the header is padded. In GIOP 1.2 and above,
the body must be aligned on an 8-octet boundary, and so the header is
padded appropriately. However, if there is no body to a request or reply
message, there is no header padding, in the unfragmented case.
used to remember headerPadding flag when mark() and restore() are used.
Called by RequestMessage_1_2 or ReplyMessage_1_2 classes only.
the mark and reset methods have been overridden to remember the
This method has been overriden to ensure that the duplicated stream
inherits the headerPadding flag, in case of GIOP 1.2 and above, streams.
headerPadding bit is set by read method of the RequestMessage_1_2
or ReplyMessage_1_2 classes. When set, the very first body read
operation (from the stub code) would trigger an alignAndCheck
method call, that would in turn skip the header padding that was
inserted during the earlier write operation by the sender. The
padding ensures that the body is aligned on an 8-octet boundary,
for GIOP versions 1.2 and beyond.
WARNING: Must compute real alignment after calling
checkBlockLength since it may move the position
In GIOP 1.2, a fragment may end with some alignment
padding (which leads to all fragments ending perfectly
on evenly divisible 8 byte boundaries).  A new fragment
never requires alignment with the header since it ends
on an 8 byte boundary.
In GIOP 1.2, a wchar is encoded as an unsigned octet length
followed by the octets of the converted wchar.
Did the provided bytes convert to more than one
character?  This may come up as more unicode values are
assigned, and a single 16 bit Java char isn't enough.
Better to use strings for i18n purposes.
In GIOP 1.2, wstrings are not terminated by a null.  The
length is the number of octets in the converted format.
A zero length string is represented with the 4 byte length
value of 0.
IMPORTANT: Do not replace 'new String("")' with "", it may result
in a Serialization bug (See serialization.zerolengthstring) and
bug id: 4728756 for details
W2K Feature: Check to see if the Underscore should be rendered.
W2K Feature: Check to see if the Underscore should be rendered.
org.w3c.dom.NodeList API follows
True if we want to see output from success cases
A new line character.
Construct a debug compiler
Run interactive tests against a single regexp
Run automated tests
Show program for compiled expression
Test matching against compiled expression
Read from keyboard
Try a match against the keyboard input
Show subparen registers
make sure the writer gets flushed.
Loop through each paren
Show paren register
Some unit tests
Test from script file
While input is available, parse lines
Show match time
Print final results
Serialization test 1: Compile regexp and serialize/deserialize it
Serialization test 2: serialize/deserialize used regexp
Test MATCH_MULTILINE. Test for eol/bol symbols.
Test MATCH_MULTILINE. Test that '.' does not matches new line.
Pre-compiled regular expression "a*b"
Simple test of pre-compiled regular expressions
Test subst() with backreferences
Test subst() with backreferences without leading characters
before first backreference
Test subst() with NO backreferences
Test subst() with NO backreferences
Bad test script
to please javac
Find next re test case
Are we done?
Get test information
number from script file
Expression didn't cause an expected error
Some expressions *should* cause exceptions to be thrown
If it was supposed to be an error, report success and continue
Wasn't supposed to be an error
Internal error happened
Try regular matching
Match against the string
Check result, parens, and iterators
test match(CharacterIterator, int)
for every CharacterIterator implementation.
Matcher blew it
Show subexpression registers
Check registers against expected contents
Compare expected result with actual
Consider "null" in test file equal to null
Matcher blew it
REVISIT: The DOM Level 2 PR has a bug: the init method should let this
attribute be specified. Since it doesn't we have to give write access.
NON-DOM CONSTANTS: Storage efficiency, avoid risk of typos.
XXX These need to go away.
Declare serialVersionUID to be compatible with JDK1.1
The common case.
arrange entries for comparison
An empty constructor used by the parser
create new Entry
clone the byte array
Compare a single pair of type/value pairs.
longer RDN wins
Sum up the hash codes of the components.
For each type/value pair...
If non-null, a cannonical representation of the value suitable
for comparison using String.compareTo()
Any change here must be reflected in hashCode()
return cached result
Find leading and trailing whitespace.
index of first char that is not leading whitespace
index of last char that is not trailing whitespace
Trim off leading and trailing whitespace.
Add back the trailing whitespace with a preceding '\'
(escaped or unescaped) that was taken off in the above
loop. Whether or not to retain this whitespace is decided below.
Value is binary (eg: "#CEB1DF80").
Trim off quotes.
index of the last escaped character
snarf escaped char
Convert hex-encoded UTF-8 to 16-bit chars.
no utf8 bytes available, invalid DN
'/' has no meaning, throw exception
snarf unescaped char
Get rid of the unescaped trailing whitespace with the
preceding '\' character that was previously added back.
allow enough room
index of first unused byte in utf8
types of model groups
REVISIT: can't use same constants as those for particles, because
there are place where the constants are used together. For example,
to check whether the content is an element or a sequence.
compositor of the model group
this particle's optional annotations
whether this model group contains nothing
return the sum of all min values of the particles
return the min of all min values of the particles
otherwise return the sum of all max values
otherwise return the max of all max values
REVISIT: Commented code may help to eliminate redundant parentheses (test first before committing)
if (fMinOccurs != 1 || fMaxOccurs != 1)
if (fCompositor == MODELGROUP_ALL || fMinOccurs != 1 || fMaxOccurs != 1)
GETTERS AND SETTERS
the classname should probably come from a property file.
vIndex gives index of row to look in.
NOTE: This will not properly work if ParagraphView contains
other ParagraphViews. It won't raise, but this does not message
the children views with getNextVisualPositionFrom.
This could be made better to check backward positions too.
--- FlowView methods ---------------------------------------------
--- TabExpander methods ------------------------------------------
If the text isn't left justified, offset by 10 pixels!
a tab every 72 pixels.
no tab, do a default of 5 pixels.
Should this cause a wrapping of the line?
Simple case, left tab.
PENDING: what does this mean?
right and decimal are treated the same way, the new
position will be the location of the tab less the
Similar to right, but half the partialSize.
will never get here!
Have to search layoutPool!
PENDING: when ParagraphView supports breaking location
into layoutPool will have to change!
PENDING: should we handle this better?
---- View methods ----------------------------------------------------
line with the negative firstLineIndent value needs
Determine what row to break on.
PENDING(prinz) add break support
PENDING(prinz) make this return a reasonable value
when paragraph breaking support is re-implemented.
If less than one row, bad weight value should be
find the longest non-breakable fragments at the view edges
further fragmentation is not possible
initial view is breakable hence must support fragmentation
update any property settings stored, and layout should be
--- variables -----------------------------------------------
if we can justifiy the content always align to
Don't adjust the height if the view represents a branch.
no justification for i18n documents
no justification for the last row
no justification for the broken rows
Calls super method after setting spaceAddon to 0.
Justification should not affect MajorAxisRequirements
no need to justify
justification is started to the right of the rightmost TAB.
leading and trailing spaces are not extendable.
for all painting and measurement.
there is nothing we can do to justify
for justified row we assume the maximum horizontal span
This is expensive, but are views are not necessarily layed
out in model order.
use firstLineIdent for the first row
this should be the last index in justificationData
EventQueue may change during the dispatching
AppContext.dispose() interrupts all
Threads in the AppContext
Exclude this object from modality and
continue to pump it's events.
5.0u3 modal exclusion
Exclude this window and all its children from
modality and continue to pump it's events.
zero => no limit.
doing a setEncoding with null should always work.
We register our own ErrorManager during initialization
so we can record exceptions.
Create a lock file.  This grants us exclusive access
to our set of output files, as long as we are alive.
Generate a lock file name from the "unique" int.
Now try to lock that filename.
Because some systems (e.g., Solaris) can only do file locks
between processes (and not within a process), we first check
if we ourself already have the file locked.
We already own this lock, for a different FileHandler
object.  Try again.
This may be a zombie file left over by a previous
execution. Reuse it - but only if we can actually
write to its directory.
Note that this is a situation that may happen,
but not too frequently.
Race condition - retry once, and if that
fails again just try the next name in
the file may not be writable for us.
try the next name in the sequence
at this point channel should still be null.
break and try the next name in the sequence.
We got the lock OK.
At this point we could call File.deleteOnExit().
However, this could have undesirable side effects
as indicated by JDK-4872014. So we will instead
rely on the fact that close() will remove the lock
file and that whoever is creating FileHandlers should
be responsible for closing them.
We got an IOException while trying to get the lock.
This normally indicates that locking is not supported
on the target directory.  We have to proceed without
getting a lock.   Drop through, but only if we did
create the file...
someone already locked this file in this VM, through
some other channel - that is - using something else
continue searching for an available lock.
We got the lock.  Remember it.
We failed to get the lock.  Try next file.
Create the initial log file.
Did we detect any exceptions during initialization?
Install the normal default ErrorManager.
Ok, we are in a set UID program.  For safety's sake
we disallow attempts to open files relative to %h.
We don't want to throw an exception here, but we
report the exception to any registered ErrorManager.
We performed access checks in the "init" method to make sure
we are only initialized from trusted code.  So we assume
it is OK to write the target files, even if we are
currently being called from untrusted code.
So it is safe to raise privilege here.
Unlock any lock file.
Close the lock file channel (which also will free any locks)
Problems closing the stream.  Punt.
If stub field not filled in, applet never active
must be overridden in sub-class
Sometimes the DefaultTableModel is subclassed
instead of the AbstractTableModel by mistake.
Set the number of rows for the case when getRowCount
Implementing the TableModel interface
This test is to cover the case when
getColumnCount has been subclassed by mistake ...
End of class DefaultTableModel
Exceptional case there is current not text case testing this(Before it was a
a common case).
Updates first and last change indices
Sets the state at this index and update all relevant state.
Update minimum and maximum indices
Clears the state at this index and update all relevant state.
Update minimum and maximum indices
If we only allow a single selection, channel through
setSelectionInterval() to enforce the rule.
If we only allow a single interval and this would result
in multiple intervals, then set the selection to be just
the new range.
private implementation allowing the selection interval
to be removed without affecting the lead and anchor
If the removal would produce to two disjoint selections in a mode
that only allows one, extend the removal to the end of the selection.
disallow a -1 lead unless the anchor is already -1
only allow a -1 lead if the anchor is already -1
otherwise, don't do anything if the anchor is -1
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of ScrollBarThumbPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of ScrollBarThumbPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
At least one argument - two at most
Parse the first argument
should not happened
Parse the second argument
should not happened
ac == 2; ac < 1 or as >2  was tested in typeChec()
The URI can be either a node-set or something else cast to a string
_arg2 == null was tested in typeChec()
Feck the rest of the parameters on the stack
Private method to configure a StreamHandler from LogManager
properties and/or default values as specified in the class
doing a setEncoding with null should always work.
This shouldn't happen.  The setEncoding method
should have validated that the encoding is OK.
Replace the current writer with a writer for the new encoding.
We don't want to throw an exception here, but we
report the exception to any registered ErrorManager.
We don't want to throw an exception here, but we
report the exception to any registered ErrorManager.
We don't want to throw an exception here, but we
report the exception to any registered ErrorManager.
We don't want to throw an exception here, but we
report the exception to any registered ErrorManager.
Copyright (c) 1995-96 by Cisco Systems, Inc.
SNMP Runtime imports
TIME BOMB HERE
We send an empty datagram packet to fix bug 4293791 (it's a jdk 1.1 bug)
First close the datagram socket.
This may generates an IO exception at the run method (_socket.receive).
Then stop the thread socket.
Wait until the thread die.
If the corresponding session is being destroyed, stop handling received responses.
We are closing the snmp socket while handling the datagram.
If the IO exception has been generated because of closing this SNMP socket,
(call to _socket.close while _socket is blocked for receiving packet) simply terminate closing properly.
If the exception (NullPointerException) has been generated because of closing this SNMP socket,
(call to _socket = null while _socket is blocked for receiving packet) simply terminate closing properly.
rethrow dead thread.
Implementation of the MBeanServer interface
Check if security manager installed
Check for addURL and getMBeansFromURL methods
Check if MBean is instance of MLet
Throw security exception
Whether or not calling getMBeansFromURL is allowed is controlled
by the value of the "jmx.remote.x.mlet.allow.getMBeansFromURL"
system property. If the value of this property is true, calling
the MLet's getMBeansFromURL method is allowed. The default value
for this property is false.
The colors are mirrored to avoid creep in adjusting an individual
PENDING: remove this when a variant of this is added to awt.
PENDING: when we straighten out user setting opacity, this should
PENDING: when we straighten out user setting opacity, this should
Force Integer to pad the string with 0's by adding 0x1000000 and
then removing the first character.
We want to handle tab ourself.
PENDING: this should come from the style.
Assign focus to either the wheel or triangle and attempt
to drag either the wheel or triangle.
Reset the flags to indicate no one has focus
Gained focus, reassign focus to the wheel if no one
currently has focus.
Draw the wheel and triangle
Draw the focus indicator for the wheel
Draw a line on the wheel indicating the selected hue.
Draw the focus indicator on the triangle
Draw the selected color indicator.
Invert the axis.
Rotate to origin and and verify x is valid.
Verify y location is valid.
Rotate again to determine value and scale
Map the location to an angle and reset hue
As far as I can tell, GTK doesn't allow stretching this
FFFF00 - FF0000
FF0000 - FF00FF
00FF00 - FFFF00
FF00FF - 0000FF
00FFFF - 00FF00
0000FF - 00FFFF
default is option unknown
default is options are valid
parsed name components
if non-null, the DN in unparsed form
no longer valid
no longer valid
no longer valid
no longer valid
check possible shortcuts
Compare RDNs one by one for equality
Compare a single pair of RDNs.
check possible shortcuts
Compare RDNs one by one, lexicographically.
Compare a single pair of RDNs.
longer DN wins
Sum up the hash codes of the components.
For each RDN...
if command specified in the args, get it
get the command
create the POA ORB
if command specified in the args, process it
process commands interactively
create a buffered reader to read commands from standard in
print tool banner
process commands until user quits
print short help
handle the help command
print long help for a specific command
determine the subcommand and execute it
construct args to the command
execute the command
unknown command - print available commands
determine longest command name
parse register server command
minimally the server class name has to be specified
register server and activate it
register the server with the repository
activate the server
print success message
the server id has to be specified
deactivate server, hold it down and and unregister it
deactivate the server
unregister the server from the repository
print success message
the server id has to be specified
locate the server
deactivate the server
print success message
the server id has to be specified
locate the server
deactivate the server
print success message
determine if list single server or all servers
process the list server command
process the list active servers command
determine the server id
shutdown the server
determine the server id
startup the server
the server id has to be specified
activate the server
Initialize the standard specifiers
0 if no alpha
0 if no alpha
0 if no alpha
Use component color model & sample model
Exception most likely thrown from a DataBuffer constructor
Ports are marshalled as shorts on the wire.  The IDL
type is unsigned short, which lacks a convenient representation
in Java in the 32768-65536 range.  So, we treat ports as
ints throught this code, except that marshalling requires a
scaling conversion.  intToShort and shortToInt are provided
for this purpose.
Common UI methods
end class JPEGImageDecoder
REVISIT - This is called from TOAImpl.
DO NOT set the IOR to null.  (Un)exporting is only concerns
the servant not the IOR.  If the ior is set to null then
null pointer exceptions happen during an colocated invocation.
It is better to let the invocation proceed and get OBJECT_NOT_EXIST
from the server side.
End of file.
This file was generated AUTOMATICALLY from a template file Fri Jul 21 22:00:53 PDT 2017
There is a titlecase equivalent.  Perform further checks:
The character does not have an uppercase equivalent, so it must
already be uppercase; so add 1 to get the titlecase form.
The character does not have a lowercase equivalent, so it must
already be lowercase; so subtract 1 to get the titlecase form.
The character has both an uppercase equivalent and a lowercase
equivalent, so it must itself be a titlecase form; return it.
This character has no titlecase equivalent but it does have an
uppercase equivalent, so use that (subtract the signed case offset).
Java supradecimal digit
AEGEAN NUMBER FORTY
AEGEAN NUMBER FIFTY
AEGEAN NUMBER SIXTY
AEGEAN NUMBER SEVENTY
AEGEAN NUMBER EIGHTY
AEGEAN NUMBER NINETY
AEGEAN NUMBER ONE HUNDRED
AEGEAN NUMBER TWO HUNDRED
AEGEAN NUMBER THREE HUNDRED
AEGEAN NUMBER FOUR HUNDRED
AEGEAN NUMBER FIVE HUNDRED
AEGEAN NUMBER SIX HUNDRED
AEGEAN NUMBER SEVEN HUNDRED
AEGEAN NUMBER EIGHT HUNDRED
AEGEAN NUMBER NINE HUNDRED
AEGEAN NUMBER ONE THOUSAND
AEGEAN NUMBER TWO THOUSAND
AEGEAN NUMBER THREE THOUSAND
AEGEAN NUMBER FOUR THOUSAND
AEGEAN NUMBER FIVE THOUSAND
AEGEAN NUMBER SIX THOUSAND
AEGEAN NUMBER SEVEN THOUSAND
AEGEAN NUMBER EIGHT THOUSAND
AEGEAN NUMBER NINE THOUSAND
AEGEAN NUMBER TEN THOUSAND
AEGEAN NUMBER TWENTY THOUSAND
AEGEAN NUMBER THIRTY THOUSAND
AEGEAN NUMBER FORTY THOUSAND
AEGEAN NUMBER FIFTY THOUSAND
AEGEAN NUMBER SIXTY THOUSAND
AEGEAN NUMBER SEVENTY THOUSAND
AEGEAN NUMBER EIGHTY THOUSAND
AEGEAN NUMBER NINETY THOUSAND
OLD ITALIC NUMERAL FIFTY
ACROPHONIC ATTIC FIFTY
ACROPHONIC ATTIC FIVE HUNDRED
ACROPHONIC ATTIC FIVE THOUSAND
ACROPHONIC ATTIC FIFTY THOUSAND
ACROPHONIC ATTIC FIFTY TALENTS
ACROPHONIC ATTIC ONE HUNDRED TALENTS
ACROPHONIC ATTIC FIVE HUNDRED TALENTS
ACROPHONIC ATTIC ONE THOUSAND TALENTS
ACROPHONIC ATTIC FIVE THOUSAND TALENTS
ACROPHONIC ATTIC FIFTY STATERS
ACROPHONIC ATTIC ONE HUNDRED STATERS
ACROPHONIC ATTIC FIVE HUNDRED STATERS
ACROPHONIC ATTIC ONE THOUSAND STATERS
ACROPHONIC ATTIC TEN THOUSAND STATERS
ACROPHONIC ATTIC FIFTY THOUSAND STATERS
ACROPHONIC TROEZENIAN FIFTY
ACROPHONIC TROEZENIAN FIFTY ALTERNATE FORM
ACROPHONIC HERMIONIAN FIFTY
ACROPHONIC THESPIAN FIFTY
ACROPHONIC THESPIAN ONE HUNDRED
ACROPHONIC THESPIAN THREE HUNDRED
ACROPHONIC EPIDAUREAN FIVE HUNDRED
ACROPHONIC TROEZENIAN FIVE HUNDRED
ACROPHONIC THESPIAN FIVE HUNDRED
ACROPHONIC CARYSTIAN FIVE HUNDRED
ACROPHONIC NAXIAN FIVE HUNDRED
ACROPHONIC THESPIAN ONE THOUSAND
ACROPHONIC THESPIAN FIVE THOUSAND
ACROPHONIC STRATIAN FIFTY MNAS
GOTHIC LETTER NINETY
GOTHIC LETTER NINE HUNDRED
OLD PERSIAN NUMBER HUNDRED
IMPERIAL ARAMAIC NUMBER ONE HUNDRED
IMPERIAL ARAMAIC NUMBER ONE THOUSAND
IMPERIAL ARAMAIC NUMBER TEN THOUSAND
PHOENICIAN NUMBER ONE HUNDRED
KHAROSHTHI NUMBER ONE HUNDRED
KHAROSHTHI NUMBER ONE THOUSAND
OLD SOUTH ARABIAN NUMBER FIFTY
INSCRIPTIONAL PARTHIAN NUMBER ONE HUNDRED
INSCRIPTIONAL PARTHIAN NUMBER ONE THOUSAND
INSCRIPTIONAL PAHLAVI NUMBER ONE HUNDRED
INSCRIPTIONAL PAHLAVI NUMBER ONE THOUSAND
RUMI NUMBER FORTY
RUMI NUMBER FIFTY
RUMI NUMBER SIXTY
RUMI NUMBER SEVENTY
RUMI NUMBER EIGHTY
RUMI NUMBER NINETY
RUMI NUMBER ONE HUNDRED
RUMI NUMBER TWO HUNDRED
RUMI NUMBER THREE HUNDRED
RUMI NUMBER FOUR HUNDRED
RUMI NUMBER FIVE HUNDRED
RUMI NUMBER SIX HUNDRED
RUMI NUMBER SEVEN HUNDRED
RUMI NUMBER EIGHT HUNDRED
RUMI NUMBER NINE HUNDRED
BRAHMI NUMBER FORTY
BRAHMI NUMBER FIFTY
BRAHMI NUMBER SIXTY
BRAHMI NUMBER SEVENTY
BRAHMI NUMBER EIGHTY
BRAHMI NUMBER NINETY
BRAHMI NUMBER ONE HUNDRED
BRAHMI NUMBER ONE THOUSAND
CUNEIFORM NUMERIC SIGN SHAR2 TIMES GAL PLUS DISH
CUNEIFORM NUMERIC SIGN SHAR2 TIMES GAL PLUS MIN
COUNTING ROD TENS DIGIT FOUR
COUNTING ROD TENS DIGIT FIVE
COUNTING ROD TENS DIGIT SIX
COUNTING ROD TENS DIGIT SEVEN
COUNTING ROD TENS DIGIT EIGHT
COUNTING ROD TENS DIGIT NINE
The following tables and code generated using:
java GenerateCharacter -plane 1 -template c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/jdk/make/data/characterdata/CharacterData01.java.template -spec c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/jdk/make/data/unicodedata/UnicodeData.txt -specialcasing c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/jdk/make/data/unicodedata/SpecialCasing.txt -proplist c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/jdk/make/data/unicodedata/PropList.txt -o c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/build/windows-amd64/jdk/gensrc/java/lang/CharacterData01.java -string -usecharforbyte 11 4 1
The X table has 2048 entries for a total of 4096 bytes.
The Y table has 2176 entries for a total of 4352 bytes.
The A table has 320 entries for a total of 1280 bytes.
The B table has 320 entries for a total of 640 bytes.
In all, the character property tables require 9728 bytes.
THIS CODE WAS AUTOMATICALLY CREATED BY GenerateCharacter:
validate the input composite data
values below valid only during upcalls to writeObject()/writeExternal()
REMIND: implement better check for pristine stream?
handle previously written and non-replaceable objects
check for replacement object
REMIND: skip this check for strings/arrays?
if object replaced, run through original checks a second time
Return true if this class is a custom subclass of ObjectOutputStream
do not invoke class descriptor write hook with old protocol
REMIND: remove once hotspot inlines Float.floatToIntBits
REMIND: remove once hotspot inlines Double.doubleToLongBits
deprecated in ObjectOutputStream.PutField
REMIND: warn if numPrimFields > 0?
avoid unnecessary copy
write one byte at a time to normalize block
End of file.
End of file.
Disallow subsequent initCause
Store the element index and position
Store the element index and position
Leaf nodes are never nullable unless its an epsilon node
If we are an epsilon node, then the first pos is an empty set
Otherwise, its just the one bit of our position
If we are an epsilon node, then the last pos is an empty set
Otherwise, its just the one bit of our position
XXX This should go away once we get rid of the port exchange for ORBD
XXX These should move to SPI
XXX This needs an SPI
REVISIT: this should be ProtocolDefault.
Run any pluggable configurators.  This is a lot like
ORBInitializers, only it uses the internal ORB and has
access to all data for parsing.
XXX Log this exception
ignore this for now: a bad user configurator does nothing
determine the ORBD port so that persistent objrefs can be
REVISIT - use exception instead of -1.
Check for incorrect configuration.
Client and Server side setup.
Set up client side.
Since the user specified a legacy socket factory we need to
use a ContactInfoList that will use the legacy socket factory.
The user specified an explicit ContactInfoListFactory.
Use the default.
Set up server side.
Maybe allocate the Legacy default listener.
If old legacy properties set, or there are no explicit
acceptors then register a default listener.  Type of
default listener depends on presence of legacy socket factory.
Note: this must happen *BEFORE* registering explicit acceptors.
Allocate user listeners.
REVISIT: see ORBD. make factory in TransportDefault.
Note: the createServerSocket and createSocket methods on the
DefaultSocketFactory need to get data from the ORB but
we cannot change the interface.  So set the ORB (if it's ours)
NOTE: If there is no method then it
is not ours - so ignore it.
Register the Dynamic Any factory
No optimization or policy selection here.
Register the ValueFactory instances for ORT
Register an ObjectKeyFactory
register client subcontracts
register server delegates
register local client subcontracts
Register object adapter factories
End of file.
this will ensure bootclassloader is used
Figure out which ClassLoader to use for loading the provider
class.  If there is a Context ClassLoader then use it.
Assert: we are on JDK 1.1 or we have no Context ClassLoader
or any Context ClassLoader in chain of system classloader
(including extension ClassLoader) so extend to widest
ClassLoader (always look in system ClassLoader if Xalan
is in boot/extension/system classpath and in current
ClassLoader otherwise); normal classloaders delegate
back to system ClassLoader first so this widening doesn't
change the fact that context ClassLoader will be consulted
Assert: Current ClassLoader in chain of
Assert: Current ClassLoader not in chain of
boot ClassLoader reached
Check for any extension ClassLoaders in chain up to
Assert: Context ClassLoader not in chain of
throw security exception if the calling thread is not allowed to access the
class. Restrict the access to the package classes as specified in java.security policy.
Fall back to current classloader
recognized features and properties
NOTE: The following defaults are nulled out on purpose.
If they are set, then when the XML Schema validator
is constructed dynamically, these values may override
those set by the application. This goes against the
whole purpose of XMLComponent#getFeatureDefault but
it can't be helped in this case. -Ac
this is the number of valuestores of each kind
we expect an element to have.  It's almost
never > 1; so leave it at that.
since it is the responsibility of each component to an
Augmentations parameter if one is null, to save ourselves from
having to create this object continually, it is created here.
If it is not present in calls that we're passing on, we *must*
clear this before we introduce it into the pipeline.
this is included for the convenience of handleEndElement
Namespace growth feature
to indicate whether we are in the scope of entity reference or CData
Did we see only whitespace in element content?
the error reporter property
number of element (depth); and whether to record error
set the external error reporter, clear errors
should be called when starting process an element or an attribute.
store the starting position for the current context
resize array if necessary
should be called on endElement: get all errors of the current element
get starting position of the current element
number of errors of the current element
if no errors, return null
copy errors from the list to an string array
remove errors of the current element
should be called when an attribute is done: get all errors of
this attribute, but leave the errors to the containing element
also called after an element was strictly assessed.
get starting position of the current element
number of errors of the current element
if no errors, return null
copy errors from the list to an string array
don't resize the vector: leave the errors for this attribute
to the containing element
updated during reset
schema location property values
JAXP Schema Source property
Init reportWhitespace for this handler
doesn't have any text content, change emptyElement call to
start + characters + end
fElementDepth == -2 indicates that the schema validator was removed
from the pipeline. then we don't need to call handleEndElement.
for union types we can't normalize data
the normalized data for union will be send
after normalization is performed (at the endElement())
doesn't have any text content, add a characters call.
REVISIT: what should we do here if schema normalization is on??
REVISIT: this methods basically duplicates implementation of
handleCharacters(). We should be able to reuse some code
if whitespace == -1 skip normalization, because it is a complexType
or a union type.
When it's a complex type with element-only content, we need to
find out whether the content contains any non-whitespace character.
data outside of element content
XMLDocumentHandler and XMLDTDHandler methods
REVISIT: what should happen if normalize_data_ is on??
temporary empty string buffer.
temporary character buffer, and empty string buffer.
got first chunk in characters() (SAX)
Previous chunk had a trailing space
REVISIT: in new simple type design, make things in DVs static,
so that we can QNameDV.getCompiledForm()
REVISIT: create decl pool, and pass it to each traversers
Schema grammar loader
REVISIT: what do we store here? QName, XPATH, some ID? use rawname now.
used to validate default/fixed values against xsi:type
only need to check facets, so we set extraChecking to false (in reset)
used to apply default/fixed values
only need to check id/idref/entity, so we set checkFacets to false
identity constraint information
cleanup id table
pass the component manager to the factory..
reset schema loader
should only clear this if the last schema had identity constraints.
get error reporter
parser settings have not been changed
Re-parse external schema location properties.
get symbol table. if it's a new one, add symbols to it.
get schema location properties
store the external schema locations. they are set when reset is called,
so any other schemaLocation declaration for the same namespace will be
effectively ignored. becuase we choose to take first location hint
available for a particular namespace.
clear grammars, and put the one for schema namespace there
a utility method for Identity constraints
handle start document
handle character contents
returns the normalized string if possible, otherwise the original string
Note: data in EntityRef and CDATA is normalized as well
if whitespace == -1 skip normalization, because it is a complexType
or a union type.
When it's a complex type with element-only content, we need to
find out whether the content contains any non-whitespace character.
data outside of element content
ensure the ch array is big enough
don't include the leading ' ' for now. might include it later.
take the first whitespace as a space and skip the others
this is a leading whitespace, record it
if we finished on a space trim it but also record it
if all we had was whitespace we skipped record it as
trailing whitespace as well
previous chunk ended on whitespace
previous chunk ended on character,
this chunk starts with whitespace
The length includes the leading ' '. Now removing it.
ensure the ch array is big enough
take the first whitespace as a space and skip the others
if we finished on a space trim it but also record it
handle ignorable whitespace
REVISIT: the same process needs to be performed as handleCharacters.
only it's simpler here: we know all characters are whitespaces.
schemaType is not specified
if a DTD grammar is found, we do the same thing as Dynamic:
otherwise, skip the whole document.
[1] Either schemaType is DTD, and in this case validate/schema is turned off
[2] Validating against XML Schemas only
[a] dynamic validation is false: report error if SchemaGrammar is not found
[b] dynamic validation is true: if grammar is not found ignore.
get xsi:schemaLocation and xsi:noNamespaceSchemaLocation attributes,
parse them to get the grammars
store the location hints..  we need to do it so that we can defer the loading of grammar until
there is a reference to a component from that namespace. To provide location hints to the
application for a namespace
if we are in the content of "skip", then just skip this element
REVISIT:  is this the correct behaviour for ID constraints?  -NG
try to find schema grammar by different means..
if we are not skipping this element, and there is a content model,
we try to find the corresponding decl object for this element.
the reason we move this part of code here is to make sure the
error reported here (if any) is stored within the parent element's
context, instead of that of the current element.
it could be an element decl or a wildcard decl
REVISIT: is it the only case we will have particle = null?
if it's not the root element, we push the current states in the stacks
increase the element depth after we've saved
all states for the parent element
and the buffer to hold the value of the element
check what kind of declaration the "decl" from
oneTransition() maps to
if the wildcard is skip, then return
try again to get the element decl:
case 1: find declaration for root element
case 2: find declaration for element from another namespace
then get the type
get type from xsi:type
if no decl/type found for the current element
if this is the validation root, report an error, because
we can't find eith decl or type for this element
REVISIT: should we report error, or warning?
for dynamic validation, skip the whole content,
because no grammar was found.
no schema grammar was found, but it's either dynamic
validation, or another kind of grammar was found (DTD,
for example). The intended behavior here is to skip
the whole document. To improve performance, we try to
remove the validator from the pipeline, since it's not
supposed to do anything.
indicate that the validator was removed.
We don't call reportSchemaError here, because the spec
doesn't think it's invalid not to be able to find a
declaration or type definition for an element. Xerces is
reporting it as an error for historical reasons, but in
PSVI, we shouldn't mark this element as invalid because
of this. - SG
if wildcard = strict, report error.
needs to be called before fXSIErrorReporter.pushContext()
so that the error belongs to the parent element.
report error, because wilcard = strict
no element decl or type found for this element.
Allowed by the spec, we can choose to either laxly assess this
element, or to skip it. Now we choose lax assessment.
any type has mixed content, so we don't need to append buffer
push error reporter context: record the current position
This has to happen after we process skip contents,
otherwise push and pop won't be correctly paired.
push error reporter context: record the current position
This has to happen after we process skip contents,
otherwise push and pop won't be correctly paired.
If it fails, use the old type. Use anyType if ther is no old type.
if the element has a fixed value constraint, we need to append
if the type is simple, we need to append
if the type is simple content complex type, we need to append
Element Locally Valid (Element)
make the current element validation root
update normalization flags
Element Locally Valid (Type)
find out if the content type is simple and if variety is union
to be able to do character normalization
normalization: simple type
if !union type
then try to get the content model
and get the initial content model state
get information about xsi:nil
only deal with xsi:nil when there is an element declaration
now validate everything related with the attributes
first, get the attribute group
activate identity constraints
initialize when identity constrains are defined for the elem
add default attributes
call all active identity constraints
PSVI: add validation context
PSVI: add element declaration
PSVI: add element type
PSVI: add notation attribute
if we are skipping, return
but if this is the top element that we are skipping,
restore the states.
set the partial validation depth to the depth of parent
PSVI: validation attempted:
use default values in psvi item for
validation attempted, validity, and error codes
check extra schema constraints on root element
now validate the content of the element
Element Locally Valid (Element)
call matchers and de-activate context
handle everything *but* keyref's.
now handle keyref's/...
nothing to do if nothing matched!
have we reached the end tag of the validation root?
7 If the element information item is the validation root, it must be valid per Validation Root Valid (ID/IDREF) (3.3.4).
check extra schema constraints
return the final set of grammars validator ended up with
Set grammars as immutable
decrease element depth and restore states
get the states for the parent element.
We should have a stack for whitespace value, and pop it up here.
But when fWhiteSpace != -1, and we see a sub-element, it must be
an error (at least for Schema 1.0). So for valid documents, the
only value we are going to push/pop in the stack is -1.
Here we just mimic the effect of popping -1. -SG
Same for append buffer. Simple types and elements with fixed
value constraint don't allow sub-elements. -SG
the 4 properties sent on startElement calls
PSVI: validation attempted
nothing below or at the same level has none or partial
(which means this level is strictly assessed, and all chidren
are full), so this one has full
nothing below or at the same level has full or partial
(which means this level is not strictly assessed, and all chidren
are none), so this one has none
otherwise partial, and anything above this level will be partial
get all errors for the current element, its attribute,
and subelements (if they were strictly assessed).
any error would make this element invalid.
and we merge these errors to the parent element.
PSVI: error codes
Discard the current context: ignore any error happened within
the sub-elements/attributes of this element, because those
errors won't affect the validity of the parent elements.
store [schema information] in the PSVI
this is the function where logic of retrieving grammar is written , parser first tries to get the grammar from
the local pool, if not in local pool, it gives chance to application to be able to retrieve the grammar, then it
tries to parse the grammar using location hints from the give namespace.
get the grammar from local pool...
give a chance to application to be able to retreive the grammar.
put this grammar into the bucket, along with grammars
imported by it (directly or indirectly)
REVISIT: a conflict between new grammar(s) and grammars
in the bucket. What to do? A warning? An exception?
use location hints instead
try to parse the grammar using location hints from that namespace..
if we are dealing with a different schema location, then include the new schema
into the existing grammar
This method also deals with clause 1.2.1.2 of the constraint
Validation Rule: Schema-Validity Assessment (Element)
Element Locally Valid (Element)
4 If there is an attribute information item among the element information item's [attributes] whose [namespace name] is identical to http:www.w3.org/2001/XMLSchema-instance and whose [local name] is type, then all of the following must be true:
4.2 The local name and namespace name (as defined in QName Interpretation (3.15.3)), of the actual value of that attribute information item must resolve to a type definition, as defined in QName resolution (Instance) (3.15.4)
if the namespace is schema namespace, first try built-in types
if it's not schema built-in types, then try to get a grammar
try to find schema grammar by different means....
still couldn't find the type, report an error
if there is no current type, set this one as current.
and we don't need to do extra checking
Element Locally Valid (Element)
3 The appropriate case among the following must be true:
whether we have seen a Wildcard ID.
for each present attribute
Element Locally Valid (Complex Type)
3 For each attribute information item in the element information item's [attributes] excepting those whose [namespace name] is identical to http:www.w3.org/2001/XMLSchema-instance and whose [local name] is one of type, nil, schemaLocation or noNamespaceSchemaLocation, the appropriate case among the following must be true:
get the corresponding attribute decl
PSVI attribute: validation context
Element Locally Valid (Type)
3.1.1 The element information item's [attributes] must be empty, excepting those
whose [namespace name] is identical to http:www.w3.org/2001/XMLSchema-instance and
whose [local name] is one of type, nil, schemaLocation or noNamespaceSchemaLocation.
for the 4 xsi attributes, get appropriate decl, and validate
for namespace attributes, no_validation/unknow_validity
simple type doesn't allow any other attributes
it's not xmlns, and not xsi, then we need to find a decl for it
3.2 otherwise all of the following must be true:
3.2.2 The attribute information item must be valid with respect to it as defined in Item Valid (Wildcard) (3.10.4).
if failed, get it from wildcard
if (attrWildcard == null)
so this attribute is not allowed
which means it matches a wildcard
skip it if processContents is skip
try to find grammar by different means...
if can't find
if strict, report error
then continue to the next attribute
5.1 There must be no more than one item in wild IDs.
end of for (all attributes)
Attribute Locally Valid
For an attribute information item to be locally valid with respect to an attribute declaration all of the following must be true:
1 The declaration must not be absent (see Missing Sub-components (5.3) for how this can fail to be the case).
get simple type
store the normalized value
PSVI: element notation
REVISIT: is it possible for the notation to be in different namespace than the attribute
with which it is associated, CHECK !!  <fof n1:att1 = "n2:notation1" ..>
should we give chance to the application to be able to  retrieve a grammar - nb
REVISIT: what would be the triggering component here.. if it is attribute value that
triggered the loading of grammar ?? -nb
get the value constraint from use or decl
PSVI: attribute declaration
PSVI: attribute type
PSVI: attribute memberType
PSVI: attribute normalized value
NOTE: we always store the normalized value, even if it's invlid,
because it might still be useful to the user. But when the it's
not valid, the normalized value is not trustable.
PSVI: validation attempted:
PSVI: error codes
Check after all specified attrs are scanned
(1) report error for REQUIRED attrs that are missing (V_TAGc)
REVISIT: should we check prohibited attributes?
(2) report error for PROHIBITED attrs that are present (V_TAGc)
(3) add default attrs (FIXED and NOT_FIXED)
for each attribute use
get value constraint
whether this attribute is specified
Element Locally Valid (Complex Type)
information item's [attributes] as per clause 3.1 above.
if the attribute is not specified, then apply the value constraint
PSVI: attribute is "schema" specified
fixed values are handled later, after xsi:type determined.
Element Locally Valid (Element)
3.2.1 The element information item must have no character or element information item [children].
5 The appropriate case among the following must be true:
REVISIT:we should pass ValidatedInfo here.
REVISIT: don't use toString, but validateActualValue instead
use the fState4ApplyDefault
The following method call also deal with clause 1.2.2 of the constraint
Validation Rule: Schema-Validity Assessment (Element)
5.2.1 The element information item must be valid with respect to the actual type definition as defined by Element Locally Valid (Type) (3.3.4).
5.2.2.1 The element information item must have no element information item [children].
5.2.2.2 The appropriate case among the following must be true:
REVISIT: how to get the initial value, does whiteSpace count?
REVISIT: the spec didn't mention this case: fixed
value with simple type
for union types we need to send data because we delayed sending
this data when we received it in the characters() call.
Element Locally Valid (Type)
3 The appropriate case among the following must be true:
3.1 If the type definition is a simple type definition, then all of the following must be true:
3.1.2 The element information item must have no element information item [children].
3.1.3 If clause 3.2 of Element Locally Valid (Element) (3.3.4) did not apply, then the normalized value must be valid with respect to the type definition as defined by String Valid (3.14.4).
Element Locally Valid (Complex Type)
For an element information item to be locally valid with respect to a complex type definition all of the following must be true:
2 If clause 3.2 of Element Locally Valid (Element) (3.3.4) did not apply, then the appropriate case among the following must be true:
REVISIT: eventually, this method should return the same actualValue as elementLocallyValidType...
obviously it'll return null when the content is complex.
if the current state is a valid state, check whether
it's one of the final states.
After the DFA has completed, check minOccurs and maxOccurs
for all elements and wildcards in this content model where
xpath matcher information
value store implementations
destroys this ValueStore; useful when, for instance, a
locally-scoped ID constraint is involved.
appends the contents of one ValueStore to those of us.
Validation Rule: Identity-constraint Satisfied
4.2.1 The target node set and the qualified node set are equal, that is, every member of the
target node set is also a member of the qualified node set and vice versa.
If the IDC is a key check whether we have all the fields.
This is needed to allow keyref's to look for matched keys
in the correct scope.  Unique and Key may also need to
override this method for purposes of their own.
This method is called whenever the DocumentFragment
of an ID Constraint goes out of scope.
do we even know this field?
REVISIT: we can improve performance by using hash codes, instead of
traversing global vector that could be quite large.
didn't find it
construct value string
construct value string
ValueStoreBase protected methods
is this value as a group duplicated?
REVISIT: Implement a more efficient storage mechanism. -Ac
ValueStoreBase protected methods
end the value Scope; here's where we have to tie
up keyRef loose ends.
do all the necessary management...
get the key store corresponding (if it exists):
value store management
sketch of algorithm:
- when a constraint is first encountered, its
- Once it is validated (i.e., when it goes out of scope),
- as we encounter keyref's, we look at the global table to
The fGlobalIDMapStack has the following structure:
- validation always occurs against the fGlobalIDConstraintMap
When an endElement is found, this Map is merged with the one
below in the stack.
When a start tag is encountered, we create a new
i.e., the top of the fGlobalIDMapStack always contains
the fGlobalIDConstraintMap contains descendants+self.
keyrefs can only match descendants+self.
startElement:  pushes the current fGlobalIDConstraintMap
onto fGlobalMapStack and clears fGlobalIDConstraint map.
only clone the hashtable when there are elements
must be an invalid doc!
return if there is no element
initialize value stores for unique fields
initialize value stores for unique fields
initialize value stores for key fields
initialize value stores for keyRef fields
This method takes the contents of the (local) ValueStore
associated with id and moves them into the global
map, if id is a <unique> or a <key>.
If it's a <keyRef>, then we leave it for later.
the purpose of this class is to enable IdentityConstraint,int
pairs to be used easily as keys in Maps.
3.9.4 Element Sequence Locally Valid (Particle) 2.3.3
check whether one element decl matches an element with the given qname
if the exemplar is not a global element decl, then it's not possible
to be substituted by another element.
if the decl blocks substitution, return false
get grammar of the element
get the decl for the element
and check by using substitutionGroup information
3.3.6 Substitution Group OK (Transitive)
check whether element can substitute exemplar
1. D and C are the same element declaration.
2 All of the following must be true:
2.1 The blocking constraint does not contain substitution.
"derived" should be derived from "base"
add block of base types to blockConstraint.
type == null means the current type is anySimpleType,
whose base type should be anyType
If the base is a union, check if "derived" is allowed through any of the member types.
check whether element is in exemplar's substitution group
Define PSG, the potential substitution group for HEAD, as follows:
HEAD's actual substitution group is then the set consisting of each member of PSG such that all of the following must be true:
2 It is validly substitutable for HEAD subject to an empty blocking constraint, as defined in Substitution Group OK (Transitive) (3.3.6).
to store substitution group information
the key to the map is an element decl, and the value is
- a Vector, which contains all elements that has this element as their
substitution group affilication
- an array of OneSubGroup, which contains its substitution group before block.
The real substitution groups (after "block")
for all elements with substitution group affiliation
check whether this an entry for this element
if not, create a new one
add to the vactor
If we already have sub group for this element, just return it.
Otherwise, get all potential sub group elements
(without considering "block" on this element
For each of such elements, check whether the derivation methods
overlap with "block". If not, add it to the sub group
Resize the array if necessary
Store the subgroup
Get potential sub group element (without considering "block")
substitution group for this one is empty
we've already calculated the element, just return.
we only have the *direct* substitutions
then for each of the direct substitutions, get its substitution
group, and combine the groups together.
Check whether this element is blocked. If so, ignore it.
Remember derivation methods and blocks from the types
Add this one to potential group
Get potential group for this element
For each of them, check whether it's blocked (by type)
Ignore it if it's blocked
Convert to an array
Store the potential sub group
type == null means the current type is anySimpleType,
whose base type should be anyType
No derivation relation, or blocked, return false
Remember the derivation methods and blocks, return true.
Record the information about how one element substitute another one
The element that substitutes another one
The combination of all derivation methods from sub's type to
the head's type
excluding sub's type
whether there is one with the same tns
if the one we have is different from the one passed, it's an error
not deep import, then just add this one grammar
get all imported grammars, and make a copy of the Vector, so that
we can recursively process the grammars, and add distinct ones
to the same vector
for all (recursively) imported grammars
get the grammar
check whether the bucket has one with the same tns
we need to add grammars imported by sg1 too
for all grammars imported by sg2, but not in the vector
we add them to the vector
we found one with the same target namespace
if the two grammars are not the same object, then it's an error
now we have all imported grammars stored in the vector. add them
if grammar already exist in the bucket, we ignore the request
not adding the imported grammars
get all imported grammars, and make a copy of the Vector, so that
we can recursively process the grammars, and add distinct ones
to the same vector
for all (recursively) imported grammars
get the grammar
check whether the bucket has one with the same tns
we need to add grammars imported by sg1 too
for all grammars imported by sg2, but not in the vector
we add them to the vector
we found one with the same target namespace, ignore it
now we have all imported grammars stored in the vector. add them
get the number of grammars
get grammars with target namespace
add the grammar without target namespace, if any
forCaching flag is ignored because this is not a dynamic provider
SAX document handler.
No warranty; no copyright -- use this as you will.
$Id: DocumentHandler.java,v 1.2 2004/11/03 22:44:51 jsuttor Exp $
end of DocumentHandler.java
If everything fails create a Constant pool entry
Create a Constant pool entry
Create a Constant pool entry
Create a Constant pool entry
Create a Constant pool entry
First try to call the delegate implementation class's
"Object get_interface_def(..)" method (will work for JDK1.2
Else call the delegate implementation class's
"InterfaceDef get_interface(..)" method using reflection
(will work for pre-JDK1.2 ORBs).
Interface doesn't support the address family of
REVISIT: the implementation of ErrorReporter.
we probably should not pass XMLParseException
method to get the DOMLocator Object
assuming DOMLocator wants the *expanded*, not the literal, URI of the doc... - neilg
should never happen
Identical to ConstantString except for the name
Trim the given byte array to the given length
Trim the given char array to the given length
We need to perform double, not float, arithmetic; otherwise
we lose low order bits when len is larger than 2**24.
Use sun.misc.MessageUtils rather than the Logging API or
System.err since this method may be called during VM
initialization before either is available.
-- Decoding --
Substitution is always enabled,
so this shouldn't happen
(1)We never cache the "external" cs, the only benefit of creating
an additional StringDe/Encoder object to wrap it is to share the
de/encode() method. These SD/E objects are short-lifed, the young-gen
gc should be able to take care of them well. But the best approash
is still not to generate them if not really necessary.
(2)The defensive copy of the input byte/char[] has a big performance
impact, as well as the outgoing result byte/char[]. Need to do the
optimization check of (sm==null && classLoader0==null) for both.
(3)getClass().getClassLoader0() is expensive
(4)There might be a timing gap in isTrusted setting. getClassLoader0()
is only chcked (and then isTrusted gets set) when (SM==null). It is
possible that the SM==null for now but then SM is NOT null later
when safeTrim() is invoked...the "safe" way to do is to redundant
check (... && (isTrusted || SM == null || getClassLoader0())) in trim
but it then can be argued that the SM is null when the opertaion
Substitution is always enabled,
so this shouldn't happen
use charset name decode() variant which provides caching.
If this code is hit during VM initialization, MessageUtils is
the only way we will be able to get any kind of error message.
If we can not find ISO-8859-1 (a required encoding) then things
are seriously wrong with the installation.
-- Encoding --
Substitution is always enabled,
so this shouldn't happen
use charset name encode() variant which provides caching.
If this code is hit during VM initialization, MessageUtils is
the only way we will be able to get any kind of error message.
If we can not find ISO-8859-1 (a required encoding) then things
are seriously wrong with the installation.
SAX exception class.
No warranty; no copyright -- use this as you will.
$Id: SAXParseException.java,v 1.2 2004/11/03 22:55:32 jsuttor Exp $
append the exception message at the end
Added serialVersionUID to preserve binary compatibility
end of SAXParseException.java
-- This file was mechanically generated: Do not edit! --
enforce limit == capacity
This check is done early so that no attempt
may be made to do a location forward to a local
object.  Doing this lazily would allow
forwarding to locals in some restricted cases.
The array to hold all data
Number of elements in this list
REVISIT: this is temp solution. In general we need to use this class
instead of the Vector.
SAXCatalogParser.java - An interface for reading catalog files
read and discard the repository ID
write the repository ID
manually code maps to ensure correct data always used
(locale data can be changed by application code)
2 digit year not handled
should handle UT/Z/EST/EDT/CST/CDT/MST/MDT/PST/MDT
buffer output to avoid writing to appendable in case of error
index not updated from input
errorIndex not updated from input
TODO: Fix tests to not depend on toString()
return "DateTimeFormatter[" + locale +
(chrono != null ? "," + chrono : "") +
(zone != null ? "," + zone : "") +
not actually serializable
private objects to cache the locale and resource bundle
memorize the most-recent locale
TODO: at this time we do not do anything with this
information, attempts to add the jarfile to the CLASSPATH
were successful via System.setProperty, but the effects
were not visible to the running JVM. For now we add jarfile
to CLASSPATH in the wrapper script that calls this program.
TODO verify jarFile exists...
Create a SAX parser and get the XMLReader object it uses
Set the DOM's DOM builder as the XMLReader's SAX2 content handler
Pass global parameters
Transform the document
Parse options starting with '-'
Enough arguments left ?
Get document file and class name
Parse stylesheet parameters
Re-declares the methods that are in class MBeanInfo of JMX 1.0
(methods will be removed when MBeanInfo is made a parent interface of this interface)
Type-specific CORBA::Object operations
some small documents won't have any sticky positions
at all, so the buffer is created lazily.
--- local methods ---------------------------------------
need to grow the array
patch the existing array
zero is a special case where we update only
marks after it.
this record is no longer used, get rid of it
this record is no longer used, get rid of it
this record is no longer used, get rid of it
Check if the Position is still valid.
schedule the record to be removed later
on another thread.
Get the Positions in the range being removed.
Update the Positions that were in the range removed.
Where the string goes.
Length of the string.
The string that was inserted. To cut down on space needed this
will only be valid after an undo.
An array of instances of UndoPosRef for the Positions in the
range that was removed, valid after undo.
Update the Positions that were in the range removed.
Get the Positions in the range being removed.
Where the string goes.
Length of the string.
The string that was inserted. This will be null after an undo.
An array of instances of UndoPosRef for the Positions in the
range that was removed, valid before undo.
lower/upper case value is not the same as code point
more effecient than NamespaceSupport(NamespaceContext)
expand namespace's size...
the trick here is to recognize that all local contexts
happen to start at fContext[3].
context 1: empty
context 3: decls on <xs:schema>: the global ones
This method removes from this object all the namespaces
returned by getEffectiveLocalContext.
may throw MidiUnavailableException
may throw MidiUnavailableException
may throw MidiUnavailableException
IMPORTANT: this code needs to be synch'ed with
all AutoConnectSequencer instances,
(e.g. RealTimeSequencer) because the
same algorithm for synth retrieval
needs to be used!
first try to connect to the default synthesizer
make sure that the synth is properly closed
something went wrong with synth
then try to connect to the default Receiver
something went wrong. Nothing to do then!
gather from all the providers
gather from all the providers
$$fb 2002-04-17: Fix for 4635287: Standard MidiFileWriter cannot write empty Sequences
$$fb 2002-04-17: Fix for 4635287: Standard MidiFileWriter cannot write empty Sequences
try to get MIDI port
try to get Synthesizer
try to get MIDI port
try to get Synthesizer
try to get MIDI port
try to get Synthesizer
try to get MIDI port
try to get Synthesizer
This clause is for deviceClass being either Synthesizer
Now the case that deviceClass is Transmitter or
Receiver. If neither allowSynthesizer nor allowSequencer is
true, we require device instances to be
neither Synthesizer nor Sequencer, since we only want
devices representing MIDI ports.
Otherwise, the respective type is accepted, too
And of cource, the device has to be able to provide
Receivers or Transmitters.
Import general CORBA classes
Get org.omg.CosNaming Types
Get base implementation
Get a hash table
If there are more elements get the next element
Return empty but marshalable binding
Remove the object from the Active Object Map.
PENDING: We need to expose the bias in DefaultCaret.
If we scroll, our visual location will have changed,
but we won't have updated our internal location as
the model hasn't changed. This checks for the change,
and if necessary, resets the internal location.
2^16 - 1
2^32 - 1
root -> IHDR
root -> PLTE
root -> PLTE -> PLTEEntry
root -> bKGD
root -> bKGD -> bKGD_Grayscale
root -> bKGD -> bKGD_RGB
root -> bKGD -> bKGD_Palette
root -> cHRM
root -> gAMA
root -> hIST
root -> hISTEntry
root -> iCCP
root -> iTXt
root -> iTXt -> iTXtEntry
root -> pHYS
root -> sBIT
root -> sBIT -> sBIT_Grayscale
root -> sBIT -> sBIT_GrayAlpha
root -> sBIT -> sBIT_RGB
root -> sBIT -> sBIT_RGBAlpha
root -> sBIT -> sBIT_Palette
root -> sPLT
root -> sPLT -> sPLTEntry
root -> sRGB
root -> tEXt
root -> tEXt -> tEXtEntry
root -> tIME
root -> tRNS
root -> tRNS -> tRNS_Grayscale
root -> tRNS -> tRNS_RGB
root -> tRNS -> tRNS_Palette
root -> zTXt
root -> zTXt -> zTXtEntry
root -> UnknownChunks
root -> UnknownChunks -> UnknownChunk
keeps track of the threads that are printing this component
True if there is at least one thread that's printing this component
This method is not synchronized under AWT tree lock.
Instead, the calling code is responsible for the
synchronization. See 6784816 for details.
This method is not synchronized under AWT tree lock.
Instead, the calling code is responsible for the
synchronization. See 6784816 for details.
This method is not synchronized under AWT tree lock.
Instead, the calling code is responsible for the
synchronization. See 6784816 for details.
NOTE: This method may be called by privileged threads.
This functionality is implemented in a package-private method
to insure that it cannot be overridden by client subclasses.
DO NOT INVOKE CLIENT CODE ON THIS THREAD!
We should remove component and then
add it by the newIndex without newIndex decrement if even we shift components to the left
after remove. Consult the rules below:
2->4: 012345 -> 013425, 2->5: 012345 -> 013452
4->2: 012345 -> 014235
was actually removed
Component didn't have parent - no removeNotify
Component didn't have peer - no removeNotify
Component has peer but new Container doesn't - call removeNotify
If component is lightweight non-Container or lightweight Container with all but heavyweight
children there is no need to call remove notify
If this point is reached, then the comp is either a HW or a LW container with HW descendants.
All three components have peers, check for peer change
Native containers change - check whether or not current platform supports
changing of widget hierarchy on native level without recreation.
The current implementation forbids reparenting of LW containers with HW descendants
into another native container w/o destroying the peers. Actually such an operation
is quite rare. If we ever need to save the peers, we'll have to slightly change the
addDelicately() method in order to handle such LW containers recursively, reparenting
each HW descendant independently.
Store parent because remove will clear it
If the oldZindex == -1, the component gets inserted,
rather than it changes its z-order.
The new 'index' cannot be == -1.
It gets checked at the checkAdding() method.
Therefore both oldZIndex and index denote
some existing positions at this point and
this is actually a Z-order changing.
If components is lightweight check if it is container
If it is container it might contain heavyweight children we need to reparent
Q: Need to update NativeInLightFixer?
If component is lightweight container we need to reparent all its explicit  heavyweight children
Traverse component's tree till depth-first until encountering heavyweight component
Check if moving between containers
index == -1 means add to the end.
Remove notify was called or it didn't have peer - create new one
Both container and child have peers, it means child peer should be reparented.
In both cases we need to reparent native widgets.
Native container changed - need to reparent native widgets
If component is heavyweight and one of the containers is lightweight
the location of the component should be fixed.
If component is focus owner or parent container of focus owner check that after reparenting
focus owner moved out if new container prohibit this kind of focus owner.
Quick check - container should be immediate parent of the component
index == -1 means add to the end.
Should only be called while holding tree lock
Verify listeningChildren is correct
Verify listeningBoundsChildren is correct
Should only be called while holding tree lock
Should only be called while holding tree lock
Should only be called while holding tree lock
Should only be called while holding tree lock
Verify descendantsCount is correct
Don't lazy-read because every app uses invalidate()
Avoid updating cursor if this is an internal call.
See validateUnconditionally() for details.
The container is showing on screen and
this paint() is not called from print().
Paint self and forward the paint to lightweight subcomponents.
super.paint(); -- Don't bother, since it's a NOP.
By default, Component.print() calls paint()
REMIND: remove when filtering is done at lower level
event was sent to a lightweight component.  The
native-produced event sent to the native container
must be properly disposed of by the peer, so it
gets forwarded.  If the native host has been removed
as a result of the sending the lightweight event,
the peer reference will be null.
found a component that intersects the point, see if there
is a deeper possibility.
there isn't a deeper target, but this component
is a target
didn't find a child target, return this component if it's
a possible target
no possible target
this container is lightweight.... continue sending it
This is a native container, so it needs to host
one of it's children.  If this function is called before
a peer has been created we don't yet have a dispatcher
because it has not yet been determined if this instance
Optimized version of two passes:
see comment in sun.awt.SunGraphicsCallback
return heavyweight component as soon as possible
save and return later the first lightweight component
checkTreeLock(); commented for a performance reason
Optimized version of two passes:
see comment in sun.awt.SunGraphicsCallback
return heavyweight component as soon as possible
save and return later the first lightweight component
addNotify() on the children may cause proxy event enabling
on this instance, so we first call super.addNotify() and
possibly create an lightweight event dispatcher before calling
addNotify() on the children which may be lightweight.
We shouldn't use iterator because of the Swing menu
the menu is being assigned as a child to JLayeredPane
instead of particular component so always affect
collection of component if menu is becoming shown or hidden.
We shouldn't use iterator because of the Swing menu
the menu is being assigned as a child to JLayeredPane
instead of particular component so always affect
collection of component if menu is becoming shown or hidden.
Fix for 6607170.
We want to suppress focus change on disposal
of the focused component. But because of focus
is asynchronous, we should suppress focus change
on every component in case it receives native focus
in the process of disposal.
If some of the children had focus before disposal then it still has.
Auto-transfer focus to the next (or previous) component if auto-transfer
Store the app context on which this component is being shown.
Event dispatch thread of this app context will be sleeping until
we wake it by any event from hideAndDisposeHandler().
keep the KeyEvents from being dispatched
until the focus has been transfered
We have two mechanisms for blocking: 1. If we're on the
EventDispatchThread, start a new event pump. 2. If we're
on any other thread, call wait() on the treelock.
Wake up event dispatch thread on which the dialog was
Don't call super.setFocusTraversalKey. The Component parameter check
does not allow DOWN_CYCLE_TRAVERSAL_KEYS, but we do.
Don't call super.getFocusTraversalKey. The Component parameter check
does not allow DOWN_CYCLE_TRAVERSAL_KEY, but we do.
I potentially have two roots, myself and my root parent
If I am the current root, then use me
If none of my parents are roots, then use me
If my root parent is the current root, then use my root parent
If neither I nor my root parent is the current root, then
use my root parent (a guess)
This synchronized should always be the second in a pair
(tree lock, KeyboardFocusManager.class)
Serialization support. A Container is responsible for restoring the
parent fields of its component children.
Old stream. Doesn't contain maxSize among Component's fields.
skip value for unrecognized key
JDK 1.1/1.2/1.3 instances will not have this optional data.
e.eof will be true to indicate that there is no more data
available for this object. If e.eof is not true, throw the
exception as it might have been caused by reasons unrelated to
inner class AccessibleAWTContainer
An invalid container with not-null layout should be ignored
by the mixing code, the container will be validated later
and the mixing code will be executed later.
An invalid container with not-null layout should be ignored
by the mixing code, the container will be validated later
and the mixing code will be executed later.
sensitive to mouse events
4508327 : MOUSE_CLICKED should only go to the recipient of
the accompanying MOUSE_PRESSED, so don't reset mouseEventTarget on a
4508327: MOUSE_CLICKED should never be dispatched to a Component
other than that which received the MOUSE_PRESSED event.  If the
mouse is now over a different Component, don't dispatch the event.
The previous fix for a similar problem was associated with bug
This may send it somewhere that doesn't have MouseWheelEvents
enabled.  In this case, Component.dispatchEventImpl() will
retarget the event to a parent that DOES have the events enabled.
Consuming of wheel events is implemented in "retargetMouseEvent".
not necessarily sensitive to mouse events
This can happen if a lightweight component which initiated the
drag has an associated drop target. MOUSE_ENTERED comes when the
mouse is in the native container already. To propagate this event
properly we should null out targetLastEntered.
any event but an exit or drag means we're in the native container
consume native exit event if we generate one
consume native enter event if we generate one
only interested in drags from other hw components
component may have disappeared since drag event posted
(i.e. Swing hierarchical menus)
check if srcComponent is in any modal blocked window
create an internal 'dragged-over' event indicating
we are being dragged over from another hw component
translate coordinates to this native container
feed the 'dragged-over' event directly to the enter/exit
code (not a real event so don't pass it to dispatchEvent)
mouse is over another hw component or target is disabled
avoid recursively calling LightweightDispatcher...
An exception for wheel bubbling to the native system.
In "processMouseEvent" total event consuming for wheel events is skipped.
Protection from bubbling of Java-accepted wheel events.
--- member variables -------------------------------
Methods for use only by StateEngineImpl
end of FSMImpl.java
since namespace context should still be valid when the parser is at the end element state therefore
we pop the context only when next() has been called after the end element state was encountered. - nb.
when skipping is true and no more elements should be added
get the stored element -- if everything goes right this should match the
token in the buffer
Be conservative -- if skipping fails -- stop.
if skipping fails reposition the stack or fallback to normal way of processing
we are still at the stage of adding elements
the elements were not matched or
fSkip is not set to true
get the next element from the stack
There are two variables,fNamespaces and fBindNamespaces
StAX uses XMLNSDocumentScannerImpl so this distinction needs to be maintained
when the elements are being added , we need to check if we are set for skipping the elements
this sets the value of fAdd variable
xxx: We dont need another pointer, fCurrentElement, we can use fElementQName
REVISIT: is it required? forbit xmlns prefix for element
bind the element
assign uri to the element
make sure that object in the element stack is updated as well
bind attributes (xmlns are already bound bellow)
fLength = 0; initialize structure
REVISIT: try removing the first "if" and see if it is faster.
decrease the markup depth..
check that this element was opened in the same entity
We should not be popping out the context here in endELement becaause the namespace context is still
valid when parser is at the endElement state.
pop the element off the stack..
complete element and attributes are traversed in this function so we can send a callback
<strong>we shouldn't be sending callback in scanDocument()</strong>
REVISIT: one more case needs to be included: external PE and standalone is no
REVISIT: it seems that this function should not take attributes, and length
fTempString would store attribute value
/fTempString2 would store attribute non-normalized value
this function doesn't use 'attIndex'. We are adding the attribute later
after we have figured out that current attribute is not namespace declaration
since scanAttributeValue doesn't use attIndex parameter therefore we
can safely add the attribute later..
record namespace declarations if any.
check the length of URI
get the internalized value of this attribute
1. "xmlns" can't be bound to any namespace
2. the namespace for "xmlns" can't be bound to any prefix
3. "xml" can't be bound to any other namespace than it's own
4. the namespace for "xml" can't be bound to any other prefix
set it equal to XMLSymbols.PREFIX_XMLNS when namespace declaration
is of type xmlns = "..", in this case prefix = "" and localname = XMLSymbols.PREFIX_XMLNS
this special behavior is because of dependency on this behavior in DOM components
We should only report an error if there is a prefix,
that is, the local part is not "xmlns". -SG
check for duplicate prefix bindings
declare prefix in context
check for duplicate xmlns declarations
by convention, prefix == "xmlns" | "xml"
error if duplicate declaration
xerces internals (XSAttributeChecker) has dependency on namespace declaration returned
as part of XMLAttributes.
addition of namespace declaration to the attribute list is controlled by fNotAddNSDeclAsAttribute
feature. This is required in Stax where namespace declarations are not considered as attribute
add the attributes to the list of attributes
WFC: Unique Att Spec
removing  as we are not using non-normalized values . -Venu
attempt to bind attribute
fDTDValidator will be null in Stax mode
re-configure pipeline by removing DTDValidator
Whups; had that backward!
Is the new index an index into the cache row of m_map?
Growing the outer array should be rare. We initialize to a
total of m_blocksize squared elements, which at the default
size is 4M integers... and we grow by at least that much each
time.  However, attempts to microoptimize for this (assume
long enough and catch exceptions) yield no noticable
Cache the current row of m_map.  Next m_blocksize-1
values added will go to this row.
No point in removing elements that "don't exist"...
This is actually a significant optimization!
Last block may need to stop before end
this controls what happens when a local element is encountered.
We may not encounter all local elements when first parsing.
The only thing we care about now is whether this element has
minOccurs=0. This affects (if the element appears in a complex
type) whether a type has emptiable content.
If it's an empty particle, return null.
General Attribute Checking
Element Declaration Representation OK
2 If the item's parent is not <schema>, then all of the following must be true:
2.1 One of ref or name must be present, but not both.
2.2 If ref is present, then all of <complexType>, <simpleType>, <key>, <keyref>, <unique>, nillable, default, fixed, form, block and type must be absent, i.e. only minOccurs, maxOccurs, id are allowed in addition to ref, along with <annotation>.
General Attribute Checking'
Step 1: get declaration information
get 'target namespace'
get 'block', 'final', 'nillable', 'abstract'
discard valid Block 'Default' values that are invalid for Block
use specified values
check for valid values
discard valid Final 'Default' values that are invalid for Final
get 'value constraint'
get 'substitutionGroup affiliation'
get 'type definition'
Handle Anonymous type if there is one
Handler type attribute
Get it from the substitutionGroup declaration
get 'identity constraint'
see if there's something here; it had better be key, keyref or unique.
need to set <key>/<unique> to hidden before traversing it,
because it has global scope
Step 3: check against schema for schemas
Step 4: check 3.3.3 constraints
1 default and fixed must not both be present.
2 If the item's parent is not <schema>, then all of the following must be true:
2.1 One of ref or name must be present, but not both.
This is checked in XSAttributeChecker
2.2 If ref is present, then all of <complexType>, <simpleType>, <key>, <keyref>, <unique>, nillable, default, fixed, form, block and type must be absent, i.e. only minOccurs, maxOccurs, id are allowed in addition to ref, along with <annotation>.
Attributes are checked in XSAttributeChecker, elements are checked in "traverse" method
3 type and either <simpleType> or <complexType> are mutually exclusive.
Step 5: check 3.3.6 constraints
check for NOTATION type
Element without a name. Return null.
Step 5: register the element decl to the grammar
we also add the element to the tolerate duplicates list as well
if we are tolerating duplicates, and we found a duplicate declaration
use the duplicate one instead
Exported operations inherited and overridden from class Object.
this method should never be called: XSSimpleTypeDecl is responsible for
calling the item type for the convertion
length of a list type is the number of items in the list
end of loop
everything went fine.
If debug was compiled to be true for testing purposes,
don't change it.
Determine the initial bootstrap port to use
Create an ORB object
-Dorg.omg.CORBA.ORBInitialPort=0 is invalid
Let arguments override
Was the initial port specified?
-ORBInitialPort 0 is invalid
If initialPort is not set, then we need to set the Default
Initial Port Property for the ORB
Set -ORBInitialPort = Persistent Server Port so that ORBImpl
will start Boot Strap.
This is used for handshaking by the IBM test framework!
Do not modify, unless another synchronization protocol is
used to replace this hack!
Let the User Know that -ORBInitialHost is not valid for
Let the User Know that -ORBInitialPort 0 is not valid for
Allocate the array and copy the data reference
Need to alloc a new destination array
Apply one LUT to all bands
Need to alloc a new destination array
Apply one LUT to all bands
NOTE: This method may be called by privileged threads.
We implement this functionality in a package-private method
to insure that it cannot be overridden by client subclasses.
DO NOT INVOKE CLIENT CODE ON THIS THREAD!
Bug #4059614: select can't be synchronized while calling the peer,
because it is called from the Window Thread.  It is sufficient to
synchronize the code that manipulates 'selected' except for the
case where the peer changes.  To handle this case, we simply
repeat the selection process.
REMIND: remove when filtering is done at lower level
skip value for unrecognized key
fredxFIXME Not implemented yet
[[[FIXME]]] need to finish implementing this!!!
required Accessible methods
required AccessibleContext methods
list elements can't have children
list elements can't have children
AccessibleComponent delegatation to parent List
[[[FIXME]]] needs to work like isShowing() below
[[[FIXME]]] should scroll to item to make it show!
[[[FIXME]]] only if it's showing!!!
[[[FIXME]]] - only if p is within the list element!!!
[[[FIXME]]] maybe - can simply return as no-op
no-op; not supported
not supported; no-op
object cannot have children!
list element cannot receive focus!
nothing to do; a no-op
nothing to do; a no-op
nothing to do; a no-op
inner class AccessibleAWTListChild
inner class AccessibleAWTList
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of MenuBarMenuPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of MenuBarMenuPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
A flag used to tell whether the background has been set by
developer code (as opposed to AWT code).  Used to determine
the background color of non-editable TextComponents.
if something bad happens, just don't enable input methods
moved from the constructor above to here and addNotify below,
this call will initialize the toolkit if not already initialized.
TextComponent handles key events without touching the eventMask or
having a key listener, so just check whether the flag is set
Please note that we do not want to post an event
if TextArea.setText() or TextField.setText() replaces an empty text
by an empty text, that is, if component's text remains unchanged.
REMIND: remove when filtering is done at lower level
Serialization support.  Since the value of the fields
selectionStart, selectionEnd, and text aren't necessarily
up to date, we sync them up with the peer before serializing.
Make sure the state we just read in for text,
selectionStart and selectionEnd has legal values
skip value for unrecognized key
--- interface AccessibleText methods ------------------------
No attributes in TextComponent
Fix for 4256662
Fix for 4256660 and 4256661.
Words iterator is different from character and sentence iterators
in that end of one word is not necessarily start of another word.
Please see java.text.BreakIterator JavaDoc. The code below is
based on nextWordStartAfter example from BreakIterator.java.
end of AccessibleAWTTextComponent
Copyright (c) 1995-96 by Cisco Systems, Inc.
Polling control parameters.
value of 0 means poll never happened.
add to adaptor queue.
should never happen.
check if request is in progress.
We can manipulate callback safely as we are in session thread.
This is being done from a different thread. So notifyClient will do the notification.
true if request completed.
PRIVATE AND PACKAGE METHODS
Consider it as a try !
This exception will caught hereafter and reported as an snmpReqUnknownError
FIXME: may be it's not the best behaviour ?
check if this request is still alive.
the request may have  cancelled.
At this point the errorIndex is rationalized to start with 0.
Refire request after fixing varbindlist.
rationalize for index to start with 0.
delete only non-poll request.
catch all user exception which may happen in callback.
catch any exception a user might not handle.
catch any exception a user might not handle.
catch any exception a user might not handle.
Remove the clause synchronized of the stopRequest method.
Synchronization is isolated as possible to avoid thread lock.
Note: the method removeRequest from SendQ is synchronized.
fix bug jaw.00392.B
may be null
absolute path pattern temporary
private objects to cache the locale and resource bundle
memorize the most-recent locale
These should not be necessary because BasicMenuUI does this,
and this class overrides createChangeListener.
result will contain the attrs which have to be output
It's not a namespace attr node. Add to the result and continue.
The default mapping for xml must not be output.
Render the ns definition
It is the first node of the subtree
Obtain all the namespaces defined in the parents, and added to the output.
output the attributes in the xml namespace.
result will contain the attrs which have to be output
A non namespace definition node.
treat xml:id like any other attribute
(emit it, but don't inherit it)
The node is visible add the attribute to the list of output attributes.
add the prefix binding to the ns symb table.
The xpath select this node output it if needed.
The element is visible, handle the xmlns definition
No xmlns def just get the already defined.
There is a definition but the xmlns is not selected by the xpath.
output the xmlns def if needed.
Float all xml:* attributes of the unselected parent elements to this one.
pre-parse the baseURI
1. The input buffer is initialized with the now-appended path
components then replace occurrences of "" in the input buffer
with "/" until no more occurrences of "" are in the input buffer.
Initialize the output buffer with the empty string.
If the input buffer starts with a root slash "/" then move this
character to the output buffer.
While the input buffer is not empty, loop as follows
2A. If the input buffer begins with a prefix of "./",
then remove that prefix from the input buffer
else if the input buffer begins with a prefix of "../", then
if also the output does not contain the root slash "/" only,
then move this prefix to the end of the output buffer else
remove that prefix
2B. if the input buffer begins with a prefix of "/./" or "/.",
where "." is a complete path segment, then replace that prefix
with "/" in the input buffer; otherwise,
FIXME: what is complete path segment?
2C. if the input buffer begins with a prefix of "/../" or "/..",
where ".." is a complete path segment, then replace that prefix
with "/" in the input buffer and if also the output buffer is
empty, last segment in the output buffer equals "../" or "..",
where ".." is a complete path segment, then append ".." or "/.."
for the latter case respectively to the output buffer else
remove the last segment and its preceding "/" (if any) from the
output buffer and if hereby the first character in the output
buffer was removed and it was not the root slash then delete a
leading slash from the input buffer; otherwise,
FIXME: what is complete path segment?
2D. if the input buffer consists only of ".", then remove
that from the input buffer else if the input buffer consists
only of ".." and if the output buffer does not contain only
the root slash "/", then move the ".." to the output buffer
else delte it.; otherwise,
2E. move the first path segment (if any) in the input buffer
to the end of the output buffer, including the initial "/"
character (if any) and any subsequent characters up to, but not
including, the next "/" character or the end of the input buffer.
3. Finally, if the only or last segment of the output buffer is
"..", where ".." is a complete path segment not followed by a slash
then append a slash "/". The output buffer is returned as the result
making the code more robust as it would handle null or 0 length data,
add the data only when it contains some thing
The serialized for of rmiServerImpl is automatically
a RMI server stub.
Check the internal access file property to see
if an MBeanServerForwarder is to be provided
Check if access file property is specified
Access file property specified, create an instance
of the MBeanServerFileAccessController class
Set the MBeanServerForwarder
fit e in the nested exception if we are on 1.4
if jndiURL is null, we must encode the stub into the URL.
OK: we are already throwing another exception
rmiServerImpl can be null if stop() called without start()
fit e in as the nested exception if we are on 1.4
if jndiURL is not null, we nust bind the stub to a
will default to local host name
Translate all full groups from byte array elements to Base64
Translate partial group if present
Note that this is a different value than in previous releases
of Xalan. It's sensitive to the exact encoding of the node
handle anyway, so fighting to maintain backward compatability
really didn't make sense; it may change again as we continue
to experiment with balancing document and node numbers within
from purely XML Schema perspective,
this implementation has a problem, since
in xs:decimal "1.0" and "1" is equal whereas the above
code will return different values for those two forms.
the code was originally using com.sun.msv.datatype.xsd.NumberType.load,
but a profiling showed that the process of normalizing "1.0" into "1"
could take non-trivial time.
also, from the user's point of view, one might be surprised if
1 (not 1.0) is returned from "1.000"
these screening process is necessary due to the wobble of Float.valueOf method
these screening process is necessary due to the wobble of Float.valueOf method
no point in searching the first char. that's not valid.
Prefix exists, check everything
uri can never be null according to javadoc,
but some users reported that there are implementations that return null.
crap. the NamespaceContext interface is broken.
error: unbound prefix
"111" is not a valid hex encoding.
compute the tail '=' chars
most likely this base64 text is indented. go with the upper bound
text.charAt(j) is now at some base64 char, so +1 to make it the size
something is wrong with base64. be safe and go with the upper bound
so far this base64 looks like it's unindented tightly packed base64.
take a chance and create an array with the expected size
convert each quadruplet to three bytes.
quadruplet is now filled.
speculation worked out to be OK
we overestimated, so need to create a new buffer
encode elements until only 1 or 2 elements are left to encode
encode when exactly 1 element (left) to encode
encode when exactly 2 elements (left) to encode
encode when exactly 1 element (left) to encode
encode when exactly 2 elements (left) to encode
not a meta character
seen meta character. we don't do error check against the format
illegal meta character. impossible.
left 0 paddings.
otherwise print out normally.
offset is in milli-seconds
n is always non-negative.
$$kk: 03.25.99: why can't this be final??
$$fb 2002-11-26: fix for 4695001: SPEC: description of equals() method contains typo
LINE EVENT TYPE DEFINES
do not fallback if given classloader can't find the class, throw exception
======= CONFIGURATION METHODS =======
Index to CONSTANT_Class or offset
TODO: use three-value variables for boolean values: true/false/default
These attributes are extracted from the xsl:output element. They also
appear as fields (with the same type, only public) in the translet
Disables this output element (when other element has higher precedence)
Some global constants
Transfer attributes from previous xsl:output
addAttribute works as a setter if it already exists
Transfer non-standard attributes as well
Ask the parser if it wants this <xsl:output> element
Do nothing if other <xsl:output> element has higher precedence
Get the output version
Get the output method - "xml", "html", "text" or <qname> (but not ncname)
Get the output encoding - any value accepted here
Create a write to verify encoding support
Should the XML header be omitted - translate to true/false
Add 'standalone' decaration to output - use text as is
Get system/public identifiers for output DOCTYPE declaration
Names the elements of whose text contents should be output as CDATA
Make sure to store names in expanded form
Get the indent setting - only has effect for xml and html output
indent-amount: extension attribute of xsl:output
Hack for supporting Old Namespace URI.
Get the MIME type for the output file
Set output properties in current stylesheet
Do nothing if other <xsl:output> element has higher precedence
Only update _version field if set and different from default
Only update _method field if "method" attribute used
Only update if _encoding field is "encoding" attribute used
Only update if "omit-xml-declaration" used and set to 'yes'
Add 'standalone' decaration to output - use text as is
Set system/public doctype only if both are set
Add 'medye-type' decaration to output - if used
Compile code to set output indentation on/off
Compile code to set indent amount.
Forward to the translet any elements that should be output as CDATA
Cleanup - pop last translet reference off stack
root -> ImageDescriptor
root -> LocalColorTable
root -> LocalColorTable -> ColorTableEntry
root -> GraphicControlExtension
root -> PlainTextExtension
root -> ApplicationExtensions
root -> ApplicationExtensions -> ApplicationExtension
root -> CommentExtensions
root -> CommentExtensions -> CommentExtension
Check that the output has been set, then throw an
Use the system property first
try to read from $java.home/lib/jaxm.properties
try to find services in CLASSPATH
If not found and fallback should not be tried, return a null result.
We didn't find the class through the usual means so try the default
(built in) factory if specified.
make sure that the current thread has an access to the package of the given name.
(only) default implementation can be loaded
using bootstrap class loader:
add this message to fix bug 21478
Earlier (JDK 1.4 XALAN 2.2-D11) at key code '204' the key name was ER_PRIORITY_NOT_PARSABLE
In latest Xalan code base key name is  ER_VALUE_SHOULD_BE_NUMBER. This should also be taken care
in locale specific files like XSLTErrorResources_de.java, XSLTErrorResources_fr.java etc.
NOTE: Not only the key name but message has also been changed.
Note to translators:  The following message should not normally be displayed
to users.  It describes a situation in which the processor has detected
an internal consistency problem in itself, and it provides this message
for the developer to help diagnose the problem.  The name
'ElemTemplateElement' is the name of a class, and should not be
Note to translators:  The following message should not normally be displayed
to users.  It describes a situation in which the processor has detected
an internal consistency problem in itself, and it provides this message
for the developer to help diagnose the problem.  The substitution text
provides further information in order to diagnose the problem.  The name
'RedundentExprEliminator' is the name of a class, and should not be
This code is shared with warning codes.
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "QNAME" is the XML data-type of
The following codes are shared with the warning codes...
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "ENUM" is the XML data-type of
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "NMTOKEN" is the XML data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "NCNAME" is the XML data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "boolean" is the XSLT data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "number" is the XSLT data-type
End of shared codes...
Note to translators:  A "match pattern" is a special form of XPath expression
that is used for matching patterns.  The substitution text is the name of
a function.  The message indicates that when this function is referenced in
a match pattern, its argument must be a string literal (or constant.)
ER_ARG_LITERAL - new error message for bugzilla 5202
Note to translators:  The following message indicates that two definitions of
a variable.  A "global variable" is a variable that is accessible everywher
in the stylesheet.
ER_DUPLICATE_GLOBAL_VAR - new error message for bugzilla #790
Note to translators:  The following message indicates that two definitions of
a variable were encountered.
ER_DUPLICATE_VAR - new error message for bugzilla #790
Note to translators:  "xsl:template, "name" and "match" are XSLT keywords
which must not be translated.
ER_TEMPLATE_NAME_MATCH - new error message for bugzilla #789
Note to translators:  "exclude-result-prefixes" is an XSLT keyword which
should not be translated.  The message indicates that a namespace prefix
encountered as part of the value of the exclude-result-prefixes attribute
was in error.
ER_INVALID_PREFIX - new error message for bugzilla #788
Note to translators:  An "attribute set" is a set of attributes that can
be added to an element in the output document as a group.  The message
was never defined.
ER_NO_ATTRIB_SET - new error message for bugzilla #782
Note to translators:  This message indicates that there was a reference
Note to translators:  This message indicates that the XSLT instruction
instructions (content) or a "select" attribute.  The word "select" is
an XSLT keyword in this case and must not be translated.
Note to translators:  This message indicates that the value argument
of setParameter must be a valid Java Object.
Following are the new WARNING keys added in XALAN code base after Jdk 1.4 (Xalan 2.2-D11)
Note to translators:  "name" and "xsl:processing-instruction" are keywords
and must not be translated.
Note to translators:  "name" and "xsl:processing-instruction" are keywords
and must not be translated.  "NCName" is an XML data-type and must not be
Note to translators:  This message is reported if the stylesheet that is
being processed attempted to construct an XML document with an attribute in a
place other than on an element.  The substitution text specifies the name of
Check: WHY THERE IS A GAP B/W NUMBERS in the XSLTErrorResources properties file?
Other miscellaneous text used inside the code...
Note to translators:  The following messages provide usage information
for the Xalan Process command line.  "Process" is the name of a Java class,
and should not be translated.
Note to translators: The option name and the parameter name do not need to
be translated. Only translate the messages in parentheses.  Note also that
leading whitespace in the messages is used to indent the usage information
for each option in the English messages.
Do not translate the keywords: XSLTC, SAX, DOM and DTM.
Following are the new options added in XSLTErrorResources.properties files after Jdk 1.4 (Xalan 2.2-D11)
Added by sboag/scurcuru; experimental
AddITIONAL  STRINGS that need L10n
Note to translators:  The following message describes usage of a particular
command-line option that is used to enable the "template inlining"
optimization.  The optimization involves making a copy of the code
generated for a template in another template that refers to it.
================= INFRASTRUCTURE ======================
-- This file was mechanically generated: Do not edit! --
various port constants
the actions mask
Left null as long as possible, then
created and re-used in the getAction function.
hostname part as it is passed
the canonical name of the host
in the case of "*.foo.com", cname is ".foo.com".
all the IP addresses of the host
true if the hostname is a wildcard (e.g. "*.sun.com")
true if we were initialized with a single numeric IP address
true if this SocketPermission represents an invalid/unknown host
used for implies when the delayed lookup has already failed
port range on host
true if this SocketPermission represents a hostname
that failed our reverse mapping heuristic test
true if the sun.net.trustNameService system property is set
name initialized to getHost(host); NPE detected in getHost()
name initialized to getHost(host); NPE detected in getHost()
IPv6 address followed by port
IPv6 address only, not followed by port
could be ambiguous
Set the integer mask that represents the actions
always OR in RESOLVE if we allow any of the others
Parse the host name.  A name has up to three components, the
hostname, a port number, or two numbers representing a port
range.   "www.sun.com:8080-9090" is a valid host name.
With IPv6 an address can be 2010:836B:4179::836B:4179
An IPv6 address needs to be enclose in []
For ex: [2010:836B:4179::836B:4179]:8080-9090
Refer to RFC 2732 for more information.
is this a domain wildcard specification
see if we are being initialized with an IP address.
this shouldn't happen
Use object identity comparison against known-interned strings for
performance benefit (these values are used heavily within the JDK).
check for the known strings
make sure we didn't just match the tail of a word
like "ackbarfaccept".  Also, skip to the comma.
point i at the location of the comma minus one (or -1).
attempt to get the canonical name
first get the IP addresses if we don't have them yet
this is because we need the IP address to then get
we have to do this check, otherwise we might not
get the fully qualified domain name
Following check seems unnecessary
now get all the IP addresses
Literal IPv6 address
check simple port range
if either includes the ephemeral range, do full check
allow a "*" wildcard to always match anything
return if either one of these NetPerm objects are invalid...
we only check IP addresses
since "this" was initialized with an IP address, we
don't check any other cases
check and see if we have any wildcards...
if they are both wildcards, return true iff
that's cname ends with this cname (i.e., *.sun.com
a non-wildcard can't imply a wildcard
this is a wildcard, lets see if that's cname ends with
comapare IP addresses
XXX: if all else fails, compare hostnames?
Do we really want this?
make sure the first thing that is done here is to return
false. If not, uncomment the return false in the above catch.
we see if the original names/IPs passed in were equal.
this is (overly?) complex!!!
check the mask first
now check the port range...
short cut. This catches:
"crypto" equal to "crypto", or
"1.2.3.4" equal to "1.2.3.4.", or
"*.edu" equal to "*.edu", but it
does not catch "crypto" equal to
we now attempt to get the Canonical (FQDN) name and
compare that. If this fails, about all we can do is return
Write out the actions. The superclass takes care of the name
call getActions to make sure actions field is initialized
Read in the action, then initialize the rest
check policy includes ephemeral range
nothing left to do
continue check with first real port number
ephemeral range only
simple check of policy only
policyLow == 0 which means possibly two ranges to check
first check if policy and ephem range overlap/contiguous
policy and ephem range do not overlap
target range must lie entirely inside policy range or eph range
Not serialized; see serialization section at end of class
optimization to ensure perms most likely to be tested
show up early (4301064)
Convert Iterator into Enumeration
Need to maintain serialization interoperability with earlier releases,
which had the serializable field:
The SocketPermissions for this set.
Don't call out.defaultWriteObject()
Write out Vector
Don't call in.defaultReadObject()
Read in serialized fields
Get the one we want
Depending on old position value
Position may be shifted by preceding expansions
to large for short (estimate)
5 - 3
DEPRECATED - DO NOT USE!
DEPRECATED - DO NOT USE!
These are a little odd, MotifInternalFrameUI isntalls em!
default: dark slate blue
default: dark slate blue
"Table.background", white,   cell background color
These window InputMap bindings are used when the Menu is
These bindings are only enabled when there is a default
button set on the rootpane.
End of file.
result will contain the attrs which have to be output
It's not a namespace attr node. Add to the result and continue.
The default mapping for xml must not be output.
Render the ns definition
It is the first node of the subtree
Obtain all the namespaces defined in the parents, and added to the output.
output the attributes in the xml namespace.
result will contain the attrs which have to be output
A non namespace definition node.
The node is visible add the attribute to the list of output attributes.
add the prefix binding to the ns symb table.
The xpath select this node output it if needed.
The element is visible, handle the xmlns definition
No xmlns def just get the already defined.
There is a definition but the xmlns is not selected by the xpath.
output the xmlns def if needed.
Float all xml:* attributes of the unselected parent elements to this one.
For strict compliance with prior platform versions, a MenuComponent
that doesn't set its name should return null from
NOTE: This method may be called by privileged threads.
This functionality is implemented in a package-private method
to insure that it cannot be overridden by client subclasses.
DO NOT INVOKE CLIENT CODE ON THIS THREAD!
NOTE: This method may be called by privileged threads.
This functionality is implemented in a package-private method
to insure that it cannot be overridden by client subclasses.
DO NOT INVOKE CLIENT CODE ON THIS THREAD!
The MenuContainer interface does not have getFont_NoClientCode()
and it cannot, because it must be package-private. Because of
this, we must manually cast classes that implement
Fixed 6312943: NullPointerException in method MenuComponent.setFont(Font)
REMIND: remove when filtering is done at lower level
Non-specific -- overridden in subclasses
MenuComponents don't have children
MenuComponents don't have children
Not supported for MenuComponents
Not supported for MenuComponents
Not supported for MenuComponents
Not supported for MenuComponents
Not supported for MenuComponents
Not supported for MenuComponents
Not supported for MenuComponents
Not supported for MenuComponents
Not supported for MenuComponents
Not supported for MenuComponents
Not supported for MenuComponents
Not supported for MenuComponents
Not supported for MenuComponents
Not supported for MenuComponents
Not supported for MenuComponents
Not supported for MenuComponents
Not supported for MenuComponents
Not supported for MenuComponents
Not supported for MenuComponents
Not supported for MenuComponents
MenuComponents don't have children
Not supported for MenuComponents
Not supported for MenuComponents
Not supported for MenuComponents
Not supported for MenuComponents
To be fully implemented in a future release
To be fully implemented in a future release
To be fully implemented in a future release
To be fully implemented in a future release
To be fully implemented in a future release
To be fully implemented in a future release
To be fully implemented in a future release
inner class AccessibleAWTComponent
MenuComponents only have accessible index when inside MenuComponents
Overridden in subclasses.
If we're in a predicate, then this will return non-null.
Then I think we're in a sort.  See sort21.xsl. So the iterator has
already been spent, and is not on the node we're processing.
It's highly possible that this is an issue for other context-list
functions.  Shouldn't be a problem for last(), and it shouldn't be
a problem for current().
Relation type handling
XXX false for release!
Get source region and subsampling factors
Clip to actual image bounds
Adjust for subsampling offsets
Get subsampling factors
Compute output dimensions
create gray-scaled color table for single-banded images
We do not have enough information here
to create well-fit color table for RGB image.
Save interlace flag state.
Undo change to interlace flag if not MODE_COPY_FROM_METADATA.
Local color table
Save the possibly converted stream metadata as an instance variable.
Check for ability to encode image.
Determine source region and destination dimensions.
Convert any provided image metadata.
Converted rgb image can use palette different from global.
In order to avoid color artefacts we want to be sure we use
appropriate palette. For this we initialize local color table
from current color and sample models.
At this point we can guarantee that local color table can be
build because image was already converted to indexed or
in case of indexed image we should take care of
Global color table values.
Write the header (Signature+Logical Screen Descriptor+
Global Color Table).
Set the version if not set.
Set the Logical Screen Desriptor if not set.
Set the Global Color Table if not set, i.e., if not
provided in the stream metadata.
Writing a sequence and a local color table was
provided in the metadata of the first image: use it.
Create a color table.
Set the Global Color Table. At this point it should be
B) the local color table of the image metadata, if any, if
C) a table created on the basis of the first image ColorModel
and SampleModel if no local color table is available; or
D) null if none of the foregoing conditions obtain (which
should only be if a sequence is not being written and
a local color table is provided in image metadata).
Write the header.
Write extension blocks, Image Descriptor, and image data.
Write the trailer.
Create default metadata.
Set GraphicControlExtension flag only if there is
Check for GraphicControlExtension element.
Should never happen.
Set GraphicControlExtension flag if element present.
If progressive mode is not MODE_COPY_FROM_METADATA, ensure
the interlacing is set per the ImageWriteParam mode setting.
Unset local color table if equal to global color table.
Write Graphics Control Extension.
Write extension blocks.
Write Image Descriptor
Write image data
take into account the raster data offset
Global Color Table
Background color index
Pixel aspect ratio
Global Color Table
Get the mask offset and #bits
Store the mask
Now find the shift
High enough to scale any 0-ff value down to 0.0, but not
high enough to get Infinity when scaling back to pixel bits
Must have the same number of components
Transfer type must be the same
Now compare the specific masks
The ORB we are initializing
The arguments passed to ORB_init
The ID of the ORB being initialized
The current stage of initialization
The pre-initialization stage (pre_init() being called)
The post-initialization stage (post_init() being called)
Reject all calls - this object should no longer be around.
The description for the OBJECT_NOT_EXIST exception in STAGE_CLOSED
As per CORBA 3.0 section 21.8.1,
if null is passed as the obj parameter,
throw BAD_PARAM with minor code OMGSystemException.RIR_WITH_NULL_OBJECT.
Though the spec is talking about IDL null, we will address both
Java null and IDL null:
Note: Local Objects can never be nil!
This check was made to determine that the objref is a
non-local objref that is fully
initialized: this was called only for its side-effects of
possibly throwing exceptions.  However, registering
local objects should be permitted!
Delegate to ORB.  If ORB version throws InvalidName, convert to
equivalent Portable Interceptors InvalidName.
Initializer is not allowed to invoke this method during
_REVISIT_ Spec issue: What exception should really be
Convert PIDL to IDL exception:
New method from CORBA 3.1
XXX ignore policies for now
New method from CORBA 3.1
XXX ignore policies for now
New method from CORBA 3.1
XXX ignore policies for now
$$fb 2002-04-12: fix for 4662090: Contradiction in Receiver specification
This may be NULL!!!
%TBD%  What to do here?
case CLASS_RTREEFRAG :
In order to handle the 'all' semantics of
nodeset comparisons, we always call the
nodeset function.  Because the arguments
are backwards, we call the opposite comparison
In order to handle the 'all' semantics of
nodeset comparisons, we always call the
nodeset function.  Because the arguments
are backwards, we call the opposite comparison
In order to handle the 'all' semantics of
nodeset comparisons, we always call the
nodeset function.  Because the arguments
are backwards, we call the opposite comparison
In order to handle the 'all' semantics of
nodeset comparisons, we always call the
nodeset function.  Because the arguments
are backwards, we call the opposite comparison
In order to handle the 'all' semantics of
nodeset comparisons, we always call the
In order to handle the 'all' semantics of
nodeset comparisons, we always call the
boolean shouldThrow = support.problem(m_support.XPATHPROCESSOR,
If equals at the expression level calls deepEquals, I think we're
still safe from infinite recursion since this object overrides
equals.  I hope.
$$fb2001-07-20: fix for bug 4385060: The "name" attribute of class "ReverbType" is not accessible.
return (super.toString() + ", early reflection delay " + earlyReflectionDelay +
Private method to infer the caller's class and method names
Get the stack trace.
The top of the stack should always be a method in the wrapper class,
or in this base class.
Search back to the first method not in the wrapper class or this class.
Set the class and method if we are not past the end of the stack
The first value is the native code set
Now process the other values as part of the
conversion code set list.
decode allows us to specify hex, decimal, etc
Otherwise return the CodeSetComponent representing
the given values
Fix 4489009: should throw IndexOutofBoundsException instead
Fix 6191114: should throw NegativeArraySizeException with
Fix 6343431: Applet compatibility problems if arrays are not
exactly npoints in length
Make sure that newLength will be greater than MIN_LENGTH and
aligned to the power of 2
Walk the edges of the polygon
Walk the edges of the polygon
Prevent a spurious SEG_CLOSE segment
These message should be read from a locale-specific resource bundle
REVISIT: Should this be a copy? -Ac
REVISIT: Should this be a copy? -Ac
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of SpinnerPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of SpinnerPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
Don't permanently allocate very large buffers.
java.util.logger package is not available in this jvm.
This is guaranteed to be interned by the VM in the 1.4
Generics and annotations support
generic info repository; lazily initialized
For sharing of MethodAccessors. This branching structure is
currently only two levels deep (i.e., one root Method and
potentially many Method objects pointing to it.)
If this branching structure would ever contain cycles, deadlocks can
occur in annotation code.
Accessor for factory
create scope and factory
Accessor for generic info repository
lazily initialize repository if necessary
create and cache generic info repository
return cached repository
This routine enables sharing of MethodAccessor objects
among Method objects which refer to the same underlying
method in the VM. (All of this contortion is only necessary
because of the "accessibility" bit in AccessibleObject,
which implicitly requires that new java.lang.reflect
objects be fabricated for each reflective call on Class
Might as well eagerly propagate this if already present
Default methods are public non-abstract instance methods
declared in an interface.
NOTE that there is no synchronization used here. It is correct
(though not efficient) to generate more than one MethodAccessor
for a given Method. However, avoiding synchronization will
probably make the implementation more scalable.
First check to see if one has been created yet, and take it
Otherwise fabricate one and propagate it up to the root
Returns MethodAccessor for this Method object, not looking up
the chain to the root
Sets the MethodAccessor for this Method object and
(recursively) its root
on error we simply have no styles... the html
will look mighty wrong but still function.
PENDING: we need a better way to express what shouldn't be
copied when editing...
Remove the related image attributes, src, width, height
Don't copy HRs or BRs either.
Don't copy COMMENTs either
or INPUT either
Don't copy unknowns either:(
----- Accessibility support -----
--- variables ------------------------------------------
ignore the drags
track the moving of the mouse.
reference changed, fire event(s)
Following is a workaround for 1.2, in which
new URL("file:...", "#...") causes the filename to
fire an exited event on the old link
fire an entered event on the new link
Make the head never visible, and never load its
children. For Cursor positioning,
getNextVisualPositionFrom is overriden to always return
the end offset of the element.
If we get here, it's either an element we don't know about
or something from StyledDocument that doesn't have a mapping to HTML.
default to text display
reimplement major axis requirements to indicate that the
block is flexible for the body element... so that it can
be stretched to fill the background properly.
try to use viewVisibleWidth if it is smaller than targetSpan
if parent == null unregister component listener
--- Action implementations ------------------------------
link navigation support
Find the common parent.
If inserting at the origin, the common parent is the
Determine how many pops to do.
And how many pushes
Try first choice
TODO: The AccessibleContext for the editor should register
as a listener for CaretEvents and forward the events to
assistive technologies listening for such events.
TODO: Should start successive iterations from the
current caret position.
highlight the next link or object after the current caret position
Contained in view, can just use bounds.
Should only render part of View.
--- determine locations ---
Only if exception
invoke the next link or object action
Check the argument type (if any)
The argument has to be a node, a node-set or a node reference
Function was called with no parameters
Function was called with node parameter
Function was called with node-set parameter
"all the fields are null"
field may not be set
int -> BigInteger
negating 0x8000000000000000L causes an overflow
let GregorianCalendar do the heavy lifting
duration is the offset from the Epoch
now find out how much each field has changed
seconds & milliseconds
only if I could use the JDK1.4 regular expression ....
phase 1: chop the string into chunks
(where a chunk is '<number><a symbol>'
phase 2: check the ordering of chunks
parse into numbers
NumberFormatException is IllegalArgumentException
check for fields that are too large in this Duration
this.getClass().getName() + "#compare(Duration duration)"
+ " years too large to be supported by this implementation "
this.getClass().getName() + "#compare(Duration duration)"
+ " months too large to be supported by this implementation "
this.getClass().getName() + "#compare(Duration duration)"
+ " days too large to be supported by this implementation "
this.getClass().getName() + "#compare(Duration duration)"
+ " hours too large to be supported by this implementation "
this.getClass().getName() + "#compare(Duration duration)"
+ " minutes too large to be supported by this implementation "
this.getClass().getName() + "#compare(Duration duration)"
+ " seconds too large to be supported by this implementation "
check for fields that are too large in rhs Duration
this.getClass().getName() + "#compare(Duration duration)"
+ " years too large to be supported by this implementation "
this.getClass().getName() + "#compare(Duration duration)"
+ " months too large to be supported by this implementation "
this.getClass().getName() + "#compare(Duration duration)"
+ " days too large to be supported by this implementation "
this.getClass().getName() + "#compare(Duration duration)"
+ " hours too large to be supported by this implementation "
this.getClass().getName() + "#compare(Duration duration)"
+ " minutes too large to be supported by this implementation "
this.getClass().getName() + "#compare(Duration duration)"
+ " seconds too large to be supported by this implementation "
turn this Duration into a GregorianCalendar
turn compare Duration into a GregorianCalendar
long comparison algorithm is required
component wise hash is not correct because 1day = 24hours
"cannot be called with field == null"
* Returns an equivalent but "normalized" duration value.
* Intuitively, the normalization moves YEARS into
* MONTHS (by x12) and moves DAYS, HOURS, and MINUTES fields
* into SECONDS (by x86400, x3600, and x60 respectively.)
* Formally, this method satisfies the following conditions:
*      always return a non-null valid value.
using int may cause overflow, but
Calendar internally treats value as int anyways.
obtain the difference in terms of days
make sure that the sign bit is consistent across all 6 fields.
repeat until all the sign bits become consistent
sign of the left fields
this field has different sign than its left field.
compute the number of unit that needs to be borrowed.
this will throw NPE if date==null
Utility method for nodes with a single attribute named "value"
root -> Chroma
root -> Chroma -> ColorSpaceType
root -> Chroma -> NumChannels
root -> Chroma -> Gamma
root -> Chroma -> BlackIsZero
root -> Chroma -> Palette
root -> Chroma -> PaletteEntry
root -> Chroma -> BackgroundIndex
root -> Chroma -> BackgroundColor
root -> Compression
root -> Compression -> CompressionTypeName
root -> Compression -> Lossless
root -> Compression -> NumProgressiveScans
root -> Compression -> BitRate
root -> Data
root -> Data -> PlanarConfiguration
root -> Data -> SampleFormat
root -> Data -> BitsPerSample
root -> Data -> SignificantBitsPerSample
root -> Data -> SampleMSB
root -> Dimension
root -> Dimension -> PixelAspectRatio
root -> Dimension -> ImageOrientation
root -> Dimension -> HorizontalPixelSize
root -> Dimension -> VerticalPixelSize
root -> Dimension -> HorizontalPhysicalPixelSpacing
root -> Dimension -> VerticalPhysicalPixelSpacing
root -> Dimension -> HorizontalPosition
root -> Dimension -> VerticalPosition
root -> Dimension -> HorizontalPixelOffset
root -> Dimension -> VerticalPixelOffset
root -> Dimension -> HorizontalScreenSize
root -> Dimension -> VerticalScreenSize
root -> Document
root -> Document -> FormatVersion
root -> Document -> SubimageInterpretation
root -> Document -> ImageCreationTime
second = 60 denotes leap second
root -> Document -> ImageModificationTime
second = 60 denotes leap second
root -> Text
root -> Text -> TextEntry
root -> Transparency
root -> Transparency -> Alpha
root -> Transparency -> TransparentIndex
root -> Transparency -> TransparentColor
root -> Transparency -> TileTransparencies
root -> Transparency -> TileTransparencies -> TransparentTile
root -> Transparency -> TileOpacities
root -> Transparency -> TileOpacities -> OpaqueTile
Draw outermost lines
Draw the bulk of the border
Draw the Long highlight lines
Draw the Long shadow lines
Draw outermost lines
Draw the bulk of the border
Draw the Long highlight lines
Draw the Long shadow lines
Draw outermost lines
Draw the bulk of the border
Draw the Long highlight lines
Draw the Long shadow lines
Draw outermost lines
Draw the bulk of the border
Only paint a border if we're not next to a horizontal toolbar
hardcoded margin for JLF requirements.
default margin so replace
Margin which has been explicitly set by the user.
special case for non-text components (bug ID 4144840)
Neither directly nor indirectly present
the element is a class
Determine if the annotation is associated with the
Loop over all directly-present annotations looking for a matching one
More robust to do a dynamic cast at runtime instead
of compile-time only.
XXX These must all be replaced by Sun private APIs.
End of file.
This is for 1.1 serialization compatibility
This is the one we actually use
this.align is used only for serialization compatibility,
so set it to a value compatible with the 1.1 version
of the class
the internal serial version which says which version was written
- 0 (default) for versions before the Java 2 platform, v1.2
- 1 for version >= Java 2 platform v1.2, which includes "newAlign" field
"newAlign" field wasn't present, so use the old "align" field.
this getter might get called from the super constructor
when the notificationInfo has not been properly set yet
'flavorMap' was written explicitly
Implementation assumes 'flavorMap' is never null.
skip value for unrecognized key
Do it the slow way
ColorModels are not the same
Create a new destination Raster, if needed
Optimize for cases we know about
Not one we recognize so do it slowly
Find data for all bands at this x,y position
Lookup the data for all bands at this x,y position
Put it back for all bands
Dst raster should be of type byte
For byte, no need to change the cm
Find the ref to the table and the offset
Check if it is one lookup applied to all bands
Loop through the data
Find data for this band, scanline
Do the lookup
Put it back
Find the ref to the table and the offset
Check if it is one lookup applied to all bands
Loop through the data
Find data for this band, scanline
Do the lookup
Put it back
WindowDisposerRecord requires a proper value of parent field.
Always send a property change event
We don't use SplashScreen.getSplashScreen() to avoid instantiating
the object if it hasn't been requested by user code explicitly
fix for 6532736: after this window is shown, its blocker
should be raised to front
If first time shown, generate WindowOpened event
Check if this window is the fullscreen window for the
device. Exit the fullscreen mode prior to disposing
of the window if that's the case.
Execute outside the Runnable because postWindowEvent is
synchronized on (this). We don't need to synchronize the call
on the EventQueue anyways.
Should only be called while holding tree lock
do nothing since parent == owner and we shouldn't
ajust counter on owner
This functionality is implemented in a final package-private method
to insure that it cannot be overridden by client subclasses.
This functionality is implemented in a final package-private method
to insure that it cannot be overridden by client subclasses.
make sure the privileged action is only
for getting the property! We don't want the
above checkPermission call to always succeed!
Recall that ownedWindowList is actually a Vector of
WeakReferences and calling get() on one of these references
may return null. Make two arrays-- one the size of the
Vector (fullCopy with size fullSize), and one the size of
all non-null get()s (realCopy with size realSize).
if we want on-fly changes, we need to uncomment the lines below
and override the method in Dialog to use modalShow() instead
REMIND: remove when filtering is handled at lower level
Dump the list of child windows to System.out.
Okay to return Set directly because it is an unmodifiable view
If a Window/Frame/Dialog was made non-focusable, then it is always
All other tests apply only to Windows.
A Window must have at least one Component in its root focus
traversal cycle to be focusable.
A Window's nearest owning Frame or Dialog must be showing on the
this if statement should really be an assert, but we don't
synchronized block not required since removeElement is
Update old focusMgr fields so that our object stream can be read
by previous releases
Clear fields so that we don't keep extra references around
write icon array
Part of deserialization procedure to be called before
Deserialized Windows are not yet visible.
Translate old-style focus tracking to new model. For 1.4 and
later releases, we'll rely on the Window's initial focusable
This field is non-transient and relies on default serialization.
However, the default value is insufficient, so we need to set
it explicitly for object data streams prior to 1.4.
skip value for unrecognized key
skip value for unrecognized key
for pre1.6 objects.
pre1.6 version if icons is null.
1.1 serialized form
ownedWindowList will be updated by Frame.readObject
Note: 1.4 (or later) doesn't use focusMgr
since 1.5; subject to permission check
inner class AccessibleAWTWindow
search a top-level of c
Adjust for bottom edge being offscreen
Avoid being placed off the edge of the screen:
Check that "component" is an acceptable focus owner and don't store it otherwise
- or later we will have problems with opposite while handling  WINDOW_GAINED_FOCUS
5079694 fix: for a toplevel to be displayed, its parent doesn't have to be visible.
We're overriding isRecursivelyVisible to implement this policy.
Shouldn't use instanceof to avoid loading Swing classes
if it's a pure AWT application.
Iterate down one level to see whether we have a JApplet
(which is also a RootPaneContainer) which requires processing
It's OK to use instanceof here because we've
already loaded the RootPaneContainer class by now
A window has an owner, but it does NOT have a container
The shape calculated by mixing code is not intended to be applied
to windows or frames
The shape calculated by mixing code is not intended to be applied
to windows or frames
The shape calculated by mixing code is not intended to be applied
to windows or frames
The position according to the spec of SecurityWarning.setPosition()
First, make sure the warning is not too far from the window bounds
Now make sure the warning window is visible on the screen
a window doesn't need to be updated in the Z-order.
-- This file was mechanically generated: Do not edit! --
Cached unsafe-access object
Cached array base offset
Cached unaligned-access capability
Base address, used in all indexing calculations
NOTE: moved up to Buffer.java for speed in JNI GetDirectBufferAddress
An object attached to this buffer. If this buffer is a view of another
buffer then we use this field to keep a reference to that buffer to
ensure that its memory isn't freed before we are done with it.
For duplicates and slices
undo the change
we should'nt get here ...
Pre-1.4 support. 'dropTargetContext' was previously transient
Pre-1.4 support. 'dtListener' was previously non-transient
1.4-compatible byte stream. 'dtListener' was written explicitly
[GIOPHeader(12) + requestID(4)] bytes
Called from read_octet or read_long or read_ulong method.
check if size < [ GIOPHeader(12) + requestID(4)] bytes
check if size < [ GIOPHeader(12) + requestID(4)] bytes
Use big endian (network byte order). This is fixed.
Both the writer and reader use the same byte order.
Cannot happen. All direct writes are contained
within the first 16 bytes.
Complex types (objects and graphs).
IDL to Java formal 01-06-06 1.21.4.2
We don't need an implementation for this method, since principal
is absent in GIOP version 1.2 or above.
This string might contain sign and/or dot
The string may contain a sign and dot
Each octet contains (up to) two decimal digits.
First calculate the string length without optional sign and dot.
If the fixed type has an odd number of decimal digits, then the
representation begins with the first (most significant) digit.
Otherwise, this first half-octet is all zero, and the first
digit is in the second half-octet.
The sign configuration in the last half-octet of the representation,
is 0xD for negative numbers and 0xC for positive and zero values.
Assume value type.
Is it a CORBA.Object?
Write the boolean flag.
Now write out the object.
Java serialization uses network byte order, that is, big-endian.
This will stay a custom add-on until the java-rtf issue is resolved.
Then it should be declared in org.omg.CORBA.portable.OutputStream.
Pads the string representation of bigDecimal with zeros to fit the given
digits and scale before it gets written to the stream.
Get rid of the sign
Determine integer and fraction parts
Pad both parts with zeros as necessary
This string contains no sign or dot
For every 16 bytes, there is one line
of output.  First, the hex output of
the 16 bytes with each byte separated
by a space.
Add any extra spaces to align the
text column in case we didn't end
Now output the ASCII equivalents.  Non-ASCII
characters are shown as periods.
Needed by request and reply messages for GIOP versions >= 1.2 only.
no-op. We don't care about body alignment while using
Java serialization. What the GIOP spec states does not apply here.
Note: These methods are defined in the super class and accessible.
public abstract void write(byte b[], int off, int len)
determine the child placements
flush changes to the container
The requests have been invalidated... recalculate
the request information.
override for Javadoc
alignedDOW and alignedWOM not supported because they cannot be set in with()
Explicitly reset hash code value to -1
-- This file was mechanically generated: Do not edit! --
A key for the collection of AWTKeyStrokes within AppContext.
A key withing the cache
Invalid ID for this KeyEvent
1.0 / (1L << 53)
L'Ecuyer, "Tables of Linear Congruential Generators of
Different Sizes and Good Lattice Structure", 1999
subclass might have overriden setSeed
power of two
reject over-represented candidates
range not representable as long
range not representable as int
correct for rounding
i.e., bound is a power of 2
it's okay that the bottom word remains signed.
See Knuth, ACP, Section 3.4.1 Algorithm C.
between -1 and 1
between -1 and 1
stream methods, coded in a way intended to better isolate for
maintenance purposes the small differences across forms.
historical reasons, but it is converted to an AtomicLong.
set the values of the Serializable fields
The seed is serialized as a long for historical reasons.
Support for resetting seed while deserializing
largest numerical value
These would not be used for EN. Only used for traditional numbering
These only used for mutiplicative-additive numbering
-- This file was mechanically generated: Do not edit! --
These fields are declared here rather than in Heap-X-Buffer in order to
reduce the number of virtual method invocations needed to access these
values, which is especially costly when coding small buffers.
Non-null only for heap buffers
Valid only for heap buffers
Creates a new buffer with the given mark, position, limit, capacity,
backing array, and array offset
Creates a new buffer with the given mark, position, limit, and capacity
Determine the number of bytes n that can be transferred
Set source limit to prevent target overflow
restore real limit
-- Singleton get/put methods --
-- Bulk get operations --
-- Bulk put operations --
-- Other stuff --
-- Other char stuff --
--- Methods to support CharSequence ---
--- Methods to support Appendable ---
-- Other byte stuff: Access to binary data --
this trick is needed to allow the RetrievalMethodResolver to eat a
ds:DSAKeyValue directly (without KeyValue)
Do not access the location path itterator during this operation!
Only for clones for findLastPos.  See bug4638.
TODO: Fix this...
Note that in the case of a UnionChildIterator, this may be a
static object and so m_proximityPositions may indeed be null!
If there is a proximity index that will not change during the
course of itteration, then we know there can be no more true
occurances of this predicate, so flag that we're done after
We can't set m_foundLast = true unless we're sure that -all-
remaining parameters are stable, or else last() fails. Fixed so
only sets m_foundLast if on the last predicate
=============== NodeFilter Implementation ===============
TODO: Fix this.
Note this will be called by all classes when they reach the
top of their superclass chain.
Also ensures the subtype is correct.
This unappealing hack is not required but makes the
representation of EventHandlers much more concise.
As of 1.3 it is not possible to call Class.forName("int"),
so we have to generate different code for primitive types.
This is needed for arrays whose subtype may be primitive.
assumes oldInstance and newInstance are Timestamps
do not initialize these custom collections in default way
Remove the new elements.
Do this first otherwise we undo the adding work.
PENDING: This "key" is not in the right environment.
Add the new elements.
Pending: should use newKey.
put oldValue(=null?) if oldKey is absent in newMap
get short name of the class
Don't install primitives, their identity will not be preserved
The "background", "foreground" and "font" properties.
The foreground and font properties of Windows change from
null to defined values after the Windows are made visible -
special case them for now.
Use the most concise construct.
Ignore the children of a JScrollPane.
Pending(milne) find a better way to do this.
Pending. Assume all the new children are unaltered.
Pending, assume any existing elements are OK.
JFrame (If we do this for Window instead of JFrame, the setVisible call
will be issued before we have added all the children to the JFrame and
will appear blank).
false means: don't execute this statement at write time.
Note, the "size" property will be set here.
Can also use "addElement".
Note that we do not need to state the initialiser for
JMenuItems since the getComponents() method defined in
Container will return all of the sub menu items that
need to be added to the menu item.
Not so for JMenu apparently.
it is possible because MatteBorder is assignable from MatteBorderUIResource
it is possible because FontUIResource is supported by java_awt_Font_PersistenceDelegate
it is possible because KeyStroke is supported by java_awt_AWTKeyStroke_PersistenceDelegate
The persistence delegate for arrays is non-trivial; instantiate it lazily.
Handle proxies lazily for backward compatibility with 1.2.
actually data stored in a byte array
canonical representation of the data
make sure required attribute(s) have been set
Prefer to handle the value as a node; fall back to String, otherwise
Turn off character escaping if so is wanted.
Translate the contents.  If the value is a string, use the
translet.characters(String, TranslatOutputHandler) method.
Otherwise, the value is a node, and the
dom.characters(int node, TransletOutputHandler) method can dispatch
the string value of the node to the output handler more efficiently.
Restore character escaping setting to whatever it was.
Access to protected field members is restricted to receivers only
of the accessing class, or one of its subclasses, and the
accessing class must in turn be a subclass (or package sibling)
of the protected member's defining class.
If the updater refers to a protected field of a declaring class
outside the current package, the receiver argument will be
narrowed to the type of the accessing class.
Access to protected field members is restricted to receivers only
of the accessing class, or one of its subclasses, and the
accessing class must in turn be a subclass (or package sibling)
of the protected member's defining class.
If the updater refers to a protected field of a declaring class
outside the current package, the receiver argument will be
narrowed to the type of the accessing class.
inline OffsetTime factory to avoid creating object and InstantProvider checks
overflow caught later
override for Javadoc
override for Javadoc
override for Javadoc and performance
inline TemporalAccessor.super.query(query) as an optimization
non-JDK classes are not permitted to make this optimization
Type-specific CORBA::Object operations
Root Naming Context for default resolution of names.
The URLHandler to parse INS URL's
"UPPER NIBBLE" shift factor for <<
Length must be even for str to be valid
XXX handle this as just another URL scheme
XXX resolve should be a method on INSURL
If RIR flag is true use the Bootstrap protocol
Case 1 of corbaname: rir#
Case 2 of corbaname: ::hostname#
This means return the Root Naming context
corbalocObject cannot be null, because it's validated during
parsing. So no null check is required.
If there is no KeyString then it's invalid
Add profile for GIOP version used by this ORB
Now remove this value from the map
Create a comparator that can sort in decending order (1.2, 1.1, ...)
Now sort using the above comparator
Add the profiles in the sorted order
Finally add the 1.0 profiles
is protected in ByteArrayInputStream
Public constants for attributes supported by the XSLTC TransformerFactory.
Unmodifiable view of external extension function from xslt compiler
It will be populated by user-specified extension functions during the
Parser's security manager
Unmodifiable hash map with loaded external extension functions
Return value for attribute 'translet-name'
Throw an exception for all other attributes
Set the default translet name (ie. class name), which will be used
for translets that cannot be given a name from their system-id.
Throw an exception for all other attributes
feature name cannot be null
set external access restriction when FSP is explicitly set
in secure mode, let _useServicesMechanism be determined by the constructor
All supported features should be listed here
feature name cannot be null
Inefficient, but array is small
Feature not supported
startElement encountered so do not parse further
Pass messages to listener, one by one
Workaround for the TCK failure ErrorListener.errorTests.error001.
Pass messages to listener, one by one
If the _useClasspath attribute is true, try to load the translet from
the CLASSPATH and create a template object using the loaded
If _autoTranslet is true, we will try to load the bytecodes
from the translet classes without compiling the stylesheet.
Reset the per-session attributes to their default values
after each newTemplates() call.
Create and initialize a stylesheet compiler
Set a document loader (for xsl:include/import) if defined
Pass parameters to the Parser to make sure it locates the correct
<?xml-stylesheet ...?> PI in an XML input document
Get the parameters for this Source object
Pass them on to the compiler (which will pass then to the parser)
Set the attributes for translet generation
Set the translet name
Compile the stylesheet
Output to the jar file if the jar file name is set.
Reset the per-session attributes to their default values
after each newTemplates() call.
Pass compiler warnings to the error listener
Check that the transformation went well before returning
Pass compiler errors to the error listener
As required by TCK 1.2, send a fatalError to the
error listener because compilation of the stylesheet
failed and no further processing will be possible.
well, we tried.
should catch it when the resolver explicitly throws the exception
Find the base name of the translet
Construct the path name for the translet class file
Return null if the translet class file does not exist.
Compare the timestamps of the translet and the xsl file.
If the translet is older than the xsl file, return null
so that the xsl file is used for the transformation and
the translet is regenerated.
Load the translet into a bytecode array.
Find the parent directory of the translet.
Find all the auxiliary files which have a name pattern of "transletClass$nnn.class".
Load the auxiliary class files and add them to the bytecode array.
Convert the Vector of byte[] to byte[][].
Construct the path for the jar file
Return null if the jar file does not exist.
Compare the timestamps of the jar file and the xsl file. Return null
if the xsl file is newer than the jar file.
Create a ZipFile object for the jar file
Iterate through all entries in the jar file to find the
translet and auxiliary classes.
Convert the Vector of byte[] to byte[][].
create an empty SignatureValue; this is filled by setSignatureValueElement
create an empty SignatureValue; this is filled by setSignatureValueElement
check out SignedInfo child
check to see if it is there
create a SignedInfo object from that element
get signedInfoElem again in case it has changed
check out SignatureValue child
check to see if it exists
<element ref="ds:KeyInfo" minOccurs="0"/>
If it exists use it, but it's not mandatory
<element ref="ds:Object" minOccurs="0" maxOccurs="unbounded"/>
Register Ids of the Object child elements
check to see if we are signing and if we have to create a keyinfo
create the KeyInfo
get the Element from KeyInfo
add it before the object
add it as the last element to the signature
throw new XMLSignatureException(
Create a SignatureAlgorithm object
initialize SignatureAlgorithm for signing
generate digest values for all References in this SignedInfo
get the canonicalized bytes from SignedInfo
set them on the SignatureValue element
see if cert is null
check the values with the public key from the cert
COMMENT: pk suggests it can only be a public key?
check to see if the key is not null
all references inside the signedinfo need to be dereferenced and
digested again to see if the outcome matches the stored value in the
If followManifestsDuringValidation is true it will do the same for
References inside a Manifest.
create a SignatureAlgorithms from the SignatureMethod inside
SignedInfo. This is used to validate the signature.
Get the canonicalized (normalized) SignedInfo
retrieve the byte[] from the stored signature
have SignatureAlgorithm sign the input bytes and compare them to
the bytes that were stored in the signature.
accessed directly by pool and workers
mask out non-completion bits
must be negative
must be < NORMAL
must be < CANCELLED
must be >= 1 << 16
short bits for tags
force completer to issue notify
Exception table support
use id not ref to avoid weak cycles
store task hashCode before weak ref disappears
public ctors only
rely on vacuous cast
measure in nanosecs, but wait in millisecs
OK to throw InterruptedException
OK to set this even before completion
rethrow outside exec() catches.
Check for EventSet compliance. Special case for vetoableChange. See 4529996
Check for null names
Be more forgiving of not finding the getListener method.
J2SE does not support Xalan interpretive
"    [-XSLTC (use XSLTC for transformation)]
J2SE does not support Xalan interpretive
J2SE does not support Xalan interpretive
main -> _main
Runtime.getRuntime().traceMethodCalls(false);  turns Java tracing off
J2SE does not support Xalan interpretive
false -> true
shut up compiler
J2SE does not support Xalan interpretive
The -XSLTC option has been processed.
J2SE does not support Xalan interpretive
">>>>>>> Xalan Version "
J2SE does not support Xalan interpretive
J2SE does not support Xalan interpretive
Generate the translet class and optionally specify the name
of the translet class.
Specify the destination directory for the translet classes.
Specify the jar file name which the translet classes are packaged into.
Specify the package name prefix for the generated translet classes.
Enable template inlining.
Turns on additional debugging message output
Create the Transformer from the translet if the translet class is newer
than the stylesheet.
Print usage instructions if no xml and xsl file is specified in the command line
Note that there are usage cases for calling us without a -IN arg
The main XSL transformation occurs here!
Parse in the xml data into a DOM
One possible improvement might be to ensure this is
a valid URI before setting the systemId, but that
might have subtle changes that pre-existing users
might notice; we can think about that later -sc r1.46
We used to default to incremental mode in this case.
We've since decided that since the -INCREMENTAL switch is
available, that default is probably not necessary nor
necessarily a good idea.
J2SE does not support Xalan interpretive
Did they pass in a stylesheet, or should we get it from the
"No stylesheet found in: "
+ inFileName + ", media="
"No xml-stylesheet PI found in: "
Override the output format?
J2SE does not support Xalan interpretive
Parse in the xml data into a DOM
Now serialize output to disk with identity transformer
Loop for diagnosing bugs with inconsistent behavior
Use JAXP1.1 ( if possible )
J2SE does not support Xalan interpretive
Use JAXP1.1 ( if possible )
close output streams
default value for entity expansion limit
default constructor.  Establishes default values for
all known security holes.
We are reading system properties only once ,
at the time of creation of this object ,
End of file.
Type-specific CORBA::Object operations
The provider that created this channel
Keys that have been created by registering this channel with selectors.
They are saved because if this channel is closed the keys must be
deregistered.  Protected by keyLock.
Lock for key set and count
Lock for registration and configureBlocking operations
Blocking mode, protected by regLock
-- Utility methods for the key set --
Find empty element of key array
Grow key array
-- Registration --
-- Closing --
-- Blocking --
-- This file was mechanically generated: Do not edit! --
Default behaviour of LocalVariableInstruction causes error
May set wide as side effect
Need WIDE prefix ?
wide byte included
Differentiate hash code from other ComponentSampleModel subclasses
read and discard the repository ID
write the repository ID
subclasses must provide a matching helper class
Validity depends upon typecode. The 'value' and 'object' instance
members are used to hold immutable types as defined by the
isStreamed[] table below. Otherwise, 'stream' is non-null and
holds the value in CDR marshaled format. As an optimization, the
stream type is an Any extension of CDR stream that is used to
detect an optimization in read_value().
Setting the typecode via the type() accessor wipes out the value.
An attempt to extract before the value is set will result
in a BAD_OPERATION exception being raised.
value_box (used to be true)
null is a valid value
Create a new AnyImpl which is a copy of obj.
Note: Indirect types are handled in kind() method
set the typecode
null is the only legal value this Any can have after resetting the type code
first check for typecode equality.
note that this will take aliases into account
Resolve aliases here
_REVISIT_ Possible optimization for the case where
otherAny is a AnyImpl and the endianesses match.
Need implementation of CDRInputStream.equals()
For now we disable this to encourage testing the generic,
unoptimized code below.
Unfortunately this generic code needs to copy the whole stream
at least once.
handle primitive types
Too complicated to handle value types the way we handle
other complex types above. Don't try to decompose it here
for faster comparison, just use Object.equals().
Unspecified for Java
Needed for equal() in order to achieve linear performance for complex types.
Uses up (recursively) copies of the InputStream in both Anys that got created in equal().
Resolve aliases here
handle primitive types
just so that the two stream are in sync
Too complicated to handle value types the way we handle
other complex types above. Don't try to decompose it here
for faster comparison, just use Object.equals().
error resolving alias above
accessors for marshaling/unmarshaling
We create a new InputStream so that multiple threads can call here
and read the streams in parallel without thread safety problems.
If the InputStream is a CDRInputStream then we can copy the bytes
since it is in our format and does not have alignment issues.
Assume that someone isn't going to think they can keep reading
from this stream after calling us. That would be likely for
an IIOPInputStream but if it is an AnyInputStream then they
presumably obtained it via our create_output_stream() so they could
write the contents of an IDL data type to it and then call
create_input_stream() for us to read it. This is how Helper classes
typically implement the insert() method.
We should probably document this behavior in the 1.1 revision
could only have been created here
We could optimize this by noticing whether the target stream
has ever had anything marshaled on it that required an
alignment of greater than 4 (was write_double() ever called on it).
If not, then we can just do a byte array copy without having to
drive the remarshaling through typecode interpretation.
_REVISIT_ check isInitialized whether all we write is TypeCode!
insertion/extraction/replacement for all basic types
A long value is applicable to enums as well, so don't erase the enum type code
in case it was initialized that way before.
Make sure type code information for bounded strings is not erased
Check if bounded strings length is not exceeded
Make sure type code information for bounded strings is not erased
Check if bounded strings length is not exceeded
Check if the object contained here is of the type in typeCode
See note in getPrimitiveTypeCodeForClass.  We
have to use the latest type code fixes in this
case since there is no way to know what ORB will
actually send this Any.  In RMI-IIOP, when using
Util.writeAny, we can do the versioning correctly,
and use the insert_Value(Serializable, TypeCode)
The ORB singleton uses the latest version.
type isn't even of kind fixed
Look in the cache first
All cases need to be able to create repository IDs.
See bug 4391648 for more info about the tcORB in this
Assertion: c instanceof Serializable?
Arrays - may recurse for multi-dimensional arrays
We know that this is a TypeCodeImpl since it is our ORB
Intruct classTC to store its buffer
Update the cache
For Merlin or later JDKs, or for foreign ORBs,
we correctly say that a Java char maps to a
CORBA wchar.  For backwards compatibility
with our older ORBs, we say it maps to a
CORBA char.  This is only used in RMI-IIOP
in our javax.rmi.CORBA.Util delegate's
writeAny method.  In Java IDL, there's no way
to know the ORB version that the Any will be
sent out with -- it could be different than
the one used to create the Any -- so we use the
most recent version (see insert_Value).
_REVISIT_ Not sure if this is right.
Extracts a member value according to the given TypeCode from the given complex Any
(at the Anys current internal stream position, consuming the anys stream on the way)
and returns it wrapped into a new Any
This method could very well be moved into TypeCodeImpl or a common utility class,
but is has to be in this package.
There is no other way for DynAnys to find out whether the Any is initialized.
the target namespace of grammar
global decls: map from decl name to decl object
extended global decls: map from schema location + decl name to decl object
key is location,name
A global map of all global element declarations - used for substitution group computation
(handy when sharing components by reference, since we might end up with duplicate components
that are not added to either of the global element declarations above)
the XMLGrammarDescription member
annotations associated with the "root" schema of this targetNamespace
number of annotations declared
symbol table for constructing parsers (annotation support)
parsers for annotation support
is this grammar immutable?  (fully constructed and not changeable)
needed to make BuiltinSchemaGrammar work.
REVISIT: do we know the numbers of the following global decls
when creating this grammar? If so, we can pass the numbers in,
and use that number to initialize the following hashtables.
All global elements table
if we are parsing S4S, put built-in types in first
they might get overwritten by the types from S4S, but that's
considered what the application wants to do.
Clone an existing schema grammar
fGrammarDescription.fContextType |= XSDDescription.CONTEXT_COLLISION;  REVISIT
All global elements table
Annotations associated with the "root" schema of this targetNamespace
All substitution group information declared in this namespace
Array to store complex type decls for constraint checking
Groups being redefined by restriction
List of imported grammars
number of built-in XSTypes we need to create for base and full
this class makes sure the static, built-in schema grammars
no global decls other than types
no extended global decls
all global element decls table
get all built-in types
assign the built-in schema grammar as the XSNamespaceItem
for each of the built-in simple type definitions.
no global decls other than attributes
no extended global decls
no all global element decls
4 attributes, so initialize the size as 4*2 = 8
return the XMLGrammarDescription corresponding to this
override these methods solely so that these
objects cannot be modified once they're created.
no global decls other than types and
element declarations for <annotation>, <documentation> and <appinfo>.
no extended global decls
all global element declarations
get all built-in types
create element declarations for <annotation>, <documentation> and <appinfo>
add global element declarations
create complex type declarations for <annotation>, <documentation> and <appinfo>
set the types on their element declarations
create attribute groups for <annotation>, <documentation> and <appinfo>
fill in attribute groups
create and fill attribute uses for <annotation>, <documentation> and <appinfo>
create lax attribute wildcard for <annotation>, <documentation> and <appinfo>
add attribute uses and wildcards to attribute groups for <annotation>, <documentation> and <appinfo>
create particles for <annotation>
create wildcard particle for <documentation> and <appinfo>
fill complex types
return the XMLGrammarDescription corresponding to this
override these methods solely so that these
objects cannot be modified once they're created.
private helper methods
return the XMLGrammarDescription corresponding to this
if there is a substitution group affiliation, store in an array,
for further constraint checking: UPA, PD, EDC
array to store complex type decls
an array to store groups being redefined by restriction
even-numbered elements are the derived groups, odd-numbered ones their bases
a flag to indicate whether we have checked the 3 constraints on this
double array size each time.
used to store all substitution group information declared in
anyType and anySimpleType: because there are so many places where
we need direct access to these two types
don't allow this.
don't allow this.
the wildcard used in anyType (content and attribute)
the spec will change strict to skip for anyType
the particle for the content wildcard
the model group of a sequence of the above particle
the content of anyType: particle of the above model group
ignore this call.
also ignore this call.
the grammars to hold components of the schema namespace
the grammars to hold components of the schema-instance namespace
the max index / the max value of XSObject type
multi value facet
store a certain kind of components from all namespaces
store the documents and their locations contributing to this namespace
REVISIT: use StringList and XSObjectList for there fields.
REVISIT:  when schema handles XML 1.1, will need to
revisit this (and the practice of not prepending an XML decl to the annotation string
note that this should never produce errors or require
entity resolution, so just a barebones configuration with
a couple of feature  set will do fine
REVISIT:  when schema handles XML 1.1, will need to
revisit this (and the practice of not prepending an XML decl to the annotation string
note that this should never produce errors or require
entity resolution, so just a barebones configuration with
a couple of feature  set will do fine
get the hashtable for this type of components
for complex/simple types, create a special implementation,
which take specific types out of the hash table
get the hashtable for this type of components
Returns the KeyIndex object of a given name
Initialises a KeyIndex to return nodes with specific values
Call getKeyIndex in AbstractTranslet with the name of the key
to get the index for this key (which is also a node iterator).
Now use the value in the second argument to determine what nodes
the iterator should return.
IMPLEMENTATION NOTES:  The implementation of the collation algorithm is
divided across three classes: RuleBasedCollator, RBCollationTables, and
CollationElementIterator.  RuleBasedCollator contains the collator's
transient state and includes the code that uses the other classes to
implement comparison and sort-key building.  RuleBasedCollator also
contains the logic to handle French secondary accent sorting.
A RuleBasedCollator has two CollationElementIterators.  State doesn't
need to be preserved in these objects between calls to compare() or
getCollationKey(), but the objects persist anyway to avoid wasting extra
creation time.  compare() and getCollationKey() are synchronized to ensure
thread safety with this scheme.  The CollationElementIterator is responsible
for generating collation elements from strings and returning one element at
a time (sometimes there's a one-to-many or many-to-one mapping between
characters and collation elements-- this class handles that).
CollationElementIterator depends on RBCollationTables, which contains the
collator's static state.  RBCollationTables contains the actual data
tables specifying the collation order of characters for a particular locale
or use.  It also contains the base logic that CollationElementIterator
uses to map from characters to collation elements.  A single RBCollationTables
object is shared among all RuleBasedCollators for the same locale, and
thus by all the CollationElementIterators they create.
The basic algorithm here is that we use CollationElementIterators
to step through both the source and target strings.  We compare each
collation element in the source string against the corresponding one
in the target, checking for differences.
If a difference is found, we set <result> to LESS or GREATER to
indicate whether the source string is less or greater than the target.
However, it's not that simple.  If we find a tertiary difference
(e.g. 'A' vs. 'a') near the beginning of a string, it can be
overridden by a primary difference (e.g. "A" vs. "B") later in
the string.  For example, "AA" < "aB", even though 'A' > 'a'.
To keep track of this, we use strengthResult to keep track of the
strength of the most significant difference that has been found
so far.  When we find a difference whose strength is greater than
strengthResult, it overrides the last difference (if any) that
Get the next collation element in each of the strings, unless
we've been requested to skip it.
If we've hit the end of one of the strings, jump out of the loop
If there's no difference at this position, we can skip it
in french, a secondary difference more to the right is stronger,
so accents have to be checked with each base element
but tertiary differences are less important than the first
secondary difference, so checking tertiary remains disabled
Compare primary differences first.
The entire source element is ignorable.
Skip to the next source element, but don't fetch another target element.
The source and target elements aren't ignorable, but it's still possible
for the primary component of one of the elements to be ignorable....
primary order in source is ignorable
The source's primary is ignorable, but the target's isn't.  We treat ignorables
as a secondary difference, so remember that we found one.
(strength is SECONDARY)
Skip to the next source element, but don't fetch another target element.
record differences - see the comment above.
(strength is SECONDARY)
Skip to the next source element, but don't fetch another target element.
Neither of the orders is ignorable, and we already know that the primary
orders are different because of the (pSOrder != pTOrder) test above.
Record the difference and stop the comparison.
(strength is PRIMARY)
(strength is PRIMARY)
else of if ( pSOrder != pTOrder )
primary order is the same, but complete order is different. So there
are no base elements at this point, only ignorables (Since the strings are
a secondary or tertiary difference may still matter
there is a secondary difference
(strength is SECONDARY)
(even in french, only the first secondary difference within
a base character matters)
a tertiary difference may still matter
there is a tertiary difference
(strength is TERTIARY)
if ( pSOrder != pTOrder )
(tOrder must be CollationElementIterator::NULLORDER,
since this point is only reached when sOrder or tOrder is NULLORDER.)
The source string has more elements, but the target string hasn't.
We found an additional non-ignorable base character in the source string.
This is a primary difference, so the source is greater
(strength is PRIMARY)
Additional secondary elements mean the source string is greater
(strength is SECONDARY)
The target string has more elements, but the source string hasn't.
We found an additional non-ignorable base character in the target string.
This is a primary difference, so the source is less
(strength is PRIMARY)
Additional secondary elements in the target mean the source string is less
(strength is SECONDARY)
For IDENTICAL comparisons, we use a bitwise character comparison
as a tiebreaker if all else is equal
The basic algorithm here is to find all of the collation elements for each
character in the source string, convert them to a char representation,
and put them into the collation key.  But it's trickier than that.
Each collation element in a string has three components: primary (A vs B),
secondary (A vs A-acute), and tertiary (A' vs a); and a primary difference
at the end of a string takes precedence over a secondary or tertiary
difference earlier in the string.
To account for this, we put all of the primary orders at the beginning of the
string, followed by the secondary and tertiary orders, separated by nulls.
Here's a hypothetical example, with the collation element represented as
a three-digit number, one digit for primary, one for secondary, etc.
String:              A     a     B   \u00e9 <--(e-acute)
Collation Elements: 101   100   201  510
Collation Key:      1125<null>0001<null>1010
To make things even trickier, secondary differences (accent marks) are compared
starting at the *end* of the string in languages with French secondary ordering.
But when comparing the accent marks on a single base character, they are compared
from the beginning.  To handle this, we reverse all of the accents that belong
to each base character, then we reverse the entire string of secondary orderings
at the end.  Taking the same example above, a French collator might return
Collation Key:      1125<null>1000<null>1010
walk through each character
accumulate all of the ignorable/secondary characters attached
to a given base character
We're doing reversed secondary ordering and we've hit a base
(non-ignorable) character.  Reverse any secondary orderings
that applied to the last base character.  (see block comment above.)
Remember where we are in the secondary orderings - this is how far
back to go if we need to reverse them later.
If we've accumulated any secondary characters after the last base character,
And now reverse the entire secResult to get French secondary ordering.
if we know we're not actually a subclass of RuleBasedCollator
(this class really should have been made final), bypass
Object.clone() and use our "copy constructor".  This is faster.
super does class check
all other non-transient information is also contained in rules.
need look up in .commit()
Expand index follows
contract indexes follow
Internal objects that are cached across calls so that they don't have to
be created/destroyed on every call to compare() and getCollationKey()
GETTERS AND SETTERS
Compiler error messages
JAXP/TrAX error messages
Command-line error messages
Recently added error messages
All error messages are localized and are stored in resource bundles.
This array and the following 4 strings are read from that bundle.
If the _isWarningError flag is true, the error is treated as
a warning by the compiler, but should be reported as an error
to the ErrorListener. This is a workaround for the TCK failure
This is used to keep indirections working across fragments.  When added
to the current bbwi.position(), the result is the current position
in the byte stream without any fragment headers.
It is equal to the following:
n = number of buffers (0 is original buffer, 1 is first fragment, etc)
n == 0, fragmentOffset = 0
n > 0, fragmentOffset
Notice that in 1.1, we won't end a fragment with
alignment padding.  We also won't guarantee that
our fragments end on evenly divisible 8 byte
boundaries.  There may be alignment
necessary with the header of the next fragment
since the header isn't aligned on an 8 byte
boundary, so we have to calculate it twice.
Must recompute the alignment after a grow.
In the case of fragmentation, the alignment
calculation may no longer be correct.
People shouldn't be able to set their fragment
sizes so small that the fragment header plus
this alignment fills the entire buffer.
Save the current size for possible post-fragmentation calculation
At this point, if we fragmented, we should have a ByteBufferWithInfo
with the fragment header already marshalled.  The size and length fields
should be updated accordingly, and the fragmented flag should be set.
Clear the flag
Update fragmentOffset so indirections work properly.
At this point, oldSize is the entire length of the
previous buffer.  bbwi.position() is the length of the
fragment header of this buffer.
In GIOP 1.1, interoperability with wchar is limited
to 2 byte fixed width encodings.  CORBA formal 99-10-07 15.3.1.6.
Note that the following code prohibits UTF-16 with a byte
order marker (which would result in 4 bytes).
The length is the number of code points (which are 2 bytes each)
including the 2 byte null.  See CORBA formal 99-10-07 15.3.2.7.
Write the 2 byte null ending
cached hash code
check set only contains elements of the given type
EnumSet.copyOf does not allow empty set
copy and check for erroneous elements
copy and check for null elements
EnumSet.copyOf does not allow empty set
copy and check for erroneous elements
copy and check for null elements
return cached hash if available
drop final slash
drop final slash
check for permission to specify a handler
Note: we don't do validation of the URL here. Too risky to change
right now, but worth considering for future reference. -br
Check for permission to specify a handler
eliminate trailing whitespace
eliminate leading whitespace
Only use our context if the protocols match.
inherit the protocol handler from the context
if not specified to the constructor
If the context is a hierarchical URL scheme and the spec
contains a matching scheme then maintain backwards
compatibility and treat it as if the spec didn't contain
the scheme; see 5.2.3 of RFC2396
Get the protocol handler if not specified or the protocol
of the context could not be used
Create a copy of Proxy as a security measure
Use the factory (if any)
Try java protocol handler
REMIND: decide whether to allow the "null" class prefix
any number of exceptions can get thrown here
Check again with hashtable just in case another
thread created a handler since we last checked
Check with factory if another thread set a
factory since our last check
The handler from the factory must be given more
importance. Discard the default handler that
this thread created.
Insert this handler into the hashtable
write the fields
already been checked in readObject
Construct authority part
Handle hosts with userInfo in them
Construct user info part
Construct path and query part
Fix: only do this if hierarchical?
Set the object fields.
create URL string from deserialized object
pre-compute length of StringBuilder
Connect to the HTTP proxy server
close the original socket impl and release its descriptor
update the Sockets impl to the impl from the http Socket
best effort is made to try and reset options previously set
we're connected, just return
store options so that they can be re-applied to the impl after connect
--- AttributeSet methods ----------------------------
specify if initiator.
perform authentication exchange if initiator
the authentication status
Encryption keys calculated from password. Assigned when storekey == true
and useKeyTab == false (or true but not found)
Unchecked warning from (Map<String, Object>)sharedState is safe
since javax.security.auth.login.LoginContext passes a raw HashMap.
Unchecked warnings from options.get(String) are safe since we are
passing known keys.
initialize any configured options
check isInitiator value
use default, if value not set
authentication failed -- try again below by prompting
authentication failed -- clean out state
attempt the authentication by getting the username and pwd
by prompting or configuration i.e. not from shared state
authentication failed -- clean out state
ticketCacheName == null implies the default cache
check to renew credentials
credentials have expired
get the principal name from the ticket cache
cred = null indicates that we didn't get the creds
from the cache or useTicketCache was false
We need the principal name whether we use keytab
or AS Exchange
XXX Even if isInitiator=false, it might be
better to do an AS-REQ so that keys can be
updated with PA info
When encKeys is empty, the login actually fails.
For compatibility, exception is thrown in commit().
we should hava a non-null cred
use the name saved by the first module in the stack
use the password saved by the first module in the stack
create Kerberos Ticket
Let us add the kerbClientPrinc,kerbTicket and KeyTab/KerbKey (if
storeKey is true)
We won't add "*" as a KerberosPrincipal
add the TGT
login succeeded but overall authentication failed
overall authentication succeeded and commit succeeded,
but someone else's commit failed
Let us remove all Kerberos credentials stored in the Subject
clean the kerberos ticket and keys
Clean the ticket and server key
save input as shared state only if
remove temp results for the next try
These are used in the text painting code to avoid allocating a bunch of
These Rectangles/Insets are used in the text size calculation to avoid a
a bunch of garbage.
draw vertical line
draw horizontal line
oblique lines are not supported
Calculate the result width
The last gap is unnecessary
Calculate the result height
Take into account menu item insets
if the width is even, bump it up one. This is critical
for the focus dash lhne to draw properly
if the height is even, bump it up one. This is critical
for the text to center properly
Save original graphics font and color
Restore original graphics font and color
Use default icon
Text is HTML
Text isn't HTML
This is a noop as this should only be for sizing calls.
Defined so that this class isn't flagged as a potential problem when
searches for missing serialVersionUID fields are done.
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of CheckBoxPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of CheckBoxPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
true if this socket is exclusively bound
emulates SO_REUSEADDR when exclusiveBind is true and socket is bound
socket already bound, emulate
This can't happen, but make sure anyway
This can't happen, but make sure anyway
this shouldn't happen, since we are Cloneable
-- This file was mechanically generated: Do not edit! --
## If the sequence is a string, use reflection to share its array
## Override bulk get methods for better performance
This constant is likely to be removed in the future. Use the
getDocument() method instead of ROOTNODE to get at the root
node of a DTM.
favor small docs.
Use smaller sizes for the internal node arrays if the block size
Only create the m_prevsib array if the usePrevsib flag is true.
Some DTM implementations (e.g. SAXImpl) do not need this array.
We can save the time to build it in those cases.
Note that this fails if we aren't talking to an instance of
* Ensure that the size of the information arrays can hold another entry
* at the given index.
* @param index On exit from this function, the information arrays sizes must be
* at least index+1.
protected void ensureSize(int index)
We've cut over to Suballocated*Vector, which are self-sizing.
Reorganized test and loop into single flow
Tiny performance improvement, saves a few bytes of code, clearer.
%OPT% Other internal getters could be treated simliarly
Boiler-plate code for each of the _xxx functions, except for the array.
Check to see if the information requested has been processed, and,
if not, advance the iterator until we the information has been
Boiler-plate code for each of the _xxx functions, except for the array.
Check to see if the information requested has been processed, and,
if not, advance the iterator until we the information has been
Check to see if the information requested has been processed, and,
if not, advance the iterator until we the information has been
Check to see if the information requested has been processed, and,
if not, advance the iterator until we the information has been
========= DTM Implementation Control Functions. ==============
========= Document Navigation Functions =========
Optimization: use the DTMManagerDefault's fast DTMID-to-offsets
table.  I'm not wild about this solution but this operation
needs need extreme speed.
%REVIEW% Wish I didn't have to perform the pre-test, but
someone is apparently asking DTMs whether they contain nodes
which really don't belong to them. That's probably a bug
which should be fixed, but until it is:
Assume that attributes and namespaces immediately follow the element.
Assume this can not be null.
If the previous sibling array is not built, we get at
the previous sibling using the parent, firstch and
Assume that attributes and namespace nodes immediately follow the element
Most recent. May be -1 (none) if DTM was pruned.
%OPT% Is there a lastElement() method? Should there be?
%OPT% Count-down might be faster, but debuggability may
be better this way, and if we ever decide we want to
keep this ordered by expanded-type...
Base the size of a new namespace list on the
size of the inherited list - but within reason!
Handle overwriting inherited.
%OPT% Keep sorted? (By expanded-name rather than by doc order...)
Downside: Would require insertElementAt if not found,
which has recopying costs. But these are generally short lists...
%OPT% Is binary-search really saving us a lot versus linear?
(... It may be, in large docs with many NS decls.)
-1-wouldbeat == 0
Not after anything; definitely not found
Not found, but we know where it should have been.
Search back until we find an ancestor or run out.
Decrement wouldBeAt to find last possible ancestor
Special case: if the candidate is before the given node, and
is in the earliest possible position in the document, it
must have the namespace declarations we're interested in.
Found ancestor in list
Too deep in tree
Too late in list
No namespaces known at this node
looked too late
looked ot early
Clean up at loop end
not-found has to be encoded.
Assume that attributes and namespaces immediately
follow the element.
%OPT% Would things be faster if all NS nodes were built
before all Attr nodes? Some costs at build time for 2nd
Since we've been given the base, try direct lookup
(could look from nodeHandle but this is at least one
Assume that attributes and namespace nodes immediately follow the element.
%REVIEW% This _should_ only be null if someone asked the wrong DTM about the node...
which one would hope would never happen...
Apparently, the axis walker stuff requires levels to count from 1.
============== Document query functions ==============
%REVIEW%  OK? -sb
%REVIEW%  OK??  -sb
============== Boolean methods ================
These return NULL if the node doesn't belong to this document.
========== Direct SAX Dispatch, for optimization purposes ========
==== Construction methods (may not be supported by some implementations!) =====
Common UI methods
cant happen ...
raises exception on error
The code below reads the reply body in some cases
SYSTEM_EXCEPTION & LOCATION_FORWARD
do nothing. The client stub will read the exception from body.
Note, this writes only the header information. SystemException or
IOR may be written afterwards into the reply mesg body.
Even works for i == -1
Fix for bug 4282900 to pass JCK regression test
The specification requires that we do nothing if the child
is already nested herein.
test before locking
The specification requires that we invoke setBeanContext() on the
newly added child if it implements the java.beans.beancontext.BeanContextChild interface
The specification requires that we fire a notification of the change
we are required to notify the child that it is no longer nested here if
it implements java.beans.beancontext.BeanContextChild
do nothing ...
lets also tell the Children that can that they may not use their GUI's
lets also tell the Children that can that they may use their GUI's
number of subsequent objects
serialize the BeanContextSupport object
Either the result or boxed AltResult
Top of Treiber stack of dependent actions
CAS from null to r
null only for NIL
by convention below, null means interrupted
Modes for Completion.tryFire. Signedness matters.
Treiber stack link
executor to use (null if none)
the dependent to complete
source for action
clear on failure
no need to claim
try to return function result directly
second source for action
clear on failure
clear on failure
clean second source
clear on failure
clear on failure
wait time if timed
non-zero if timed
> 0: interruptible, < 0: interrupted
no need to atomically claim
Use brief spin-wait on multiprocessors
We intentionally don't spin here (as waitingGet does) because
the call to nanoTime() above acts much like a spin.
not in interface CompletionStage
method moved from util.Utility
Is Java serialization enabled?
Check the JavaSerializationComponent (tagged component)
in the IIOPProfile. If present, the peer ORB's GIOP is capable
of using Java serialization instead of CDR serialization.
In such a case, use Java serialization, iff the java serialization
Since encodingVersion is <= 0 (CDR_ENC_VERSION).
construct repositoryId -> className hashtable
SystemExceptions from OMG Transactions Service Spec
from portability RTF 98-07-01.txt
from orbrev/00-09-01 (CORBA 2.4 Draft Specification)
Exception types introduced between CORBA 2.4 and 3.0
Exception types introduced in CORBA 3.0
construct className -> repositoryId hashtable
find the maximum span of the string "n.n.n..." where n is an integer
no digit found
cases like "n." or "n..m"
convert equivalent to "n.0" or "n.0.m"
v1 is longer or greater than v2
Note that this must end in . in order to be renamed correctly.
Return a compressed representation of the thread name.  This is particularly
useful on the server side, where there are many SelectReaderThreads, and
we need a short unambiguous name for such threads.
This depends on the formatting in SelectReaderThread and CorbaConnectionImpl.
Pattern for SelectReaderThreads:
SelectReaderThread CorbaConnectionImpl[ <host> <post> <state>]
Any other pattern in the Thread's name is just returned.
print the stack trace, ommitting the zeroth element, which is
always this method.
Implements all dprint calls in this package.
This is our code, but the ContactInfoList is not a
CorbaContactInfoList.  This should not happen, because
we are in the CORBA application of the DCSA framework.
This is a coding error, and thus an INTERNAL exception
should be thrown.
XXX needs minor code
obj is implemented by a foreign ORB, because the Delegate is not a
XXX this case could be handled by marshalling and
unmarshalling.  However, object_to_string cannot be used
here, as it is implemented with getIOR.  Note that this
will require access to an ORB, so that we can create streams
as needed.  The ORB is available simply as io._orb().
Letters and $ _
= ~ + | < >
Returns a String which looks similar to:
PermissionCollection java.security.Permissions@1053693 ...
(java.io.FilePermission <<ALL FILES>> ....)
(java.io.FilePermission /export0/sunwappserv/lib/- ...)
... other permissions ...
Domain ProtectionDomain  (file:/export0/sunwappserv/lib-)
(java.io.FilePermission <<ALL FILES>> ...)
(java.io.FilePermission /var/tmp- ...)
Don't need to add 'Protection Domain' string, it's
in ProtectionDomain.toString() already.
End of file.
Accessor methods (RequestMessage interface)
REVISIT Should we throw an exception or return null ?
this will raise a MARSHAL exception upon errors.
No-op, must be GIOP Version 1.1 or greater
to support this SUN PROPRIETARY EXTENSION.
---- BoxView methods -------------------------------------
This synthetic insertUpdate call gives the strategy a chance
repair the flow if necessary
Temporary fix for 4250847
Can be removed when TraversalContext is added
nb idk 12/12/2001 host should not be equal to null. We need to add assertion here
Don't include insets, Box.getXXXSpan will include them.
---- View methods ----------------------------------------------------
--- variables -----------------------------------------------
shouldn't happen since offset is inside view bounds
FlowView.loadChildren() makes a synthetic call into this,
passing null as e
In some cases there's no view at position damageStart, so
step back and search again. See 6452106 for details.
if the view does not break, and it is the only view
in a row, use the whole view
row is too long, and we may break
it's a forced break, so there is
no point in searching further.
there is nothing that can be broken, leave
it in it's current state.
Break the best candidate view, and patch up the row.
Get the child view that contains the given starting position
return the entire view
return a fragment.
Update the view responsible for the changed element by invocation of
Re-calculate the update indexes and update the views followed by
the changed place. Note: we update the views only when insertion or
removal takes place.
The following methods don't do anything useful, they
simply keep the class from being abstract.
XXX Validate the URL?
If the ORBDefaultInitRef is not defined simply return null
If the ORBDefaultInitDef is  defined as corbaloc: then create the
corbaloc String in the format
and resolve it using resolveCorbaloc method
Attempt to resolve the system identifier against the base URI.
Ignore the exception. Fallback to the literal system identifier.
The namespace is useful for resolving namespace aware
grammars such as XML schema. Let it take precedence over
the external identifier if one exists.
Attempt to resolve the system identifier against the base URI.
Ignore the exception. Fallback to the literal system identifier.
Resolve against an external identifier if one exists. This
is useful for resolving DTD external subsets and other
external entities. For XML schemas if there was no namespace
mapping we might be able to resolve a system identifier
specified as a location hint.
Ignore IOException. It cannot be thrown from this method.
The namespace is useful for resolving namespace aware
grammars such as XML schema. Let it take precedence over
the external identifier if one exists.
Resolve against an external identifier if one exists. This
is useful for resolving DTD external subsets and other
external entities. For XML schemas if there was no namespace
mapping we might be able to resolve a system identifier
specified as a location hint.
Comparison and hashing
this usually means the entry is no longer in the map.
this usually means the entry is no longer in the map.
ise thrown from function is not a cme.
this usually means the entry is no longer in the map.
something to remove
nothing to do. Leave things as they were.
add or replace old mapping
If nonzero, forces the inial chunk size.
%BUG% %REVIEW% *****PROBLEM SUSPECTED: If data from an FSB is being copied
back into the same FSB (variable set from previous variable, for example)
and blocksize changes in mid-copy... there's risk of severe malfunction in
the read process, due to how the resizing code re-jiggers storage. Arggh.
If we want to retain the variable-size-block feature, we need to reconsider
that issue. For now, I have forced us into fixed-size mode.
Should this force to larger value, or smaller? Smaller less efficient, but if
someone requested variable mode it's because they care about storage space.
On the other hand, given the other changes I'm making, odds are that we should
adopt the larger size. Dither, dither, dither... This is just stopgap workaround
anyway; we need a permanant solution.
Don't bite off more than we're prepared to swallow!
10 bits is 1K. 15 bits is 32K. Remember that these are character
counts, so actual memory allocation unit is doubled for UTF-16 chars.
For reference: In the original FastStringBuffer, we simply
overallocated by blocksize (default 1KB) on each buffer-growth.
Recover the original chunk size
Discard the hierarchy
Replace this FSB with the appropriate inner FSB, truncated
There's an edge case if l is an exact multiple of m_chunkBits, which risks leaving
us pointing at the start of a chunk which has not yet been allocated. Rather than
pay the cost of dealing with that in the append loops (more scattered and more
inner-loop), we correct it here by moving to the safe side of that
line -- as we would have left the indexes had we appended up to that point.
Undo encapsulation -- pop the innerFSB data back up to root.
Inefficient, but attempts to keep the code simple.
Finally, truncate this sucker.
We may have preallocated chunks. If so, all but last should
be at full size.
Simplified test single-character-fits
Advance one chunk
Should do all the work of both encapsulating
existing data and establishing new sizes/offsets
Add a chunk.
Space exists in the chunk. Append the character.
Repeat while data remains to be copied
Copy what fits
If there's more left, allocate another chunk and continue
Advance one chunk
Should do all the work of both encapsulating
existing data and establishing new sizes/offsets
Add a chunk.
Adjust the insert point in the last chunk, when we've reached it.
Repeat while data remains to be copied
Copy what fits
If there's more left, allocate another chunk and continue
Advance one chunk
Should do all the work of both encapsulating
existing data and establishing new sizes/offsets
Add a chunk.
Adjust the insert point in the last chunk, when we've reached it.
Repeat while data remains to be copied
Copy what fits
If there's more left, allocate another chunk and continue
Advance one chunk
Should do all the work of both encapsulating
existing data and establishing new sizes/offsets
Add a chunk.
Adjust the insert point in the last chunk, when we've reached it.
Complicating factor here is that the two buffers may use
different chunk sizes, and even if they're the same we're
probably on a different alignment due to previously appended
data. We have to work through the source in bite-sized chunks.
Repeat while data remains to be copied
Copy what fits
If there's more left, allocate another chunk and continue
Advance one chunk
Should do all the work of both encapsulating
existing data and establishing new sizes/offsets
Add a chunk.
Adjust the insert point in the last chunk, when we've reached it.
after first chunk
after first chunk
Last, or only, chunk
This call always starts at the beginning of the
string being written out, either because it was called directly or
because it was an m_innerFSB recursion. This is important since
it gives us a well-known initial state for this flag:
after first chunk
Last, or only, chunk
%REVIEW% Is this update really needed?
%REVIEW% Is this update really needed?
Strip any leading spaces first, if required
If we've only encountered leading spaces, the
current state remains unchanged
If we get here, there are no more leading spaces to strip
Grab a chunk of non-whitespace characters
Non-whitespace seen - emit them, along with a single
space for any preceding whitespace characters
Consume any whitespace characters
%OPT% Do it this way for now...
%TBD% Joe needs to write this function.  Make public when implemented.
Copy existing information into new encapsulation
These have to be adjusted because we're calling just at the time
when we would be about to allocate another chunk
Establish capsule as the Inner FSB, reset chunk sizes/addressing
Since we encapsulated just as we were about to append another
chunk, return ready to create the chunk after the innerFSB
-- 1, not 0.
Only for use by Runtime.exec(...envp...)
Before 1.5, we blindly passed invalid envstrings
to the child process.
We would like to throw an exception, but do not,
for compatibility with old broken code.
Silently discard any trailing junk.
Silently ignore envstrings lacking the required `='.
Must convert to array first -- a malicious user-supplied
list might try to circumvent the security check.
Throws IndexOutOfBoundsException if command is empty
Can not disclose the fail reason for read-protected files.
It's much easier for us to create a high-quality error
message than the low-level C code which found the problem.
Reading private fields of base class
Parse 'name' and 'select' attributes plus parameter contents
Add a ref to this var to its enclosing construct
Mark this as a global variable
Check if a global variable with this name already exists...
...and if it does we need to check import precedence
It is an error if the two have the same import precedence
Ignore this if previous definition has higher precedence
Add this variable if we have higher precedence
Type check the 'select' expression if present
Type check the element contents otherwise
The return type is void as the variable element does not leave
anything on the JVM's stack. The '_type' global will be returned
by the references to this variable, and not by the variable itself.
This is only done for local variables that are actually used
Create a variable slot if none is allocated
Push the default value on the JVM's stack
0 for node-id, integer and boolean
0.0 for floating point numbers
and 'null' for anything else
Mark the store as the start of the live range of the variable
Don't generate code for unreferenced variables
Make sure that a variable instance is only compiled once
Compile variable value computation
Add a new local variable and store value
If the local is just being created, mark the store as the start
of its live range.  Note that it might have been created by
initializeVariables already, which would have set the start of
the live range already.
Global variables are store in class fields
Push a reference to "this" for putfield
Compile variable value computation
Store the variable in the allocated field
end of Input.java
Note: check only at classloading time, not dynamically during combine()
Relevant only when useJavaxPolicy is true
No need to optimize assignedDomains because it should
have been previously optimized (when it was set).
Note that we are returning a direct reference
to the input array - since ACC does not clone
the arrays when it calls combiner.combine,
multiple ACC instances may share the same
array instance in this case
No need to optimize assignedDomains because it should
have been previously optimized (when it was set).
maintain backwards compatibility for developers who provide
their own custom javax.security.auth.Policy implementations
the ProtectionDomains for the new AccessControlContext
that we will return
if the Subject was mutated, clear the PD cache
Need to keep static ProtectionDomain objects static
now add on the assigned domains
optimize the result (cached PDs might exist in assignedDomains)
if aLen == 0 || allNew, no need to further optimize newDomains
return the new ProtectionDomains
Call refresh only caching is disallowed
the ProtectionDomains for the new AccessControlContext
that we will return
if the Subject was mutated, clear the PD cache
keep static ProtectionDomain objects static
we must first add the original permissions.
that way when we later add the new JAAS permissions,
any unresolved JAAS-related permissions will
automatically get resolved.
get the original perms
get perms from the policy
add the newly granted perms,
now add on the assigned domains
return the new ProtectionDomains
skip domains with AllPermission
skip System Domains
resize the array if necessary
cache by default
Type-specific CORBA::Object operations
This component is disabled, so return the disabled color.
In some cases this means ignoring the color specified by the
developer on the component. In other cases it means using a
specified disabledTextColor, such as on JTextComponents.
For example, JLabel doesn't specify a disabled color that the
developer can set, yet it should have a disabled color to the
text when the label is disabled. This code allows for that.
If the developer has specified a color, prefer it. Otherwise, get
the color for the state.
Then use what we've locally defined
No color, fallback to that of the widget.
Special case the Border as this will likely change when the LAF
can have more control over this.
NOTE: because getForeground, getBackground and getFont will look
at the parent Container, if we set them to null it may
mean we they return a non-null and non-UIResource value
preventing install from correctly settings its colors/font. For
this reason we do not uninstall the fg/bg/font.
REVISIT - this needs alot more from previous ReaderThread.
End of file.
private constructor defined to "hide" the default public constructor
PUBLIC STATIC METHODS
PUBLIC STATIC VARIABLES
Node that XPathNamespaceImpl wraps
For namespace node, the namespaceURI is the namespace URI
of the namespace represented by the node.
For namespace node, the local name is the same as the prefix
check for letter T but no time sections
regex limits to [-+]?[0-9]+
1300 used by sun.awt.windows.ModalityEvent
cache shape bounds, since GeneralPath doesn't
translating graphics to draw Shape !!!
REMIND: set stroke to correct size
don't retain ref while waiting
don't retain ref while waiting
In this order, in case add() throws.
In this order, in case add() throws.
Array of all elements
index of next element to return
index of last element, or -1 if no such
## check lock object
The default encoding should always be available
-- This file was mechanically generated: Do not edit! --
For duplicates and slices
REVISIT - why special?
REVISIT: replace next two with PlugInFactory (implemented by ContactInfo
End of file.
loads IIOPProxy implementation class if available
must have exact type Object[]
Visibility guaranteed by final field guarantees
Note: This must be changed if any additional fields are defined
Need to signal one of OBJECT_HERE, OBJECT_FORWARD, OBJECT_NOT_EXIST.
send a locate forward with the right IOR. If the insKey is not
registered then it will throw OBJECT_NOT_EXIST Exception
send a locate forward with the right IOR. If the insKey is not
registered then it will throw OBJECT_NOT_EXIST Exception
If entry is not null then the locate is with an INS Object key,
so send a location forward with the right IOR.
To workaround problem where Gridbad will set child
to its minimum size if its preferred size will not fit
within allocated cells
break up newlines
Primitive line wrapping
Option Pane Auditory Cue Activation
only respond to "ancestor" changes
the idea being that a JOptionPane gets a JDialog when it is
set to appear and loses it's JDialog when it is dismissed.
if the old value is null, then the JOptionPane is being
created since it didn't previously have an ancestor.
figure out what to do based on the message type
Classes used when optionPane.getWantsInput returns true.
Returning false will allow further processing
of the bindings, eg our parent Containers will get a
crack at them.
Adding tagged components is not allowed for IIOP 1.0,
so this template is complete and should be made immutable.
Handle any tagged components (if applicable)
Note that this is NOT an encapsulation: do not marshal
the endianness flag.  However, the length is required.
Note that this cannot be accomplished with a codec!
Use the byte order of the given stream
non-racing this.hashCodeForCache : final int
racing e : current value <=> stale value from current cache or from stale cache
invariant:  e is null or an Entry with readable Entry.version and Entry.value
invariant:  No false positive matches.  False negatives are OK if rare.
The key fact that makes this work: if this.version == e.version,
then this thread has a right to observe (final) e.value.
The fast path can fail for any of these reasons:
1. no entry has been computed yet
2. hash code collision (before or after reduction mod cache.length)
3. an entry has been removed (either on this type or another)
4. the GC has somehow managed to delete e.version and clear the reference
Possible functionality for JSR 292 MR 1
invariant:  returned value is safe to dereference and check for an Entry
Hack to suppress warnings on the (T) cast, which is a no-op.
The fail-safe recovery is to fall back to the underlying classValueMap.
Try to make a real entry for the promised version.
Whether computeValue throws or returns normally,
be sure to remove the empty entry.
else try again, in case a racing thread called remove (so e == null)
racing e.version : null (blank) => unique Version token => null (GC-ed version)
non-racing this.version : v1 => v2 => ... (updates are read faithfully from volatile)
invariant:  No false positives on version match.  Null is OK for false negative.
invariant:  If version matches, then e.value is readable (final set in Entry.<init>)
usually of type T, but sometimes (Entry)this
for a regular entry, value is of type T
for a promise, value is not of type T, but Entry!
if !isPromise, type is T
if !isPromise, type is T
value = null -- caller must drop
racing type.classValueMap : null (blank) => unique ClassValueMap
if a null is observed, a map is created (lazily, synchronously, uniquely)
all further access to that map is synchronized
private object to avoid deadlocks
happens about once per type
Note that explicitVersion might be different from this.version.
As soon as the Entry is put into the cache, the value will be
reachable via a data race (as defined by the Java Memory Model).
This race is benign, assuming the value object itself can be
read safely by multiple threads.  This is up to the user.
The entry and version fields themselves can be safely read via
a race because they are either final or have controlled states.
If the pointer from the entry to the version is still null,
or if the version goes immediately dead and is nulled out,
the reader will take the slow path and retry under a lock.
The following class could also be top level and non-public:
one map has entries for all value types <T>
The presence of a promise means that a value is pending for v.
Eventually, finishEntry will overwrite the promise.
Note that the promise is never entered into the cache!
Somebody else has asked the same question.
Let the races begin!
there is already a completed entry here; report it
There is a stale but valid entry here; make it fresh again.
Once an entry is in the hash table, we don't care what its version is.
Add to the cache, to enable the fast path, next time.
one map has entries for all value types <T>
We can get here during exception processing, unwinding from computeValue.
If e0 matches the intended entry, there has not been a remove call
between the previous startEntry and now.  So now overwrite e0.
Add to the cache, to enable the fast path, next time.
Some sort of mismatch; caller must try again.
Uninitialized, and no pending calls to computeValue.  No change.
State is uninitialized, with a pending call to finishEntry.
Since remove is a no-op in such a state, keep the promise
by putting it back into the map.
In an initialized state.  Bump forward, and de-initialize.
Make all cache elements for this guy go stale.
one map has entries for all value types <T>
no value change => no version change needed
Add to the cache, to enable the fast path, next time.
Statics do not need synchronization.
non-racing cache.length : constant
racing cache[i & (mask)] : null <=> Entry
invariant:  returned value is null or well-constructed (ready to match)
Probe the cache carefully, in a range of slots.
victim, if we find the real guy
if nobody is at home, no need to search nearby
assume !classValue.match(e2), but do not assert, because of races
only search within non-null runs
relocate colliding entry e2 (from cache[home]) to first empty slot
put e2 here if it fits
Remember first empty slot, if any:
entry is not live!
/ Below this line all functions are private, and assume synchronized access.
must be power of 2
skip null and live entries
avoid breaking up a non-null run
End of non-null run.
e2 already optimally placed
e2 can replace entry at cache[home1]
Put e2 exactly where he belongs.
And keep going, so we can favor larger dislocations.
Be conservative, to avoid breaking up a non-null run.
do not fill cache
Add e to the cache.
try to move e2 somewhere else in his probe range
Note:  At this point, e2 is just dropped from the cache.
do not overwrite a live entry
N.B.  Set PROBE_LIMIT=0 to disable all fast paths.
Data flow in Calendar
The current time is represented in two ways by Calendar: as UTC
milliseconds from the epoch (1 January 1970 0:00 UTC), and as local
fields such as MONTH, HOUR, AM_PM, etc.  It is possible to compute the
millis from the fields, and vice versa.  The data needed to do this
conversion is encapsulated by a TimeZone object owned by the Calendar.
The data provided by the TimeZone object may also be overridden if the
user sets the ZONE_OFFSET and/or DST_OFFSET fields directly. The class
keeps track of what information was most recently set by the caller, and
uses that to compute any other information as needed.
If the user sets the fields using set(), the data flow is as follows.
This is implemented by the Calendar subclass's computeTime() method.
During this process, certain fields may be ignored.  The disambiguation
algorithm for resolving which fields to pay attention to is described
in the class documentation.
local fields (YEAR, MONTH, DATE, HOUR, MINUTE, etc.)
| Using Calendar-specific algorithm
local standard millis
| Using TimeZone or user-set ZONE_OFFSET / DST_OFFSET
UTC millis (in time data member)
If the user sets the UTC millis using setTime() or setTimeInMillis(),
the data flow is as follows.  This is implemented by the Calendar
subclass's computeFields() method.
UTC millis (in time data member)
| Using TimeZone getOffset()
local standard millis
| Using Calendar-specific algorithm
local fields (YEAR, MONTH, DATE, HOUR, MINUTE, etc.)
In general, a round trip from fields, through local and UTC millis, and
back out to fields is made when necessary.  This is implemented by the
complete() method.  Resolving a partial set of fields into a UTC millis
value allows all remaining fields to be generated from that value.  If
the Calendar is lenient, the fields are also renormalized to standard
ranges when they are regenerated.
Calendar contains two kinds of time representations: current "time" in
milliseconds, and a set of calendar "fields" representing the current time.
The two representations are usually in sync, but can get out of sync
1. Initially, no fields are set, and the time is invalid.
2. If the time is set, all fields are computed and in sync.
3. If a single field is set, the time is invalid.
Recomputation of the time and fields happens when the object needs
to return a result to the user, or use a result for a computation.
Special values of stamp[]
the internal serial version which says which version was written
- 0 (default) for version up to JDK 1.1.5
- 1 for version from JDK 1.1.6, which writes a correct 'time' value
as well as compatible values for other fields.  This is a
- 2 (not implemented yet) a future version, in which fields[],
areFieldsSet, and isTimeSet become transient, and isSet[] is
removed. In JDK 1.1.6 we write a format compatible with version 2.
Proclaim serialization compatibility with JDK 1.1
Mask values for calendar fields
+1 for WEEK_YEAR
Calendar.stamp[] (lower half) and Calendar.fields[] (upper half) combined
Pseudo timestamp starting from MINIMUM_USER_STAMP.
(COMPUTED is used to indicate that the instant has been set.)
maxFieldIndex keeps the max index of fields which have been set.
(WEEK_YEAR is never included.)
NPE if instant == null
Note: WEEK_YEAR can't be set with this method.
Note: WEEK_YEAR can't be set with this method.
NPE if type == null
make gcal a proleptic Gregorian
and week definition to be compatible with ISO 8601
Set the fields from the min stamp to the max stamp so that
the fields resolution works in the Calendar.
fall back to the default instantiation
If no known calendar type is explicitly specified,
perform the traditional way to create a Calendar:
create a BuddhistCalendar for th_TH locale,
a JapaneseImperialCalendar for ja_JP_JP locale, or
a GregorianCalendar for any other locales.
NOTE: The language, country and variant strings are interned.
If we don't need to recalculate the calendar field values,
If the fields are partially normalized, calculate all the
fields before changing any fields.
UNSET == 0
the standalone and narrow styles are supported only through CalendarDataProviders.
Perform fallback here to follow the CLDR rules
Perform fallback here to follow the CLDR rules
SHORT or LONG
Ignore the standalone mask
ignore the standalone mask
DateFormatSymbols doesn't support any narrow names.
fills in unset fields
UNSET == 0
Some or all of the fields are in sync with the
milliseconds, but the stamp values are not normalized yet.
This implementation has been taken from the GregorianCalendar class.
The YEAR field must always be used regardless of its SET
state because YEAR is a mandatory field to determine the date
and the default value (EPOCH_YEAR) may change through the
Find the most recent group of fields specifying the day within
the year.  These may be any of the following combinations:
MONTH + DAY_OF_MONTH
MONTH + WEEK_OF_MONTH + DAY_OF_WEEK
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK
WEEK_OF_YEAR + DAY_OF_WEEK
We look for the most recent of the fields in each group to determine
the age of the group.  For groups involving a week-related field such
as WEEK_OF_MONTH, DAY_OF_WEEK_IN_MONTH, or WEEK_OF_YEAR, both the
week-related field and the DAY_OF_WEEK must be set for the group as a
whole to be considered.  (See bug 4153860 - liu 7/24/98.)
When they are equal, give the priority to
WEEK_OF_MONTH for compatibility.
Find the best set of fields specifying the time of day.  There
are only two possibilities here; the HOUR_OF_DAY or the
AM_PM and the HOUR.
if bestStamp is still UNSET, then take HOUR or AM_PM. (See 4846659)
Note: GregorianCalendar.computeTime throws
IllegalArgumentException if the ERA value is invalid
even it's in lenient mode.
'otheritems' represents the hash code for the previous versions.
If the TimeZone object is shared by other Calendar instances, then
create a clone.
if we know that the minimum value is always the same, just return it
clone the calendar so we don't mess with the real one, and set it to
accept anything for the field values
now try each value from getLeastMaximum() to getMaximum() one by one until
we get a value that normalizes to another value.  The last value that
normalizes to itself is the actual minimum for the current date
if we know that the maximum value is always the same, just return it.
clone the calendar so we don't mess with the real one, and set it to
accept anything for the field values.
if we're counting weeks, set the day of the week to Sunday.  We know the
last week of a month or year will contain the first day of the week.
now try each value from getLeastMaximum() to getMaximum() one by one until
we get a value that normalizes to another value.  The last value that
normalizes to itself is the actual maximum for the current date
this shouldn't happen, since we are Cloneable
NOTE: BuddhistCalendar.toString() interprets the string
produced by this method so that the Gregorian year number
is substituted by its B.E. year value. It relies on
"...,YEAR=<year>,..." or "...,YEAR=?,...".
The areFieldsSet and areAllFieldsSet values are no longer
controlled here (as of 1.5).
We have to check the new values of these fields after changing
firstDayOfWeek and/or minimalDaysInFirstWeek. If the field values
have been changed, then set the new values. (4822110)
Try to compute the time correctly, for the future (stream
version 2) in which we don't write out fields[] or isSet[].
If this Calendar has a ZoneInfo, save it and set a
SimpleTimeZone equivalent (as a single DST schedule) for
Write out the 1.1 FCS object.
Write out the ZoneInfo object
4802409: we write out even if it is null, a temporary workaround
the real fix for bug 4844924 in corba-iiop
Starting with version 2 (not implemented yet), we expect that
fields[], isSet[], isTimeSet, and areFieldsSet may not be
streamed out anymore.  We expect 'time' to be correct.
If there's a ZoneInfo object, use it for zone.
If the deserialized object has a SimpleTimeZone, try to
replace it with a ZoneInfo equivalent (as of 1.4) in order
to be compatible with the SimpleTimeZone-based
implementation as much as possible.
Message keys used by the serializer
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The localname is the portion after the optional colon; the message indicates
that there is a problem with that part of the QNAME.
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The prefix is the portion before the optional colon; the message indicates
that there is a problem with that part of the QNAME.
--- View methods ---------------------------------------------
determine if a repaint is needed
Repaint is needed because one of the tiled children
have changed their span along the major axis.  If there
is a hosting component and an allocated shape we repaint.
layout the major axis
flush changes to the children
layout the minor axis
flush changes to the children
We should paint views that intersect with clipping region
even if the intersection has no inside points (is a line).
This is needed for supporting views that have zero width, like
views that contain only combining marks.
The child allocation may not have been set yet.
--- local methods ----------------------------------------------------
determine the adjustment to be made
make the adjustments
can't make the child this wide, align it
make it the target width, or as small as it can get.
calculate tiled request
if resizable then resize to the best fit
the smallest span possible
the largest span possible
if the alignment is 0 then we need to fit into the descent
if the alignment is 1 then we need to fit into the ascent
figure out the span that we must fit into
fit into the calculated span
otherwise use the preferred spans
loop through all children calculating the max of all their ascents and
descents at minimum, preferred, and maximum sizes
find the maximum of the preferred ascents and descents
if the view is resizable then do the same for the minimum and
maximum ascents and descents
otherwise use the preferred
we now have an overall preferred, minimum, and maximum ascent and descent
calculate the preferred span as the sum of the preferred ascent and preferred descent
calculate the preferred alignment as the preferred ascent divided by the preferred span
if the preferred alignment is 0 then the minimum and maximum spans are simply
the minimum and maximum descents since there's nothing above the baseline
if the preferred alignment is 1 then the minimum and maximum spans are simply
the minimum and maximum ascents since there's nothing below the baseline
we want to honor the preferred alignment so we calculate two possible minimum
span values using 1) the minimum ascent and the alignment, and 2) the minimum
descent and the alignment. We'll choose the larger of these two numbers.
a similar calculation is made for the maximum but we choose the smaller number.
--- variables ------------------------------------------------
Windows displays the open icon when the tree item selected.
Too far in positive X direction to represent...
We cannot even reach the left side of the specified
rectangle even with both x & width set to MAX_VALUE.
The intersection with the "maximal integer rectangle"
is non-existant so we should use a width < 0.
REMIND: Should we try to determine a more "meaningful"
adjusted value for neww than just "-1"?
Too far in positive Y direction to represent...
Return best integer representation for v, clipped to integer
range and floor-ed or ceiling-ed, depending on the boolean.
Only adjust width if it was valid (>= 0).
The right edge is now conceptually at
newv+width, but we may move newv to prevent
overflow.  But we want the right edge to
remain at its new location in spite of the
clipping.  Think of the following adjustment
conceptually the same as:
width may go negative if the right edge went past
MIN_VALUE, but it cannot overflow since it cannot
have moved more than MIN_VALUE and any non-negative
number + MIN_VALUE does not overflow.
moving rightward (or staying still)
Conceptually the same as:
With large widths and large displacements
we may overflow so we need to check it.
See above comment about no overflow in this case
moving downward (or staying still)
At least one of the dimensions is negative...
Note: if any dimension is zero, tests below must return false...
X+W overflowed or W was zero, return false if...
either original w or W was zero or
x+w did not overflow or
the overflowed x+w is smaller than the overflowed X+W
X+W did not overflow and W was not zero, return false if...
original w was zero or
x+w did not overflow and x+w is smaller than X+W
At least one of the dimensions is negative...
Note: if either dimension is zero, tests below must return false...
overflow || intersect
overflow || intersect
tx2,ty2 will never overflow (they will never be
larger than the smallest of the two source w,h)
they might underflow, though...
This rectangle has negative dimensions...
If r has non-negative dimensions then it is the answer.
If r is non-existant (has a negative dimension), then both
are non-existant and we can return any non-existant rectangle
as an answer.  Thus, returning r meets that criterion.
Either way, r is our answer.
tx2,ty2 will never underflow since both original rectangles
were already proven to be non-empty
they might overflow, though...
tx2,ty2 will never underflow since both original
rectangles were non-empty
they might overflow, though...
Non-existant in X direction
Final width must remain negative so subtract x0 before
it is clipped so that we avoid the risk that the clipping
of x0 will reverse the ordering of x0 and x1.
(x1 >= x0)
Clip x0 before we subtract it from x1 in case the clipping
affects the representable area of the rectangle.
The only way x1 can be negative now is if we clipped
x0 against MIN and x1 is less than MIN - in which case
we want to leave the width negative since the result
did not intersect the representable area.
Non-existant in Y direction
(y1 >= y0)
this shouldn't happen, since we are Cloneable
The number of chars produced may be less than utflen
All axis past this are absolute.
parent (one node, has no order)
self (one node, has no order)
REVISIT - impl/poa specific:
REVISIT - POA specific policies
End of file.
Points to attribute name in constant pool
Content length of attribute field
Tag to distiguish subclasses
Get class name from constant pool via `name_index' indirection
Length of data in bytes
Compare strings to find known attribute
Call proper constructor, depending on `tag'
Placeholder for data for native functions
REMIND: make sure transferType is set correctly
Check for bits < 0
Make sure that we don't have all 0-bit components
Save this since we always need to check if it is the default CS
Save the transfer type
Make sure that someone isn't using a custom color model
that called the super(bits) constructor.
Make sure that someone isn't using a custom color model
that called the super(bits) constructor.
Normalized coordinates are non premultiplied
8-bit linear to 8-bit non-linear sRGB LUT
8-bit non-linear sRGB to 8-bit linear LUT
16-bit linear to 8-bit non-linear sRGB LUT
8-bit non-linear sRGB to 16-bit linear LUT
Maps to hold LUTs for grayscale conversions
8-bit gray values to 8-bit sRGB values
16-bit linear to 8-bit "other" gray
16-bit gray values to 8-bit sRGB values
16-bit linear to 16-bit "other" gray
Note: CMM.LINEAR_RGBspace will be null if the linear
RGB space has not been created yet.
Note: CMM.GRAYspace will be null if the linear
gray space has not been created yet.
algorithm for linear RGB to nonlinear sRGB conversion
is from the IEC 61966-2-1 International Standard,
Colour Management - Default RGB colour space - sRGB,
First Edition, 1999-10,
avaiable for order at http:www.iec.ch
algorithm from IEC 61966-2-1 International Standard
algorithm from IEC 61966-2-1 International Standard
algorithm from IEC 61966-2-1 International Standard
All three components of tmp should be equal, since
the input color space to colorConvert is a gray scale
space.  However, there are slight anomalies in the results.
Copy tmp starting at index 2, since colorConvert seems
to be slightly more accurate for the third component!
scale unsigned short (0 - 65535) to unsigned byte (0 - 255)
All three components of tmp should be equal, since
the input color space to colorConvert is a gray scale
space.  However, there are slight anomalies in the results.
Copy tmp starting at index 2, since colorConvert seems
to be slightly more accurate for the third component!
scale unsigned short (0 - 65535) to unsigned byte (0 - 255)
GTK allows you to specify the foreground and background in a
gtkrc, the rest (dark, mid, light) are calculated from these
private constructor for constructing point at infinity
Common UI methods
If the variable stack position is not -1, we'll have to
set our position in the variable stack, so our variable access
will be correct.  Iterators that are at the top level of the
expression need to reset the variable stack, while iterators
in predicates do not need to, and should not, since their execution
may be much later than top-level iterators.
m_varStackPos is set in setRoot, which is called
from the execute method.
These three statements need to be combined into one operation.
These two statements need to be combined into one operation.
Always call the superclass detach last!
trace creates and disposes
show reuse hits/misses
show bad params, misc.
installing additional listener if found in the AppContext
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
This can happen if a mouseReleased removes the
containing component -- bug 4146684
4188027: drag enter/exit added in JDK 1.1.7A, JDK1.2
Enter/exit detection -- needs tuning...
finally dispatch event to the first component in path
index in _nodes of the next node to try
gather all nodes from the source iterator
now sort the records
shared between clones
shared between clones
XXX This could probably be further extended by using more reflection and
a dynamic proxy that satisfies the interfaces that are inherited by the
more derived class.  Do we want to go that far?
Do nothing in this case: no parsing takes place
Since exc wraps the actual exception, use exc.getCause()
instead of exc.
Make sure that any extra initialization takes place after all the
fields are set from the map.
Where the search started
Or "*" to mean all-tags-acceptable
Preload all matching elements. (Stops when we run out of subtree!)
Tree changed. Do it all from scratch!
In the cache
Not yet seen
Pick up where we left off (Which may be the beginning)
Add nodes up to the one we're looking for
Either what we want, or null (not avail.)
Protected methods (might be overridden by an extending DOM)
Look down to first child.
Look right to sibling (but not from root!)
Look up and right (but not past root!)
Stop when we return to starting point
Have we found an Element with the right tagName?
("*" matches anything.)
DOM2: Namespace logic.
Otherwise continue walking the tree
Fell out of tree-walk; no more instances found
return the Subject from the DomainCombiner of the provided context
set up the new Subject-based AccessControlContext
call doPrivileged and push this new context on the stack
set up the new Subject-based AccessControlContext for doPrivileged
call doPrivileged and push this new context on the stack
set up the new Subject-based AccessControlContext
call doPrivileged and push this new context on the stack
set up the new Subject-based AccessControlContext for doPrivileged
call doPrivileged and push this new context on the stack
always return an empty Set instead of null
so LoginModules can add to the Set if necessary
always return an empty Set instead of null
so LoginModules can add to the Set if necessary
always return an empty Set instead of null
so LoginModules can add to the Set if necessary
we do not need a security check for
because we already restrict access to private credentials
via the PrivateCredentialPermission.  all the extra AuthPermission
would do is protect the set operations themselves
(like size()), which don't seem security-sensitive.
always return an empty Set instead of null
so LoginModules can add to the Set if necessary
always return an empty Set instead of null
so LoginModules can add to the Set if necessary
we do not need a security check for
because we already restrict access to private credentials
via the PrivateCredentialPermission.  all the extra AuthPermission
would do is protect the set operations themselves
(like size()), which don't seem security-sensitive.
always return an empty Set instead of null
so LoginModules can add to the Set if necessary
check the principal and credential sets
avoid deadlock from dual locks
avoid deadlock from dual locks
avoid deadlock from dual locks
Rewrap the principals into a SecureSet
Sometimes people deserialize the principals set only.
Subject is not accessible, so just don't fail.
want the default deserialization routine to set it to null.
ok to add Objects of any kind to credential sets
check for duplicates
For private credentials:
If the caller does not have read permission for
for o.getClass(), we throw a SecurityException.
Otherwise we check the private cred set to see whether
it contains the Object
check permissions before serializing
Check whether the caller has permisson to get
credentials of Class c
Check permission for private creds
Patch the size field in the header.
This should do nothing even if it is called. The Message Header already
is read off java.io.InputStream (not a CDRInputStream) by IIOPConnection
in order to choose the correct CDR Version, msg_type, and msg_size.
So, we would never need to read the Message Header off a CDRInputStream.
If the millisecond date value contains time info, mask it out.
If the millisecond date value contains time info, mask it out.
Override just in case it has been changed
make sure required attribute(s) have been set
Save current node and current iterator on the stack
Collect sort objects associated with this instruction
Store existing DOM on stack - must be restored when loop is done
<xsl:sort> cannot be applied to a result tree - issue warning
Put the result tree on the stack (DOM)
Get an iterator for the whole DOM - excluding the root node
Store the result tree as the default DOM
Compile node iterator
Overwrite current iterator
Give local variables (if any) default values before starting loop
Restore current DOM (if result tree was used instead for this loop)
Restore current node and current iterator from the stack
translatex and translatey are additional translations that
must occur on the graphics context when rendering a toolbar
we only do the +1 hack for UIResource borders, assuming
that the border is probably going to be our border
use image if we are printing to a Java 1.1 PrintGraphics as
it is not a instance of Graphics2D
we only do the -1 hack for UIResource borders, assuming
that the border is probably going to be our border
we only do the -1 hack for UIResource borders, assuming
that the border is probably going to be our border
The key "JComponent.sizeVariant" is used to match Apple's LAF
mini is not quite as small for icons as full mini is
just too tiny
Table of line/numbers pairs
array is empty
else constrain search area
pos > j
each TrayIcon added gets a unique ID
connecting tray to native resource
skip initialization as the init routine
TrayIcon with no peer is not contained in the array.
REVISIT - add ORBUtil mkdir -p like operation for this.
NODE FOR THIS CACHE
End of file.
serialVersionUID is not constant
Serialization compatibility stuff:
Two serial forms are supported in this class. The selected form depends
on system property "jmx.serial.form":
- "1.0" for JMX 1.0
- any other value for JMX 1.1 and higher
Serial version for old serial form
Serial version for new serial form
Serializable fields in old serial form
Serializable fields in new serial form
Actual serial version and serial form
OK: No compat with 1.0
END Serialization compatibility stuff
put getter and setter methods in constructors list
create default descriptor
put getter and setter methods in constructors list
create default descriptor
New serial form ignores extra field "currClass"
Serializes this instance in the old serial form
Serializes this instance in the new serial form
IF YOU ADD A SimpleType, YOU MUST UPDATE OpenType and typeArray
As this instance is immutable, these two values
need only be calculated once.
if obj is null, return false
Test if obj's class name is the same as for this instance
Test if other's className field is the same as for this instance
Calculate the hash code value if it has not yet been done (ie 1st call to hashCode())
return always the same hash code for this instance (immutable)
Calculate the string representation if it has not yet been done (ie 1st call to toString())
return always the same string representation for this instance (immutable)
Should not happen
Accessor methods (LocateRequestMessage interface)
this will raise a MARSHAL exception upon errors.
this does AddressingDisposition check
General Attribute Checking for elmNode
also add it to extended map
Ignore xsl:if when test is false (function-available() and
Make sure required attribute(s) have been set
Type-check the test expression
Type-check the contents (if necessary)
A key contains a name
Setup the object
Precompute lengths and values since they will not change
Compare the keys by comparing name's id and kind
Both lengths must match
If id is set is must be equal
If kind is set it must be equal
Must be the same
Return precomputed value
setFocusable(false);  for strict win/mac compatibility mode,
this method should be invoked
Initialize local ivars
Get UI going
Local behavior attributes
Locate the renderer under the event location
Now have to see if the component is a JComponent before
getting the tip
Convert the event to the renderer's coordinate system
No tip from the renderer get our own tip
Implementing TableColumnModelListener interface
--Redrawing the header is slow in cell selection mode.
--Since header selection is ugly and it is always clear from the
--view which columns are selected, don't redraw the header.
I'm registered to do tool tips so we can draw tips for the
Locate the renderer under the Point
Fixes 4772355 - ArrayOutOfBoundsException in
Fixes 4772355 - ArrayOutOfBoundsException in
return the cell renderer's AccessibleName
fall back to the client property
must be non null?
to override getBounds()
inner class AccessibleJTableHeaderElement
inner class AccessibleJTableHeader
End of Class JTableHeader
Type-specific CORBA::Object operations
check if caller is authorized to create context
all we had was privileged system code. We don't want
to return null though, so we construct a real ACC.
if context is null, we had privileged system code on the stack.
determine the x coordinate to render the glyphs
determine the y coordinate to render the glyphs
render the glyphs
The caller of this is left to right and borders a right to
left view, return our end location.
determine range to the left of the position
No need to return backward bias as GlyphPainter1 is used for
ltr text only.
fetch a new FontMetrics
--- variables ---------------------------------------------
already in array
Merge the two arrays
Copy the rest if of different lengths
Update reference to this array
read and discard the repository ID
write the repository ID
ExceptionRW interface and implementations.
Used to read and write exceptions.
read and ignore!
This may occur when rws has not been fully
populated, in which case the search should just fail.
Note that the exception ID is present in both ae
and in the input stream from ae.  The exception
reader must actually read the exception ID from
This is here just for the dynamicrmiiiop test
List of all the JPEG markers (pre-JPEG2000)
Codes 0x02 - 0xBF are reserved
SOF markers for Nondifferential Huffman coding
SOF markers for Differential Huffman coding
SOF markers for Nondifferential arithmetic coding
SOF markers for Differential arithmetic coding
codes 0xF0 to 0xFD are reserved
JFIF Resolution units
Adobe transform values
Spi initialization stuff
Names of the formats we can read or write
IJG Color codes.
Y/Cb/Cr (also known as YUV)
8 and 9 were old "Legacy" codes which the old code never identified
on reading anyway.  Support for writing them is being dropped, too.
PYCC.pf may not always be installed
Default value for ImageWriteParam
Can't have alpha
Gray is OK, always
If it isn't gray, it must have 3 channels
Must be RGB
Must be YCbCr
The following is converted from the IJG code.
recognized features and properties
REVISIT: [Q] Should the locator be passed to the reportError
method? Otherwise, there is no way for a parser
component to store information about where an
error occurred so as to report it later.
An example would be to record the location of
IDREFs so that, at the end of the document, if
there is no associated ID declared, the error
could report the location information of the
NOTE: I added another reportError method that allows the
caller to specify the location of the error being
REVISIT: [Q] Should we do anything about invalid severity
format error message and create parse exception
get error handler
call error handler
Allows the parser to continue after a fatal error.
Normally, a fatal error would stop the parse.
return state of given feature or false if unsupported.
Allows the parser to continue after a fatal error.
Normally, a fatal error would stop the parse.
ask the currently installed security manager if we
can create a new one.
make sure we don't include ourself
just return false
Using a snapshot of packageAccess -- don't care if static field
changes afterwards; array contents won't change.
No need to continue; only need to check this once
Using a snapshot of packageDefinition -- don't care if static
field changes afterwards; array contents won't change.
No need to continue; only need to check this once
override for Javadoc
inline TemporalAccessor.super.query(query) as an optimization
non-JDK classes are not permitted to make this optimization
OffsetDateTime is treated as three separate fields, not an instant
this produces the most consistent set of results overall
the offset is set after the date and time, as it is typically a small
tweak to the result, with ZonedDateTime frequently ignoring the offset
SocketImpl.connect() is a protected method, therefore we need to use
getDeclaredMethod, therefore we need permission to access the member
No need to do a checkOldImpl() here, we know it's an up to date
If we're bound, the impl has been created
so we shouldn't get here
If we're bound, the impl has been created
so we shouldn't get here
Before 1.3 ServerSockets were always bound during creation
This can happen because of erasure.  The particular
exception is a historical artifact - an implementation
detail that leaked into the API.
Check compositeType is not null
item names defined in compositeType:
This is just a comparison, but we do it this way for a better
Check each value, if not null, is of the open type defined for the
Initialize internal fields: compositeType and contents
if obj is not a CompositeData, return false
their compositeType should be equal
All tests for equality were successful
private objects to cache the locale and resource bundle
memorize the most-recent locale
this line contains the composed text.
no selection, or it is invisible
The font changed, we need to recalculate the
---- View methods ----------------------------------------------------
If the lines are clipped then we don't expend the effort to
try and paint them.  Since all of the lines are the same height
with this object, determination of what lines need to be repainted
update the visible lines
This should never really happen, in so far as if
firstLineOffset is non 0, there should only be one
line of text.
determine span from the start of the line
fill in the results and return
PENDING(prinz) properly calculate bias
above the area covered by this icon, so the the position
is assumed to be the start of the coverage for this view.
below the area covered by this icon, so the the position
is assumed to be the end of the coverage for this view.
positioned within the coverage of this view vertically,
so we figure out which line the point corresponds to.
if the line is greater than the number of lines contained, then
simply use the last line as it represents the last possible place
we can position to.
point is to the left of the line
point is to the right of the line
Determine the offset into the text
should not happen
--- TabExpander methods ------------------------------------------
--- local methods ------------------------------------------------
lines were added or removed...
check to see if the line is longer than current
removed from longest line... recalc
--- member variables -----------------------------------------------
These attributes are extracted from the xsl:output element. They also
appear as fields (with the same type, only public) in Output.java
Initialize Translet version field to base value.  A class that extends
AbstractTranslet may override this value to a more recent translet
version; if it doesn't override the value (because it was compiled
before the notion of a translet version was introduced, it will get
this default value).
DOM/translet handshaking - the arrays are set by the compiled translet
The Templates object that is used to create this Translet instance
Boolean flag to indicate whether this translet has id functions.
TODO - these should only be instanciated when needed
This is the name of the index used for ID attributes
Parameter's stack: <tt>pbase</tt> and <tt>pframe</tt> are used
to denote the current parameter frame.
Local parameters need to be re-evaluated for each iteration
Only overwrite if current value is the default value and
the new value is _NOT_ the default value.
Add new parameter to parameter stack
Holds the translet's message handler - used for <xsl:message>.
The deault message handler dumps a string stdout, but anything can be
used, such as a dialog box for applets, etc.
Contains decimal number formatting symbols used by FormatNumberCall
Instanciate map for formatting symbols if needed
The name cannot be null - use empty string instead
Construct a DecimalFormat object containing the symbols we got
The name cannot be null - use empty string instead
If the input source is DOMSource, the KeyIndex table is not
built at this time. It will be built later by the lookupId()
and containsId() methods of the KeyIndex class.
Given a Map of DTM nodes indexed by ID attribute values,
loop through the table copying information to a KeyIndex
for the mapping from ID attribute value to DTM node
If the version of the translet had just one namesArray, split
it into multiple fields.
Distinguish attribute and element names.  Attribute has
Was translet compiled using a more recent version of the XSLTC
compiler than is known by the AbstractTranslet class?  If, so
and we've made it this far (which is doubtful), we should give up.
Container for all indexes for xsl:key elements
Return an empty key index iterator if none are defined
Look up the requested key index
Return an empty key index iterator if the requested index not found
Hold the DOM cache (if any) used with this translet
what can you do?
GTM added (see pg 110)
Listens to changes in the native setting for showing hidden files.
The Listener is removed and the native setting is ignored if
setFileHidingEnabled() is ever called.
Track native setting for showing hidden files
Prevent to show second instance of dialog if the previous one still exists
Remove all components from dialog. The MetalFileChooserUI.installUI() method (and other LAFs)
registers AWT listener for dialogs and produces memory leaks. It happens when
installUI invoked after the showDialog method.
PENDING(jeff) - fire button text change property
PENDING(jeff) - have ui set this on dialog type change
choose default filter if it is used
choose the first filter, because it is not removed
choose the second filter, because the first one is removed
no more filters
Dump showFilesListener since we'll ignore it from now on
NOTE: all of the following methods attempt to delegate
first to the client set fileView, and if <code>null</code> is returned
(or there is now client defined fileView) then calls the
UI's default fileView.
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Our JFileChooser is no longer around, so we no longer need to
listen for PropertyChangeEvents.
We were probably deserialized
The AcceptAllFileFilter is UI specific, it will be reset by
updateUI() after deserialization
The default FileSystemView is platform specific, it will be
reset by updateUI() after deserialization
inner class AccessibleJFileChooser
Nothing to do here, rowHeight still same, which is all
this is interested in, visible region may have changed though.
node hasn't been created yet.
YECK! Make the parent expanded.
And collapse the child.
PENDING(scott): make sure childIndexs is sorted!
Null for root indicates it changed.
PENDING(scott): make sure childIndexs is sorted!
PENDING(scott): make sure that changedIndexs are sorted in
Node has become a leaf, collapse it.
Check if root has changed, either to a null root, or
to an entirely new root.
Getting bounds for parent
No node dimensions, bail.
Make sure the last entry isn't a leaf.
Check all the parent paths, until a match is found.
Found a match, create entries for all paths in
If we get here it means they share a different root!
Overriden DefaultMutableTreeNode methods
PENDING: Make this a binary search!
This too could be a binary search!
This node has a created sibling, to calc total
child count directly from that!
Could check isVisible, but probably isn't worth it.
children following startIndex.
This can be rather expensive, but is needed for the collapse
case this is resulting from a remove (although I could fix
that by having instances of FHTreeStateNode hold a ref to
the number of children). I prefer this though, making determing
the row of a particular node fast is very nice!
This is the root, reset total ROWCOUNT!
Update the selection model.
We can do this because adjustRowBy won't descend
Adjust the rows.
Since matched and children are always sorted by
index, no need to continue testing with the
No children to adjust, but it was a child, so we still need
to adjust nodes after this one.
No children to adjust, but it was a child, so we still need
to adjust nodes after this one.
No node exists for it, and is first.
May have been in last child's bounds.
Between last child and child, but not in last child
Not in children, but we should have it, offset from
Between last child and child, but not in last child
This is very similar to
mark as invalid!
nextIndex == -1 identifies receiver, make sure is expanded
Check that it can have kids
Make sure next index not beyond child count.
we did add something
Can't use % here because it's not mod: -3 % 2 is -1, not +1.
Not previously established
Note that we're doing both setMark() -- which saves _currentChild
-- and explicitly saving our position counter (number of nodes
yielded so far).
%REVIEW% Should position also be saved by setMark()?
(It wasn't in the XSLTC version, but I don't understand why not.)
Count the nodes found by this iterator
Restore saved state
Note: This orb could be an instanceof ORBSingleton or ORB
Note: the size arg is only a hint of the size of the NVList.
SAX Attribute List Interface.
No warranty; no copyright -- use this as you will.
$Id: AttributeList.java,v 1.3 2004/11/03 22:44:51 jsuttor Exp $
end of AttributeList.java
--- Tag Names -----------------------------------
Force HTMLs static initialize to be loaded.
There is no unique instance of UnknownTag, so we allow it to be
The secret to 73, is that, given that the Hashtable contents
never change once the static initialization happens, the initial size
that the hashtable grew to was determined, and then that very size
This is used in cases where the value for the attribute has not
size determined similar to size of tagHashtable
Find the maximum bit depth across all channels
4450894: Ensure bitDepth is between 1 and 8
read and discard the repository ID
write the repository ID
no need to sync in the future
we don't want to generate any event for this so turn them off
extract local part from QName
Take special care of schema defaulted attributes. Calling the
non-namespace aware setAttributeNode() method could overwrite
another attribute with the same local name.
set mutation events flag back to its original value
Pre-1.4 support. 'events' was previously non-transient
1.4-compatible byte stream. 'events' was written explicitly
Implementation assumes 'events' is never null.
Constructor treats empty events list as invalid value
Throw exception if serialized list is empty
-- This file was mechanically generated: Do not edit! --
enforce limit == capacity
The following code was generated by CUP v0.10j
Fri Feb 27 13:01:50 PST 2004
NOP -> same representation
same internal representation, convert null to ""
Private fields -------------------------------------------->
Private fields <=============================================
Private methods --------------------------------------------->
If key property value pattern but not key property list
pattern, then the number of key properties must be equal
If key property value pattern or key property list pattern,
then every property inside pattern should exist in name
Find value in given object name for key at current
index in receiver
Did we find a value for this key ?
If this property is ok (same key, same value), go to next
wildmatch key property values
v is the string
If no pattern, then canonical names must be equal
if all couples (property, value) are contained
shouldn't come here...
No patterns inside reposit
Extract the domain name.
Default domain case
No domain containing registered object names
Private methods <=============================================
Protected methods --------------------------------------------->
Protected methods <=============================================
Public methods --------------------------------------------->
we use == domain later on...
Creates a new hashtable for the default domain
Skip domains that are in the table but have no
MBean registered in them
in particular the default domain may be like this
Make an array from result.
Extract the domain name.
Set domain to default if domain is empty and not already set
Do we have default domain ?
ES: OK (dom & domain are interned)
Validate name for an object
Domain cannot be JMImplementation if entry does not exist
If domain does not already exist, add it to the hash table
Add instance if not already present
Calls internal retrieve method to get the named object
The following filter cases are considered:
null, "", "*:*" : names in all domains
":*", ":[key=value],*" : names in defaultDomain
"domain:*", "domain:[key=value],*" : names in the specified domain
Surely one of the most frequent cases ... query on the whole world
If pattern is not a pattern, retrieve this mbean !
All names in all domains
All names in default domain
Pattern matching in the domain name (*, ?)
Extract domain name.
Default domain case
Find the domain subtable
Remove the corresponding element
We removed it !
No more object for this domain, we remove this domain hashtable
set a new default domain table (always present)
need to reinstantiate a hashtable because of possible
big buckets array size inside table, never cleared,
thus the new !
ES: OK dom and domain are interned.
Public methods <=============================================
-- This file was mechanically generated: Do not edit! --
For duplicates and slices
Check for null parameter
Check for non-Attribute objects
Build the List<Attribute>
will throw IllegalArgumentException
Throw an IllegalStateException if region falls between subsamples
Throw an IllegalStateException if region falls between subsamples
needed for recursive type codes
Constructed DynAnys maintain an ordered collection of component DynAnys.
set the current position to 0 if any has components, otherwise to -1.
assertion: typeCode has been checked to be valid for this particular subclass.
note: We don't copy TypeCodes since they are considered immutable.
set the current position to 0 if any has components, otherwise to -1.
_REVISIT_ Would need REPRESENTATION_TYPECODE for lazy initialization
No way to find out unless the TypeCode spec changes.
DynAny traversal methods
_REVISIT_ What about status?
If all we got is TypeCode representation (no value)
then we don't want to force creating a default value
Makes sure that the components representation is initialized
Makes sure that the Any representation is initialized
Collapses the whole DynAny hierarchys values into one single streamed Any
Not our implementation. Nothing we can do to prevent copying.
DynAny interface methods
Spec: Returns a copy of the internal Any
Anys value may still be uninitialized if DynAny was initialized by TypeCode only
This changes the current position of dyn_any.
Make sure that our position isn't changed.
Remember the current position to restore it later
System.out.println(this + " comparing component " + i + "=" + components[i] +
impossible, we checked the type codes already
Restore the current position of the other DynAny
getter / setter methods
List of properties where the name of the
property argument is to be looked for.
Needs to return the version number of the spec we conform to.
Use SecuritySupport class to provide priveleged access to property file
get a buffered version
and load up the property bag from this
close out after reading
try to find services in CLASSPATH
try to read from $java.home/lib/jaxws.properties
Use the system property
make sure that the current thread has an access to the package of the given name.
anyone can access the platform default factory class without permission
Use reflection to avoid having any dependendcy on ServiceLoader class
log and continue
Exclude this object from modality and
continue to pump it's events.
When a modal dialog is hidden its modal filter may not be deleted from
EventDispatchThread event filters immediately, so we need to mark the filter
as disabled to prevent it from working. Simple checking for visibility of
the modalDialog is not enough, as it can be hidden and then shown again
with a new event pump and a new filter
check if modalDialog is from anotherDialog's hierarchy
or vice versa
check if one dialog blocks (directly or indirectly) another
compare modality types
application- and toolkit-excluded windows are blocked by
document-modal dialogs from their child hierarchy
This should never happen
This should never happen
no way to signal EOF from available()
Methods that javax.management.StandardMBean should call from its
preRegister and postRegister, given that it is not supposed to
call the contained object's preRegister etc methods even if it has them
Undo any work from registration.  We do this in postDeregister
not preDeregister, because if the user preDeregister throws an
exception then the MBean is not unregistered.
OK: attribute is not included in returned list, per spec
XXX: log the exception
We can't use AttributeList.asList because it has side-effects
OK: attribute is not included in returned list, per spec
XXX: log the exception
Overridden by StandardMBeanSupport
TODO - document elimination of globalColorTableFlag
87a or 89a
1 to 8
Valid if globalColorTable != null
Valid if globalColorTable != null
Set global color table flag in header to 0 if null, 1 otherwise
Stored value plus one
NumChannels not in stream
Gamma not in format
backgroundColorIndex is valid iff there is a color table
NumProgressiveScans not in stream
BitRate not in format
HorizontalPixelSize not in format
VerticalPixelSize not in format
HorizontalPhysicalPixelSpacing not in format
VerticalPhysicalPixelSpacing not in format
HorizontalPosition not in format
VerticalPosition not in format
HorizontalPixelOffset not in stream
VerticalPixelOffset not in stream
SubimageInterpretation not in format
ImageCreationTime not in format
ImageModificationTime not in format
Not in stream
Not in stream
Note: This orb could be an instanceof ORBSingleton or ORB
Constants returned by acceptNode, borrowed from the DOM Traversal chapter
%REVIEW% Should we explicitly initialize them from, eg,
========= Random Access ==========
=========== Cloning operations. ============
'b' must be 0
'b' must be 0
If we implement equals() we must also implement hashCode
<h3>3.0 FilteredRowSet Internals</h3>
internalNext, Frist, Last. Discuss guidelines on how to approach this
and cite examples in reference implementations.
LexicalHandler.java - optional handler for lexical parse events.
Public Domain: no warranty.
$Id: LexicalHandler.java,v 1.2 2004/11/03 22:49:08 jsuttor Exp $
end of LexicalHandler.java
True if last slot nonempty
Try to attach new Cell
Recheck under lock
Slot is now non-empty
CAS already known to fail
Continue after rehash
At max size or stale
Expand table unless stale
Retry with expanded table
Fall back on using base
True if last slot nonempty
Try to attach new Cell
Recheck under lock
Slot is now non-empty
CAS already known to fail
Continue after rehash
At max size or stale
Expand table unless stale
Retry with expanded table
Fall back on using base
Last recorded value of Exchanger.bound
Number of CAS failures at current bound
Pseudo-random for spins
This thread's current item
Item provided by releasing thread
Set to this thread when parked, else null
access slot at i
j is raw array offset
clear for next use
approx 50% true
two yields per wait
releaser hasn't set match yet
try to shrink
preserve interrupt status so caller can recheck
create arena on contention, but continue until slot null
caller must reroute to arenaExchange
translate null args
disambiguates null return
ABASE absorbs padding in front of element 0
A DynAny is destroyable if it is the root of a DynAny hierarchy.
A DynAny is undestroyable if it is a node in a DynAny hierarchy other than the root.
A DynAny is destroyed if its root has been destroyed.
An Any is used internally to implement the basic DynAny.
It stores the DynAnys TypeCode.
For primitive types it is the only representation.
For complex types it is the streamed representation.
Destroyable is the default status for free standing DynAnys.
set the current position to 0 if any has components, otherwise to -1.
Uses getAny() if this is our implementation, otherwise uses to_any()
which copies the Any.
_REVISIT_ Nothing we can do about copying at this point
if this is not our implementation of DynAny.
To prevent this we would need another representation,
one where component DynAnys are initialized but not the component Anys.
This clears the data part of the Any while keeping the TypeCode info.
DynAny interface methods
Makes a copy of the Any value inside the parameter
Makes a copy of the Any parameter
If the passed Any does not contain a legal value
(such as a null string), the operation raises InvalidValue.
Needed for org.omg.CORBA.Object
Methods unique to this class
org.w3c.dom.NodeList API follows
Private implementation class pointed to by all public methods.
The hostname of the Socket Address
The IP address of the Socket Address
The port number of the Socket Address
private constructor for creating unresolved instances
Don't call defaultWriteObject()
Don't call defaultReadObject()
Check that our invariants are satisfied
Check coefficient c is a valid element in ECField field.
can only perform check if field is ECFieldFp or ECFieldF2m.
there is no point in asking a validation because
there is no guarantee that the document will come with
a proper schemaLocation.
we don't handle other types of Source
use the client specified XMLReader contained in the SAXSource.
copied from JAXP
check the nested exception to see if it's an UnmarshalException
typically this is an unexpected exception,
just throw it rather than wrap it, so that the full stack
trace can be displayed.
otherwise simply wrap it
Traverse the bitset until a used word is found
The new logical size
nbits can't be negative; size 0 is OK
Allocate larger of doubled size or required size
Case 1: One word
Case 2: Multiple words
Handle first word
Handle intermediate words, if any
Handle last word
Increase capacity if necessary
Case 1: One word
Case 2: Multiple words
Handle first word
Handle intermediate words, if any
Handle last word (restores invariants)
Case 1: One word
Case 2: Multiple words
Handle first word
Handle intermediate words, if any
Handle last word
If no set bits in range return empty bitset
Process all words but the last word
Process the last word
Set wordsInUse correctly
Neither spec nor implementation handle bitsets of maximal length.
Perform logical AND on words in common
Perform logical OR on words in common
Copy any remaining words
recalculateWordsInUse() is unnecessary
Perform logical XOR on words in common
Copy any remaining words
Perform logical (a & !b) on words in common
Check words in use by both BitSets
Assume maximum length then find real length
because recalculateWordsInUse assumes maintenance
or reduction in logical size
StAX Stream source
Main Work Starts Here.
remembers the nest level of elements to know when we are done.
skip over START_DOCUMENT
If not a START_ELEMENT (e.g., a DTD), skip to next tag
An error if a START_ELEMENT isn't found now
These are all of the events listed in the javadoc for
The spec only really describes 11 of them.
workaround for bugid 5046319 - switch over to commented section
below when it is fixed.
construct prefix:localName from qName
end namespace bindings
true for default namespace
start namespace bindings
true for default namespace
in SAX, namespace declarations are not part of attributes by default.
(there's a property to control that, but as far as we are concerned
we don't use it.) So don't add xmlns:* to attributes.
gather non-namespace attrs
namespace events don't normally occur outside of a startElement
attribute events don't normally occur outside of a startElement
it seems like we need to pass this info along, but how?
this event is listed in the javadoc, but not in the spec.
this event is listed in the javadoc, but not in the spec.
this event is listed in the javadoc, but not in the spec.
this event is listed in the javadoc, but not in the spec.
just in case stop is buggy and doesn't stop
JToolBar by default uses a somewhat modified BoxLayout as
its layout manager. For compatibility reasons, we want to
support Box "glue" as a way to move things around on the
toolbar. "glue" is represented in BoxLayout as a Box.Filler
with a minimum and preferred size of (0,0).
So what we do here is find the number of such glue fillers
and figure out how much space should be allocated to them.
Note: contentRect does not take insets into account
since it is used for determining the bounds that are
passed to paintToolBarContentBackground().
However, we do take the insets into account here for
the purposes of laying out the toolbar child components.
we need to get the minimum width for laying things out
so that we can calculate how much empty space needs to
be distributed among the "glue", if any
Fill available height
Center component vertically in the available space
if the component is a "glue" component then add to its
width the extraSpacePerGlue it is due
See notes above regarding the use of insets
we need to get the minimum height for laying things out
so that we can calculate how much empty space needs to
be distributed among the "glue", if any
Fill available width
Center component horizontally in the available space
if the component is a "glue" component then add to its
height the extraSpacePerGlue it is due
Stub class generated by rmic, do not edit.
Contents subject to change without notice.
Uses protected field.
W2K Feature: Check to see if the Underscore should be rendered.
hack for loading only built-in function classes.
runState is stored in the high-order bits
Packing and unpacking ctl
inhibit interrupts until runWorker
The value 0 represents the unlocked state.
The value 1 represents the locked state.
Eligible to terminate
else retry on failed CAS
Check if queue empty only if necessary.
else CAS failed due to workerCount change; retry inner loop
Recheck while holding lock.
Back out on ThreadFactory failure or if
shut down before lock acquired.
precheck that t is startable
If abrupt, then workerCount wasn't adjusted
replacement not needed
Did the last poll() time out?
Check if queue empty only if necessary.
Are workers subject to culling?
if not, ensure thread is not interrupted.  This
requires a recheck in second case to deal with
shutdownNow race while clearing interrupt
Public constructors and methods
hook for ScheduledThreadPoolExecutor
We don't really know how many new threads are "needed".
As a heuristic, prestart enough new workers (up to new
core size) to handle the current number of tasks in
queue, but stop if queue becomes empty while doing so.
In case SHUTDOWN and now empty
Take slow path if we encounter interference during traversal.
Make copy for traversal and call remove for cancelled entries.
The slow path is more likely to be O(N*N).
In case SHUTDOWN and now empty
Remove rare and surprising possibility of
isTerminated() && getPoolSize() > 0
Multiple of cubic & quad curve size
The source iterator
Square of the flatness parameter
for testing against squared lengths
Maximum number of recursion levels
The cache of interpolated coords
Note that this must be long enough
to store a full cubic segment and
a relative cubic segment to avoid
aliasing when copying the coords
of a curve to the end of the array.
This is also serendipitously equal
to the size of a full quad segment
and 2 relative quad segments.
The ending x,y of the last segment
The x,y of the last move segment
The type of the curve being held
The index of the last curve segment
being held for interpolation
The index of the curve segment
that was last interpolated.  This
is the curve segment ready to be
returned in the next call to
The recursion level at which
each curve being held in storage
The index of the entry in the
levels array of the curve segment
at the holdIndex
True when iteration is done
prime the first path segment
Move the coordinates to the end of the array.
Now that we have subdivided, we have constructed
two curves of one depth lower than the original
curve.  One of those curves is in the place of
the former curve and one of them is in the next
set of held coordinate slots.  We now set both
curves level values to the next higher level.
This curve segment is flat enough, or it is too deep
in recursion levels to try to flatten any more.  The
two coordinates at holdIndex+4 and holdIndex+5 now
contain the endpoint of the curve which can be the
endpoint of an approximating line segment.
Move the coordinates to the end of the array.
Now that we have subdivided, we have constructed
two curves of one depth lower than the original
curve.  One of those curves is in the place of
the former curve and one of them is in the next
set of held coordinate slots.  We now set both
curves level values to the next higher level.
This curve segment is flat enough, or it is too deep
in recursion levels to try to flatten any more.  The
two coordinates at holdIndex+6 and holdIndex+7 now
contain the endpoint of the curve which can be the
endpoint of an approximating line segment.
property identifier:  ValidationManager
recognized features and properties
updated during reset
the grammar pool
information regarding the current element
children list and offset stack
to check for duplicate ID or ANNOTATION attribute declare in
ATTLIST, and misc VCs
parser settings have not been changed
get needed components
get initial grammars
save standalone state
save root element state
find or create grammar:
give grammar pool a chance...
Do not bother checking the pool if no public or system identifier was provided.
Since so many different DTDs have roots in common, using only a root name as the
key may cause an unexpected grammar to be retrieved from the grammar pool. This scenario
would occur when an ExternalSubsetResolver has been queried and the
XMLInputSource returned contains an input stream but no external identifier.
This can never happen when the instance document specified a DOCTYPE. -- mrglavas
we'll have to create it...
we've found a cached one;so let's make sure not to read
any external subset!
REVISIT: [Q] Is there a more efficient way of doing this?
Perhaps if the scanner told us so we don't have to
look at the characters again. -Ac
call the ignoreableWhiteSpace callback
never call ignorableWhitespace if we are in cdata section
Do validation if all of the following are true:
1. The JAXP Schema Language property is not XML Schema
REVISIT: since only DTD and Schema are supported at this time,
such checking is sufficient. but if more schema types
are introduced in the future, we'll need to change it
to something like
(fSchemaType == null || fSchemaType == NS_XML_DTD)
2. One of the following is true (validation features)
2.1 Dynamic validation is off, and validation is on
2.2 Dynamic validation is on, and DOCTYPE was seen
3 Xerces schema validation feature is off, or DOCTYPE was seen.
REVISIT:we can convert into functions.. adding default attribute values.. and one validating.
is there anything to do?
Check after all specified attrs are scanned
(1) report error for REQUIRED attrs that are missing (V_TAGc)
(2) add default attrs (FIXED and NOT_FIXED)
add namespace information
get next att decl in the Grammar for this element
now iterate through the expanded attributes for
1. if every attribute seen is declared in the DTD
2. check if the VC: default_fixed holds
3. validate every attribute.
check VC: Standalone Document Declaration, entities
references appear in the document.
REVISIT: this can be combined to a single check in
startEntity if we add one more argument in
found the match att decl,
REVISIT - cache the elem/attr tuple so that we only
give this error once for each unique occurrence
attribute is declared
fTempAttDecl should have the right value set now, so
the following is not needed
check VC: Standalone Document Declaration
for all attributes
NOTE: Save this information because invalidStandaloneAttDef
Caveat - Save this information because invalidStandaloneAttDef
Caveat - Save this information because invalidStandaloneAttDef
REVISIT: This obviously needs to be fixed! -Ac
now the tricky part
check if the last appended character is a space.
Get the element name index from the element
Get out the content spec for this element
Deal with the possible types of content. We try to optimized here
by dealing specially with content models that don't require the
full DFA treatment.
If the child count is greater than zero, then this is
an error right off the bat at index 0.
This one is open game so we don't pass any judgement on it
at all. Its assumed to fine since it can hold anything.
Get the content model for this element, faulting it in if needed
this should never be reached in the case of DTD validation.
REVISIT: datatypeRegistry + initialization of datatype
why do we cast to ListDatatypeValidator?
should never happen
VC: Root Element Type
see if the root element's name matches the one in DoctypeDecl
REVISIT: Here are current assumptions about validation features
given that XMLSchema validator is in the pipeline
[1] XML instance document only has reference to a DTD
Outcome: report validation errors only against dtd.
[2] XML instance document has only XML Schema grammars:
Outcome: report validation errors only against schemas (no errors produced from DTD validator)
[3] XML instance document has DTD and XML schemas:
[a] if schema language is not set outcome - validation errors reported against both grammars: DTD and schemas.
[b] if schema language is set to XML Schema - do not report validation errors
if dynamic validation is on
validate only against grammar we've found (depending on settings
for schema feature)
resolve the element
changed here.. new function for getContentSpecType
0. insert default attributes
1. normalize the attributes
2. validate the attrivute list.
changed here.. also pass element name,
set element content state
increment the element depth, add this element's
QName to its enclosing element 's children list
push current length onto stack
add this element to children
save current element information
decrease element depth
now pop this element off the top of the element stack
TO DO : fix this
Check after document is fully parsed
(1) check that there was an element with a matching id for every
IDREF and IDREFS attr (V_IDREF0)
If Namespace enable then localName != rawName
NOTE: The binding of the element doesn't actually happen
yet because the namespace binder does that. However,
if it does it before this point, then the endPrefix-
Mapping calls get made too soon! As long as the
rawnames match, we know it'll have a good binding,
so we can just use the current element. -Ac
returns whether a character is space according to the
version of XML this validator supports.
-- This file was mechanically generated: Do not edit! --
these declarations are here as documentation
If you add or remove anything from here, make sure you
The following are all under consideration for potential future use.
public static final AccessibleRole APPLICATION
public static final AccessibleRole BORDER
public static final AccessibleRole CHECK_BOX_MENU_ITEM
public static final AccessibleRole CHOICE
public static final AccessibleRole COLUMN
public static final AccessibleRole CURSOR
public static final AccessibleRole DOCUMENT
public static final AccessibleRole IMAGE
public static final AccessibleRole INDICATOR
public static final AccessibleRole RADIO_BUTTON_MENU_ITEM
public static final AccessibleRole ROW
public static final AccessibleRole TABLE_CELL
public static final AccessibleRole TREE_NODE
does nothing at this time
for now, the identifier can only be (XMLConstants.FEATURE_SECURE_PROCESSING)
if the type is union it is possible that we receive
a character call with empty data
cleans up TypeInfoProvider
should only clear this if the last document contained unparsed entities
Fill element QName
there seems to be no corresponding method on XMLDocumentFilter.
just pass it down to the output, if any.
create one now
If this is a Xerces SAX parser, set the security manager if there is one
Ignore the exception if the security manager cannot be set.
this is impossible, but better safe than sorry
If XML names and Namespace URIs are already internalized we
can avoid running them through the SymbolTable.
The feature isn't recognized or getting it is not supported.
In either case, assume that strings are not internalized.
release the reference to user's handler ASAP
TODO: make sure if this is correct.
TODO: since the number of types in a schema is quite limited,
TypeInfoImpl should be pooled. Even better, it should be a part
of the element decl.
TODO: can t be null?
In the event that resolution failed against the
base URI, just return the system id as is. There's not
much else we can do.
Note: Comments containing the word "ASSERT" indicate places where a
throw of an InternalError should be replaced by an appropriate assertion
statement once asserts are enabled in the build.
-- Properties and components of this instance --
Components of all URIs: [<scheme>:]<scheme-specific-part>[#<fragment>]
null ==> relative URI
Hierarchical URI components: [<authority>]<path>[?<query>]
Registry or server
Server-based authority: [<userInfo>@]<host>[:<port>]
null ==> registry-based
-1 ==> undefined
Remaining components of hierarchical URIs
null ==> opaque
The remaining fields may be computed on demand
Zero ==> undefined
The only serializable field
-- Constructors and factories --
-- Operations --
We could be clever and cache the error message and index from the
exception thrown during the original parse, but that would require
either more fields or a more-obscure representation.
-- Component access methods --
-- Equality, comparison, hash code, toString, and serialization --
Opaque > hierarchical
Hierarchical < opaque
If one or both authorities are registry-based then we simply
compare them in the usual, case-sensitive way.  If one is
registry-based and one is server-based then the strings are
guaranteed to be unequal, hence the comparison will never return
zero and the compareTo and equals methods will remain
-- Serialization support --
Writes the string field only
-- End of public methods --
-- Utility methods for string-field comparison and hashing --
These methods return appropriate values for null string arguments,
thereby simplifying the equals, hashCode, and compareTo methods.
The case-ignoring methods should only be applied to strings whose
characters are all known to be US-ASCII.  Because of this restriction,
these methods are faster than the similar methods in the String class.
-- String construction --
If a scheme is given then the path, if given, must be absolute
authority should (but may not) contain an embedded IPv6 address
the authority contains an IPv6 address
-- Normalization, resolution, and relativization --
RFC2396 5.2 (6)
5.2 (6g): If the result is absolute but the path begins with "../",
then we simply leave the path as-is
check if child if opaque first so that NPE is thrown
if child is null.
5.2 (2): Reference to current document (lone fragment)
5.2 (3): Child is absolute
5.2 (4): Authority
5.2 (5): Child path is absolute
5.2 (6): Resolve relative path
5.2 (7): Recombine (nothing to do here)
o.w., return a new URI containing the normalized path.
If both URIs are hierarchical, their scheme and authority components are
identical, and the base path is a prefix of the child's path, then
return a relative URI that, when resolved against the base, yields the
child; otherwise, return the child.
check if child if opaque first so that NPE is thrown
if child is null.
-- Path normalization --
The following algorithm for path normalization avoids the creation of a
string object for each segment, as well as the use of a string buffer to
compute the final result, by using a single char array and editing it in
place.  The array is first split into segments, replacing each slash
with '\0' and creating a segment-index array, each element of which is
the index of the first char in the corresponding segment.  We then walk
through both arrays, removing ".", "..", and other segments as necessary
by setting their entries in the index array to -1.  Finally, the two
arrays are used to rejoin the segments and compute the final result.
This code is based upon src/solaris/native/java/io/canonicalize_md.c
Check the given path to see if it might need normalization.  A path
might need normalization if it contains duplicate slashes, a "."
segment, or a ".." segment.  Return -1 if no further normalization is
possible, otherwise return the number of segments found.
This method takes a string argument rather than a char array so that
this test can be performed without invoking path.toCharArray().
Number of segments
Index of last char in path
Index of next char in path
Skip initial slashes
Looking at "." or ".." ?
Find beginning of next segment
Skip redundant slashes
Split the given path into segments, replacing slashes with nulls and
filling in the given segment-index array.
segs.length == Number of segments in path
All slashes in path replaced by '\0'
segs[i] == Index of first char in segment i (0 <= i < segs.length)
Index of last char in path
Index of next char in path
Index of current segment
Skip initial slashes
Note start of segment
Find beginning of next segment
Skip redundant slashes
Join the segments in the given path according to the given segment-index
array, ignoring those segments whose index entries have been set to -1,
and inserting slashes as needed.  Return the length of the resulting
segs[i] == -1 implies segment i is to be ignored
path computed by split, as above, with '\0' having replaced '/'
path[0] .. path[return value] == Resulting path
Number of segments
Index of last char in path
Index of next path char to write
Restore initial slash for absolute paths
Ignore this segment
We're already at this segment, so just skip to its end
Preserve trailing slash
Copy q down to p
Preserve trailing slash
Remove "." segments from the given path, and remove segment pairs
consisting of a non-".." segment followed by a ".." segment.
Number of dots found (0, 1, or 2)
Find next occurrence of "." or ".."
Remove this occurrence of "."
If there is a preceding non-".." segment, remove both that
segment and this occurrence of ".."; otherwise, leave this
".." segment as-is.
DEVIATION: If the normalized path is relative, and if the first
segment could be parsed as a scheme name, then prepend a "." segment
The path is absolute
Index of first segment
The path is empty, or else the original first segment survived,
in which case we already know that no leading "." is needed
No colon in first segment, so no "." needed
At this point we know that the first segment is unused,
hence we can insert a "." segment at that position
Normalize the given path string.  A normal path string has no empty
segments (i.e., occurrences of ""), no segments equal to ".", and no
segments equal to ".." that are preceded by a segment not equal to "..".
In contrast to Unix-style pathname normalization, for URI paths we
always retain trailing slashes.
Does this path need normalization?
Number of segments
Nope -- just return it
Path in char-array form
Split path into segments
Prevent scheme-name confusion
Join the remaining segments and return the result
string was already normalized
-- Character classes for parsing --
RFC2396 precisely specifies which characters in the US-ASCII charset are
permissible in the various components of a URI reference.  We here
define a set of mask pairs to aid in enforcing these restrictions.  Each
mask pair consists of two longs, a low mask and a high mask.  Taken
together they represent a 128-bit mask, where bit i is set iff the
character with value i is permitted.
This approach is more efficient than sequentially searching arrays of
permitted characters.  It could be made still more efficient by
precompiling the mask information so that a character's presence in a
given mask could be determined by a single table lookup.
Compute the low-order mask for the characters in the given string
Compute the high-order mask for the characters in the given string
Compute a low-order mask for the characters
between first and last, inclusive
Compute a high-order mask for the characters
between first and last, inclusive
Tell whether the given character is permitted by the given mask pair
0 doesn't have a slot in the mask. So, it never matches.
Character-class masks, in reverse order from RFC2396 because
initializers for static fields cannot make forward references.
digit    = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" |
"8" | "9"
upalpha  = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" |
"J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" |
"S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z"
lowalpha = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" |
"j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" |
"s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"
alpha         = lowalpha | upalpha
alphanum      = alpha | digit
hex           = digit | "A" | "B" | "C" | "D" | "E" | "F" |
"a" | "b" | "c" | "d" | "e" | "f"
mark          = "-" | "_" | "." | "!" | "~" | "*" | "'" |
"(" | ")"
unreserved    = alphanum | mark
reserved      = ";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" |
"$" | "," | "[" | "]"
Added per RFC2732: "[", "]"
The zero'th bit is used to indicate that escape pairs and non-US-ASCII
characters are allowed; this is handled by the scanEscape method below.
uric          = reserved | unreserved | escaped
pchar         = unreserved | escaped |
":" | "@" | "&" | "=" | "+" | "$" | ","
All valid path characters
Dash, for use in domainlabel and toplabel
Dot, for use in hostnames
userinfo      = *( unreserved | escaped |
";" | ":" | "&" | "=" | "+" | "$" | "," )
reg_name      = 1*( unreserved | escaped | "$" | "," |
";" | ":" | "@" | "&" | "=" | "+" )
All valid characters for server-based authorities
Special case of server authority that represents an IPv6 address
In this case, a % does not signify an escape sequence
scheme        = alpha *( alpha | digit | "+" | "-" | "." )
uric_no_slash = unreserved | escaped | ";" | "?" | ":" | "@" |
"&" | "=" | "+" | "$" | ","
-- Escaping and encoding --
Quote any characters in s that are not permitted
by the given mask pair
Encodes all characters >= \u0080 into escaped, normalized UTF-8 octets,
assuming that s is otherwise legal
First check whether we actually need to encode
Evaluates all escapes in s, applying UTF-8 decoding if needed.  Assumes
that escapes are well-formed syntactically, i.e., of the form %XX.  If a
sequence of escaped octets is not valid UTF-8 then the erroneous octets
are replaced with '\uFFFD'.
Exception: any "%" found between "[]" is left alone. It is an IPv6 literal
with a scope_id
This is not horribly efficient, but it will do for now
-- Parsing --
For convenience we wrap the input URI string in a new instance of the
following internal class.  This saves always having to pass the input
string as an argument to each internal scan/parse method.
URI input string
-- Methods for throwing URISyntaxException in various ways --
-- Simple access to the input string --
Return a substring of the input string
Return the char at position p,
assuming that p < input.length()
Tells whether start < end and, if so, whether charAt(start) == c
Tells whether start + s.length() < end and, if so,
whether the chars at the start position match s exactly
-- Scanning --
The various scan and parse methods that follow use a uniform
convention of taking the current start position and end index as
their first two arguments.  The start is inclusive while the end is
exclusive, just as in the String class, i.e., a start/end pair
denotes the left-open interval [start, end) of the input string.
These methods never proceed past the end position.  They may return
-1 to indicate outright failure, but more often they simply return
the position of the first char after the last char scanned.  Thus
a typical idiom is
if (q > p)
We scanned something
else if (q == p)
We scanned nothing
else if (q == -1)
Something went wrong
Scan a specific char: If the char at the given start position is
equal to c, return the index of the next char; otherwise, return the
Scan forward from the given start position.  Stop at the first char
in the err string (in which case -1 is returned), or the first char
in the stop string (in which case the index of the preceding char is
returned), or the end of the input string (in which case the length
of the input string is returned).  May return the start position if
Scan a potential escape sequence, starting at the given position,
with the given first char (i.e., charAt(start) == c).
This method assumes that if escapes are allowed then visible
non-US-ASCII chars are also allowed.
Process escape pair
Allow unescaped but visible non-US-ASCII chars
Scan chars that match the given mask pair
Check that each of the chars in [start, end) matches the given mask
Check that the char at position p matches the given mask
-- Parsing --
Start of scheme-specific part
DEVIATION from RFC2396: We allow an empty authority component as
long as it's followed by a non-empty path, query component, or
fragment component.  This is so that URIs such as "file:/foo/bar"
will parse.  This seems to be the intent of RFC2396, though the
grammar does not permit it.  If the authority is empty then the
userInfo, host, and port components are undefined.
DEVIATION from RFC2396: We allow empty relative paths.  This seems
to be the intent of RFC2396, but the grammar does not permit it.
The primary consequence of this deviation is that "#f" parses as a
relative URI with an empty path.
DEVIATION: Allow empty authority prior to non-empty
path, query component or fragment identifier
DEVIATION: May be empty
authority     = server | reg_name
Ambiguity: An authority that is a registry name rather than a server
might have a prefix that parses as a server.  We use the fact that
the authority component is always followed by '/' or the end of the
input string to resolve this: If the complete authority did not
parse as a server then we try to parse it as a registry name.
contains a literal IPv6 address, therefore % is allowed
Must be a registry-based authority
Might be (probably is) a server-based authority, so attempt
to parse it as such.  If the attempt fails, try to treat it
as a registry-based authority.
Undo results of failed parse
If we're insisting upon a server-based authority,
then just re-throw the exception
Save the exception in case it doesn't parse as a
Re-throw exception; it was probably due to
a malformed IPv6 address
hostname, IPv4 address, or IPv6 address
DEVIATION from RFC2396: Support IPv6 addresses, per RFC2732
look for a "%" scope id
Scan a string of decimal digits whose value fits in a byte
Scan an IPv4 address.
If the strict argument is true then we require that the given
interval contain nothing besides an IPv4 address; if it is false
then we only require that it start with an IPv4 address.
If the interval does not contain or start with (depending upon the
strict argument) a legal IPv4 address characters then we return -1
immediately; otherwise we insist that these characters parse as a
legal IPv4 address and throw an exception on failure.
We assume that any string of decimal digits and dots must be an IPv4
address.  It won't parse as a hostname anyway, so making that
assumption here allows more meaningful exceptions to be thrown.
Per RFC2732: At most three digits per byte
Further constraint: Each element fits in a byte
Take an IPv4 address: Throw an exception if the given interval
contains anything except an IPv4 address
Attempt to parse an IPv4 address, returning -1 on failure but
allowing the given interval to contain [:<characters>] after
the IPv4 address.
IPv4 address is followed by something - check that
it's a ":" as this is the only valid character to
follow an address.
hostname      = domainlabel [ "." ] | 1*( domainlabel "." ) toplabel [ "." ]
domainlabel   = alphanum | alphanum *( alphanum | "-" ) alphanum
toplabel      = alpha | alpha *( alphanum | "-" ) alphanum
Start of last parsed label
domainlabel = alphanum [ *( alphanum | "-" ) alphanum ]
for a fully qualified hostname check that the rightmost
label starts with an alpha character.
IPv6 address parsing, from RFC2373: IPv6 Addressing Architecture
Bug: The grammar in RFC2373 Appendix B does not allow addresses of
the form ::12.34.56.78, which are clearly shown in the examples
earlier in the document.  Here is the original grammar:
IPv6address = hexpart [ ":" IPv4address ]
hexpart     = hexseq | hexseq "::" [ hexseq ] | "::" [ hexseq ]
hexseq      = hex4 *( ":" hex4)
hex4        = 1*4HEXDIG
We therefore use the following revised grammar:
IPv6address = hexseq [ ":" IPv4address ]
| hexseq [ "::" [ hexpost ] ]
| "::" [ hexpost ]
hexpost     = hexseq | hexseq ":" IPv4address | IPv4address
hexseq      = hex4 *( ":" hex4)
hex4        = 1*4HEXDIG
This covers all and only the following cases:
hexseq : IPv4address
hexseq :: hexseq
hexseq :: hexseq : IPv4address
hexseq :: IPv4address
:: hexseq : IPv4address
Additionally we constrain the IPv6 address as follows :-
i.  IPv6 addresses without compressed zeros should contain
exactly 16 bytes.
ii. IPv6 addresses with compressed zeros should contain
less than 16 bytes.
Scan a hex sequence; return -1 if one could not be scanned
Beginning of IPv4 address
Beginning of IPv4 address
Stateless intermediate ops from IntStream
We can do better that this too; optimize for depth=0 case and just grab spliterator and forEach it
Stateful intermediate ops from IntStream
While functional and quick to implement, this approach is not very efficient.
An efficient version requires an int-specific map/set implementation.
Terminal ops from IntStream
Optimized sequential terminal operations for the head of the pipeline
NAME is used while we still have a "port-exchange" ORBD
to get what used to be called "default" or "bootstrap" endpoints.
End of file.
Name of field/method
and its signature.
Ignored.  The data is either single frame and already in TDLR
format or it is multi-frame and TDLR resends aren't critical.
this closes the RandomAccessFile
Empty finalizer: for performance reasons we instead use the
Disposer mechanism for ensuring that the underlying
RandomAccessFile is closed prior to garbage collection
Use SourceLoader if available
No SourceLoader or not resolved by SourceLoader
Return if we could not resolve the URL
An included stylesheet gets the same import precedence
as the stylesheet that included it.
-- This file was mechanically generated: Do not edit! --
For duplicates and slices
-- This file was mechanically generated: Do not edit! --
enforce limit == capacity
--- Methods to support CharSequence ---
use serialVersionUID from JDK 1.2.2 for interoperability
$$kk: 08.30.99: is this backwards?
dataLine.matches(targetDataLine) == true: targetDataLine is always dataLine
targetDataLine.matches(dataLine) == false
so if i want to make sure i get a targetDataLine, i need:
targetDataLine.matches(prospective_match) == true
=> prospective_match may be other things as well, but it is at least a targetDataLine
targetDataLine defines the requirements which prospective_match must meet.
"if this Class object represents a declared class, this method returns
true if the specified Object argument is an instance of the represented
class (or of any of its subclasses)"
GainControlClass.isInstance(MyGainObj) => true
GainControlClass.isInstance(MySpecialGainInterfaceObj) => true
this_class.isInstance(that_object)       => that object can by cast to this class
=> that_object's class may be a subtype of this_class
=> that may be more specific (subtype) of this
"If this Class object represents an interface, this method returns true
if the class or any superclass of the specified Object argument implements
GainControlClass.isInstance(MyGainObj) => true
GainControlClass.isInstance(GenericControlObj) => may be false
=> that may be more specific
this.isAssignableFrom(that)  =>  this is same or super to that
=>      this is at least as general as that
=>      that may be subtype of this
SlotTablePool is the container for reusable SlotTables'
Contains a list of reusable SlotTable
High water mark for the pool
If the pool size reaches this limit then putSlotTable will
not put SlotTable to the pool.
currentIndex points to the last SlotTable in the list
If there are enough SlotTables in the pool, then don't add
this table to the pool.
Let the garbage collector collect it.
If there are no entries in the pool then return null
Works like a stack, Gets the last one added first
Contains all the active SlotTables for each thread.
The List is made to behave like a stack.
Keeps track of number of PICurrents in the stack.
For Every Thread there will be a pool of re-usable SlotTables'
stored in SlotTablePool
The ORB associated with this slot table stack
SlotTableStack will be created with one SlotTable on the stack.
This table is used as the reference to query for number of
allocated slots to create other slottables.
get an existing PICurrent to get the slotSize
NOTE: Very important not to always "add" - otherwise a memory leak.
Add will cause the table to grow.
Set will override unused slots.
Do not pop the SlotTable, If there is only one.
This should not happen, But an extra check for safety.
Do not leak memory.
End of file.
We can move this out somewhere later.  For now, it serves its purpose
to create a concrete CDR delegate based on the GIOP version.
else fall through and report exception.
Required for the case when a ClientResponseImpl is
created with a SystemException due to a dead server/closed
connection with no warning.  Note that the stream will
not be initialized in this case.
Probably also required by ServerRequestImpl.
Needed by TCUtility
This should be overridden by any stream (ex: IIOPInputStream)
which wants to read values.  Thus, TypeCodeInputStream doesn't
have to do this.
Use Latin-1 for GIOP 1.0 or when code set negotiation was not
Subclasses must decide what to do here.  It's inconvenient to
make the class and this method abstract because of dup().
Prints the current buffer in a human readable form
Needed by request and reply messages for GIOP versions >= 1.2 only.
In the case of SystemExceptions, a stream is created
with its default constructor (and thus no impl is set).
End of file.
Wrap the border to avoid having the UIResource be replaced by
the ButtonUI. This is the opposite of using BorderUIResource.
if editor alignment isn't set in LAF, we get 0 (CENTER) here
Most likely resulting from being in ActionMap.
The arrowButtonInsets value is used instead of the JSpinner's
insets if not null. Defining this to be (0, 0, 0, 0) causes the
buttons to be aligned with the outer edge of the spinner's
border, and leaving it as "null" places the buttons completely
inside the spinner's border.
Syncronizes the ToolTip text for the components within the spinner
to be the same value as the spinner ToolTip text.
Use setValues so that a consistent policy relating
minimum, maximum, visible amount, and value is enforced.
No checks are necessary in this method since minimum is
the first variable checked in the setValues function.
Use setValues so that a consistent policy relating
minimum, maximum, visible amount, and value is enforced.
minimum is checked first in setValues, so we need to
enforce minimum and maximum checks here.
Use setValues so that a consistent policy relating
minimum, maximum, visible amount, and value is enforced.
Use setValues so that a consistent policy relating
minimum, maximum, visible amount, and value is enforced.
REMIND: remove when filtering is done at lower level
skip value for unrecognized key
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of SpinnerPreviousButtonPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of SpinnerPreviousButtonPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
Will be set from the outside
byte code offset of instruction
Overridden in BranchHandle
List of reusable handles
The Scheme Name i.e element
The scheme Data
The scheme Data & child sequence
Should we attempt to resolve the ChildSequence from the
current element position. If a ShortHand Pointer is present
attempt to resolve relative to the short hand pointer.
Has the element been found
Was only an empty element found
If a shorthand pointer is present and resolved
The depth at which the element was found
The XPointer element child sequence
The current child position
The current child depth
The current element's child sequence
Stores if the Fragment was resolved by the pointer
Stores if the Fragment was resolved by the pointer
The XPointer Error reporter
The XPointer Error Handler
scan the element() XPointer expression
Initialize a temp arrays to the size of token count which should
be atleast twice the size of child sequence, to hold the ChildSequence.
the element depth
Traverse the scanned tokens
Note:  Only a single ShortHand pointer can be present
The shortHand name
Create a new ShortHandPointer
Initialize the arrays to the number of elements in the ChildSequence.
if a ChildSequence exisits, resolve child elements
if an element name exists
resolve ShortHand Pointer
Added here to skip the ShortHand pointer corresponding to
an element if one exisits and start searching from its child
if only a resolved shorthand pointer exists
need to resize fCurrentChildSequence
Increase the size by a factor of 2 (?)
reset the current child position
or empty element found
reset array position of last child
Donot check for empty elements if the empty element is
a child of a found parent element
If the number of elements in the ChildSequence is greater than the
current child depth, there is not point in checking further
If a shorthand pointer is not present traverse the children
If a shorthand pointer is present traverse the children
ignoring the first element of the CurrenChildSequence which
contains the ShortHand pointer element and compare
ensure fCurrentChildSequence is large enough
ignore the first element of fCurrentChildSequence
Return true if the Fragment was resolved and the current Node depth
is greater than or equal to the depth at which the element was found
if only a shorthand pointer was present
element() Scheme expression scanner
Current token position
invalid XML characters, control characters and 7F
A valid XML character (possibly invalid NCNameChar) that does not fall in one of the other categories
'0'-'9' (0x30 to 0x39)
'A'-'Z' or 'a'-'z' (0x41 to 0x5A and 0x61 to 0x7A)
Non-ASCII Unicode codepoint (>= 0x80)
save pool and tokens
[1]    ElementSchemeData    ::=    (NCName ChildSequence?) | ChildSequence
[2]    ChildSequence    ::=    ('/' [1-9] [0-9]*)+
if last character is '/', break and report an error
ChildSequence    ::=    ('/' [1-9] [0-9]*)+
An invalid child sequence character
Scan the ShortHand Pointer NCName
Check that the src datatype is either a BYTE or SHORT
Check dst sample sizes. All must be 8 or 16 bits.
Check src sample sizes. All must be the same size
Try to use a native BI rescale operation first
Native BI rescale failed - convert to rasters
Call the raster filter method
ColorModels are not the same
Create a new destination Raster, if needed
Make sure that the number of bands are equal
Make sure that the arrays match
Make sure that the low/high/constant arrays match
Try for a native raster rescale first
Native raster rescale failed.
Try to see if a lookup operation can be used
Fall back to the slow code
Determine bits per band to determine maxval for clamps.
The min is assumed to be zero.
REMIND: This must change if we ever support signed data types.
Get data for all bands at this x,y position
Put it back for all bands
recognized features and properties
add new namespace context
search for new namespace bindings
when it's of form xmlns="..." or xmlns:prefix="...",
it's a namespace declaration. but prefix:xmlns="..." isn't.
get the internalized value of this attribute
1. "xmlns" can't be bound to any namespace
2. the namespace for "xmlns" can't be bound to any prefix
3. "xml" can't be bound to any other namespace than it's own
4. the namespace for "xml" can't be bound to any other prefix
We should only report an error if there is a prefix,
that is, the local part is not "xmlns". -SG
Since this is an error condition in XML 1.0,
and should be relatively uncommon in XML 1.1,
making this test into a method call to reuse code
should be acceptable.  - NG
declare prefix in context
bind the element
bind the attributes
verify that duplicate attributes don't exist
Example: <foo xmlns:a='NS' xmlns:b='NS' a:attr='v1' b:attr='v2'/>
returns true iff the given prefix is bound to "" *and*
this is disallowed by the version of XML namespaces in use.
prefixBoundToNullURI(String, String):  boolean
Flags for checkOccurrences to indicate any special
restrictions on minOccurs and maxOccurs relating to "all".
NOT_ALL_CONTEXT    - not processing an <all>
PROCESSING_ALL_EL  - processing an <element> in an <all>
GROUP_REF_WITH_ALL - processing <group> reference that contained <all>
CHILD_OF_GROUP     - processing a child of a model group definition
PROCESSING_ALL_GP  - processing an <all> group itself
used to validate default/fixed attribute values
traverse the annotation declaration
REVISIT: how to pass the parentAttrs? as DOM attributes?
as name/value pairs (string)? in parsed form?
General Attribute Checking
the only valid children of "annotation" are
"appinfo" and "documentation"
General Attribute Checking
There is no difference between global or local appinfo/documentation,
so we assume it's always global.
nothing to contribute to PSVI
find the grammar; fSchemaHandler must be known!
fish out local attributes passed from parent
optimize for case where there are no local attributes
Vector should contain rawname value pairs
skip the next value, too
search for pesky "s and <s within attr value:
and now splice it into place; immediately after the annotation token, for simplicity's sake
annotation must occur somewhere or we're in big trouble...
find the grammar; fSchemaHandler must be known!
fish out local attributes passed from parent
optimize for case where there are no local attributes
Vector should contain rawname value pairs
search for pesky "s and <s within attr value:
and now splice it into place; immediately after the annotation token, for simplicity's sake
annotation must occur somewhere or we're in big trouble...
the QName simple type used to resolve qnames
Temp data structures to be re-used in traversing facets
facets that have fixed="true"
General Attribute Checking
The facet can't be used if the value is missing. Ignore
this facet element.
for NOTATION types, need to check whether there is a notation
declared with the same name as the enumeration value.
need to use the namespace context returned from checkAttributes
try to get the notation decl. if failed, getGlobalDecl
reports an error, so we don't need to report one again.
Either the QName value is invalid, or it doens't
resolve to a notation declaration.
Ignore this facet, to avoid instance validation problems
restore to the normal namespace context
traverse annotation if any
The facet can't be used if the value is missing. Ignore
this facet element.
datatypes: 5.2.4 pattern: src-multiple-pattern
traverse annotation if any
check for duplicate facets
Ignore this facet, to avoid corrupting the previous facet
The facet can't be used if the value is missing. Ignore
this facet element.
Report an error if the "value" attribute is missing.
If it's not missing, then its value is invalid, and an
error should have already been reported by the
check for fixed facet
traverse annotation if any
return whether QName/NOTATION is part of the given type
Traverse a set of attribute and attribute group elements
Needed by complexType and attributeGroup traversal
This method will return the first non-attribute/attrgrp found
REVISIT: do we need to save some state at this point??
perform intersection of attribute wildcard
perform intersection of attribute wildcard
Checks constraints for minOccurs, maxOccurs
Neither minOccurs nor maxOccurs may be specified
for the child of a model group definition.
If minOccurs=maxOccurs=0, no component is specified
For the elements referenced in an <all>, minOccurs attribute
must be zero or one, and maxOccurs attribute must be one.
For a complex type definition that contains an <all> or a
reference a <group> whose model group is an all model group,
minOccurs and maxOccurs must be one.
normally, nothing will happen
this is not terribly performant!
Must escape 0x09, 0x0A and 0x0D if they appear in attribute
value so that they may be round-tripped. They would otherwise
be transformed to a 0x20 during attribute value normalization.
Template for building up constant pool
ArrayLists instead of arrays to gather fields, methods, etc.
Put everything needed by default into the constant pool and the vectors
Must be last since the above calls may still add something to it
-- ServerSocket-specific operations --
Type-specific CORBA::Object operations
Only used in ServerManagerImpl.
Only used by POAPolicyMediatorBase.
this server is activated by orbd
this is a user-activated server
Only used by PI IORInfoImpl.
Used in RepositoryImpl, ServerManagerImpl, POAImpl,
To get either default or bootnaming endpoint.
Check to see if the given port is equal to any of the ORB Server Ports.
XXX Does this need to change for the multi-homed case?
Used in IIOPProfileImpl, ORBImpl.
End of file.
The instances of SystemColor are tightly controlled and
only the canonical instances appearing above as static
constants are allowed.  The serial form of SystemColor
objects stores the color index as the value.  Here we
map that index back into the canonical instance.
we put an array index in the SystemColor.value while serialize
to keep compatibility.
-- This file was mechanically generated: Do not edit! --
Used for baseline calculations
Bad Scott, Bad Scott!
If prefBaseline < 0, then no baseline, assume preferred
If prefBaseline == baseline, then specified baseline
matches preferred baseline, return preferred height
Component baseline and specified baseline will NEVER
match, fall through to default
No way to map from baseline to height.
The applyDefaults() method automatically adds width and
height springs that delegate their calculations to the
getMinimumSize(), getPreferredSize() and getMaximumSize()
methods of the relevant component. In the case of the
parent this will cause an infinite loop since these
methods, in turn, delegate their calculations to the
layout manager. Check for this case and replace the
the springs that would cause this problem with a
constant springs that supply default values.
End of LayoutManger2 methods
At this point there must be exactly one constraint defined already.
Check width/height first.
If width/height is already defined, install a default for x/y.
Either way, leave the user's constraint topmost on the stack.
The interning here is unnecessary; it was added for efficiency.
read and discard the repository ID
write the repository ID
Copyright (c) 1995-96 by Cisco Systems, Inc.
SNMPv1 values for generic trap info in Trap-PDU.
PDU error status enumeration.
API error status enumeration.
a list of PatternEntries
This is really used as a local variable inside fixEntry, but we cache
it here to avoid newing it up every time the method is called.
When building a MergeCollation, we need to do lots of searches to see
whether a given entry is already in the table.  Since we're using an
array, this would make the algorithm O(N*N).  To speed things up, we
use this bit array to remember whether the array contains any entries
starting with each Unicode character.  If not, we can avoid the search.
Using BitSet would make this easier, but it's significantly slower.
check to see whether the new entry has the same characters as the previous
entry did (this can happen when a pattern declaring a difference between two
strings that are canonically equivalent is normalized).  If so, and the strength
is anything other than IDENTICAL or RESET, throw an exception (you can't
declare a string to be unequal to itself).       --rtg 5/24/99
otherwise, just skip this entry and behave as though you never saw it
We're going to add an element that starts with this
character, so go ahead and set its bit.
most likely entry is last one
Stateless intermediate ops from LongStream
We can do better that this too; optimize for depth=0 case and just grab spliterator and forEach it
Stateful intermediate ops from LongStream
While functional and quick to implement, this approach is not very efficient.
An efficient version requires a long-specific map/set implementation.
Terminal ops from LongStream
use better algorithm to compensate for intermediate overflow?
Optimized sequential terminal operations for the head of the pipeline
Make no net change to g
outer border, top
outer border, left
inner border, top
inner border, left
outer border, bottom
outer border, right
inner border, right
inner border, bottom
Make no net change to g
Make no net change to g
draw upper and lower horizontal dashes
draw left and right vertical dashes
If there are Params in the stylesheet or WithParams in this call?
Build the parameter list if the called template is simple named
This is only needed when the called template is not
a simple named template.
Push parameter frame
Generate a valid Java method name
Load standard arguments
Initialize prefix of method signature
If calling a simply named template, push actual arguments
append Object to signature
Push 'null' if Param to indicate no actual parameter specified
Complete signature and generate invokevirtual call
release temporary result trees
Do not need to call Translet.popParamFrame() if we are
calling a simple named template.
Pop parameter frame
Put the parameters from the called template into the array first.
This is to ensure the order of the parameters.
Replace a Param with a WithParam if they have the same name.
Ignore if not WithParam
Search for a Param with the same name
Skips a white space.
Skips chracters between '#' and a line end.
Strips an escaped white space.
Other escaped character.
Type-specific CORBA::Object operations
-- This file was mechanically generated: Do not edit! --
these declarations are here as documentation
serial counter useful for debugging
Any time currentThreadCount and/or availableWorkerThreads is updated
or accessed this ThreadPool's WorkQueue must be locked. And, it is
expected that this ThreadPool's WorkQueue is the only object that
updates and accesses these values directly and indirectly though a
call to a method in this ThreadPool. If any call to update or access
those values must synchronized on this ThreadPool's WorkQueue.
Stores the number of available worker threads
Stores the number of threads in the threadpool currently
Minimum number of worker threads created at instantiation of the threadpool
Maximum number of worker threads in the threadpool
Inactivity timeout value for worker threads to exit and stop running
Indicates if the threadpool is bounded or unbounded
Running count of the work items processed
Set the value to 1 so that divide by zero is avoided in
Running aggregate of the time taken in millis to execute work items
processed by the threads in the threadpool
Name of the ThreadPool
MonitoredObject for ThreadPool
ThreadGroup in which threads should be created
Note that this method should not return until AFTER all threads have died.
Copy to avoid concurrent modification problems.
Setup monitoring for this threadpool
Get root monitored object
Create the threadpool monitoring root
Add the monitored object for the WorkQueue
Package private method to get the monitored object for this
Thread creation needs to be in a doPrivileged block
if there is a non-null security manager for two reasons:
1. The creation of a thread in a specific ThreadGroup
is a privileged operation.  Lack of a doPrivileged
block here causes an AccessControlException
(see bug 6268145).
2. We want to make sure that the permissions associated
with this thread do NOT include the permissions of
the current thread that is calling this method.
This leads to problems in the app server where
some threads in the ThreadPool randomly get
bad permissions, leading to unpredictable
permission errors (see bug 6021011).
A Java thread contains a stack of call frames,
one for each method called that has not yet returned.
Each method comes from a particular class.  The class
was loaded by a ClassLoader which has an associated
CodeSource, and this determines the Permissions
for all methods in that class.  The current
Permissions for the thread are the intersection of
all Permissions for the methods on the stack.
This is part of the Security Context of the thread.
When a thread creates a new thread, the new thread
inherits the security context of the old thread.
This is bad in a ThreadPool, because different
creators of threads may have different security contexts.
This leads to occasional unpredictable errors when
a thread is re-used in a different security context.
Avoiding this problem is simple: just do the thread
creation in a doPrivileged block.  This sets the
inherited security context to that of the code source
for the ORB code itself, which contains all permissions
in either Java SE or Java EE.
The thread must be set to a daemon thread so the
VM can exit if the only threads left are PooledThreads
or other daemons.  We don't want to rely on the
calling thread always being a daemon.
Note that no exception is possible here since we
are inside the doPrivileged block.
If we get here, we need to create a thread.
Decrementing the count of current worker threads.
But, it will be increased in the finally block.
unique id for the thread
name seen by Thread.getName()
set currentWork to null so that the work item can be
garbage collected without waiting for the next work item.
This should not be possible
End of WorkerThread class
End of file.
where keywords go while we
read their parameters
for the \'xx construct
in a \bin blob?
value for the 'state' variable
reading random text
read a backslash, waiting for next
reading a multicharacter token
reading a token's parameter
after reading \'
after reading \'x
in a \bin blob
table of non-text characters in rtf
TODO: Handle wrapup at end of file correctly.
unadorned newlines are ignored
Non-space delimiters get included in the text
Delimiters here are interpreted as text too
Type strings for this class and its superclases
DSI Dispatch call
XXX This should be in the SPI
InvocationInfo must be pushed before calling getInvocationServant
This is an error since no user of this implementation
should ever throw this exception
End of File
Ok, formal parameter
Parameterized or method
List of parameters
-- This file was mechanically generated: Do not edit! --
The class calling the meta-factory via invokedynamic "class X"
The type of the invoked method "(CC)II"
The type of the returned instance "interface JJ"
Name of the SAM method "foo"
Type of the SAM method "(Object)Object"
Raw method handle for the implementation method
Info about the implementation method handle "MethodHandleInfo[5 CC.impl(int)String]"
Invocation kind for implementation "5"=invokevirtual
Is the implementation an instance method "true"
Type defining the implementation "class CC"
Type of the implementation method "(int)String"
Instantiated erased functional interface method type "(Integer)Object"
Should the returned instance be serializable
Additional marker interfaces to be implemented
Signatures of additional methods to bridge
Check arity: optional-receiver + captured + SAM == impl
If instance: first captured arg (receiver) must be subtype of class where impl method is defined
implementation is an instance method, adjust for receiver in captured variables / SAM arguments
receiver is function parameter
receiver is a captured variable
check receiver type
Check for exact match on non-receiver captured arguments
Check for adaptation match on SAM arguments
Adaptation match: return type
both are primitive: widening
from primitive to reference: boxing
from reference to primitive: unboxing
fromType is a primitive wrapper; unbox+widen
must be convertible to primitive
both are reference types: fromType should be a superclass of toType.
Type-specific CORBA::Object operations
un-premultiply the components (by modifying mult here, we
are effectively doing the divide by mult and divide by
alpha in the same step)
getRGB() always returns non-premultiplied components
premultiply the components if necessary
PENDING(prinz) need to add support for some of the other
elements, but for now just ignore anything that is not
fall through to one column
fall through to one row
Default cell spacing equals 2
determine which views are table rows and clear out
grid points marked filled.
advance to a free column
fill in the overflow entries for this cell
setup the column layout/requirements
clean offsets and spans
pass 1 - single column cells
advance to a free column
pass 2 - multi-column cells
advance to a free column
calculate the totals
check if the minimum size needs adjustment.
apply the adjustments
check if the preferred size needs adjustment.
apply the adjustments
--- BoxView methods -----------------------------------------
calculate column requirements for each column
the requirements are the sum of the columns.
The user has requested a smaller size than is needed to
show the table, override it.
set the alignment
set horizontal alignment
make grid is properly represented
all of the row layouts are invalid, so mark them that way
calculate column spans
continue normal layout
place the caption
it's in this view.
--- View methods ---------------------------------------------
paint the border
adjust the border for the caption
A change in any of the table cells usually effects the whole table,
so redraw it all!
--- ViewFactory methods ------------------------------------------
default is to delegate to the normal factory
---- variables ----------------------------------------------------
whether to display comments inside table or not.
advance to a free column
add a percentage requirement
--- RequirementIterator methods -------------------
do not care for percentages, since min span can't
be less than columnRequirements[col].minimum,
but can be less than percentage value.
adjust requirements of multi-row cells
rows are missing (could be a bad rowspan specification)
or not all the rows have arrived.  Do the best we can with
the current set of rows.
--- RequirementIterator methods -------------------
The major axis requirements for a row are dictated by the column
requirements. These methods use the value calculated by
advance to a free column
Because the table may be only partially formed, some
of the columns may not yet exist.  Therefore we check
advance to a free column
it's in this view.
PENDING(prinz) change to use the css alignment.
for the cell the minimum should be derived from the child views
the parent behaviour is to use CSS for that
BEGIN: Keys needed for exception messages of  JAXP 1.3 XPath API implementation
END: Keys needed for exception messages of  JAXP 1.3 XPath API implementation
Note to translators:  A relative location path is a form of XPath expression.
The message indicates that such an expression was expected following the
characters '/' or '', but was not found.
Note to translators:  A location path is a form of XPath expression.
The message indicates that syntactically such an expression was expected,but
the characters specified by the substitution text were encountered instead.
Note to translators:  A location path is a form of XPath expression.
The message indicates that syntactically such a subexpression was expected,
but no more characters were found in the expression.
Note to translators:  A location step is part of an XPath expression.
The message indicates that syntactically such an expression was expected
following the specified characters.
Note to translators:  A node test is part of an XPath expression that is
used to test for particular kinds of nodes.  In this case, a node test that
consists of an NCName followed by a colon and an asterisk or that consists
of a QName was expected, but was not found.
Note to translators:  A step pattern is part of an XPath expression.
The message indicates that syntactically such an expression was expected,
but the specified character was found in the expression instead.
Note to translators: A relative path pattern is part of an XPath expression.
The message indicates that syntactically such an expression was expected,
but was not found.
Note to translators:  The substitution text is the name of a data type.  The
message indicates that a value of a particular type could not be converted
to a value of type boolean.
Note to translators: Do not translate ANY_UNORDERED_NODE_TYPE and
Note to translators: Do not translate UNORDERED_NODE_SNAPSHOT_TYPE and
Note to translators: This message indicates that the document being operated
upon changed, so the iterator object that was being used to traverse the
document has now become invalid.
Note to translators:  The substitution text is the name of a data type.  The
message indicates that a value of a particular type could not be converted
to a value of type string.
Note to translators: Do not translate snapshotItem,
UNORDERED_NODE_SNAPSHOT_TYPE and ORDERED_NODE_SNAPSHOT_TYPE.
Note to translators:  XPathEvaluator is a Java interface name.  An
XPathEvaluator is created with respect to a particular XML document, and in
this case the expression represented by this object was being evaluated with
respect to a context node from a different document.
Note to translators:  The XPath expression cannot be evaluated with respect
to this type of node.
BEGIN:  Definitions of error keys used  in exception messages of  JAXP 1.3 XPath API implementation
END:  Definitions of error keys used  in exception messages of  JAXP 1.3 XPath API implementation
Other miscellaneous text used inside the code...
================= INFRASTRUCTURE ======================
UnixSystem to retrieve underlying system info
the authentication status
Underlying system info
initialize any configured options
Clean out state
overall authentication succeeded and commit succeeded,
but someone else's commit failed
remove the added Principals from the Subject
clean out state
The order of EUROPEAN to MOGOLIAN must be consistent
with the bitmask-based constants.
The order of EUROPEAN to MOGOLIAN must be consistent
with the bitmask-based constants.
base character of range digits
TAMIL DIGIT ZERO was added in Unicode 4.1
EXTENDED ARABIC-INDIC (EASTERN_ARABIC)
TAMIL - zero was added in Unicode 4.1
ETHIOPIC - no zero
some ranges adjoin or overlap, rethink if we want to do a binary search on this
'EUROPEAN' (really latin-1 and extended)
EASTERN_ARABIC -- note overlap with arabic
ETHIOPIC - note missing zero
assume most characters are near each other so probing the cache is infrequent,
and a linear probe is ok.
warning, synchronize access to this as it modifies state
if we're not in a known range, then return EUROPEAN as the range key
cache for the NumericShaper.Range version
use a binary search with a cache
throws NPE if ranges is null.
Give precedance to EASTERN_ARABIC if both ARABIC and
EASTERN_ARABIC are specified.
As well as the above case, give precedance to TAI_THAM_THAM if both
TAI_THAM_HORA and TAI_THAM_THAM are specified.
sort rangeArray for binary search
Ethiopic doesn't use decimal zero
if we don't support this context, then don't shape
Ethiopic doesn't use decimal zero
Ethiopic doesn't use decimal zero
if we don't support the specified context, then don't shape.
Use the CONTEXTUAL_MASK bit only for the enum-based
NumericShaper. A deserialized NumericShaper might have
taken from the project-X parser
IANA also defines two that JDK 1.2 doesn't handle:
EBCDIC-CP-GR        --> CP423
EBCDIC-CP-TR        --> CP905
try known alias
recognize and handle four pre-defined properties.
recognize and handle four pre-defined properties.
Parse 'name' and 'select' attributes plus parameter contents
Add a ref to this param to its enclosing construct
Mark this as a global parameter
Check if a global variable with this name already exists...
...and if it does we need to check import precedence
It is an error if the two have the same import precedence
Ignore this if previous definition has higher precedence
Add this variable if we have higher precedence
This element has no type (the parameter does, but the parameter
element itself does not).
Call addParameter() from this class
nobody uses the value
Cache the result of addParameter() in a local variable
Call addParameter() from this class
Cache the result of addParameter() in a field
override for Javadoc
override for Javadoc and performance
inline TemporalAccessor.super.query(query) as an optimization
For very small negative numerators, the answer might
be such a tiny bit less than den that the difference
is smaller than the mantissa of a double allows and
the result would then be rounded to den.  If that is
the case then we map that number to 0 as the nearest
If h==1, we will probably get lots of "scanline" rects
If we are going to cache this Raster, make it non-tiny
If we are going to cache this Raster, make it non-tiny
If we are going to cache this Raster, make it non-tiny
xmul/ymul are 31 bits wide, (0 => 2^31-1)
shift them to 12 bits wide, (0 => 2^12-1)
The complement of the [xy]mul values (1-[xy]mul) can result
in new values in the range (1 => 2^12).  Thus for any given
loop iteration, the values could be anywhere in (0 => 2^12).
xmul and ymul are each 12 bits (0 => 2^12)
factor is thus 24 bits (0 => 2^24)
accum variables will accumulate 32 bits
bytes extracted from rgb fit in 8 bits (0 => 255)
byte * factor thus fits in 32 bits (0 => 255 * 2^24)
Note that we do not pass srcRas to makeRaster since it
is a Byte Raster and this colorModel needs an Int Raster
Make sure the user didn't lie
%REVIEW% Is there a better way to send a warning?
Create the basic SAX2DTM.
Go ahead and add the DTM to the lookup table.  This needs to be
done before any parsing occurs. Note offset 0, since we've just
created a new DTM.
Then the user will construct it themselves.
It should have been handled by a derived class or the caller
made a mistake.
-- SOL_SOCKET --
-- IPPROTO_IP --
-- IPPROTO_TCP --
orbos 98-01-18: Objects By Value -- begin
orbos 98-01-18: Objects By Value -- end
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of InternalFrameTitlePaneMaximizeButtonPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of InternalFrameTitlePaneMaximizeButtonPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
* Cast result object to a string.
* @return "NaN" if the number is NaN, Infinity or -Infinity if
* the number is infinite or the string value of the number.
public String str()
else if (Double.isInfinite(m_val))
if (m_val > 0)
if ((double)longVal == m_val)
if (s.charAt(len - 2) == '.' && s.charAt(len - 1) == '0')
if (e != -1)
Calculate Significant Digits:
look from start of string for first digit
look from end for last digit
significant digits = end - start + (0 or 1 depending on decimal location)
findStart: for( ; start < len; start++ )
findEnd: for( ; end > start; end-- )
clarify decimal location if it has not yet been found
if (decimalPos == -1)
if decimal is not between start and end, add one to sigDig
if (decimalPos < start || decimalPos > end)
reduce significant digits to PRECISION if necessary
if (sigDig > PRECISION)
re-scale BigDecimal in order to get significant digits = PRECISION
if (newScale < 0)
remove trailing '0's; keep track of decimalPos
while (s.charAt(--truncatePoint) == '0')
if (s.charAt(truncatePoint) == '.')
Account for exponent by adding zeros as needed
and moving the decimal place
if (exp == 0)
if (s.charAt(0) == '-')
get the number of digits right of the decimal
if (exp >= decimalLen)
if (exp > 0)
return sign + wholePart + decimalPart.substring(0, exp) + "."
Eliminate trailing 0's - bugzilla 14241
In order to handle the 'all' semantics of
nodeset comparisons, we always call the
Default to 0
We don't use a fast path as with get() because it is at
least as common to use set() to create new entries as
it is to replace existing ones, in which case, a fast
path would fail more often than not.
Back up to check for prior stale entry in current run.
We clean out whole runs at a time to avoid continual
incremental rehashing due to garbage collector freeing
up refs in bunches (i.e., whenever the collector runs).
Find either the key or trailing null slot of run, whichever
If we find key, then we need to swap it
with the stale entry to maintain hash table order.
The newly stale slot, or any other stale slot
encountered above it, can then be sent to expungeStaleEntry
to remove or rehash all of the other entries in run.
Start expunge at preceding stale entry if it exists
If we didn't find stale entry on backward scan, the
first stale entry seen while scanning for key is the
first still present in the run.
If key not found, put new entry in stale slot
If there are any other stale entries in run, expunge them
expunge entry at staleSlot
Rehash until we encounter null
Unlike Knuth 6.4 Algorithm R, we must scan until
null because multiple entries could have been stale.
Use lower threshold for doubling to avoid hysteresis
Help the GC
read and discard the repository ID
write the repository ID
protect against bad ZoneRules
TODO: rules should be queryable by epochSeconds
error message says daylight savings for simplicity
even though there are other kinds of gaps
override for Javadoc
override for Javadoc and performance
override for return type
override for return type
override for Javadoc and performance
override for Javadoc
override for Javadoc and performance
override for Javadoc
zero or more instances
zero or more instances
zero or more instances
zero or more instances
Sun Platform Extension
zero or more instances
Lazy loading the MXBean interface only when it is needed
ObjectName of a singleton MXBean contains only domain and type
if there are more than 1 key properties (i.e. other than "type")
a map from MXBean interface name to PlatformComponent
Use String as the key rather than Class<?> to avoid
causing unnecessary class loading of management interface
will replace the to be serialized 'this' object
link-local unicast in IPv4 (169.254.0.0/16)
defined in "Documenting Special Use IPv4 Address Blocks
that have been Registered with IANA" by Bill Manning
refer to RFC 1918
224.0.1.0 to 238.255.255.255
unless ttl == 0
224.0.0/24 prefix and ttl == 1
239.255/16 prefix or ttl < 32
239.192 - 239.195
matches, i.e., case 1: ...
target objects in instruction list
fixed length defined by subclasses
number of cases
number of pad bytes for alignment
Additional offset caused by preceding SWITCHs, GOTOs, etc.
Write default target offset
Compute number of pad bytes
Default branch target common for both cases (TABLESWITCH, LOOKUPSWITCH)
reinstantiate Signature object to work around bug in JDK
this shouldn't occur, but if it does, restore previous
the authentication status
initialize any configured options
Indicate not yet successful
we must have a userPrincipal - everything else is optional
overall authentication succeeded and commit succeeded,
but someone else's commit failed
REVISIT - should we make these throw UnsupportedOperationExceptions?
Right now, they'll go up to the java.io versions!
public abstract int read(byte b[], int off, int len) throws IOException
This should return false so that outside users (people using the JDK)
don't have any guarantees that mark/reset will work in their
custom marshaling code.  This is necessary since they could do things
like expect obj1a == obj1b in the following code:
Needed by AnyImpl and ServiceContexts
Needed by TCUtility
Needed by TypeCodeImpl
Needed by request and reply messages for GIOP versions >= 1.2 only.
Needed by IIOPInputStream and other subclasses
Starts the server if it is not already running.
Starts the server if it is not already running.
get the port for the endpoint of the locator
to pick a particular port type.
Type-specific CORBA::Object operations
Accessor methods (LocateRequestMessage interface)
this will raise a MARSHAL exception upon errors.
public String getValue ()
public String getName()
RAMESH : Pending proper implementation of DOM Level 3
we don't have any alternate node, either this node does the job
or we don't have anything that does
in theory nodeName can't be null but better be careful
who knows what other implementations may be doing?...
REVISIT: is it possible that prefix is empty string?
looking for default namespace
non default namespace
at this point we are dealing with DOM Level 2 nodes only
non default namespace
type is unknown
REVISIT: When Namespaces 1.1 comes out this may not be true
Prefix can't be bound to null namespace
type is unknown
we do not use any wrapper so the answer is obvious
overriden in some subclasses
Major version 13 indicates Java serialization,
Minor version [00-FF] is the version number.
Check if the profile is from a legacy Sun ORB.
we are dealing with a SUN legacy orb which emits 1.1 IORs,
in spite of being able to handle only GIOP 1.0 messages.
Now the target has to be (FOREIGN | NEWER*)
both major version are the same
Find methods for up to 2 params. We are guessing here.
This block should never execute unless the classloader
that loaded the argument classes disappears.
pp getParamNames used as an optimization to avoid method.getParameterTypes.
trace creates and disposes
show reuse hits/misses
show bad params, misc.
single selection model for JMenuBar
first close up any open menu
now popup the new menu
internal class AccessibleJMenuBar
See if we have a local binding.
We don't, pass along to children JMenu's
%%% improve later
These message should be read from a locale-specific resource bundle
This is the ORB implementation used when nothing else is specified.
Whoever provides this class customizes this string to
point at their ORB implementation.
The global instance of the singleton ORB implementation which
acts as a factory for typecodes for generated Helper classes.
TypeCodes should be immutable since they may be shared across
different security contexts (applets). There should be no way to
use a TypeCode as a storage depot for illicitly passing
information or Java objects between different security contexts.
Get System property
This will not throw a SecurityException because this
class was loaded from rt.jar using the bootstrap classloader.
Get property from orb.properties in either <user.home> or <java-home>/lib
This will not throw a SecurityException because this
class was loaded from rt.jar using the bootstrap classloader.
Note that there is no standard command-line argument for
specifying the default ORB implementation. For an
application you can choose an implementation either by
setting the CLASSPATH to pick a different org.omg.CORBA
and it's baked-in ORB implementation default or by
setting an entry in the properties object or in the
ORB method implementations.
We are trying to accomplish 2 things at once in this class.
It can act as a default ORB implementation front-end,
creating an actual ORB implementation object which is a
subclass of this ORB class and then delegating the method
To accomplish the delegation model, the 'delegate' private instance
variable is set if an instance of this class is created directly.
If we came here, it means that the actual ORB implementation
did not have a create_operation_list(...CORBA.Object oper) method,
so lets check if it has a create_operation_list(OperationDef oper)
First try to load the OperationDef class
if this throws a ClassNotFoundException, it will be caught below.
OK, we loaded OperationDef. Now try to get the
create_operation_list(OperationDef oper) method.
OK, the method exists, so invoke it and be happy.
orbos 98-01-18: Objects By Value -- begin
implemented in subclass
implemented in subclass
orbos 98-01-18: Objects By Value -- end
orbos 98-01-18: Objects By Value -- begin
Currently not implemented until PIORB.
Avoid creation of special accessor
GC spliterator, left and right child
Note: This method is not backward-compatible with 1.3 and earlier
releases. It now throws a SecurityException in an applet, whereas
in previous releases, it did not. This issue was discussed at
length, and ultimately approved by Hans.
return a copy of commonContents; in theory we want a deep clone
of commonContents, but since it only contains (immutable) Strings,
this shallow copy is sufficient
attributes of source file
delete target if it exists and REPLACE_EXISTING is specified
create directory or copy file
copy basic attributes to target
Do not instantiate.
Assumes targetKinds and E are sensible.
Assumes targetKinds and E are sensible.
Return set preserving iteration order of input set.
NPCTE fix for bugId 4510777, esc 532372, MR October 2001
file Task.java created for this bug fix
manifest main attributes
Write out the main attributes for the manifest
Now write out the pre-entry attributes
Buffered input stream for reading manifest data
Read the main attributes for the manifest
Total number of entries, attributes read
Average size of entry attributes
Now parse the manifest entries
name is wrapped
name is wrapped
XXX: Fix for when the average is 0. When it is 0,
you get an Attributes object with an initial
capacity of 0, which tickles a bug in HashMap.
nothing left in buffer
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of PopupMenuSeparatorPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of PopupMenuSeparatorPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
Source, null if using the default one. Note that the default name
is maintained in snapshot, this field is never "resolved".
Bound user: normally from the "principal" value in a JAAS krb5
login conf. Will be null if it's "*".
Set up JavaxSecurityAuthKerberosAccess in KerberosSecrets
Takes a snapshot of the keytab content. This method is called by
JavaxSecurityAuthKerberosAccessImpl so no more private
It's OK to show the name if caller specified it
add this message to fix bug 21478
Earlier (JDK 1.4 XALAN 2.2-D11) at key code '204' the key name was ER_PRIORITY_NOT_PARSABLE
In latest Xalan code base key name is  ER_VALUE_SHOULD_BE_NUMBER. This should also be taken care
in locale specific files like XSLTErrorResources_de.java, XSLTErrorResources_fr.java etc.
NOTE: Not only the key name but message has also been changed.
Note to translators:  The following message should not normally be displayed
to users.  It describes a situation in which the processor has detected
an internal consistency problem in itself, and it provides this message
for the developer to help diagnose the problem.  The name
'ElemTemplateElement' is the name of a class, and should not be
Note to translators:  The following message should not normally be displayed
to users.  It describes a situation in which the processor has detected
an internal consistency problem in itself, and it provides this message
for the developer to help diagnose the problem.  The substitution text
provides further information in order to diagnose the problem.  The name
'RedundentExprEliminator' is the name of a class, and should not be
This code is shared with warning codes.
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "QNAME" is the XML data-type of
The following codes are shared with the warning codes...
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "ENUM" is the XML data-type of
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "NMTOKEN" is the XML data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "NCNAME" is the XML data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "boolean" is the XSLT data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "number" is the XSLT data-type
End of shared codes...
Note to translators:  A "match pattern" is a special form of XPath expression
that is used for matching patterns.  The substitution text is the name of
a function.  The message indicates that when this function is referenced in
a match pattern, its argument must be a string literal (or constant.)
ER_ARG_LITERAL - new error message for bugzilla 5202
Note to translators:  The following message indicates that two definitions of
a variable.  A "global variable" is a variable that is accessible everywher
in the stylesheet.
ER_DUPLICATE_GLOBAL_VAR - new error message for bugzilla #790
Note to translators:  The following message indicates that two definitions of
a variable were encountered.
ER_DUPLICATE_VAR - new error message for bugzilla #790
Note to translators:  "xsl:template, "name" and "match" are XSLT keywords
which must not be translated.
ER_TEMPLATE_NAME_MATCH - new error message for bugzilla #789
Note to translators:  "exclude-result-prefixes" is an XSLT keyword which
should not be translated.  The message indicates that a namespace prefix
encountered as part of the value of the exclude-result-prefixes attribute
was in error.
ER_INVALID_PREFIX - new error message for bugzilla #788
Note to translators:  An "attribute set" is a set of attributes that can
be added to an element in the output document as a group.  The message
was never defined.
ER_NO_ATTRIB_SET - new error message for bugzilla #782
Note to translators:  This message indicates that there was a reference
Note to translators:  This message indicates that the XSLT instruction
instructions (content) or a "select" attribute.  The word "select" is
an XSLT keyword in this case and must not be translated.
Note to translators:  This message indicates that the value argument
of setParameter must be a valid Java Object.
Following are the new WARNING keys added in XALAN code base after Jdk 1.4 (Xalan 2.2-D11)
Note to translators:  "name" and "xsl:processing-instruction" are keywords
and must not be translated.
Note to translators:  "name" and "xsl:processing-instruction" are keywords
and must not be translated.  "NCName" is an XML data-type and must not be
Note to translators:  This message is reported if the stylesheet that is
being processed attempted to construct an XML document with an attribute in a
place other than on an element.  The substitution text specifies the name of
Check: WHY THERE IS A GAP B/W NUMBERS in the XSLTErrorResources properties file?
Other miscellaneous text used inside the code...
Note to translators:  The following messages provide usage information
for the Xalan Process command line.  "Process" is the name of a Java class,
and should not be translated.
Note to translators: The option name and the parameter name do not need to
be translated. Only translate the messages in parentheses.  Note also that
leading whitespace in the messages is used to indent the usage information
for each option in the English messages.
Do not translate the keywords: XSLTC, SAX, DOM and DTM.
Following are the new options added in XSLTErrorResources.properties files after Jdk 1.4 (Xalan 2.2-D11)
Added by sboag/scurcuru; experimental
AddITIONAL  STRINGS that need L10n
Note to translators:  The following message describes usage of a particular
command-line option that is used to enable the "template inlining"
optimization.  The optimization involves making a copy of the code
generated for a template in another template that refers to it.
================= INFRASTRUCTURE ======================
Creating a stream from an array is safe
clac expanded size
create tmp buffers
extract src image alpha channel and inverse and offset
create color image with shadow color and greyscale image as alpha
Make sure the locator used by the error reporter is the current entity scanner.
Note: above we reset fEntityScanner in the entity manager, thus in startEntity
in each scanner fEntityScanner field must be reset to reflect the change.
Must use XML 1.0 scanner to handle whitespace correctly
in the XML declaration.
definitely not a well-formed 1.1 doc!
Check if the next character is '='. If it is then consume it.
REVISIT:  should we check whether this equals quoteChar?
premature end of file
This method prepends "length" chars from the char array,
from offset 0, to the manager's fCurrentEntity.ch.
resize array; this case is hard to imagine...
have to move sensitive stuff out of the way...
have to reintroduce some whitespace so this parses:
NOTE: class/name/type and reference kind constitute a symbolic reference
member and modifiers are an add-on, derived from Core Reflection (or the equivalent)
spelling derived from java.lang.reflect.Executable, not MethodHandle.isVarargsCollector
fields are never varargs:
not in the public API: Modifier.VARARGS
from JVMS 4.6 (Table 4.20)
if nested read, passHandle contains handle of enclosing object
if nested read, passHandle contains handle of enclosing object
define proxy in class loader of non-public interface(s), if any
Allow replacement of the process-wide filter if not already set
Preventive interception of an exception to log
Debug logging of filter checks that fail
Trace logging for those that succeed
force header read
The type of the original object has been filtered but resolveObject
may have replaced it;  filter the replacement's type
REMIND: what type of exception to throw here?
REMIND: what type of exception to throw here?
just a check for number of references, depth, no class
Return true if this class is a custom subclass of ObjectInputStream
ReflectUtil.checkProxyPackageAccess makes a test
equivalent to isCustomSubclass so there's no need
to condition this call to isCustomSubclass == true here.
Filter the interfaces
Call filterCheck on the class before reading anything else
Call filterCheck on the class before reading anything else
Filter the replacement object
skip field values
defer until reset is true
REMIND: remove once hotspot inlines Float.intBitsToFloat
REMIND: remove once hotspot inlines Double.longBitsToDouble
block data state fields; values meaningful only when blkmode true
avoid unnecessary call to in.available() if possible
deprecated, not worth optimizing
near block boundary, read one byte at a time
shift and refill buffer manually
stop short of last char unless all of utf bytes in buffer
1 byte format: 0xxxxxxx
2 byte format: 110xxxxx 10xxxxxx
3 byte format: 1110xxxx 10xxxxxx 10xxxxxx
10xx xxxx, 1111 xxxx
1 byte format: 0xxxxxxx
2 byte format: 110xxxxx 10xxxxxx
3 byte format: 1110xxxx 10xxxxxx 10xxxxxx
consume remaining byte
10xx xxxx, 1111 xxxx
REMIND: add full description of exception propagation algorithm?
ignore dependencies on objs with no exception
eagerly propagate exception
add to dependency list of target
remember lowest unresolved target seen
propagate exception to dependents
no pending unknowns, only resolve current handle
pending unknowns now clearable, resolve all upward handles
unresolved backrefs present, can't resolve anything yet
change STATUS_UNKNOWN -> STATUS_OK in selected span of handles
controlled access to ObjectStreamClassValidator
avoid backpatching more than once
We will register the OID arcs leading to subgroups in this hashtable.
So for each arc in varList, if the arc is also in subgroups, it leads
to a subgroup, if it is not in subgroup, it leads either to a table
or to a variable.
We use a hashtable (subgroup) in order to determine whether an
OID arc leads to a subgroup. This implementation can be changed if
For instance, the subclass could provide a generated isNestedArc()
method in which the subgroup OID arcs would be hardcoded.
However, the generic approach was preferred because at this time
groups and subgroups are dynamically registered in the MIB.
if the arc is registered in the hashtable,
it leads to a subgroup.
If we reach this node, we are below the root OID, so we just
This method can also be overriden in a subclass to provide a
different implementation of the isNestedArc() method.
=> if isNestedArc() is hardcoded, then registerSubArc() becomes
useless and can become empty.
registers the arc in the hashtable.
The SnmpMibOid algorithm relies on the fact that for every arc
registered in varList, there is a corresponding node at the same
position in children.
So the trick is to register a null node in children for each variable
in varList, so that the real subgroup nodes can be inserted at the
registerObject() should be called for each scalar object and each
table arc by the generated subclass.
this will register the variable in both varList and children
The node registered in children will be null, so that the parent
algorithm will behave as if no node were registered. This is a
trick that makes the parent algorithm behave as if only subgroups
were registered in varList and children.
registerNode() will be called at runtime when nested groups are
registered in the MIB. So we do know that this method will only
be called to register nested-groups.
We trap registerNode() in order to call registerSubArc()
if we get here, then it means we are registering a subgroup.
We will thus register the sub arc in the subgroups hashtable.
see comments in SnmpMibNode
Nothing is left... the oid is not valid
This arc leads to a subgroup: delegates the search to the
method defined in SnmpMibOid
This arc leads to a table: forward the search to the table.
Gets the table
Forward the search to the table
If it's not a variable, throws an exception
The trailing .0 is missing in the OID
There are too many arcs left in the OID (there should remain
a single trailing .0)
The last trailing arc is not .0
It's one of our variable, register this node.
See comments in SnmpMibNode.
This should be considered as a genErr, but we do not want to
abort the whole request, so we're going to throw
The generic case where the end of the OID has been reached is
handled in the superclass
XXX Revisit: this works but it is somewhat convoluted. Just setting
arc to -1 would work too.
Ok, we've got the arc.
We have a recursive logic. Should we have a loop instead?
If the arc identifies a table, then we need to forward
the search to the table.
Gets the table identified by `arc'
Forward to the table
Build up the leaf OID
If the arc identifies a readable variable, then two cases:
The end of the OID is reached, so we return the leaf
corresponding to the variable identified by `arc'
Build up the OID
Registers this node
The end of the OID is not yet reached, so we must return
the next leaf following the variable identified by `arc'.
We cannot return the variable because whatever follows in
the OID will be greater or equals to 0, and 0 identifies
the variable itself - so we have indeed to return the
So we do nothing, because this case is handled at the
end of the if ... else if ... else ... block.
Now if the arc leads to a subgroup, we delegate the
search to the child, just as done in SnmpMibNode.
get the child ( = nested arc node).
The oid is not valid, we will throw an exception in order
to try with the next valid identifier...
We didn't find anything at the given arc, so we're going
to try with the next valid arc
REVISIT: allow both --MM and --MM-- now.
need to remove the following 4 lines to disallow --MM--
when the errata is offically in the rec.
validate and normalize
save unnormalized values
The state of this digest
The provider implementation (delegate)
Because 'algorithm', 'provider', and 'state' are private
members of our supertype, we must perform a cast to
The epoch second of Instant.MIN.
The epoch second of Instant.MAX.
hashcode of instant representation to satisfy contract with equals
compare using instant representation when unit differs
if both this and other's Instant reps are MIN/MAX,
use daysSinceEpoch and nanosOfDays, which will not
saturate during calculation.
days in a 400 year cycle = 146097
days in a 10,000 year cycle = 146097 * 25
seconds per day = 86400
append year/month/day/hour/minute/second/nano with width and 0 padding
before current era
adding leading zeros and stripping any trailing zeros
REVISIT: What should the order be?  enter/push...pop/exit?
Basic methods for supporting interceptors
Methods needed to support ORT.
Methods required for dispatching to servants
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of ScrollPanePainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of ScrollPanePainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
doing or waiting reconnection
only update mbeanRemovedNotifID
old listeners are re-added
not update clientSequenceNumber
only new listeners added during reconnection
need update clientSequenceNumber
Log only once.
Set new context class loader, returns previous one.
if ctxt is null, log a config message and throw a
get context class loader - may throw
SecurityException - though unlikely.
if nothing needs to be done, break here...
reset context class loader - may throw
nr == null means got exception
check sequence number.
check if an mbean unregistration notif
tell that the thread is REALLY stopped
no more fetching
0 notifs to update startSequenceNumber
1 notif to skip possible missing class
Even if result.getEarliestSequenceNumber() is now greater than
it was initially, meaning some notifs have been dropped
from the buffer, we don't want the caller to see that
because it is then likely to renotify about the lost notifs.
So we put back the first value of earliestSequenceNumber
that we saw.
no more listener, stop fetching
wait for another thread to do, which is doing reconnection
make sure only one fetching thread.
re-call this method to check the state again,
the state can be other value like TERMINATED.
wait for another thread to do, which is doing reconnection
init the clientSequenceNumber if not reconnected.
reconnection must happen during
fetchNotifs(-1, 0, 0), and a new
thread takes over the fetching job
servant not found
servant not found
if we come here Object does not exist
Assume caller is synchronized
also stores "next pointer" in free list
valid=true if this Element contains
a valid servant
Convert the index+counter into an 8-byte (big-endian) key.
prevent double deletion
add this to freeList
Maps Integer(policy type) to Policy
Make sure the defaults are set according to the POA spec
Set to record all indices in policies for which errors
Save the policy in policyMap to support
POA.get_effective_policy, if it was not already saved
if the value of this POA policy was previously set to a
different value than the current value given in
POAPolicyValue, record an error.
Check for bad policy combinations
NON_RETAIN requires USE_DEFAULT_SERVANT or USE_SERVANT_MANAGER
IMPLICIT_ACTIVATION requires SYSTEM_ID and RETAIN
workaround for 4530952
The original value is not a string. Should return the value in it's
Must take the value from the editor and get the value and cast it to the new type.
Fail silently and return the newValue (a String object)
This used to do something but now it doesn't.  It couldn't be
removed because it would be an API change to do so.
This used to do something but now it doesn't.  It couldn't be
removed because it would be an API change to do so.
workaround for 4530952
-- This file was mechanically generated: Do not edit! --
Simon And Ken Will Ask About Editorial Changes
In Idl To Java For The Following Signature.
The get_interface() method has been replaced by get_interface_def()
These message should be read from a locale-specific resource bundle
Can't clone image
ensure origin is in Image?
snapshot of pre-transaction names
need endEdit call to tidy things up
keep a record of where everything was to start with
check resultName also
something was replaced at pos1
kill only one dup
Now that we are done with originalNames, remove "killed" names.
restart loop at this position
no nested transactions
make a new buffer to hold the names
no multiple changes
Assuming names have been changed pairwise from originalNames[i] to names[i],
update arguments to ensure referential integrity.
space for removed duplicate
If any parameters have been changed, then reorder them as needed.
This is a "sheep-and-goats" stable sort, pushing all non-parameters
to the right of all parameters.
copy the exprs just after the last remaining param
else use replaceParameterByCopy
temporarily, will occur twice in the names array
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of TextPanePainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of TextPanePainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
IOException if there a problem accessing the starting file
END_DIRECTORY events are ignored
As we unwind from the recursion, create the iterators.
Is the iteration a one-step attribute pattern (i.e. select="@foo")?
Then use a simple iteration of the attributes, with node test
and predicate testing.
Is the iteration exactly one child step?
Does the pattern specify *any* child with no predicate? (i.e. select="child::node()".
Use simple child iteration without any test.
Else use simple node test iteration with predicate test.
Is the iteration a one-step attribute pattern (i.e. select="@foo")?
Then use a simple iteration of the attributes, with node test
and predicate testing.
Then use a simple iteration of the attributes, with node test
and predicate testing.
Then use a simple iteration of the attributes, with node test
and predicate testing.
Analysis of "center":
It's highly possible that we should have a seperate bit set for
For at least the time being, we can't optimize patterns like
"table[3]", because this has to be analyzed as
"/descendant-or-self::node()/table[3]" in order for the indexes
to work right.
&& getStepCount(analysis) <= 3
"Programmer's assertion: unknown opcode: "
Generate new traverser
case Axis.PRECEDINGANDANCESTOR :
Would need more smarts to tell if this could be a number or not!
that's all she wrote!
The DescendantIterator can only do one node test.  If there's more
than one, use another iterator.
"Programmer's assertion: unknown opcode: "
32 bits of analysis
boolean isNSWild = (null != namespace)
Use a special bit to to make sure we get the right analysis of "foo".
"Programmer's assertion: unknown opcode: "
|| (Axis.FOLLOWINGSIBLING == axis)
|| (Axis.PRECEDINGSIBLING == axis)
The predicate axis can't be moved!!!  Test Axes103
If we have an attribute or namespace axis that went up, then
it won't find the attribute in the inverse, since the select-to-match
axes are not invertable (an element is a parent of an attribute, but
and attribute is not a child of an element).
If we don't do the magic below, then "@*/ancestor-or-self::*" gets
inverted for match to "self::*/descendant-or-self::@*/parent::node()",
which obviously won't work.
So we will rewrite this as:
Child has to be rewritten a little differently:
inverted match: "self::*/child::@*/parent::node()"
Axes that go down in the select, do not have to have special treatment
in the rewrite. The following inverted match will still not select
inverted match: "self::*/parent::@*/parent::node()"
Lovely business, this.
don't care about the predicate axis
This is needed to inverse a following pattern, because of the
wacky Xalan rules for following from an attribute.  See axes108.
By these rules, following from an attribute is not strictly
In this case just change the axis.
We need to keep the new nodetest from affecting the score...
"Programmer's assertion: unknown opcode: "
"Programmer's assertion: unknown opcode: "
This could be done faster.  Coded for clarity.
Namespaces can present some problems, so just punt if we're looking for
The following, preceding, following-sibling, and preceding sibling can
be found in doc order if we get to this point, but if they occur
together, they produce
duplicates, so it's better for us to eliminate this case so we don't
have to check for duplicates during runtime if we're using a
OK, now we have to check for select="@*/axis::*" patterns, which
can also cause duplicates to happen.  But select="axis*/@::*" patterns
are OK, as are select="@foo/axis::*" patterns.
Unfortunately, we can't do this just via the analysis bits.
Steps that can traverse anything other than down a
subtree or that can produce duplicates when used in
combonation are counted with this variable.
Maybe not needed, but be safe.
This doesn't seem to work as a test for wild card.  Hmph.
"Programmer's assertion: unknown opcode: "
except parent of attrs.
can't go higher than 18!
IDL stubs must always use static factories.
Inform IIOReadProgressListeners we're starting a sequence
Inform IIOReadProgressListeners and IIOReadUpdateListeners
that we're starting a new image
Inform IIOReadProgressListeners we're ending a sequence
Add an element to a list, creating a new list if the
existing list is null, and return the list.
Remove an element from a list, discarding the list if the
resulting list is empty, and return the list or null.
Start with the entire source image
Destination also starts with source image, as that is the
maximum extent if there is no subsampling
Clip that to the param region, if there is one
Now clip any negative destination offsets, i.e. clip
to the top and left of the destination image
Now clip the destination Region to the subsampled width and height
Now clip that to right and bottom of the destination image,
if there is one, taking subsampling into account
A null param is equivalent to srcBands == dstBands == null.
If param is non-null, use it
Try to get the image itself
No image, get the image type
No info from param, use fallback image type
Create a new image based on the type specifier
TODO: %REVIEW% Not really the right error message.
We used to just allocate the array size to IDENT_MAX_DTMS.
But we expect to increase that to 16 bits, and I'm not willing
to allocate that much space unless needed. We could use one of our
handy-dandy Fast*Vectors, but this will do for now.
Various growth strategies are possible. I think we don't want
to over-allocate excessively, and I'm willing to reallocate
more often to get that. See also Fast*Vector classes.
%REVIEW% Should throw a more diagnostic error if we go over the max...
The DTM should have been told who its manager was when we created it.
Do we need to allow for adopting DTMs _not_ created by this manager?
count on addDTM() to throw exception if out of range
%REVIEW% Is there a better way to send a warning?
Special case to support RTF construction into shared DTM.
It should actually still work for other uses,
but may be slightly deoptimized relative to the base
to allow it to deal with carrying multiple documents.
we need to consider architectural improvements.
Create the basic SAX2DTM.
Go ahead and add the DTM to the lookup table.  This needs to be
done before any parsing occurs. Note offset 0, since we've just
created a new DTM.
No matter what.  %REVIEW%
If the reader is null, but they still requested an incremental
build, then we still want to set up the IncrementalSAXSource stuff.
IncrementalSAXSource_Xerces to avoid threading.
Create a IncrementalSAXSource to run on the secondary thread.
Have the DTM set itself up as IncrementalSAXSource's listener.
Then the user will construct it themselves.
Launch parsing coroutine.  Launches a second thread,
if we're using IncrementalSAXSource.filter().
Then the user will construct it themselves.
Reset the ContentHandler, DTDHandler, ErrorHandler to the DefaultHandler
after creating the DTM.
Reset the LexicalHandler to null after creating the DTM.
It should have been handled by a derived class or the caller
made a mistake.
Find the DOM2DTMs wrapped around this Document (if any)
and check whether they contain the Node in question.
NOTE that since a DOM2DTM may represent a subtree rather
than a full document, we have to be prepared to check more
than one -- and there is no guarantee that we will find
one that contains ancestors or siblings of the node we're
%REVIEW% We could search for the one which contains this
node at the deepest level, and thus covers the widest
subtree, but that's going to entail additional work
checking more DTMs... and getHandleOfNode is not a
cheap operation in most implementations.
TODO: %REVIEW% If overflow addressing, we may recheck a DTM
already examined. Ouch. But with the increased number of DTMs,
scanning back to check this is painful.
Generate a list of _unique_ DTM objects?
Have each DTM cache last DOM node search?
Not found; generate a new DTM.
%REVIEW% Is this really desirable, or should we return null
and make folks explicitly instantiate from a DOMSource? The
latter is more work but gives the caller the opportunity to
explicitly add the DTM to a DTMManager... and thus to know when
it can be discarded again, which is something we need to pay much
more attention to. (Especially since only DTMs which are assigned
to a manager can use the overflow addressing scheme.)
%BUG% If the source node was a DOM2DTM$defaultNamespaceDeclarationNode
and the DTM wasn't registered with this DTMManager, we will create
a new DTM and _still_ not be able to find the node (since it will
be resynthesized). Another reason to push hard on making all DTMs
be managed DTMs.
Since the real root of our tree may be a DocumentFragment, we need to
use getParent to find the root, instead of getOwnerDocument.  Otherwise
DOM2DTM#getHandleOfNode will be very unhappy.
Can't return the same node since it's unique to a specific DTM,
but can return the equivalent node -- find the corresponding
Document Element, then ask it for the xml: namespace decl.
If user did not supply a reader, ask for one from the reader manager
Performance critical function.
Accept as a special case.
Programming error; want to know about it.
Shortcut using DTMDefaultBase's extension hooks
%REVIEW% Should the lookup be part of the basic DTM API?
Following shouldn't need a nodeHandle, but does...
and doesn't seem to report the intended value
Multiple DTM IDs may be assigned to a single DTM.
The Right Answer is to ask which (if it supports
extension, the DTM will need a list anyway). The
Wrong Answer, applied if the DTM can't help us,
is to linearly search them all; this may be very
%REVIEW% Should the lookup move up into the basic DTM API?
Get a new source first time and when mask changes
end of AxisIterator
%HZ% %REVISIT% Is this the right thing to do here?  In the old
%HZ% %REVISIT% version, the main document did not get added through
%HZ% %REVISIT% a call to addDOMAdapter, which meant it couldn't be
%HZ% %REVISIT% found by a call to getDocumentMask.  The problem is
%HZ% %REVISIT% TransformerHandler is typically constructed with a
%HZ% %REVISIT% system ID equal to the stylesheet's URI; with SAX
%HZ% %REVISIT% input, it ends up giving that URI to the document.
%HZ% %REVISIT% Then, any references to document('') are resolved
%HZ% %REVISIT% using the stylesheet's URI.
%HZ% %REVISIT% MultiDOM.getDocumentMask is called to verify that
%HZ% %REVISIT% a document associated with that URI has not been
%HZ% %REVISIT% encountered, and that method ends up returning the
%HZ% %REVISIT% mask of the main document, when what we really what
%HZ% %REVISIT% is to read the stylesheet itself!
This method only has a function in DOM adapters
Add the DOM adapter to the array of DOMs
Store reference to document (URI) in the Map
If the dom is an AdaptiveResultTreeImpl, we need to create a
DOMAdapter around its nested dom object (if it is non-null) and
add the DOMAdapter to the list.
main source document @ 0
TODO: gather nodes from all DOMs ?
%HZ% Does this method make any sense here???
%HZ% Does this method make any sense here???
make invisible borders.
scrollbars will be displayed if needed
Need a way to handle exceptions
Need a way to handle exceptions
Need a way to handle exceptions
Need a way to handle exceptions
the list of buttons participating in this group
this should puke in some way.
build the first zone.
PENDING(prinz) this could be done as a binary
search, and probably should be.
divide the old zone into a new set of bins
---- View methods ----------------------------------------------------
mark the major span as estimated
estimate the span
replace this with something real
the structure of this element changed.
The change is in this zone
--- View methods ----------------------------------
marker: value will be computed on request
Marker for the default value.  Use 'color' property value as the
computed value of the 'border-color' property (CSS2 8.5.2)
The 'border-style' value of "none" forces the computed value
of 'border-width' to be 0 (CSS2 8.5.3)
Position and size of the border interior.
Coordinates of the interior corners, from NW clockwise.
Draw the borders for all sides.
"stretch" the border shape by the interior area dimension
Restore initial clip
Enable SO_REUSEADDR before binding
Security manager makes sure that the multicast address
is allowed one and that the ttl used is less
than the allowed maxttl.
set the ttl
call the datagram method to send
set it back to default
-- This file was mechanically generated: Do not edit! --
these declarations are here as documentation
-sb Add this to force empty strings to be index 0.
Is it one we already know?
New value. Add to tables.
Initialize to no-following-same-hash
First for this hash
Link from previous with same hash
end pass loop
Access to protected field members is restricted to receivers only
of the accessing class, or one of its subclasses, and the
accessing class must in turn be a subclass (or package sibling)
of the protected member's defining class.
If the updater refers to a protected field of a declaring class
outside the current package, the receiver argument will be
narrowed to the type of the accessing class.
same implementation as strong form for now
System-dependent portion of ProcessBuilder.start()
In theory, close() can throw IOException
(although it is rather unlikely to happen here)
We guarantee the only command file execution for implicit [cmd.exe] run.
The code protects the [java.exe] and console command line
parser, that interprets the [\"] combination as an escape
sequence for the ["] char.
If the argument is an FS path, doubling of the tail [\]
char is not a problem for non-console applications.
The [\"] sequence is not an escape sequence for the [cmd.exe]
command line parser. The case of the [""] tail escape
sequence could not be realized due to the argument validation
The argument has already been quoted.
There is ["] inside.
There is ["] inside.
Switch off MS heuristic for internal ["].
Please, use the explicit [cmd.exe] call
if you need the internal ["].
Example: "cmd.exe", "/C", "Extended_MS_Syntax"
For [.exe] or [.com] file the unpaired/internal ["]
in the argument is not a problem.
Win32 CreateProcess requires path to be normalized
From the [CreateProcess] function documentation:
"If the file name does not contain an extension, .exe is appended.
Therefore, if the file name extension is .com, this parameter
must include the .com extension. If the file name ends in
a period (.) with no extension, or if the file name contains a path,
.exe is not appended."
"If the file name !does not contain a directory path!,
the system searches for the executable file in the following
In practice ANY non-existent path is extended by [.exe] extension
in the [CreateProcess] funcion with the only exception:
the path ends by (.)
Normalize path if possible.
No worry about internal, unpaired ["], and redirection/piping.
legacy mode doesn't worry about extended verification
Workaround for the calls like
Runtime.getRuntime().exec("\"C:\\Program Files\\foo\" bar")
No chance to avoid CMD/BAT injection, except to do the work
right from the beginning. Otherwise we have too many corner
Runtime.getRuntime().exec(String[] cmd [, ...])
calls with internal ["] and escape sequences.
Restore original command line.
terminal space in command line is ok
Parse the command line again.
Check new executable name once more
Quotation protects from interpretation of the [path] argument as
start of longer path with spaces. Quotation has no influence to
[.exe] extension heuristic.
We need the extended verification procedure for CMD files.
Round up to next millisecond
serialVersionUID is not constant
Serialization compatibility stuff:
Two serial forms are supported in this class. The selected form depends
on system property "jmx.serial.form":
- "1.0" for JMX 1.0
- any other value for JMX 1.1 and higher
Serial version for old serial form
Serial version for new serial form
Serializable fields in old serial form
Serializable fields in new serial form
Actual serial version and serial form
OK: No compat with 1.0
END Serialization compatibility stuff
put getter and setter methods in operations list
create default descriptor
put getter and setter methods in operations list
create default descriptor
New serial form ignores extra field "currClass"
Serializes this instance in the old serial form
Serializes this instance in the new serial form
Stateless intermediate operations from Stream
We can do better than this, by polling cancellationRequested when stream is infinite
We can do better that this too; optimize for depth=0 case and just grab spliterator and forEach it
We can do better than this, by polling cancellationRequested when stream is infinite
We can do better that this too; optimize for depth=0 case and just grab spliterator and forEach it
We can do better than this, by polling cancellationRequested when stream is infinite
We can do better that this too; optimize for depth=0 case and just grab spliterator and forEach it
We can do better than this, by polling cancellationRequested when stream is infinite
We can do better that this too; optimize for depth=0 case and just grab spliterator and forEach it
Stateful intermediate operations from Stream
Terminal operations from Stream
Since A has no relation to U (not possible to declare that A is an upper bound of U)
there will be no static type checking.
Therefore use a raw type and assume A == U rather than propagating the separation of A and U
throughout the code-base.
The runtime type of U is never checked for equality with the component type of the runtime type of A[].
Runtime checking will be performed when an element is stored in A[], thus if A is not a
super type of U an ArrayStoreException will be thrown.
Optimized sequential terminal operations for the head of the pipeline
These nodeType mnemonics and values are deliberately the same as those
used by the DOM, for convenient mapping
%REVIEW% Should we actually define these as initialized to,
========= DTM Implementation Control Functions. ==============
%TBD% RETIRED -- do via setFeature if needed. Remove from impls.
========= Document Navigation Functions =========
============== Document query functions ==============
============== Boolean methods ================
========== Direct SAX Dispatch, for optimization purposes ========
==== Construction methods (may not be supported by some implementations!) =====
%REVIEW% What response occurs if not supported?
%REVIEW% Do these appends make any sense, should we support a
wider set of methods (like the "append" methods in the
current DTMDocumentImpl draft), or should we just support SAX
listener interfaces?  Should it be a separate interface to
make that distinction explicit?
These message should be read from a locale-specific resource bundle
This will not throw a SecurityException because this
class was loaded from rt.jar using the bootstrap classloader.
The following fields are only used if the anchor is
one of BASELINE, BASELINE_LEADING or BASELINE_TRAILING.
ascent and descent include the insets and ipady values.
The folllowing two fields are used if the baseline type is
centerPadding is either 0 or 1 and indicates if
the height needs to be padded by one when calculating where the
Where the baseline lands relative to the center of the component.
this shouldn't happen, since we are Cloneable
the type of wildcard: any, other, or list
the type of process contents: strict, lax, or skip
the namespace list:
for NSCONSTRAINT_LIST, it means one of the namespaces in the list
for NSCONSTRAINT_NOT, it means not any of the namespaces in the list
I'm trying to implement the following constraint exactly as what the
spec describes. Sometimes it seems redundant, and sometimes there seems
to be much easier solutions. But it makes it easy to understand,
easy to maintain, and easy to find a bug (either in the code, or in the
NOTE: Schema spec only requires that ##other not(tNS,absent).
The way we store ##other is not(NS1,NS2,...,NSN), which covers
what's required by Schema, and allows future enhanced features.
In the following in-line comments:
- Bullet removed from w3c specification.
+ Bullet added as proposed by Sandy Gao, IBM.
/ Since we store ##other as not(NS1,NS2,...,NSN), we need to put some
comments on where we didn't follow the spec exactly.
1 The constraint must be any.
2 All of the following must be true:
2.1 The constraint is a pair of not and a namespace name or absent ([Definition:]  call this the namespace test).
2.2 The value must not be identical to the namespace test.
2.3 The value must not be absent.
/ we store ##other as not(list), so our actual rule is
/ 2 The constraint is a pair of not and a set, and the value is not in such set.
3 The constraint is a set, and the value is identical to one of the members of the set.
none of the above conditions applied, so return false.
if the super is null (not expressible), return false
For a namespace constraint (call it sub) to be an intensional subset of another
namespace constraint (call it super) one of the following must be true:
1 super must be any.
2 All of the following must be true:
2.1 sub must be a pair of not and a namespace name or absent.
2.2 super must be a pair of not and the same value.
* we can't just compare whether the namespace are the same value
since we store other as not(list)
3 All of the following must be true:
3.1 sub must be a set whose members are either namespace names or absent.
3.2 One of the following must be true:
3.2.1 super must be the same set or a superset thereof.
-3.2.2 super must be a pair of not and a namespace name or absent and
that value must not be in sub's set.
+3.2.2 super must be a pair of not and a namespace name or absent and
either that value or absent must not be in sub's set.
* since we store ##other as not(list), we acturally need to make sure
that none of the namespaces in super.list is in sub.list.
none of the above conditions applied, so return false.
if the other wildcard is not expressible, the result is still not expressible
other such values (call them O1 and O2): the appropriate case among the following
must be true:
1 If O1 and O2 are the same value, then that value must be the value.
2 If either O1 or O2 is any, then any must be the value.
3 If both O1 and O2 are sets of (namespace names or absent), then the union of
those sets must be the value.
-4 If the two are negations of different namespace names, then the intersection
is not expressible.
+4 If the two are negations of different namespace names or absent, then
a pair of not and absent must be the value.
not(intersection of two lists).
5 If either O1 or O2 is a pair of not and a namespace name and the other is a set of
(namespace names or absent), then The appropriate case among the following must be true:
-5.1 If the set includes the negated namespace name, then any must be the value.
-5.2 If the set does not include the negated namespace name, then whichever of O1 or O2
is a pair of not and a namespace name must be the value.
+5.1 If the negated value is a namespace name, then The appropriate case
among the following must be true:
+5.1.1 If the set includes both the namespace name and absent, then any
must be the value.
+5.1.2 If the set includes the namespace name but does not include
absent, then a pair of not and absent must be the value.
+5.1.3 If the set does not include the namespace name but includes
absent, then the union is not expressible.
+5.1.4 If the set does not include either the namespace name or absent,
then whichever of O1 or O2 is a pair of not and a namespace name must be
+5.2 If the negated value is absent, then The appropriate case among the
following must be true:
+5.2.1 If the set includes absent, then any must be the value.
+5.2.2 If the set does not include absent, then whichever of O1 or O2 is
a pair of not and a namespace name must be the value.
!foundNS && !foundAbsent
other[0] == ABSENT
if the other wildcard is not expressible, the result is still not expressible
two other such values (call them O1 and O2): the appropriate case among the following
must be true:
1 If O1 and O2 are the same value, then that value must be the value.
2 If either O1 or O2 is any, then the other must be the value.
both cannot be ANY, if we have reached here.
-3 If either O1 or O2 is a pair of not and a namespace name and the other is a set of
(namespace names or absent), then that set, minus the negated namespace name if
it was in the set, must be the value.
+3 If either O1 or O2 is a pair of not and a namespace name and the other
is a set of (namespace names or absent), then that set, minus the negated
namespace name if it was in the set, then minus absent if it was in the
set, must be the value.
4 If both O1 and O2 are sets of (namespace names or absent), then the intersection of those
sets must be the value.
-5 If the two are negations of different namespace names, then the intersection is not expressible.
+5 If the two are negations of namespace names or absent, then The
appropriate case among the following must be true:
+5.1 If the two are negations of different namespace names, then the
intersection is not expressible.
+5.2 If one of the two is a pair of not and absent, the other must be
##other, only check the negated value
as for NSCONSTRAINT_LIST.
## list, must have the same length,
and each item in one list must appear in the other one
(we are assuming that there are no duplicate items in a list)
Document URI index, which increases by 1 at each getDocumentURI() call.
The SAXImpl object wrapped by this class, if the RTF is a tree.
The whitespace filter
The size of the RTF
True if we want to build the ID index table
The element name
Create a AdaptiveResultTreeImpl
Return the DOM object wrapped in this object.
Return the document ID
Return the String value of the RTF
Return the expanded type id of a given node
Create and initialize the wrapped SAXImpl object
Flush pending Text nodes to SAXImpl
"prefix:localpart" or "localpart"
Use try/catch block to support applets
getContextClassLoader() undefined in JDK1.1
system property look up
try to read from $java.home/lib/jaxp.properties
Try with ServiceLoader
The following assertion should always be true.
Uncomment it, recompile, and run with -ea in case of doubts:
make sure we have access to restricted packages
use approprite ClassLoader
get Class from className
instantiate Class as a XPathFactory
Retain maximum compatibility if no security manager.
Do not call "newXPathFactoryNoServiceLoader" if it's
not public static.
Only calls "newXPathFactoryNoServiceLoader" if it's
declared to return an instance of XPathFactory.
Should not happen since
declared to return XPathFactory.
Call isObjectModelSupportedBy with initial context.
store current context.
restore initial context to call
no factory found.
-- This file was mechanically generated: Do not edit! --
Old actions forward to an instance of this.
Make sure we don't resize less than minimum size.
Ensure that we keep the internal frame on the desktop.
Make sure we don't resize less than minimum size.
Ensure that we keep the internal frame on the desktop.
Make sure we don't resize less than minimum size.
Ensure that we keep the internal frame on the desktop.
Make sure we don't resize less than minimum size.
Ensure that we keep the internal frame on the desktop.
maximize the selected frame
minimize the selected frame
restore the selected minimized or maximized frame
$Id: XPathFactoryImpl.java,v 1.2 2005/08/16 22:41:13 jeffsuttor Exp $
know how to support default object model, W3C DOM
don't know how to support anything else
feature name cannot be null
all done processing feature
in secure mode, let _useServicesMechanism be determined by the constructor
feature name cannot be null
resolver cannot be null
resolver cannot be null
-- This file was mechanically generated: Do not edit! --
will throw NPE if options contains null
if attributes are cached then use them if possible
attempt to get attributes of file. If fails and we are following
links then a link target might not exist so get attributes of link
attempt to get attrmptes without following links
if this directory and ancestor has a file key then we compare
them; otherwise we use less efficient isSameFile test.
need the file attributes
at maximum depth or file is not a directory
check for cycles when following links
file is a directory, attempt to open it
push a directory node to the stack and return an event
stack is empty, we are done
continue iteration of the directory at the top of the stack
get next entry in the directory
no next entry so close and pop directory, creating corresponding event
visit the entry
This used to be a constant before the pipe size was allowed
to change. This field will continue to be maintained
for backward compatibility.
A byte is read beforehand outside the loop
In addition to the previous method it can extend spaces for
all params are the same as in the preious method except the last
if null not justification is needed
In addition to the previous method it can extend spaces for
all params are the same as in the preious method except the last
if null not justification is needed
Ignore newlines, they take up space and we shouldn't be
In addition to the previous method it can extend spaces for
all params are the same as in the preious method except the last
if null not justification is needed
x before x0, return.
s may be a shared segment, so it is copied prior to calling
the tab expander
found the hit position... return the appropriate side
the length of the string measured as a whole may differ from
the sum of individual character lengths, for example if
fractional metrics are enabled; and we must guard from this.
didn't find, return end offset
break on whitespace
a multibyte char found; use BreakIterator to find line break
Skip invisible elements
Skip invisible elements
didn't find in this line, try the next line
there are no more words on this line.
if we haven't shot past the end... check to
see if the current boundary represents whitespace.
if so, we need to try again
it was whitespace, try again.  The assumption
is that it must be a word start if the last
one had whitespace following it.
didn't find in this line, try the prev line
there are no more words on this line.
if we haven't shot past the end... check to
see if the current boundary represents whitespace.
if so, we need to try again
it was whitespace, try again.  The assumption
is that it must be a word start if the last
one had whitespace following it.
Add text attributes
Nothing to do.
Start from the first View.
Special case that should ONLY happen if first view
isn't valid (can happen when end position is put at
beginning of line.
If there is a bias change, it is a fake position
and we should skip it. This is usually the result
of two elements side be side flowing the same way.
Reached the end of a view, make sure the next view
is a different direction.
assert !policies.retainServants() && policies.useDefaultServant()
my ORB instance
Added from last version because it broke the build - RTW
XXX remove me and rebuild: probably no longer needed
Called only for its side-effect of throwing appropriate exceptions
to set the codebase information, if any transmitted; and also
appropriate ORB Version.
Now that we have the service contexts processed and the
correct ORBVersion set, we must finish initializing the
Check that this server is the right server
Thrown by Portable Interceptors from InterceptorInvoker,
through Response constructor.
DO NOT CALL THIS HERE:
The problem is that OADestroyed is only thrown by oa.enter, in
which case oa.exit should NOT be called, and neither should
the invocationInfo stack be popped.
Destroyed POAs can be recreated by normal adapter activation.
So just restart the dispatch.
IDLJ generated non-tie based skeletons do not catch the
RequestCanceledException. Rethrow the exception, which will
cause the worker thread to unwind the dispatch and wait for
RMIC generated tie skeletons convert all Throwable exception
types (including RequestCanceledException, ThreadDeath)
thrown during reading fragments into UnknownException.
If RequestCanceledException was indeed raised,
then rethrow it, which will eventually cause the worker
thread to unstack the dispatch and wait for other requests.
Note that objectAdapter.enter() must be called before getServant.
Prepare Portable Interceptors for a new server request
and invoke receive_request_service_contexts.  The starting
point may throw a SystemException or ForwardException.
This must be set just after the enter so that exceptions thrown by
enter do not cause
the exception reply to pop the thread stack and do an extra oa.exit.
Note: we do not know the MDI on a null servant.
We only end up in that situation if _non_existent called,
so that the following handleNullServant call does not throw an
we cannot depend on this since for our local case, we do not send
in this service context.  Can we rely on just the CodeSetServiceContext?
boolean rtSC = false;  Runtime ServiceContext
the RTSC is sent only once during session establishment.  We
need to find out if the CodeBaseRef is already set.  If yes,
then also the rtSC flag needs to be set to true
this is not possible for the LocalCase since there is no
IIOPConnection for the LocalCase
used for a case where we have JDK 1.3 supporting 1.0 protocol,
but sending 2 service contexts, that is not normal as per
GIOP rules, based on above information, we figure out that we
are talking to the legacy ORB and set the ORB Version Accordingly.
this special case tell us that it is legacy SUN orb
and not a foreign one
rtSC is not available for localcase due to which this generic
path would fail if relying on rtSC
if (giopVersion.equals(GIOPVersion.V1_0) && hasCodeSetContext && rtSC)
If it didn't include our ORB version service context (below),
then it must be a foreign ORB.
try to get the ORBVersion sent as part of the ServiceContext
Invoke on the servant using the portable DSI skeleton
Note: When/if dynimpl.invoke calls arguments() or
set_exception() then intermediate points are run.
Note: When/if dynimpl.invoke calls arguments() or
set_exception() then intermediate points are run.
Check if ServerRequestImpl.result() has been called
Marshal out/inout/return parameters into the ReplyMessage
Check if the servant set a SystemException or
Get the exception object from the Any
Marshal the exception back
Somehow a code set service context showed up in the local case.
If it's GIOP 1.0, it shouldn't have this context at all.  Our legacy
ORBs sent it and we need to know if it's here to make ORB versioning
decisions, but we don't use the contents.
Note on threading:
getCodeSetContext and setCodeSetContext are synchronized
on the Connection.  At worst, this will result in
multiple threads entering this block and calling
setCodeSetContext but not actually changing the
values on the Connection.
Alternative would be to lock the connection for the
whole block, but it's fine either way.
The connection's codeSetContext is null until we've received a
request with a code set context with the negotiated code sets.
Use these code sets on this connection
We had to read the method name using ISO 8859-1
(which is the default in the CDRInputStream for
char data), but now we may have a new char
code set.  If it isn't ISO8859-1, we must tell
the CDR stream to null any converter references
it has created so that it will reacquire
the code sets again using the new info.
This should probably compare with the stream's
char code set rather than assuming it's ISO8859-1.
(However, the operation name is almost certainly
ISO8859-1 or ASCII.)
If no code set information is ever sent from the client,
the server will use ISO8859-1 for char and throw an
exception for any wchar transmissions.
In the local case, we use ORB provided streams for
marshaling and unmarshaling.  Currently, they use
ISO8859-1 for char/string and UTF16 for wchar/wstring.
End of file.
read and discard the repository ID
write the repository ID
Hand off to SAX validator helper.
Hand off to DOM validator helper.
Hand off to stream validator helper.
Hand off to stax validator helper.
Source parameter cannot be null.
Source parameter must be a SAXSource, DOMSource or StreamSource
for now, the identifier can only be (XMLConstants.FEATURE_SECURE_PROCESSING)
Support current-element-node; return current node if DOMSource is used.
avoid resetting features and properties if the state the validator
is currently in, is the same as it will be after reset.
Check and construct state defined by parent
Check the 3 arrays are not null or empty (ie length==0) and that there is no null element or empty string in them
Check the sizes of the 3 arrays are the same
Initialize internal "names to descriptions" and "names to types" sorted maps,
and, by doing so, check there are no duplicate item names
Initializes myNamesSet on first call
always return the same value
if obj is null or not CompositeData, return false
if obj is not a CompositeData, return false
test value's CompositeType is assignable to this CompositeType instance
if obj is null, return false
if obj is not a CompositeType, return false
Now, really test for equality between this CompositeType instance and the other
their names should be equal
their items names and types should be equal
All tests for equality were successfull
Calculate the hash code value if it has not yet been done (ie 1st call to hashCode())
return always the same hash code for this instance (immutable)
Calculate the string representation if it has not yet been done (ie 1st call to toString())
return always the same string representation for this instance (immutable)
Register with the ToolTipManager so that tooltips from the
renderer show through.
Try the top left(LTR) or top right(RTL) corner, and
then go across checking each cell for HORIZONTAL_WRAP.
Try the lower left corner, and then go across checking
each cell for other list layout orientation.
Past visible region, bail.
Past visible region, bail.
special case for below all cells
special case for below all cells
start search from the next element after the selected element
Will only happen if UI null, shouldn't matter what we return
Show remainder of leading cell
Hide rest of leading cell
Hide rest of leading cell
ASSUME: All cells are the same width
last cell is the lowest left cell
position is upper right if ltr, or upper left otherwise
position is upper left corner of the visibleRect shifted
left by the visibleRect.width if ltr, or upper right shifted
right by the visibleRect.width otherwise
the right of the first cell
re-set listData listeners
re-set listSelectionModel listeners
Process the State changes for Multiselectable
to override getBounds()
The UI incorrectly returns a -1 for the last
visible index if the list is smaller than the
TIGER - 4733624
inner class AccessibleJListChild
inner class AccessibleJList
We don't force the initialization of the default SSLSocketFactory
at construction time - because the RMI client socket factory is
created on the server side, where that initialization is a priori
meaningless, unless both server and client run in the same JVM.
We could possibly override readObject() to force this initialization,
but it might not be a good idea to actually mix this with possible
So contrarily to what we do for the server side, the initialization
of the SSLSocketFactory will be delayed until the first time
createSocket() is called - note that the default SSLSocketFactory
might already have been initialized anyway if someone in the JVM
already called SSLSocketFactory.getDefault().
Retrieve the SSLSocketFactory
Create the SSLSocket
Set the SSLSocket Enabled Cipher Suites
Set the SSLSocket Enabled Protocols
Return the preconfigured SSLSocket
We use a static field because:
SSLSocketFactory.getDefault() always returns the same object
(at least on Sun's implementation), and we want to make sure
that the Javadoc & the implementation stay in sync.
If someone needs to have different SslRMIClientSocketFactory factories
with different underlying SSLSocketFactory objects using different key
and trust stores, he can always do so by subclassing this class and
overriding createSocket(String host, int port).
validate and normalize
save unnormalized values
if (_name.equals("*")) _typeChecked = true; no wildcard allowed!
Type check all the predicates (e -> position() = e)
context node is on the stack
Push current node on the stack
Overwrite current node with matching node
If pattern not reduced then check kernel
Load the requested processing instruction name
Load the current processing instruction's name
Compare the two strings
Compile the expressions within the predicates
Backpatch true list and restore current iterator/node
Backpatch false list and restore current iterator/node
True list falls through
do not instantiate
See IMPL_LOOKUP below.
Method handle creation from ordinary methods.
use maximally privileged lookup
Copied from AccessibleObject, as used by Method.setAccessible, etc.:
This is just for calling out to MethodHandleImpl.
make sure we haven't accidentally picked up a privileged class:
IMPL_LOOKUP can make any lookup at all
keep same capabilities
Allow nestmate lookups to be created without special privilege:
The requested class it not accessible from the lookup class.
Make sure outer class is initialized first.
For caller-sensitive MethodHandles.lookup()
disallow lookup more restricted packages
internal only; not exported
Should not happen, but it's a bitfield...
these names require special lookups because of the implicit MethodType argument
may get NPE
these names require special lookups because they throw UnsupportedOperationException
ignore m.isAccessible:  this is a new kind of access
Devirtualized method invocation is usually formally virtual.
To avoid creating extra MemberName objects for this common case,
we encode this extra degree of freedom using MH.isInvokeSpecial.
Symbolic reference is through interface but resolves to Object method (toString, etc.)
Check SM permissions and member access before cracking.
Produce the handle to the results.
/ Helper methods, all package-private.
do this before attempting to resolve
do this before attempting to resolve
NPE check on name
do this before attempting to resolve
Only lookups with private access are allowed to resolve caller-sensitive methods
The JVM does this hack also.
Because the JVM does not allow separate methods on array types,
there is no separate method for int[].clone.
All arrays simply inherit Object.clone.
But for access checking logic, we make Object.clone
(normally protected) appear to be public.
Later on, when the DirectMethodHandle is created,
its leading argument will be restricted to the
requested array type.
N.B. The return type is not adjusted, because
that is *not* the bytecode behavior.
cannot "new" a protected ctor in a different package
adjust 0 => PACKAGE
Protected members can also be checked as if they were package-private.
check the class first:
The accessing class only has the right to use a protected member
on itself or a subclass.  Enforce that restriction, from JVMS 5.4.4, etc.
receiver type of mh is too wide; narrow to caller
viewAsType will lose varargs-ness
not needed for reflection or for linking CONSTANT_MH constants
Optionally check with the security manager; this isn't needed for unreflect* calls.
not this code path
Per JVMS 6.5, desc. of invokespecial instruction:
If the method is in a superclass of the LC,
and if our original search was above LC.super,
repeat the search (symbolic lookup) from LC.super
and continue with the direct superclass of that class,
and so forth, until a match is found or no further superclasses exist.
FIXME: MemberName.resolve should handle this instead.
no method is found yet
search up to refc
redo basic checks
Optionally narrow the receiver argument to refc using restrictReceiver.
caller must have private access
callerClass came from a security manager style stack walk
Note: caller will apply varargs after this step happens.
not needed for reflection or for linking CONSTANT_MH constants
Optionally check with the security manager; this isn't needed for unreflect* calls.
not needed for reflection or for linking CONSTANT_MH constants
Optionally check with the security manager; this isn't needed for unreflect* calls.
maybeBindCaller not relevant here
Treat MethodHandle.invoke and invokeExact specially.
better safe than sorry
/ method handle invocation (reflective style)
/ method handle modification (creation from other method handles)
use the asTypeCache when possible:
get a private copy
first detect dropped arguments and handle them separately
Normalize the reordering into a real permutation,
by removing duplicates and adding dropped elements.
This somewhat improves lambda form caching, as well
as simplifying the transform by breaking it up into steps.
We found a duplicated entry at reorder[ddIdx].
permuted by [1*,0,1] => (a0,a1)=>asList(a1,a0,a1)
permuted by [0,1,0*] => (a0,a1)=>asList(a0,a1,a0)
The starred element corresponds to the argument
deleted by the dupArgumentForm transform.
Set killFirst if the dup is larger than an intervening position.
This will remove at least one inversion from the permutation.
contract the reordering by removing the element at dstPos
Find first element of reorder larger than dropVal.
This is where we will insert the dropVal.
expand the reordering by inserting an element at insPos
a perfect permutation
Note:  This may cache too many distinct LFs. Consider backing off to varargs code.
max number of bits in bit mask
>0 indicates a dup
find first zero
same algorithm, different bit set
>0 indicates a dup
something like identity(Foo.class); do not bother to intern these
Simulate a CAS, to avoid racy duplication of results.
throw CCE if needed
perform unboxing and/or primitive conversion
ignore null elements of filters
Note:  This may cache too many distinct LFs. Consider backing off to varargs code.
omit leading parameter from handler
In order to handle the 'all' semantics of
nodeset comparisons, we always call the
Probably not so good.  Think about this.
General Attribute Checking for elmNode declared locally
ref should be here.
get global decl
no children are allowed here except annotation, which is optional.
General Attribute Checking for elmNode declared globally
global declaration must have a name
check the content
Traverse the attribute and attribute group elements and fill in the
An invalid element was found...
if a global group doesn't have a name, then don't add it.
Remove prohibited attributes from the set
check for restricted redefine:
make an entry in global declarations.
also add it to extended map
We need at least one StorageResolver otherwise
the KeyResolvers would not be called.
The default StorageResolver is null.
First search using the individual resolvers from the user
Then use the system-wide Resolvers
not using StorageResolvers at the moment
since they cannot return private keys
not using StorageResolvers at the moment
since they cannot return private keys
Replace the default null StorageResolver
Common UI methods
message formatter; used to produce localized
Locale to use for messages
<init>(InputStream, MessageFormatter, Locale)
<init>(InputStream, int, MessageFormatter, Locale)
NOTE: We use the index into the buffer if there are remaining
bytes from the last block read. -Ac
get first byte
UTF-8:   [0xxx xxxx]
Unicode: [0000 0000] [0xxx xxxx]
UTF-8:   [110y yyyy] [10xx xxxx]
Unicode: [0000 0yyy] [yyxx xxxx]
UTF-8:   [1110 zzzz] [10yy yyyy] [10xx xxxx]
Unicode: [zzzz yyyy] [yyxx xxxx]
UTF-8:   [1111 0uuu] [10uu zzzz] [10yy yyyy] [10xx xxxx]*
Unicode: [1101 10ww] [wwzz zzyy] (high surrogate)
[1101 11yy] [yyxx xxxx] (low surrogate)
* uuuuu = wwww + 1
adjust length to read
perform read operation
skip read; last character was in error
NOTE: Having an offset value other than zero means that there was
an error in the last character read. In this case, we have
skipped the read so we don't consume any bytes past the
error. By signalling the error on the next block read we
allow the method to return the most valid characters that
it can on the previous block read. -Ac
convert bytes to characters
UTF-8:   [0xxx xxxx]
Unicode: [0000 0000] [0xxx xxxx]
UTF-8:   [110y yyyy] [10xx xxxx]
Unicode: [0000 0yyy] [yyxx xxxx]
UTF-8:   [1110 zzzz] [10yy yyyy] [10xx xxxx]
Unicode: [zzzz yyyy] [yyxx xxxx]
UTF-8:   [1111 0uuu] [10uu zzzz] [10yy yyyy] [10xx xxxx]*
Unicode: [1101 10ww] [wwzz zzyy] (high surrogate)
[1101 11yy] [yyxx xxxx] (low surrogate)
* uuuuu = wwww + 1
check if output buffer is large enough to hold 2 surrogate chars
decode bytes into surrogate characters
return number of characters converted
Special case for '@*/following::*' expressions. The resulting
iterator is initialised with the parent's first child, and this
can cause duplicates in the output if the parent has more than
one attribute that matches the left step.
Compile path iterator
iterator on stack....
Backwards branches are prohibited if an uninitialized object is
on the stack by section 4.9.4 of the JVM Specification, 2nd Ed.
We don't know whether this code might contain backwards branches
so we mustn't create the new object until after we've created
the suspect arguments to its constructor.  Instead we calculate
the values of the arguments to the constructor first, store them
in temporary variables, create the object and reload the
arguments from the temporaries to avoid the problem.
Create new StepIterator
Initialize StepIterator with iterators from the stack
This is a special case for the * path with or without predicates
the classes that these predefined types declare must exist!
OK: must not be a primitive wrapper
Should not reach here
Huge hack to avoid compiler warnings here.  The ElementType
parameter is ignored but allows us to obtain a type variable
T that matches <T extends Enum<T>>.
For historical reasons GcInfo implements CompositeData but we
shouldn't count its CompositeData.getCompositeType() field as
an item in the computed CompositeType.
skip other builders in this group
See if it has a method "T from(CompositeData)"
as is conventional for a CompositeDataView
OK: it doesn't have the method
java.beans not present
should not reach here
Applicable if and only if there are any annotated constructors
Now check that all the annotated constructors are valid
and throw an exception if not.
First link the itemNames to their getter indexes.
Run through the constructors making the checks in the spec.
For each constructor, remember the correspondence between its
parameters and the items.  The int[] for a constructor says
what parameter index should get what item.  For example,
if element 0 is 2 then that means that item 0 in the
CompositeData goes to parameter 2 of the constructor.  If an
element is -1, that item isn't given to the constructor.
Also remember the set of properties in that constructor
so we can test unambiguity.
The CompositeData might come from an earlier version where
not all the items were present.  We look for a constructor
that accepts just the items that are present.  Because of
the ambiguity check in applicable(), we know there must be
at most one maximally applicable constructor.
Should be name.offsetByCodePoints but 6242664 makes this fail
really an IdentityHashSet but that doesn't exist
Three possible actions for the translet:
The 3 different categories of strip/preserve rules (order important)
Should be replaced by NS type (int)
Should be replaced by node type (int)
Determine the action (strip or preserve) for this rule
Get the namespace and element name for this rule
Determine the initial priority for this rule
Get the strip/preserve type; either "NS:EL", "NS:*" or "*"
Strip/preserve _all_ elements
Strip/reserve elements within NS
Strip/preserve single element
Determine if this is an xsl:strip- or preserve-space element
Determine the import precedence
Get the list of elements to strip/preserve
Go through each element and instanciate strip/preserve-object
Get the next rule in the prioritized list
We only consider rules with higher priority
Sort all rules with regard to priority
Check if there are any "xsl:strip-space" elements at all.
If there are no xsl:strip elements we can ignore all xsl:preserve
elements and signal that all whitespaces should be preserved
Return with default action: PRESERVE_SPACE
Remove all rules that are contradicted by rules with higher priority
Remove this single rule if it has no purpose
Remove all following rules if this one overrides all
Skip to next rule (there might not be any)...
The rules vector could be empty if first rule has strength RULE_ALL
Now work backwards and strip away all rules that have the same
action as the default rule (no reason the check them at the end).
Signal that whitespace detection predicate must be used.
private boolean Translet.stripSpace(int type) - cannot be static
Traverse all strip/preserve rules
Get the next rule in the prioritised list
Returns the namespace for a node in the DOM
Handle elements="ns:*" type rule
Handle elements="ns:el" type rule
Create the QName for the element
Register the element.
Compare current node type with wanted element type
private boolean Translet.stripSpace(int type) - cannot be static
Get the core rules in prioritized order
The rules vector may be empty after prioritising
Now - create a predicate method and sequence through rules...
Return with the translets required action (
We don't return anything.
Check the access rights according to the MIB.
The MBean might be less restrictive (have a getter
while the MIB defines the variable as AFN)
java.lang.System.out.println(name + "variable[" + j +
java.lang.System.out.println(name + "variable[" +j +
call meta.check() here, and meta.check will call check()
XXX xxx ZZZ zzz Maybe we should go through the MBeanInfo here?
checkXXXX() not defined => do nothing
Note: JViewport is special cased as it does not allow for
a border to be set. JViewport.setBorder is overriden to throw
an IllegalArgumentException. Refer to SynthScrollPaneUI for
details of this.
If the colCount is Integer.MAX_VALUE,
we do not initialize the colInfo object.
even if we try to initialize the colCount with
colCount = Integer.MAx_VALUE-1, the colInfo
initialization fails throwing an ERROR
OutOfMemory Exception. So we do not initialize
colInfo at Integer.MAX_VALUE. This is to pass TCK.
examine java.sql.Type reflectively, loop on the fields and check
this. Separate out into a private method
Text positioning and alignment
PENDING(jeff) - hold icons in an array
Whether or not we've set the LayoutManager.
This is only used by JButton, promoted to avoid an extra
boolean field in JButton
TIGER - 4840653
Removed code which fired an AccessibleState.SELECTED
PropertyChangeEvent since this resulted in two
identical events being fired since
AbstractButton.fireItemStateChanged also fires the
same event. This caused screen readers to speak the
name of the item twice.
Cache the old margin if it comes from the UI
If the client passes in a null insets, restore the margin
from the UI if possible
No way to determine whether we are currently in
a rollover state, so repaint regardless
No way to determine whether we are currently in
a rollover state, so repaint regardless
Don't add if it is already a listener
This won't notify ActionListeners, but that should be
ok as the change is coming from the Action.
Make sure the change actually took effect
index out of range
We invoke setEnabled() from JComponent
because setModel() can be called from a constructor
when the button is not fully initialized
disabled icons are generated by the LF so they should be unset here
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
NOTE: This class is NOT used, instead the functionality has
been moved to Handler.
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Set the UI
We don't know about this image, disable the notification so
we don't keep repainting.
Listeners that are added to model
Check where the AccessibleContext's relation
set already contains a MEMBER_OF relation.
get the members of the button group if one exists
set the target of the MEMBER_OF relation to be
the members of the button group.
TIGER - 4422535
There is no caret.
Text cannot be selected.
Text cannot be selected.
Text cannot be selected.
Little wolf of rounding error
Better error bounds to add both terms as the final sum
end of Action.java
Ugly code... will go away when AST work is done.
Find the position of the last step.
Fix for http:nagoya.apache.org/bugzilla/show_bug.cgi?id=1336
These three statements need to be combined into one operation.
Yuck.  Just to shut up the compiler!
These two statements need to be combined into one operation.
Always call the superclass detach last!
Document and doctype counter.  Used to assign order to documents and
doctypes without owners, on an demand basis.   Used for
check if Xalan implementation is around and if yes report true for supporting
if a plus sign "+" is prepended to any feature name, implementations
are considered in which the specified feature may not be directly
castable DOMImplementation.getFeature(feature, version). Without a
plus, only features whose interfaces are directly castable are considered.
Check if the DOM XPath implementation implements
the interface org.w3c.dom.XPathEvaluator
REVISIT: this might allow creation of invalid name for DOCTYPE
also there is no way for a user to turn off error checking.
it is an error for NCName to have more than one ':'
check if it is valid QName [Namespace in XML production 6]
Namespace in XML production [6]
check that prefix is NCName
check local part
REVISIT: add qname parameter to the message
Check if the DOM XPath implementation implements
the interface org.w3c.dom.XPathEvaluator
DOM L3 LS
create default parser configuration validating against XMLSchemas
REVISIT: implement retrieving DTD validator
create new validator - we should not attempt
to restrict the number of validation handlers being
return first available validator
return first available validator
REVISIT: implement support for DTD validators as well
resize size of the validators
resize size of the validators
PENDING(rjrjr) Throw an exception if this fails?
Estimate size of array; be prepared to see more or fewer elements
fewer elements than expected
Estimate size of array; be prepared to see more or fewer elements
fewer elements than expected
more elements than expected
trim if overallocated
m_lastFetched = (DTM.NULL == m_lastFetched)
? m_traverser.first(m_context, m_extendedTypeID)
: m_traverser.next(m_context, m_lastFetched,
if(DTMFilter.SHOW_ALL == what ||
((DTMFilter.SHOW_ELEMENT & what) == 0)
|| localName == NodeTest.WILD
|| namespace == NodeTest.WILD)
Always call the superclass detach last!
remove the old html view client property if one
existed, and install a new one if the text installed
into the JLabel is html source.
When the accelerator is pressed, temporarily make the JLabel
focusTraversable by registering a WHEN_FOCUSED action for the
release of the accelerator.  Then give it focus so it can
prevent unwanted keyTyped events from getting to other components.
Need this when the sticky keys are enabled
Need this if ALT is released before the accelerator
inputMap should never be null.
should never be called
Passing chunks to add is safe
Future methods START
Future methods END
PropertyChangeSupports methods START
PropertyChangeSupports methods END
this creates daemon threads.
Don't use ShutdownHook here as it's not enough. We should track
AppContext disposal instead of JVM shutdown, see 6799345 for details
End of file.
message formatter; used to produce localized
Locale to use for messages
<init>(InputStream, MessageFormatter, Locale)
<init>(InputStream,int, MessageFormatter, Locale)
End of file.
If there is text
If there is an icon and no text
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of SplitPaneDividerPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of SplitPaneDividerPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
don't allow instantiation
assume empty namespaces are absolute
The following shouldn't create a runtime dependence on ldap package.
Disallow anyone from creating one of these.
Parse codebase into separate URLs
Do not adjust this except for special platforms:
/ Factory methods to create method handles:
Trigger selected static initializations.
safe to view non-strictly, because element type follows from array type
Atomically update accessor cache.
Throw away newly constructed accessor and use cached version.
/ Support for array element access
FIXME: Reduce number of bindings when there is more than one Class conversion.
FIXME: Reduce number of bindings when there are repeated conversions.
rebind if too complex
Calculate extra arguments (temporaries) required in the names array.
Now build a LambdaForm.
Collect the arguments to the outgoing call, maybe with conversions:
target MH is Name.function, name Name.arguments[0]
do nothing: difference is trivial
Build argument array for the call.
don't pass retval to void conversion
inlined Class.cast because we can't ForceInline it
caller must recognize this specially
Examples: int->byte, byte->int, boolean->int (!strict)
Examples: int->Integer, boolean->Object, float->Number
Corner case, such as int->Long, which will probably fail.
Use a strongly-typed unboxer, if possible.
Examples:  Object->int, Number->int, Comparable->int, Byte->int
must include additional conversions
src must be examined at runtime, to detect Byte, Character, etc.
Simple reference conversion.
Note:  Do not check for a class hierarchy relation
between src and dst.  In all cases a 'null' argument
will pass the cast conversion.
make sure this attribute is turned off
if arity and trailing parameter are compatible, do normal thing
build and cache a collector
extra assertion for non-strict checks:
Now build a LambdaForm.
Spread the array.
leave room for the final call
Build argument array for the call.
fall through to error:
(a..., c, [b...])=>r
in  arglist: [0: ...keep1 | cpos: collect...  | cpos+cacount: keep2... ]
out arglist: [0: ...keep1 | cpos: collectVal? | cpos+cvcount: keep2... ]
out(retain): [0: ...keep1 | cpos: cV? coll... | cpos+cvc+cac: keep2... ]
Now build a LambdaForm.
Build argument array for the target.
Incoming LF args to copy are: [ (mh) headArgs collectArgs tailArgs ].
Output argument array is [ headArgs (collectVal)? (collectArgs)? tailArgs ].
incoming LF args to copy to target
fill pointer for targetArgs
optionally pass on the collected chunk
all the rest
use of rest of input args also
Intrinsified by C2. Counters are used during parsing to calculate branch frequencies.
Profile is int[2] where [0] and [1] correspond to false and true occurrences respectively.
Avoid continuous overflow by halving the problematic count.
no need for a counting wrapper anymore
Try to limit number of updates. MethodHandle.updateForm() doesn't guarantee LF update visibility.
Reached invocation threshold. Replace counting behavior with a non-counting one.
speed up warmup by avoiding LF interpretation again after transition
start of incoming arguments
previous statement: either PROFILE or CALL_TEST
must be true to trigger IBG.emitSelectAlternative
call target or fallback
start of incoming arguments
FIXME: rework argument boxing/result unboxing logic for LF interpretation
Prepare auxiliary method handles used during LambdaForm interpreation.
Box arguments and wrap them into Object[]: ValueConversions.array().
Result unboxing: ValueConversions.unbox() OR ValueConversions.identity() OR ValueConversions.ignore().
Use asFixedArity() to avoid unnecessary boxing of last argument for VarargsCollector case.
Put the whole mess into its own nested class.
That way we can lazily load the code and set up the constants.
Do not use this function to inject calls into system classes.
does not happen, and should not anyway
For simplicity, convert mh to a varargs-like method.
Cache the result of makeInjectedInvoker once per argument class.
Self-check was blocked by security manager.  This is OK.
In fact the whole try body could be turned into an assertion.
force initialization of the class
Test the invoker, to ensure that it really injects into the right place.
Adapt mh so that it can be called directly from an injected invoker:
eliminate LFI stack frames
eliminate LFI stack frames
Undo the adapter effect of prepareForInvoker:
This method is called via MH_checkCallerClass and so it's
correct to ask for the immediate caller here.
The following class is used as a template for Unsafe.defineAnonymousClass:
side effect: initializes this class
This MH is an alias for target, except for the MemberName
Drop the MemberName if there is any conversion.
no intrinsic associated
This MH is an alias for target, except for the intrinsic name
Drop the name if there is any conversion.
/ Collection of multiple arguments.
current number of methods
filling versions of the above:
using Integer len instead of int len and no varargs to avoid bootstrapping problems
using Integer pos instead of int pos to avoid bootstrapping problems
current number of fillArray methods
there is no empty fill; at least a0 is required
Array identity function (used as Lazy.MH_arrayIdentity).
Build up the result mh as a sequence of fills like this:
The various fill(_,10*I,___*[J]) are reusable.
absorb some arguments immediately
no args to fill; return the array unchanged
we need room for both mh and a in mh.invoke(a, arg*[nargs])
build some precursors from left to right
Combine the two fills:
right(mid(a, x10..x19), x20..x23)
The final product will look like this:
right(mid(newArrayLeft(24, x0..x9), x10..x19), x20..x23)
Type-polymorphic version of varargs maker.
limit imposed by the JVM
FIXME: Need more special casing and caching here.
1 for receiver MH
other cases:  primitive arrays, subtypes of Object[]
must be weakly typed
link at the end of list
apply src's links to dst
overrides of HashMap hook methods
possibly remove eldest
move node to last
Some generic FileChooser functions
The accessoryPanel is a container to place the JFileChooser accessory component
Note: we can't depend on evt.getSource() because of backward
Strip trailing ".."
That's ok, we'll use f as is
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
Note: Don't return null for readOnly, it might
break older apps.
Strip trailing ".."
Ok, use f as is
Remove whitespaces from end of filename
no file selected, multiple selection off, therefore cancel the approve action
Unix: Resolve '~' to user's home directory
Optimize searching files by names in "children" array
check for wildcard pattern
Not a valid glob pattern. Abandon filter.
Check for directory change action
Do it again. This is a fix for bug 4949273 to force the
selected value in case the ListSelectionModel clears it
for non-existing file names.
On windows, a pattern ending with *.* is equal to ending with *
Traverse shortcuts on Windows
If linkedTo is null we try to use dir
PENDING(jeff) - pass in the icon cache size
Note: Returns display name rather than file name
remove the last newline
First, read all of the IIOP IOR data
Handle any tagged components (if applicable)
If there is no codebase in this IOR and there IS a
java.rmi.server.codebase property set, we need to
update the IOR with the local codebase.  Note that
there is only one instance of the local codebase, but it
can be safely shared in multiple IORs since it is immutable.
Whether codebase is null or not, we have it,
and so getCodebase ned never call uncachedGetCodebase.
Could not find the OA, so just return null.
This usually happens when POAs are being deleted,
and the POA always return null for getLocalServant anyway.
Before all the ckecks below we first see if it's an FTP provider or a focus cycle root.
If it's the case just go down cycle (if it's set to "implicit").
See if the component is inside of policy provider.
FTP knows how to find component after the given. We don't.
Null result means that we overstepped the limit of the FTP's cycle.
In that case we must quit the cycle, otherwise return the component found.
See if the component is inside of policy provider.
FTP knows how to find component after the given. We don't.
Null result means that we overstepped the limit of the FTP's cycle.
In that case we must quit the cycle, otherwise return the component found.
If the provider is traversable it's returned.
Verify that the Component is recursively enabled. Disabling a
heavyweight Container disables its children, whereas disabling
a lightweight Container does not.
From Graphics Gems:
substitute x = y - A/3 to eliminate quadratic term:
x^3 +Px + Q = 0
Since we actually need P/3 and Q/2 for all of the
calculations that follow, we will calculate
p = P/3
q = Q/2
instead and use those values for simplicity of the code.
Please see the comment in fixRoots marked 'XXX' before changing
any of the code in this case.
this must be done after the potential Arrays.copyOf
num == 3 || num == 2
Copies res[2] to res[1] if needed
preconditions: eqn != res && eqn[3] != 0 && num > 1
This method tries to improve the accuracy of the roots of eqn (which
should be in res). It also might eliminate roots in res if it decideds
that they're not real roots. It will not check for roots that the
computation of res might have missed, so this method should only be
used when the roots in res have been computed using an algorithm
that never underestimates the number of roots (such as solveCubic above)
below we use critCount to possibly filter out roots that shouldn't
have been computed. We require that eqn[3] != 0, so eqn is a proper
cubic, which means that its limits at -/+inf are -/+inf or +/-inf.
Therefore, if critCount==2, the curve is shaped like a sideways S,
and it could have 1-3 roots. If critCount==0 it is monotonic, and
if critCount==1 it is monotonic with a single point where it is
flat. In the last 2 cases there can only be 1 root. So in cases
where num > 1 but critCount < 2, we eliminate all roots in res
this just tries to improve the accuracy of the computed
roots using Newton's method.
we only need fx0 and fxe for the sign of the polynomial
at -inf and +inf respectively, so we don't need to do
fx0 = solveEqn(eqn, 3, x0); fxe = solveEqn(eqn, 3, xe)
if critCount == 1 or critCount == 0, but num == 3 then
something has gone wrong. This branch and the one below
would ideally never execute, but if they do we can't know
therefore, we can't use refineRootWithHint. But even if
we did know, being here most likely means that the
curve is very flat close to two of the computed roots
(or maybe even all three). This might make Newton's method
fail altogether, which would be a pain to detect and fix.
This is why we use a very stable bisection method.
XXX: here we assume that res[0] has better accuracy than res[1].
This is true because this method is only used from solveCubic
which puts in res[0] the root that it would compute anyway even
if num==1. If this method is ever used from any other method, or
if the solveCubic implementation changes, this assumption should
be reevaluated, and the choice of goodRoot might have to become
goodRoot = (abs(eqn'(res[0])) > abs(eqn'(res[1]))) ? res[0] : res[1]
where eqn' is the derivative of eqn.
If a cubic curve really has 2 roots, one of those roots must be
at a critical point. That can't be goodRoot, so we compute x to
be the farthest critical point from goodRoot. If there are two
roots, x must be the second one, so we evaluate eqn at x, and if
it is zero (or close enough) we put x in res[1] (or badRoot, if
|solveEqn(eqn, 3, badRoot)| < |solveEqn(eqn, 3, x)| but this
shouldn't happen often).
else there can only be one root - goodRoot, and it is already in res[0]
use newton's method.
We count the "Y" crossings to determine if the point is
inside the curve bounded by its closing line.
Trivially reject non-existant rectangles
the intended return value is
numCrossings != 0 || numCrossings == Curve.RECT_INTERSECTS
but if (numCrossings != 0) numCrossings == INTERSECTS won't matter
and if !(numCrossings != 0) then numCrossings == 0, so
numCrossings != RECT_INTERSECT
we call this with the curve's direction reversed, because we wanted
to call rectCrossingsForLine first, because it's cheaper.
this shouldn't happen, since we are Cloneable
Revisit :: change to a better data structure.
DOM Level 3: normalizeDocument
support of XPath API
Did version change at any point when the document was created ?
this field helps us to optimize when normalizingDocument.
Document number.   Documents are ordered across the implementation using
positive integer values.  Documents are assigned numbers on demand.
Node counter and table.  Used to assign numbers to nodes for this
document.  Node number values are negative integers.  Nodes are
assigned numbers on demand.
by default 1.0
even though ownerDocument refers to this in this implementation
the DOM Level 2 spec says it must be null, so make it appear so
clone the children by importing them
Build a reverse mapping from element to identifier.
Copy children into new document.
Only one such child permitted
Adopt orphan doctypes
If insert succeeded, cache the kid appropriately
If remove succeeded, un-cache the kid appropriately
Adopt orphan doctypes
if a plus sign "+" is prepended to any feature name, implementations
are considered in which the specified feature may not be directly
castable DOMImplementation.getFeature(feature, version). Without a
plus, only features whose interfaces are directly castable are
If an XPathEvaluator was created previously
return it otherwise create a new one.
Check if the DOM XPath implementation implements
the interface org.w3c.dom.XPathEvaluator
other document methods
Currently implemented as a singleton, since it's hardcoded
we need to change the flag value only --
when the version set is different than already set.
change the normalization value back to false
NOT_SUPPORTED_ERR: Raised if the vesion is set to a value that is not supported by
we dont support any other XML version
fire user data NODE_RENAMED event
fire user data NODE_RENAMED event
we need to create a new object
register event listeners on new node
remove user data from old node
remove old node from parent if any
move children to new node
move specified attributes to new node
attach user data to new node
and fire user data NODE_RENAMED event
insert new node where old one was
fire ElementNameChanged event
dettach attr from element
reattach attr to element
fire user data NODE_RENAMED event
reattach attr to element
fire user data NODE_RENAMED event
we need to create a new object
register event listeners on new node
remove user data from old node
move children to new node
attach user data to new node
and fire user data NODE_RENAMED event
reattach attr to element
fire AttributeNameChanged event
No need to normalize if already normalized.
set the XMLversion changed value to false -- once we have finished
attribute value is always empty string
REVISIT: what should happen in this case?
DOM L3 LS
does nothing by default - overidden in subclass
does nothing by default - overriden in subclass
non-DOM factory methods
other non-DOM methods
Check if the node is already in the hash
If so, retrieve the node number
If not, assign a number to the node
Node numbers are negative, from -1 to -n
Sigh. This doesn't work; too many nodes have private data that
would have to be manually tweaked. May be able to add local
shortcuts to each nodetype. Consider ?????
if(source instanceof NodeImpl &&
!(source instanceof DocumentImpl))
Can't clone DocumentImpl since it invokes us...
Create element according to namespace support/qualification.
Copy element's attributes, if any.
NOTE: this methods is used for both importingNode
and cloning the document node. In case of the
clonning default attributes should be copied.
But for importNode defaults should be ignored.
Attach attribute according to namespace
Register element identifier.
Does element have an associated identifier?
if source is an AttrImpl from this very same implementation
avoid creating the child nodes if possible
According to the DOM spec the kids carry the value.
However, there are non compliant implementations out
there that fail to do so. To avoid ending up with no
value at all, in this case we simply copy the text value
the subtree is created according to this doc by the method
above, so avoid carrying over original subtree
Kids carry additional value,
allow deep import temporarily
unless this is used as part of cloning a Document
forbid it for the sake of being compliant to the DOM spec
Values are on NamedNodeMaps
NOTE: At this time, the DOM definition of DocumentType
doesn't cover Elements and their Attributes. domimpl's
extentions in that area will not be preserved, even if
copying from domimpl to domimpl. We could special-case
that here. Arguably we should. Consider. ?????
No name, kids carry value
Kids carry additional value
No name, no value
Can't import document nodes
Unknown node type
If deep, replicate and attach the kids.
source node comes from a different DOMImplementation
Return null if the source is null
when the source node comes from a different implementation.
Adopting from a DefferedDOM to DOM
traverse the DOM and expand deffered nodes and then allow adoption
Adopting from a DOM into a DefferedDOM, this should be okay
Adopting between two dissimilar DOM's is not allowed
remove node from wherever it is
1. owner element attribute is set to null
2. specified flag is set to true
3. change ownership
entity, notation nodes are read only nodes.. so they can't be adopted.
runtime will fall through to NOTATION_NODE
document, documentype nodes can't be adopted.
runtime will fall through to DocumentTypeNode
remove node from wherever it is
discard its replacement value
set its new replacement value if any
remove node from wherever it is
reconcile default attributes
remove node from wherever it is
DOM L3 Core CR
check that the element is in the tree
DOM2: Namespace methods
Public static methods
check that both prefix and local part match NCName
revoke previous ownership
c.next = null; not necessary, except for confused people...
Temporarily comment out this method, because
1. It seems that finalizers are not guaranteed to be called, so the
functionality is not implemented.
2. It affects the performance greatly in multi-thread environment.
it is an error for NCName to have more than one ':'
check if it is valid QName [Namespace in XML production 6]
:camera , nikon:camera:minolta, camera:
check that both prefix and local part match NCName
REVISIT: add qname parameter to the message
REVISIT: Implement to optimize when normalization
we should be checking the (elements, attribute, entity etc.) names only when
version of the document is changed.
Event related methods overidden in subclass
does nothing by default - overidden in subclass
does nothing by default - overidden in subclass
does nothing by default - overidden in subclass
does nothing by default - overidden in subclass
Notification methods overidden in subclasses
Convert Maps to Hashtables
e.getValue() will not be null since an entry is always put with a non-null value
Write serialized fields
userData is the original name. It has been changed to nodeUserData, refer to the corrsponding @serialField
We have to read serialized fields first.
userData is the original name. It has been changed to nodeUserData, refer to the corrsponding @serialField
convert Hashtables back to HashMaps
8 is a byte size. Common to any InetAddress (V4 or V6).
8 is a byte size. Common to any InetAddress (V4 or V6).
we don't need to add members because the ip address is a subnet mask
TextCatalogReader.java - Read text/plain Catalog files
Skip over leading whitespace and comments
skip leading whitespace
all ctrls are whitespace
now 'ch' is the current char from the file
we've found a comment, skip it...
Ok, we've found the end of the comment,
loop back to the top and start again...
return the next whitespace or comment delimited
Use Integer.MAX_VALUE instead of getRowCount() in case rows were deleted.
The Map for DTM to mapping array
Cache the DTM and mapping that are used last time
%OPT% The mapping array does not have information about all the
exptypes. However it does contain enough information about all names
in the translet's namesArray. If the expType does not fall into the
range of the mapping array, it means that the expType is not for one
of the recognized names. In this case we can just set the type to -1.
Iterate over the supported key types until one produces a public key.
Do nothing, try the next type
Do nothing, try the next type
read and discard the repository ID
write the repository ID
most of the texts are already in the collapsed form.
so look for the first whitespace in the hope that we will
never see it.
the input happens to be already collapsed.
we now know that the input contains spaces.
let's sit down and do the collapsing normally.
skip this character
remove trailing whitespaces
whitespaces are already collapsed,
so all we have to do is to remove the last one character
if it's a whitespace.
most of the characters are non-control characters.
so check that first to quickly return false for most of the cases.
other than we have to do four comparisons.
============ privates ============
Short cuts to constant pool
We could either leave this on, which wouldn't be secure,
or obscure the composted text, which essentially makes displaying
it useless. Therefore, we turn off input methods.
--- JTextComponent methods ----------------------------------
use the non-String API
--- variables -----------------------------------------------
Treat the text displayed in the JPasswordField
as one word and sentence.
There is no word or sentence after the text
displayed in the JPasswordField.
There is no word or sentence before the text
displayed in the JPasswordField.
Treat the text displayed in the JPasswordField
as one word, sentence, line and attribute run
There is no word, sentence, line or attribute run
after the text displayed in the JPasswordField.
There is no word, sentence, line or attribute run
before the text displayed in the JPasswordField.
Print constant to string depending on its type
The base name of the method name which will be prefixed with the
read and write method. If name == "foo" then the baseName is "Foo"
If this class or one of its base classes allow PropertyChangeListener,
then we assume that any properties we discover are "bound".
See Introspector.getTargetPropertyInfo() method.
The read method was explicitly set to null.
Since there can be multiple write methods but only one getter
method, find the getter method first so that you know what the
property type is.  For booleans, there can be "is" and "get"
methods.  If an "is" method exists, this is the official
reader method so look for this one first.
The property type is determined by the read method.
The write method was explicitly set to null.
We need the type to fetch the correct method.
Can't use getPropertyType since it will lead to recursive loop.
Without the correct property type we can't be guaranteed
to find the correct method.
Set the property type - which validates the method
don't replace a subclass with a superclass
Note: perhaps this should be a protected method in FeatureDescriptor
Figure out the merged read method.
Normally give priority to y's readMethod.
However, if both x and y reference read methods in the same class,
give priority to a boolean "is" method over a boolean "get" method.
Calculate once since capitalize() is expensive.
choose second method
choose first method
choose second method by default
choose first method: it declared later
choose first method: it overrides return type
choose second method by default
choose first method: it overrides parameter
choose second method
Cached information needed for local dispatch
If isNextIsLocalValid.get() == Boolean.TRUE,
the next call to isLocal should be valid
Normally, this test will never fail.  However, if the servant
and the stub were loaded in different class loaders, this test
When servant_preinvoke returns null, the stub will
recursively re-invoke itself.  Thus, the next call made from
the stub is another useLocalInvocation call.
End of file.
The method cloneIterator() also does resetting
wrap native call to allow instrumentation
'Random access' stuff
Some "reading/writing Java data types" methods stolen from
DataInputStream and DataOutputStream.
old impls do not support connect/disconnect
socket is now connected by the impl
Do we need to filter some packets?
connection will be emulated by DatagramSocket
create a datagram socket.
DatagramSocketImpl.peekdata() is a protected method, therefore we need to use
getDeclaredMethod, therefore we need permission to access the member
creates a udp socket
check the address is ok wiht the security manager on every send.
The reason you want to synchronize on datagram packet
is because you don't want an applet to change the address
while you are trying to send the packet for example
after the security check but before the send.
Check whether the socket is bound
call the  method to send
check the address is ok with the security manager before every recv.
peek at the packet to see who it is from.
We can use the new peekData() API
security check succeeded - so now break
and recv the packet.
Throw away the offending packet by consuming
it in a tmp buffer.
silently discard the offending packet
and continue: unknown/malicious
entities on nets should not make
runtime throw security exception and
disrupt the applet by sending random
end of while
We have to do the filtering the old fashioned way since
the native impl doesn't support connect or the connect
via the impl failed, or .. "explicitFilter" may be set when
a socket is connected via the impl, for a period of time
when packets from other sources might be queued on socket.
peek at the packet to see who it is from.
We can use the new peekData() API
this api only works for IPv4
throw the packet away and silently continue
If the security check succeeds, or the datagram is
connected then receive the packet
packet was not filtered, account for it here
Integer instead of Boolean for compatibility with older DatagramSocketImpl
not supported if socket already connected
Solaris returns error in such cases
ResolvingParser.java - An interface for reading catalog files
Ideally this method would not attempt to open the
InputStream, but there is a bug (in Xerces, at least)
that causes the parser to mistakenly open the wrong
system identifier if the returned InputSource does
not have a byteStream.
It could be argued that we still shouldn't do this here,
but since the purpose of calling the entityResolver is
almost certainly to open the input stream, it seems to
do little harm.
don't make instances
-- Swapping --
-- get/put char --
-- get/put short --
-- get/put int --
-- get/put long --
-- get/put float --
-- get/put double --
-- Unsafe access --
-- Processor and memory-system properties --
-- Direct memory management --
A user-settable upper limit on the maximum amount of allocatable
direct buffer memory.  This value may be changed during VM
initialization if it is launched with "-XX:MaxDirectMemorySize=<size>".
max. number of sleeps during try-reserving with exponentially
increasing delay before throwing OutOfMemoryError:
1, 2, 4, 8, 16, 32, 64, 128, 256 (total 511 ms ~ 0.5 s)
which means that OOME will be thrown after 0.5 s of trying
These methods should be called whenever direct memory is allocated or
freed.  They allow the user to control the amount of direct memory
which a process may access.  All sizes are specified in bytes.
retry while helping enqueue pending Reference objects
which includes executing pending Cleaner(s) which includes
Cleaner(s) that free direct buffer memory
trigger VM's Reference processing
a retry loop with exponential back-off delays
(this gives VM some time to do it's job)
don't swallow interrupts
-XX:MaxDirectMemorySize limits the total capacity rather than the
actual memory usage, which will differ when buffers are page
-- Monitoring of direct buffer usage --
setup access to this package in SharedSecrets
-- Bulk get/put acceleration --
These numbers represent the point at which we have empirically
determined that the average cost of a JNI call exceeds the expense
of an element by element copy.  These numbers may change over time.
This number limits the number of bytes to copy per call to Unsafe's
copyMemory method. A limit is imposed to allow for safepoint polling
during a large copy
These methods do no bounds checking.  Verification that the copy will not
result in memory corruption should be done prior to invocation.
All positions and lengths are specified in bytes.
Define system property "jaxp.debug" to get output
Use try/catch block to support applets, which throws
SecurityException out of this code.
Allow simply setting the prop to turn on debug
Use current class loader - should always be bootstrap CL
make sure we have access to restricted packages
Extra check to avoid computing cl strings
Use the system property first
try to read from $java.home/lib/jaxp.properties
Try Jar Service Provider Mechanism
XXX remove this once getProfile is gone
The check for typeId length of 0 below is commented out
as a workaround for a bug in ORBs which send a
null objref with a non-empty typeId string.
Maps ObjectKeyTemplate to IORTemplate
used to check that all profiles have the same oid.
Check that all oids for all profiles are the same: if they are not,
Find or create the IORTemplate for oktemp.
if we come to this point then no IIOP Profile
is present.  Therefore, throw an exception.
XXX This is fully initialized here.  So do we ever want to
generalize this (or perhaps this is the wrong place for this?)
Make sure that we are ready to handle -ORBInitRef.  This is special
due to the need to handle multiple -ORBInitRef args as prefix
Public interface defined in DataCollector
public interface from DataCollector that must be defined
Implementation methods needed in subclasses
methods for use by subclasses
All command-line args are of the form "-ORBkey value".
The key is mapped to <prefix>.ORBkey.
Cannot use propertyPrefixes here, since there is no
way to fetch properties by prefix from an Applet.
Convert any applet parameter relative URLs to an
absolute URL based on the Document Root. This is so HTML
URLs can be kept relative which is sometimes useful for
managing the Document Root layout.
Just preserve the original (malformed) value:
the error will be handled later.
Map System properties to ORB properties.
Security bug fix 4278205:
Only allow reading of system properties with ORB prefixes.
Previously a malicious subclass was able to read ANY system property.
Note that other prefixes are fine in other contexts; it is only
system properties that should impose a restriction.
Store name, value in resultProps, with special
treatment of ORBInitRef.  All updates to resultProps
must happen through this method.
Value is <name>=<URL>
For each prefix in prefixes, For each name in propertyNames,
if (prefix is a prefix of name) get value from getProperties and
setProperty (name, value).
Note: do a put even if value is null since just
the presence of the property may be significant.
For each prefix in names, get the corresponding property
value from the callback, and store the name/value pair in
Map command-line arguments to ORB properties.
This will not throw a SecurityException because this
class was loaded from rt.jar using the bootstrap classloader.
dprint( "ORB properties file " + fileName + " not found: " +
Return only those element of prefixes for which hasCORBAPrefix
Used to collect properties from various sources.
Translate to ParserConfigurationException
If this is the secure processing feature, save it then return.
XXX This is ugly.  We have to collect the features and then
later create an XMLReader to verify the features.
Test the feature by possibly throwing SAX exceptions
Check for valid name by creating a dummy XMLReader to get
Common UI methods
Numbers from the OSF code set registry version 1.2g.
Please see the individual Entry definitions for
wrap native call to allow instrumentation
EOF already encountered
acquire file descriptor and do the read
Prevent recursion. See BugId 4484411
Get the required attributes and parser XPath expressions
Parse key name and add to symbol table
Make sure required attribute(s) have been set
Type check match pattern
Cast node values to string values (except for nodesets)
DOM.getStringValueX(nodeIndex) => String
AbstractTranslet.SetKeyIndexDom(name, Dom) => void
This variable holds the id of the node we found with the "match"
attribute of xsl:key. This is the id we store, with the value we
get from the nodes we find here, in the index for this key.
Get the 'parameter' from the stack and store it in a local var.
Save current node and current iterator on the stack
Overwrite current iterator with one that gives us only what we want
Now get the node value and push it on the parameter stack
Finally do the call to add an entry in the index for this key.
Go on to next matching node....
Restore current node and current iterator from the stack
AbstractTranslet.buildKeyIndex(name,node_id,value) => void
AbstractTranslet.SetKeyIndexDom(name, Dom) => void
DOM.getAxisIterator(root) => NodeIterator
Get an iterator for all nodes in the DOM
Reset the iterator to start with the root node
Loop for traversing all nodes in the DOM
Check if the current node matches the pattern in "match"
Leaves 0 or 1 on stack
If this is a node-set we must go through each node in the set
Pass current node as parameter (we're indexing on that node)
Get the next node from the iterator and do loop again...
Restore current node and current iterator from the stack
Equivalent to JOptionPane.createDialog,
but create a modeless dialog.
This is necessary because the Solaris implementation doesn't
support Dialog.setModal yet.
Once window gets focus, set initial focus
Accessibility support for ProgressOptionPane
Notify the AccessibleProgressMonitor that the
ProgressOptionPane was created. It is necessary
to poll for ProgressOptionPane creation because
the ProgressMonitor does not have a Component
to add a listener to until the ProgressOptionPane
add a listener for progress bar ChangeEvents
add a listener for note label PropertyChangeEvents
the progress bar value changed
the note label text changed
defined in AccessibleContext
delegate to the AccessibleJOptionPane
defined in AccessibleContext
delegate to the AccessibleJOptionPane
delegate to the AccessibleJOptionPane
delegate to the AccessibleJOptionPane
return the number of children in the JPanel containing
the message, note label and progress bar
return a child in the JPanel containing the message, note label
and progress bar
delegate to the AccessibleJOptionPane
delegate to the AccessibleJOptionPane
delegate to the AccessibleJProgressBar
AccessibleJLabel implements AccessibleText if the
JLabel contains HTML text
convert point from the option pane bounds
to the note label bounds.
return rectangle in the option pane bounds
JLabel contains HTML text
JLabel contains HTML text
JLabel contains HTML text
JLabel contains HTML text
JLabel contains HTML text
JLabel contains HTML text
JLabel contains HTML text
JLabel contains HTML text
JLabel contains HTML text
inner class AccessibleProgressMonitor
if any static fields are found, an exception
should be thrown
get Class. Object instance should always be available
determine if object implements Serializable i/f
can only determine public fields (obviously). If
any of these are static, this should invalidate
the action of attempting to persist these fields
in a serialized form
this shouldn't happen, since we are Cloneable
Draw the arrow
Draw the arrow
Draw the arrow
Draw the arrow
Required for serialization interoperability with JSR 28
Override Throwable.toString() to conform to JSR 28
NOTE: As of JDK 8, this class instantiates
sun.security.provider.ConfigFile.Spi and forwards all methods to that
implementation. All implementation fixes and enhancements should be made to
sun.security.provider.ConfigFile.Spi and not this class.
See JDK-8005117 for more information.
Disallow subsequent initCause
Disallow subsequent initCause
Disallow subsequent initCause
property identifier:  ValidationManager
recognized features and properties
should be diplayed trace resolving messages
are the entities being parsed in the external subset?
NOTE:  this *is not* the same as whether they're external entities!
for entity managers not created by parsers
pass a reference to current entity being scanned
search for the first external entity on the stack
default to 1.0
First chance checking strict URI
setup URLConnection if we have an HTTPInputSource
set request properties
set preference for redirection
REVISIT: If the URLConnection has external encoding
information, we should be reading it here. It's located
in the charset parameter of Content-Type. -- mrglavas
E43: Check if the URL was redirected, and then
update literal and expanded system IDs if needed.
wrap this stream in RewindableInputStream
perform auto-detect of encoding if necessary
read first four bytes and determine encoding
Special case UTF-8 files with BOM created by Microsoft
tools. It's more efficient to consume the BOM than make
the reader perform extra checks. -Ac
ignore first three bytes...
use specified encoding
If encoding is UTF-8, consume BOM if one is present.
First three bytes are not BOM, so reset.
If encoding is UTF-16, we still need to read the first four bytes
in order to discover the byte order.
UTF-16, big-endian, no BOM
UTF-16, little-endian, no BOM
If encoding is UCS-4, we still need to read the first four bytes
in order to discover the byte order.
Ignore unusual octet order for now.
UCS-4, big endian (1234)
UCS-4, little endian (1234)
If encoding is UCS-2, we still need to read the first four bytes
in order to discover the byte order.
UCS-2, big endian
UCS-2, little endian
read one character at a time so we don't jump too far
ahead, converting characters from the byte stream in
the wrong encoding
We've seen a new Reader.
Push it on the stack so we can close it later.
push entity on stack
setupCurrentEntity(String, XMLInputSource, boolean, boolean):  String
this should only be used with caution by callers that
carefully manage the entity manager's behaviour, so that
this doesn't returning meaningless or misleading data.
this function returns StaxXMLInputSource
if no base systemId given, assume that it's relative
to the systemId of the current scanned entity
Sometimes the system id is not (properly) expanded.
We need to expand the system id if:
a. the expanded one was null; or
b. the base system id was null, but becomes non-null from the current entity.
REVISIT:  why would the baseSystemId ever be null?  if we
didn't have to make this check we wouldn't have to reuse the
give the entity resolver a chance
either of Stax or Xerces would be null
wrap this XMLInputSource to StaxInputSource
do default resolution
this works for both stax & Xerces, if staxInputSource is null, it means parser need to revert to default resolution
REVISIT: when systemId is null, I think we should return null.
is this the right solution? -SG
if (systemId != null)
Waiting for the clarification from EG. - nb
if no base systemId given, assume that it's relative
to the systemId of the current scanned entity
Sometimes the system id is not (properly) expanded.
We need to expand the system id if:
a. the expanded one was null; or
b. the base system id was null, but becomes non-null from the current entity.
REVISIT:  why would the baseSystemId ever be null?  if we
didn't have to make this check we wouldn't have to reuse the
give the entity resolver a chance
do default resolution
REVISIT: what's the correct behavior if the user provided an entity
resolver (fEntityResolver != null), but resolveEntity doesn't return
an input source (xmlInputSource == null)?
do we do default resolution, or do we just return null? -SG
REVISIT: when systemId is null, I think we should return null.
is this the right solution? -SG
if (systemId != null)
was entity declared?
should we skip external entities?
is entity recursive?
resolve external entity
let the not-LoadExternalDTD or not-SupportDTD process to handle the situation
wrap internal entity
start the entity
xxx these methods are not required.
indicate start of external subset so that
location of entity decls can be tracked
when entity expansion limit is set by the Application, we need to
check for the entity expansion limit set by the parser, if number of entity
expansions exceeds the entity expansion limit, parser will throw fatal error.
Note that this represents the nesting level of open entities.
is there anything better to do than reset the counter?
at least one can envision debugging applications where this might
pop the entity from the stack
close the reader
close the reader
so this is the last opened entity, signal it to current fEntityHandler using Augmentation
check if it is a document entity
set popped entity as current entity
check if there are any entity left in the stack -- if there are
no entries EOF has been reached.
throw exception when it is the last entity but it is not a document entity
Zephyr feature ignore-external-dtd is the opposite of Xerces' load-external-dtd
JAXP 1.5 feature
parser settings have not been changed
JAXP 1.5 feature
reset general state
reset general state.  Should not be called other than by
a class acting as a component manager but not
implementing that interface for whatever reason.
should never happen
JAXP 1.5 properties
Public static methods
Public static methods
current value of the "user.dir" property
cached URI object for the current value of the escaped "user.dir" property stored as a URI
which ASCII characters need to be escaped
the first hex character if a character needs to be escaped
the second hex character if a character needs to be escaped
initialize the above 3 arrays
To escape the "user.dir" system property, by using %HH to represent
special ASCII characters: 0x00~0x1F, 0x7F, ' ', '<', '>', '#', '%'
and '"'. It's a static method, so needs to be synchronized.
this method looks heavy, but since the system property isn't expected
to change often, so in most cases, we only need to return the URI
that was escaped before.
According to the URI spec, non-ASCII characters (whose value >= 128)
need to be escaped too.
REVISIT: don't know how to escape non-ASCII characters, especially
which encoding to use. Leave them for now.
get the user.dir property
return empty string if property value is empty string.
compute the new escaped value if the new property value doesn't
match the previous one
record the new value as the global property value
change C:/blah to /C:/blah
for each character in the path
if it's not an ASCII character, break here, and use UTF-8 encoding
record the fact that it's escaped
we saw some non-ascii character
get UTF-8 bytes for the remaining sub-string
should never happen
for each byte
for non-ascii character: make it positive, then escape
change blah/blah to blah/blah/
check for bad parameters id
if id already expanded, return
for xml schemas we might have baseURI with
a specified drive
let it go through
check if there is a system id before
trying to expand it.
system id has to be a valid URI
if it's already an absolute one, return it
if there isn't a base uri, use the working directory
otherwise, use the base uri
assume "base" is also a relative uri
absolutize the system id using the base
return the string rep of the new uri (an absolute one)
if any exception is thrown, it'll get thrown to the caller.
Assume the URIs are well-formed. If it turns out they're not, try fixing them up.
check for bad parameters id
for xml schemas we might have baseURI with
a specified drive
let it go through
If it's already an absolute one, return it
If there isn't a base URI, use the working directory
assume "base" is also a relative uri
absolutize the system identifier using the base URI
return the string rep of the new uri (an absolute one)
if any exception is thrown, it'll get thrown to the caller.
setInstanceFollowRedirects doesn't exist.
If it's already an absolute one, return it
If there isn't a base URI, use the working directory
assume "base" is also a relative uri
absolutize the system identifier using the base URI
return the string rep of the new uri (an absolute one)
if any exception is thrown, it'll get thrown to the caller.
If it's already an absolute one, return it
If there isn't a base URI, use the working directory
assume "base" is also a relative uri
absolutize the system identifier using the base URI
return the string rep of the new uri (an absolute one)
if any exception is thrown, it'll get thrown to the caller.
UTF-16, with BOM
default to UTF-8 if we don't have enough bytes to make a
good determination of the encoding
UTF-8 with a BOM
default to UTF-8 if we don't have enough bytes to make a
good determination of the encoding
UCS-4, big endian (1234)
UCS-4, little endian (4321)
UCS-4, unusual octet order (2143)
REVISIT: What should this be?
UCS-4, unusual octect order (3412)
REVISIT: What should this be?
UTF-16, big-endian, no BOM
(or could turn out to be UCS-2...
REVISIT: What should this be?
UTF-16, little-endian, no BOM
(or could turn out to be UCS-2...
a la xerces1, return CP037 instead of EBCDIC here
normalize encoding name
try to use an optimized reader
sould never happen with this encoding...
check for valid name
NOTE: AndyH suggested that, on failure, we use ISO Latin 1
because every byte is a valid ISO Latin 1 character.
It may not translate correctly but if we failed on
the encoding anyway, then we're expecting the content
of the document to be bad. This will just prevent an
invalid UTF-8 sequence to be detected. This is only
important when continue-after-fatal-error is turned
try to use a Java reader
see comment above.
createReader(InputStream,String, Boolean): Reader
search for the first external entity on the stack
search for the first external entity on the stack
search for the first external entity on the stack
search for the first external entity on the stack
Protected static methods
handle platform dependent strings
change "C:blah" to "/C:blah"
change "blah" to "file:blah"
replace spaces in file names with %20.
Original comment from JDK5: the following algorithm might not be
very performant, but people who want to use invalid URI's have to
pay the price.
put characters before ' ' into the string builder
and %20 for the space
for the remamining part, also convert ' ' to "%20".
Package visible methods
end of RewindableInputStream class
Table of indices into
Go up the tree, cancel right siblings of this node and all parents
If node is a left child of parent, then has a right sibling
raises exception on error
CORBA formal 00-11-0 15.4.2.2 GIOP 1.2 body must be
aligned on an 8 octet boundary.
Ensures that the first read operation called from the stub code,
during body deconstruction, would skip the header padding, that was
inserted to ensure that the body was aligned on an 8-octet boundary.
The code below reads the reply body in some cases
SYSTEM_EXCEPTION & LOCATION_FORWARD & LOCATION_FORWARD_PERM &
do nothing. The client stub will read the exception from body.
read GIOP::AddressingDisposition from body and resend the
original request using the requested addressing mode. The
resending is transparent to the client program.
Note, this writes only the header information. SystemException or
IOR or GIOP::AddressingDisposition may be written afterwards into the
reply mesg body.
CORBA formal 00-11-0 15.4.2.2 GIOP 1.2 body must be
aligned on an 8 octet boundary.
Ensures that the first write operation called from the stub code,
during body construction, would insert a header padding, such that
the body is aligned on an 8-octet boundary.
OASISXMLCatalogReader.java - Read XML Catalog files
Implement the SAX ContentHandler interface
This is an XML Catalog entry
nop, start of catalog
nop, a group
This is equivalent to an invalid catalog entry type
This is a TR9401 Catalog entry
This is equivalent to an invalid catalog entry type
Re-declares the methods that are in class MBeanAttributeInfo of JMX 1.0
(these will be removed when MBeanAttributeInfo is made a parent interface of this interface)
methods specific to open MBeans are inherited from
we need to override these methods in both places.  Ah for
This needs to be refactored!!!  - NG
skip leading whitespace
REVISIT:  it could really only be \n or 0x20; all else is normalized, no?  - neilg
take the first whitespace as a space and skip the others
if we finished on a space let's trim it
returns true if the given character is not
valid with respect to the version of
XML understood by this scanner.
returns true if the given character is not
valid or may not be used outside a character reference
with respect to the version of XML understood by this scanner.
returns true if the given character is
a valid nameChar with respect to the version of
XML understood by this scanner.
returns true if the given character is
a valid nameStartChar with respect to the version of
XML understood by this scanner.
returns true if the given character is
a valid NCName character with respect to the version of
XML understood by this scanner.
returns true if the given character is
a valid high surrogate for a nameStartChar
with respect to the version of XML understood
by this scanner.
note that, according to 4.3.4 of the XML 1.1 spec, XML 1.1
documents may invoke 1.0 entities; thus either version decl (or none!)
is allowed to appear in this context
returns the error message key for unsupported
versions of XML with respect to the version of
XML understood by this scanner.
compute format string for this lexical representation.
current parser needs a format string,
use following heuristics to figure out what xml schema date/time
datatype this lexical string could represent.
Fix 4971612: invalid SCCS macro substitution in data string,
found Date Time separater, must be xsd:DateTime
found ":", must be xsd:Time
check for gDay || gMonth || gMonthDay
per XML Schema Errata, used to be --MM--(z?)
gMonthDay, --MM-DD(z?), (or invalid lexicalRepresentation)
length should be:
check for Date || GYear | GYearMonth
start at index 1 to skip potential negative sign for year.
found timezone, strip it off for distinguishing
between Date, GYear and GYearMonth so possible
negative sign in timezone is not mistaken as
Date or invalid lexicalRepresentation
Fix 4971612: invalid SCCS macro substitution in data string
check for validity
"\"" + lexicalRepresentation + "\" is not a valid representation of an XML Gregorian Calendar value."
field initializers already do the correct initialization.
check for validity
Calendar.MONTH is zero based, XSD Date datatype's month field starts
with JANUARY as 1.
Calendar ZONE_OFFSET and DST_OFFSET fields are in milliseconds.
both are defined
only year is defined
neither are defined
or only eon is defined which is not valid without a year
TODO: Non-optimal solution for now.
Efficient implementation would only store as BigDecimal
when needed and millisecond otherwise.
Treat ZERO as field being undefined.
while 0-24 is acceptable in the lexical space, 24 is not valid in value space
W3C XML Schema Part 2, Section 3.2.7.1
leap second allows for 60
must test hour after setting seconds
must test hour after setting seconds
both instances are in same timezone or
both are FIELD_UNDEFINED.
Avoid costly normalization of timezone to 'Z' time.
Both instances have different timezones.
Normalize to UTC time and compare.
C. step 1
C. step 2
C. step 3
Q.getTimezone() != DatatypeConstants.FIELD_UNDEFINED
P has no timezone and Q does.
D. step 1
D. step 2
D. step 3
if timezone was undefined, leave it undefined
if milliseconds was undefined, leave it undefined
normalizing to UTC time negates the timezone offset before
set to zulu UTC time.
Eon field is only equal when null.
optimized case for comparing year not requiring eon field.
fields are either equal in value or both undefined.
Step B. 1.1 AND optimized result of performing 1.1-1.4.
Step B. 1.2
Step B. 1.3-4.
optimization. especially when both arguments are null.
Following two dates compare to EQUALS since in different timezones.
2000-01-15T12:00:00-05:00 == 2000-01-15T13:00:00-04:00
Must ensure both instances generate same hashcode by normalizing
this to UTC timezone.
Fix 4971612: invalid SCCS macro substitution in data string
since setters do not allow for invalid values,
(except for exceptional case of year field of zero),
no need to check for anything except for constraints
check if days in month is valid. Can be dependent on leap year.
years could not be set
XML Schema 1.0 specification defines year value of zero as
invalid. Allow this class to set year field to zero
since XML Schema 1.0 errata states that lexical zero will
be allowed in next version and treated as 1 B.C.E.
seconds + fractionalSeconds
Duration seconds is SECONDS + FRACTIONALSECONDS.
calculate days in previous month, watch for month roll over
roll over to December of previous year
set fields that where undefined before this addition, back to undefined.
XML Schema months start at 1.
is a leap year.
is a leap year.
if year( and eon) are undefined, leave default Calendar values
only set month if it is set
Calendar.MONTH is zero based while XMLGregorianCalendar month field is not.
only set day if it is set
only set hour if it is set
only set minute if it is set
only set second if it is set
only set millisend if it is set
if year( and eon) are undefined, leave default Calendar values
use default if set
only set month if it is set
Calendar.MONTH is zero based while XMLGregorianCalendar month field is not.
use default if set
Calendar.MONTH is zero based while XMLGregorianCalendar month field is not.
only set day if it is set
use default if set
only set hour if it is set
use default if set
only set minute if it is set
use default if set
only set second if it is set
use default if set
only set millisend if it is set
use default if set
zoneoffset is in minutes. Convert to custom timezone id format.
Javadoc for java.util.TimeZone documents max length
for customTimezoneId is 8 when optional ':' is not used.
"GMT" ('-'|''+') (digit digit?) (digit digit)?
Both this.eon and this.fractionalSecond are instances
of immutable classes, so they do not need to be cloned.
not a meta character
seen meta character. we don't do error check against the format
time zone. missing, 'Z', or [+-]nn:nn
illegal meta character. impossible.
some tokens are left in the input
we are expecting more digits
skip leading negative, if it exists
we are expecting more digits
definitely int only. I don't know the exact # of digits that can be in int,
but as long as we can catch (0-9999) range, that should be enough.
not a meta char
reallocate the buffer now so that it has enough space
Note: toPlainString() isn't available before Java 1.5
do it the hard way
reallocate the buffer now so that it has enough space
skip leading zero.
PENDING : Implementation of reset method
If length == 0, leave it null
-- This file was mechanically generated: Do not edit! --
JSR 160 import
used to import com.sun.jmx.snmp.MBeanServerForwarder
Now using JSR 160 instead. => this is an additional
dependency to JSR 160.
States of a CommunicatorServer
Types of connectors.
Notifs count, broadcaster and info
No op. int Type deciding debugging removed.
Fix for bug 4352451:
"java.net.BindException: Address in use".
cannot happen because of `0'
Stop the connector thread
Call terminate on each active client handler
timeOut == 0
Time elapsed since startTime...
wait for timeout - elapsed.
A timeout of Long.MAX_VALUE is equivalent to something
like 292271023 years - which is pretty close to
forever as far as we are concerned ;-)
If remainingTime is negative, the timeout has elapsed.
We're going to wait until someone notifies on the
the stateLock object, or until the timeout expires,
or until the thread is interrupted.
If we are now ONLINE, then no need to rethrow the
exception... we're simply going to exit the while
loop. Otherwise, throw the InterruptedException.
We're no longer in STARTING state
OK, we're started, everything went fine, just return
There was some exception during the starting phase.
Cast and throw...
There was some exception during the starting phase.
Cast and throw...
There was some exception during the starting phase.
Wrap and throw...
We're not ONLINE, and there's no exception...
Something went wrong but we don't know what...
It seems that the init of "i" and "success"
need to be done outside the "try" clause...
A bug in Java 2 production release ?
Fix for bug 4352451: "java.net.BindException: Address in use".
Try socket connection.
Retry last time to get correct exception.
Try socket connection.
To be defined by the subclass.
Each method below is called by run() and must be subclassed.
If the method sends an exception (Communication or Interrupt), this
will end up the run() method and switch the connector offline.
If it is a CommunicationException, run() will call
All these methods should propagate the InterruptedException to inform
run() that the connector must be switch OFFLINE.
doBind() should do all what is needed before calling doReceive().
If doBind() throws an exception, doUnbind() is not to be called
and run() ends up.
To be called by the subclass if needed
The ClientHandler will remove themselves from the
clientHandlerVector at the end of their run() method, by
Since the clientHandlerVector is modified by the ClientHandler
threads we must avoid using Enumeration or Iterator to loop
over this array. We must also take care of NoSuchElementException
which could be thrown if the last ClientHandler removes itself
between the call to clientHandlerVector.isEmpty() and the call
What we *MUST NOT DO* is locking the clientHandlerVector, because
this would most probably cause a deadlock.
The ClientHandler will remove themselves from the
clientHandlerVector at the end of their run() method, by
Since the clientHandlerVector is modified by the ClientHandler
threads we must avoid using Enumeration or Iterator to loop
over this array.
We cannot use the same logic here than in waitClientTermination()
because there is no guarantee that calling interrupt() on the
ClientHandler will actually terminate the ClientHandler.
Since we do not want to wait for the actual ClientHandler
termination, we cannot simply loop over the array until it is
empty (this might result in calling interrupt() endlessly on
the same client handler. So what we do is simply take a snapshot
copy of the vector and loop over the copy.
What we *MUST NOT DO* is locking the clientHandlerVector, because
this would most probably cause a deadlock.
Call the default deserialization of the object.
Call the specific initialization for the CommunicatorServer service.
This is for transient structures to be initialized to specific
Initialize notifInfos on first call to getNotificationInfo()
2^16 - 1
2^8 - 1
Applies to classes compiled by new compilers only
Old name in JDK 1.0
Cache contents of id() or key() index right away. Necessary for
union expressions containing multiple calls to the same index, and
correct as well since start-node is irrelevant for id()/key() exrp.
KeyIndex iterators are always relative to the root node, so there
is never any point in re-reading the iterator (and we SHOULD NOT).
Nodes produced by KeyIndex are known to be in document order.
Take advantage of it.
result will contain all the attrs declared directly on that element
nothing to do
nothing to do
Processing Instructions before or after the document element are not treated specially
Comments before or after the document element are not treated specially
Disallow subsequent initCause
Disallow subsequent initCause
Disallow subsequent initCause
read and discard the repository ID
write the repository ID
Used in size calculations
Used by prepare, indicates min, pref or max isn't going to be used.
Whether or not we automatically try and create the preferred
padding between components.
Whether or not we automatically try and create the preferred
padding between components the touch the edge of the container and
Maps from Component to ComponentInfo.  This is used for tracking
information specific to a Component.
Container we're doing layout for.
Used by areParallelSiblings, cached to avoid excessive garbage.
Indicates Springs have changed in some way since last change.
Indicates invalidateLayout has been invoked.
Whether or not any preferred padding (or container padding) springs
Force the component to be added
Make sure all the components have been registered, otherwise we may
not update the correct Springs.
Step 1: Prepare for layout.
Step 2: Calculate autopadding springs
Step 3: set the size of the groups.
Step 4: apply the size to the components.
invalidateLayout is called from Container.invalidate, which
does NOT grab the treelock.  All other methods do.  To make sure
there aren't any possible threading problems we grab the tree lock
Step 1: If not-valid, clear springs and update visibility.
Step 2: Make sure components are bound to ComponentInfos
Step 3: Adjust the autopadding. This removes existing
autopadding, then recalculates where it should go.
Step 4: (for min/pref/max size calculations only) calculate the
autopadding. This invokes for unsetting the calculated values, then
If sizeType == SPECIFIC_SIZE, it indicates we're doing layout, this
step will be done later on.
This is here purely as a convenience for ParallelGroup to avoid
having to track alignment separately.
Clear cached pref/min/max.
Force size to be reset.
Clear cached pref/min/max.
Layout at preferred size
Adjust between min/pref
The following algorithm if used for resizing springs:
1. Calculate the resizability of each spring (pref - min or
max - pref) into a list.
2. Sort the list in ascending order
3. Iterate through each of the resizable Springs, attempting
to give them (pref - size) / resizeCount
4. For any Springs that can not accommodate that much space
add the remainder back to the amount to distribute and
recalculate how must space the remaining springs will get.
5. Set the size of the springs.
First pass, sort the resizable springs into the List resizable
How much we would like to give each Spring.
Second pass, accumulate the resulting deltas (relative to
preferred) into sizes.
Spring didn't take all the space, reset how much
each spring will get.
And finally set the size of each spring
Nothing resizable, use the min or max of each of the
First pass, figure out what is resizable
Warning, this must use springs.size, as it may change during the
Autopadding spring. Set the sources of the
autopadding spring based on newLeading.
Last spring in the list, add it to
Not a padding spring
There's leading ComponentSprings, create an
Force the newly created spring to be considered
by NOT incrementing counter
Spring is a Component, make it the target of any
Last Spring, add it to trailing
Not that last Spring, add it to leading
Forward call to child Group
Spring to use for baseline isn't resizable. In this case
baseline resize behavior can be determined based on how
preceding springs resize.
If we get here, both leading and trailing springs are
resizable. Fall through to OTHER.
Not resizable, treat as constant_ascent
Delta, one of pref - min or max - pref.
How children are layed out.
Whether or not we're resizable.
LEADING, or BASELINE
Whether or not all child springs have a baseline
max(spring.getBaseline()) of all springs aligned along the baseline
that have a baseline
max(spring.getPreferredSize().height - spring.getBaseline()) of all
springs aligned along the baseline that have a baseline
Whether baselineAnchoredToTop was explicitly set
Whether the baseline is anchored to the top or the bottom.
If anchored to the top the baseline is always at prefAscent,
otherwise the baseline is at (height - prefDescent)
Whether or not the baseline has been calculated.
do baseline layout
CENTER_OFFSET and OTHER, not resizable
Not aligned along the baseline, or no baseline.
CENTER_OFFSET and OTHER are !resizable, use
the preferred size.
Not aligned along the baseline, or no baseline.
CENTER_OFFSET & OTHER, not resizable
Force the baseline to be calculated
If the axis is VERTICAL, throws an IllegalStateException
min/pref/max are either a value >= 0 or one of
DEFAULT_SIZE or PREFERRED_SIZE
Baseline for the component, computed as necessary.
Whether or not the size has been requested yet.
getComponentInfo makes sure component is a child of the
Container GroupLayout is the LayoutManager for.
Type of gap
LinkInfo contains the set of ComponentInfosthat are linked along a
Component being layed out
If the component's size is linked to other components, the
horizontalMaster and/or verticalMaster reference the group of
Remove horizontal/vertical springs
Clean up links
horizontalMaster field is directly set by adding
us to the LinkInfo.
verticalMaster field is directly set by adding
us to the LinkInfo.
Points to field name in constant pool
Points to encoded signature
No. of attributes
Collection of attributes
Chapter 5.3 (as below)
Chapter 5.4 (no errors but the ones that _always_ could happen! How stupid.)
Look up the servant for this request and return it in a
ServantObject.  Note that servant_postinvoke is always called
by the stub UNLESS this method returns null.  However, in all
cases we must be sure that ObjectAdapter.getServant and
ObjectAdapter.returnServant calls are paired, as required for
Portable Interceptors and Servant Locators in the POA.
Thus, this method must call returnServant if it returns null.
Destroyed POAs can be recreated by normal adapter activation.
So just reinvoke this method.
Cleanup after this call, then throw to allow
outer try to handle the exception appropriately.
ThreadDeath on the server side should not cause a client
side thread death in the local case.  We want to preserve
this behavior for location transparency, so that a ThreadDeath
has the same affect in either the local or remote case.
The non-colocated case is handled in iiop.ORB.process, which
throws the same exception.
End of file.
current class object
name of package, unclean to make it static, but ...
name of current class, dito
Remember full name
Get package name by tacking off everything after the last `.'
Write main file (with frames, yuk)
Where to store HTML files
command line switch
Specify target directory, default '.'
Create target directory if necessary
add file name to list */
Loop through files ...
Create parser object from file
Create parser object from zip file
Type is an array?
Tack of the `['
test for basic type
Filter any characters HTML doesn't like such as < and > in particular
The name of the template (if any)
Mode in which this template is instantiated.
Matching pattern defined for this template.
Matching priority of this template.
Position within stylesheet (prio. resolution)
make sure it is compiled only once
True if this is a simple named template. A simple named
template is a template which only has a name but no match pattern.
The list of parameters in this template. This is only used
for simple named templates.
Add the (named) template to the symbol table
Is this a simple named template?
set current template
bug fix #4433133, add a call to named template from applyTemplates
%OPT% Special handling for simple named templates.
Update load/store instructions to access Params from the stack
Listen for desktop being resized
Listen for frames being added to desktop
Move desktopIcon from desktop to taskBar
First shrink buttons to fit
Start with the largest preferred width
Shrink equally to fit if needed
PENDING: This should be handled by the painter
Initial size, because we have no buttons yet
We already have a good height
We have it already
Frame was removed without using setClosed(true)
Get topmost of the remaining frames
Common UI methods
Move to root of include tree
Indicate to the top-level stylesheet that all templates must be
compiled into separate methods.
Get the mode we are currently in (might not be any)
Get the method name for <xsl:apply-imports/> in this mode
Push the arguments that are passed to applyTemplates()
Push a new parameter frame in case imported template might expect
parameters.  The apply-imports has nothing that it can pass.
Get the [min,max> precedence of all templates imported under the
Get name of appropriate apply-templates function for this
Construct the translet class-name and the signature of the method
Pop any parameter frame that was pushed above.
why the above method doens't return QName ?
If the text isn't left justified, offset by 10 pixels!
Assume f is fixed point.
root -> ImageDescriptor
should not happen as this class is cloneable
RFC 2732 added '[' and ']' as reserved characters
Add ASCII Digits and ASCII Hex Numbers
Add ASCII Letters and ASCII Hex Numbers
Add ASCII Letters
Add Reserved Characters
Add Mark Characters
Add Scheme Characters
Add Userinfo Characters
Add Path Characters
just make a copy of the base if spec is empty
Check for scheme, which must be before '/', '?' or '#'.
search backwards starting from character before ':'.
A standalone base is a valid URI according to spec
Neither 'scheme:' or 'scheme:#fragment' are valid URIs.
Two slashes means we may have authority, but definitely means we're either
matching net_path or abs_path. These two productions are ambiguous in that
every net_path (except those containing an IPv6Reference) is an abs_path.
RFC 2396 resolves this ambiguity by applying a greedy left most matching rule.
Try matching net_path first, and if that fails we don't have authority so
then attempt to match abs_path.
net_path = "" authority [ abs_path ]
abs_path = "/"  path_segments
Authority will be everything up to path, query or fragment
Attempt to parse authority. If the section is an empty string
this is a valid server based authority, so set the host to this
If we didn't find authority we need to back up. Attempt to
match against abs_path next.
Resolve relative URI to base URI - see RFC 2396 Section 5.2
In some cases, it might make more sense to throw an exception
(when scheme is specified is the string spec and the base URI
is also specified, for example), but we're just following the
just make a copy of the base if spec is empty
Check for scheme, which must be before '/', '?' or '#'.
search backwards starting from character before ':'.
A standalone base is a valid URI according to spec
Neither 'scheme:' or 'scheme:#fragment' are valid URIs.
Two slashes means we may have authority, but definitely means we're either
matching net_path or abs_path. These two productions are ambiguous in that
every net_path (except those containing an IPv6Reference) is an abs_path.
RFC 2396 resolves this ambiguity by applying a greedy left most matching rule.
Try matching net_path first, and if that fails we don't have authority so
then attempt to match abs_path.
net_path = "" authority [ abs_path ]
abs_path = "/"  path_segments
Authority will be everything up to path, query or fragment
Attempt to parse authority. If the section is an empty string
this is a valid server based authority, so set the host to this
If we didn't find authority we need to back up. Attempt to
match against abs_path next.
Same as java.net.URI:
DEVIATION: Allow empty authority prior to non-empty
path, query component or fragment identifier
Resolve relative URI to base URI - see RFC 2396 Section 5.2
In some cases, it might make more sense to throw an exception
(when scheme is specified is the string spec and the base URI
is also specified, for example), but we're just following the
check to see if this is the current doc - RFC 2396 5.2 #2
note that this is slightly different from the RFC spec in that
we don't include the check for query string being null
- this handles cases where the urispec is just a query
string or a fragment (e.g. "?y" or "#s") -
see <http:www.ics.uci.edu/~fielding/url/test1.html> which
identified this as a bug in the RFC
check for scheme - RFC 2396 5.2 #3
if we found a scheme, it means absolute URI, so we're done
check for authority - RFC 2396 5.2 #4
if we found a host, then we've got a network path, so we're done
check for absolute path - RFC 2396 5.2 #5
if we get to this point, we need to resolve relative path
RFC 2396 5.2 #6
6a - get all but the last segment of the base URI path
6b - append the relative URI path
6c - remove all "./" where "." is a complete path segment
6d - remove "." if path ends with "." as a complete path segment
6e - remove all "<segment>/../" where "<segment>" is a complete
path segment not equal to ".."
6f - remove ending "<segment>/.." where "<segment>" is a
complete path segment
userinfo is everything up to @
host is everything up to last ':', or up to
and including ']' if followed by ':'.
REVISIT: Remove this code.
REVISIT: Remove this code.
Store port value as string instead of integer.
Note: Registry based authority is being removed from a
new spec for URI which would obsolete RFC 2396. If the
spec is added to XML errata, processing of reg_name
needs to be removed. - mrglavas.
Check if the host is well formed.
Check that port is well formed if it exists.
REVISIT: There's no restriction on port value ranges, but
perform the same check as in setPort to be consistent. Pass
in a string to this method instead of an integer.
Check that userinfo is well formed if it exists.
Userinfo can contain alphanumerics, mark characters, escaped
check for valid escape sequence
can check against path characters because the set
is the same except for '/' which we've already excluded.
path - everything up to query string or fragment
RFC 2732 only allows '[' and ']' to appear in the opaque part.
abs_path = "/"  path_segments
rel_path = rel_segment [ abs_path ]
check for valid escape sequence
Path segments cannot contain '[' or ']' since pchar
production was not changed by RFC 2732.
Scan opaque part.
opaque_part = uric_no_slash *uric
check for valid escape sequence
If the scheme specific part is opaque, it can contain '['
and ']'. uric_no_slash wasn't modified by RFC 2732, which
I've interpreted as an error in the spec, since the
production should be equivalent to (uric - '/'), and uric
contains '[' and ']'. - mrglavas
query - starts with ? and up to fragment or end
fragment - starts with #
Server based authority.
Registry based authority.
Server based authority.
Registry based authority.
userinfo can contain alphanumerics, mark characters, escaped
reg_name = 1*( unreserved | escaped | "$" | "," |
";" | ":" | "@" | "&" | "=" | "+" )
presence of the host (whether valid or empty) means
double-slashes which means generic uri
presence of the scheme means absolute uri
Check if the host is a valid IPv6reference.
Cannot start with a '.', '-', or end with a '-'.
rightmost domain label starting with digit indicates IP address
since top level domain label can only start with an alpha
see RFC 2396 Section 3.2.2
hostname      = *( domainlabel "." ) toplabel [ "." ]
domainlabel   = alphanum | alphanum *( alphanum | "-" ) alphanum
toplabel      = alpha | alpha *( alphanum | "-" ) alphanum
RFC 2396 states that hostnames take the form described in
RFC 1034 (Section 3) and RFC 1123 (Section 2.1). According
to RFC 1034, hostnames are limited to 255 characters.
domain labels can contain alphanumerics and '-"
but must start and end with an alphanumeric
RFC 1034: Labels must be 63 characters or less.
make sure that 1) we see only digits and dot separators, 2) that
any dot separator is preceded and followed by a digit and
3) that we find 3 dots
RFC 2732 amended RFC 2396 by replacing the definition
of IPv4address with the one defined by RFC 2373. - mrglavas
IPv4address = 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT
One to three digits must be in each segment.
Check that that there are no more than three digits
in this segment.
Check that this segment is not greater than 255.
Check if string is a potential match for IPv6reference.
Counter for the number of 16-bit sections read in the address.
Scan hex sequence before possible '::' or IPv4 address.
Address must contain 128-bits of information.
'::' represents at least one 16-bit group of zeros.
Trailing zeros will fill out the rest of the address.
If the second character wasn't ':', in order to be valid,
the remainder of the string must match IPv4Address,
and we must have read exactly 6 16-bit groups.
3. Scan hex sequence after '::'.
We've either reached the end of the string, the address ends in
an IPv4 address, or it is invalid. scanHexSequence has already
made sure that we have the right number of bits.
Trying to match the following productions:
hexseq = hex4 *( ":" hex4)
hex4   = 1*4HEXDIG
IPv6 addresses are 128-bit, so there can be at most eight sections.
This could be '::'.
This might be invalid or an IPv4address. If it's potentially an IPv4address,
backup to just after the last valid character that matches hexseq.
There can be at most 4 hex digits per group.
Null is a valid value for all OpenTypes, even though
OpenType.isValue(null) will return false.  It can always be
matched to the corresponding Java type, except when that
type is primitive.
Ignore the exception and let MBeanIntrospector.invokeSetter()
throw the initial exception.
could also consult annotations for defaultValue,
minValue, maxValue, legalValues
End of file.
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of ScrollBarButtonPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of ScrollBarButtonPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
set version based on magic
any other magic should not be here
number of nodes on stack
no need to sync in the future
we don't want to generate any event for this so turn them off
attributes are now synced
create attributes node map
Default attributes dangle as children of the element
definition "node" in the internal fast table.
set mutation events flag back to its original value
index of referenced variable
compact version, such as ILOAD_0
canonical tag such as ILOAD
Need WIDE prefix ?
Otherwise ILOAD_n, instruction, e.g.
compact load instruction such as ILOAD_2
Assert ISTORE_0 <= tag <= ASTORE_3
Use more compact instruction xLOAD_n
Need WIDE prefix ?
Copyright (c) 1995-96 by Cisco Systems, Inc.
Try to see if the variable name is actually an OID to resolve.
The oid starts with a '.' ala CMU.
Go through the oidStore ... Good luck !
get the locally defined elements ...
Possible type conversions between internal types
use inherited field
check if conversion is valid
This is a special case for the self:: axis. Instead of letting
the Step object create and iterator that we cast back to a single
node, we simply ask the DOM for the node type.
check if the property is managed by security manager
fall back to the default configuration to handle the property
The actual payload of this call site:
Note: This field is known to the JVM.  Do not change.
warning:  do not call getTarget here, because CCS.getTarget can throw IllegalStateException
unchecked view is OK since no values will be received or returned
this implements the upcall from the JVM, MethodHandleNatives.makeDynamicCallSite:
Extra arguments for BSM, if any:
(caller, name, type)
must rebox; see JLS 5.1.7
handle scaling for sizeVarients for special case components. The
key "JComponent.sizeVariant" scales for large/small/mini
components are based on Apples LAF
there is an overlap between the track and button
adjust the height by decrGap
Note: decrGap is negative!
adjust the width by decrGap
Note: decrGap is negative!
there is an overlap between the track and button
adjust the height and y by incrGap
Note: incrGap is negative!
adjust the width and x by incrGap
Note: incrGap is negative!
XXX Make these flag indices public
Caller needs to make sure `sessionKey` will not be null
Fill in whatever we have
Squelch it since we don't care about the old ticket.
authTime may be null
startTime may be null
renewTill may be null
clientAddress may be null, the array's hashCode is 0
authTime may be null
startTime may be null
Location of the default password file
Key to retrieve the stored username
Key to retrieve the stored password
Supplied username and password
initialize any configured options
set the location of the password file
attempt the authentication
attempt the authentication by getting the
username and password from shared state
authentication failed -- try again below by prompting
attempt the authentication by getting the
username and password from shared state
attempt the authentication using the supplied username and password
add Principals to the Subject
in any case, clean out state
Clean out state
overall authentication succeeded and commit succeeded,
but someone else's commit failed
clean out state
sharedState used as Map<String,Object>
get the username and password
userCredentials is initialized in login()
username not found or passwords do not match
Save the username and password in the shared state
only if authentication succeeded
Create a new user principal
use the password saved by the first module in the stack
acquire username and password
Flags needed to implement the matching/differing mechanism.
GETTERS AND SETTERS
Check that the observed attribute is of type "String".
Send matching notification if notifyMatch is true.
Send differing notification if notifyDiffer is true.
set from native code.
for MS Windows only
numpad numeric keys handled below
remove trailing '+'
Return a keycode (if any) associated with a character.
Get the height
Null indicies for root indicates it changed.
PENDING(scott): make sure childIndexs is sorted!
Update the size of the parent.
PENDING(scott): make sure that changedIndexs are sorted in
Update the size of the parent.
Node has become a leaf, collapse it.
Check if root has changed, either to a null root, or
to an entirely new root.
Check all the parent paths, until a match is found.
Found a match, create entries for all paths in
If we get here it means they share a different root!
We could throw an exception...
Make sure the last entry isn't a leaf.
Overriden DefaultMutableTreeNode methods
don't add me, I'm already in
Adjust the Y origin of any nodes following this row.
Update the rows in the selection
don't remove me, I'm still visible
Clean up the visible nodes.
Adjust the Y origin of any rows following this one.
End of VariableHeightLayoutCache.TreeStateNode
mark as invalid!
nextIndex == -1 identifies receiver, make sure is expanded
Check that it can have kids
Make sure next index not beyond child count.
largest numerical value
These would not be used for EN. Only used for traditional numbering
These only used for mutiplicative-additive numbering
check that the mr_type is supported by this JMXAgent
only "objectReference" is supported
convert seconds to milliseconds for time comparison
Parse for class name and method
may still be null now
This is only an optimization so we'll go on to discover
whether the name really is an RMMB method.
error/validity check return value here
change cached value in attribute descriptor
response was invalid or really returned null
not getMethod so return descriptor (default) value
!! cast response to right class
make sure response class matches type field
inequality may come from primitive/wrapper class
inequality may come from type subclassing
throw exception, didn't get
back right attribute type
eat exceptions because interface doesn't have an
exception on it
OK: Default "Unknown" value used for unknown attribute
if descriptor ... else no descriptor
else no descriptor
Go through the list of attributes
log notification if specified in descriptor
Using hasNotification() is not optimal, but shouldn't really
matter in this context...
hasGeneric==true if GENERIC notification is present.
hasAttributeChange==true if ATTRIBUTE_CHANGE notification is
User supplied list of notification infos.
Length of the returned list of notification infos:
length of user suplied list + possibly 1 for GENERIC, +
possibly 1 for ATTRIBUTE_CHANGE
Returned list of notification infos:
Preserve previous ordering (JMX 1.1)
Counter of "standard" notification inserted before user
We need to add description for GENERIC notification
We need to add description for ATTRIBUTE_CHANGE notification
Now copy user supplied list in returned list.
log notification if specified in descriptor
XXX Revisit: This is a quickfix: it would be better to have a
single broadcaster. However, it is not so simple because
remove only listeners whose filter is an instanceof
do we really want to do this?
Since ModelMbeanInfo cannot be null (otherwise exception
thrown at creation)
no exception thrown on ModelMBeanInfo not set.
Fix for XP bug where sometimes these sizes aren't updated properly
Assume for now that height is correct and derive width using the
ratio from the uxtheme part
JDK-8039383: initialize these colors because getXP() may return null when theme is changed
Get around protected method in superclass
Center text vertically.
There are no icons
There are no icons
Note: Don't know how to calculate height on XP,
the captionbarheight is 25 but native caption is 30 (maximized 26)
Create scratch graphics
Set drawing scale to make icon scale to our desired size
Center icon vertically
Center icon horizontally
Note: this icon is square, but the buttons aren't always.
Right hand buttons
XP seems to ignore margins and offset here
Update the internal frame icon for the system menu.
We can use an arbitrary size here because we scale to it in paintIcon()
Calculate how big our drawing area is in pixels
Assume we are square
Set drawing scale to make icon act true to our reported size
PENDING(hmuller) - the next three methods should be removed
TIGER - 4422535
TIGER - 4422362
Validation against namespace aware grammar
Update PSVI information in the tree
attribute value normalization
Check if element content is all "ignorable whitespace"
intialize and reset DOMNormalizer component
reset namespace context
report fatal error on DOM Level 1 nodes
check if we need to fill in PSVI
reset ID table
reset schema validator
processing aborted by the user
REVISIT: well-formness encoding info
do the name check only when version of the document was changed &
application has set the value of well-formed features to true
push namespace context
fix namespaces and remove default attributes
normalize attribute values
remove default attributes
REVISIT: possible solutions to discard default content are:
either we pass some flag to XML Schema validator
or rely on the PSVI information.
updates global qname
set error node in the dom error wrapper
so if error occurs we can report an error node
call re-validation handler
REVISIT: possible solutions to discard default content are:
either we pass some flag to XML Schema validator
or rely on the PSVI information.
updates global qname
set error node in the dom error wrapper
so if error occurs we can report an error node
call re-validation handler
updates global qname
set error node in the dom error wrapper
so if error occurs we can report an error node
updates global qname
set error node in the dom error wrapper
so if error occurs we can report an error node
pop namespace context
remove the comment node
if comment node need not be removed
check comments for invalid xml chracter as per the version
of the document
end-else if comment node is not to be removed.
and entity has a first child as a text
we should not advance
REVISIT: traverse entity reference and send appropriate calls to the validator
(no normalization should be performed for the children).
convert CDATA to TEXT nodes
send characters call for CDATA
set error node in the dom error wrapper
so if error occurs we can report an error node
set error node in the dom error wrapper
so if error occurs we can report an error node
If node is a text node, we need to check for one of two
1) There is an adjacent text node
2) There is no adjacent text node, but node is
an empty text node.
If an adjacent text node, merge it with this node
We don't need to check well-formness here since we are not yet
done with this node.
If kid is empty, remove it
validator.characters() call and well-formness
Don't send characters or check well-formness in the following cases:
1. entities is false, next child is entity reference: expand tree first
2. comments is false, and next child is comment
3. cdata is false, and next child is cdata
do the well-formed valid PI target name , data check when application has set the value of well-formed feature to true
1.check PI target name
2. check PI data
processing isntruction data may have certain characters
which may not be valid XML character
end case Node.PROCESSING_INSTRUCTION_NODE
end of switch
normalize attribute values
remove default attributes
check attribute names if the version of the document changed.
pick up local namespace declarations
<!-- add the following via DOM
body is bound to http:xslt
Record all valid local declarations
do the name check only when version of the document was changed &
application has set the value of well-formed features to true
checkQName does checking based on the version of the document
"namespace-declarations" == false; Discard all namespace declaration attributes
Check for invalid namespace declaration:
A null value for locale is passed to formatMessage,
which means that the default locale will be used
XML 1.0 Attribute value normalization
REVISIT: issue error on invalid declarations
xmlns:foo = ""
(localpart == fXmlnsSymbol && prefix == fEmptySymbol)  -- xmlns
empty prefix is always bound ("" or some string)
end-else: valid declaration
end-if: namespace attribute
Fix up namespaces for element: per DOM L3
Need to consider the following cases:
case 1: <xsl:stylesheet xmlns:xsl="http:xsl">
We create another element body bound to the "http:xsl" namespace
as well as namespace attribute rebounding xsl to another namespace.
Need to make sure that the new namespace decl value is changed to
check if prefix/namespace is correct for current element
"namespace-declarations" == false? Discard all namespace declaration attributes
no namespace declaration == no namespace URI, semantics are to keep prefix
Element has a namespace
The xmlns:prefix=namespace or xmlns="default" was declared at parent.
The binder always stores mapping of empty prefix to "".
the prefix is either undeclared
conflict: the prefix is bound to another URI
Element has no namespace
Error: DOM Level 1 node!
uri=null and no colon (DOM L2 node)
undeclare default namespace declaration (before that element
bound to non-zero length uir), but adding xmlns="" decl
Fix up namespaces for attributes: per DOM L3
check if prefix/namespace is correct the attributes
clone content of the attributes
normalize attribute value
make sure that value is never null.
attribute has namespace !=null
skip namespace declarations
REVISIT: can we assume that "uri" is from some symbol
table, and compare by reference? -SG
check if value of the attribute is namespace well-formed
remove default attributes
XML 1.0 Attribute value normalization
find if for this prefix a URI was already declared
attribute has no prefix (default namespace decl does not apply to attributes)
attribute prefix is not declared
conflict: attribute has a prefix that conficlicts with a binding
already active in scope
Find if any prefix for attributes namespace URI is available
in the scope
use the prefix that was found (declared previously for this URI
the current prefix is not null and it has no in scope declaration
use this prefix
find a prefix following the pattern "NS" +index (starting at 1)
make sure this prefix is not declared in the current scope.
add declaration for the new prefix
change prefix for this attribute
attribute uri == null
XML 1.0 Attribute value normalization
It is an error if document has DOM L1 nodes.
uri=null and no colon
no fix up is needed: default namespace decl does not
remove default attributes
end loop for attributes
Methods for well-formness checking
version of the document is XML 1.1
we need to check all chracters as per production rules of XML11
check if this is a supplemental character
version of the document is XML 1.0
we need to check all chracters as per production rules of XML 1.0
check if this is a supplemental character
Note:  The key InvalidCharInCDSect from XMLMessages.properties
is being used to obtain the message and DOM error type
"wf-invalid-character" is used.  Also per DOM it is error but
as per XML spec. it is fatal error
version of the document is XML 1.1
we need to check all characters as per production rules of XML11
check if this is a supplemental character
version of the document is XML 1.0
we need to check all characters as per production rules of XML 1.0
check if this is a supplemental character
version of the document is XML 1.1
we need to check all chracters as per production rules of XML11
check if this is a supplemental character
invalid: '--' in comment
version of the document is XML 1.0
we need to check all chracters as per production rules of XML 1.0
check if this is a supplemental character
invalid: '--' in comment
check each child node of the attribute's value
If the attribute's child is an entity refernce
search for the entity in the docType
of the attribute's ownerDocument
If the entity was not found issue a fatal error
REVISIT: the symbols are added too often: start/endElement
and in the namespaceFixup. Should reduce number of calls to symbol table.
specified attributes should already have a normalized form
since those were added by validator
skip following xA
REVISIT: this implementation does not store any value in augmentations
and basically not keeping augs in parallel to attributes map
untill all attributes are added (default attributes)
add defaults to the tree
the default attribute was removed by a user and needed to
be added back
REVISIT: the following should also update ID table
default attribute is in the tree
we don't need to do anything since prefix was already fixed
at the namespace fixup time and value must be same value, otherwise
attribute will be treated as specified and we will never reach
REVISIT: is this desired behaviour?
The values are updated in the case datatype-normalization is turned on
in this case we need to make sure that specified attributes stay specified
REVISIT: instead we should be using augmentations:
to set/retrieve Id attributes
NOTE: The specified value MUST be set after we set
the node value because that turns the "specified"
flag to "true" which may overwrite a "false"
value from the attribute list.
include element default content (if one is available)
NOTE: this is a hack: it is possible that DOM had an empty element
and validator sent default value using characters(), which we don't
implement. Thus, here we attempt to add the default value.
default content could be provided
GTK has a separate widget for the handle box, to mirror this
we create a unique icon per ToolBar and lookup the style for the
we don't allow instantiation
some copying needed
no need to skip anything
valid length of the string
skip sign bit
valid length of the string
pad with leading nulls
some copying needed
no need to skip anything
valid length of the string
skip sign bit
valid length of the string
pad with leading nulls
form integral number of 6-bit groups
remove white spaces
should be divisible by four
first last bits.
if found "no data" just return null
Check if they are PAD characters
Two PAD e.g. 3c[Pad][Pad]
last 4 bits should be zero
One PAD  e.g. 3cQ[Pad]
last 2 bits should be zero
an error  like "3c[Pad]r", "3cdX", "3cXd", "3cXX" where X is non data
No PAD e.g 3cQl
if found "no data" just return null
remove white spaces
should be divisible by four
if found "no data" just return null
first last bits.
if found "no data" just return null
Check if they are PAD characters
Two PAD e.g. 3c[Pad][Pad]
last 4 bits should be zero
One PAD  e.g. 3cQ[Pad]
last 2 bits should be zero
an error  like "3c[Pad]r", "3cdX", "3cXd", "3cXX" where X is non data
No PAD e.g 3cQl
if found "no data" just return null
Check if they are PAD characters
Two PAD e.g. 3c[Pad][Pad]
last 4 bits should be zero
One PAD  e.g. 3cQ[Pad]
last 2 bits should be zero
an error  like "3c[Pad]r", "3cdX", "3cXd", "3cXX" where X is non data
No PAD e.g 3cQl
count characters that's not whitespace
Attribute value types
Content model types
Attribute value modifiers
Store away the children and operation. This is all we need to
do the content model check.
The operation is one of the ContentSpecNode.NODE_XXX values!
According to the type of operation, we do the correct type of
If there is not a child, then report an error at index 0
If the 0th child is not the right kind, report an error at 0
If more than one child, report an error at index 1
If there is one child, make sure its the right type. If not,
then its an error at index 0.
If the child count is greater than one, then obviously
bad, so report an error at index 1.
If the child count is zero, that's fine. If its more than
zero, then make sure that all children are of the element
type that we stored. If not, report the index of the first
If the child count is zero, that's an error so report
an error at index 0.
Otherwise we have to check them all to make sure that they
are of the correct child type. If not, then report the index
of the first one that is not.
There must be one and only one child, so if the element count
is zero, return an error at index 0.
If the zeroth element isn't one of our choices, error at 0
If there is more than one element, then an error at 1
There must be two children and they must be the two values
we stored, in the stored order.
We survived, so return success status
the compilation unit is identified by the file
Message keys used by the serializer
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The localname is the portion after the optional colon; the message indicates
that there is a problem with that part of the QNAME.
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The prefix is the portion before the optional colon; the message indicates
that there is a problem with that part of the QNAME.
horizontally align the interior
adjust the allocation to match the bounded range.
--- View methods -------------------------------------------
for computing the structural UID
maintained here for backward compatability with JDK 1.3, where
writeObject method was not being checked at all, so there is
no need to lookup the ObjectStreamClass
for non-serializable/proxy classes
to maintain same suid as the JDK 1.3, we pick
up suid only for classes with private,static,final
declarations, and compute it for all others
In the old case, for the caller class, the write Method wasn't considered
for rep-id calculations correctly, but for parent classes it was taken
into account.  That is the reason there is the klude of getting the write
Object method in there
Get SUID of parent
need to find the java replacement for hasStaticInitializer
TBD: what modifiers does it have
cached parameter signature
is a Method.
use java.io.ObjectStream's hasStaticInitializer method
if (!Modifier.isPrivate(mods) ||
Since it is alright if methodName does not exist,
no need to do anything special here.
no need for future synchronizations
get initial text value
NOTE: We used to normalize adjacent text node values here.
This code has moved to the DeferredDocumentImpl
getNodeValueString() method. -Ac
Message keys used by the serializer
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The localname is the portion after the optional colon; the message indicates
that there is a problem with that part of the QNAME.
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The prefix is the portion before the optional colon; the message indicates
that there is a problem with that part of the QNAME.
look for the first whitespace char.
no such whitespace. replace(text)==text.
we now know that we need to modify the text.
allocate a char array to do it.
most of the characters are non-control characters.
so check that first to quickly return false for most of the cases.
other than we have to do four comparisons.
compress to -72 to +72
quarter hours between 1825 and 2300
Clear out old entries every few queries
construct an ID datatype validator
Check if is valid key-[81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*
TODO: fix error messages in XIncludeMessages.properties
private objects to cache the locale and resource bundle
memorize the most-recent locale
Class.forName() won't load classes outside
of core from a class inside core. Special
case this method.
Provide a short form for array instantiation by faking an nary-constructor.
The Character class, as of 1.4, does not have a constructor
which takes a String. All of the other "wrapper" classes
for Java's primitive types have a String constructor so we
fake such a constructor here so that this special case can be
Note: there is a minor problem with using the non-caching
NameGenerator method. The return value will not have
specific information about the inner class name. For example,
In 1.4.2 an inner class would be represented as JList$1 now
would be named Class.
Respect a subclass's implementation here.
escapingStyle gives the method used at creation time for
quoting or escaping characters in the name.  It is set to the
first style of quote or escape encountered if and when the name
Returns true if "match" is not null, and n contains "match" at
handle quoted strings
record choice of quote chars being used
consume string until matching quote
skip escape character if it is escaping ending quote
otherwise leave as is.
no ending quote found
verify that end-quote occurs at separator or end of string
throw (new Exception(
if escape precedes meta, consume escape and let
Handle quote occurring after typeval separator
consume string until matching quote
skip escape character if it is escaping ending quote
otherwise leave as is.
no ending quote found
verify that end-quote occurs at separator or end of string
Trailing separator found.  Add an empty component.
%% comps could shrink in the middle.
determine whether there are any separators; if so escape
or quote them
if quoting component,
start string off with opening quote
component is being quoted, so we only need to worry about
escaping end quotes that occur in component
end-quotes must be escaped when inside a quoted string
no special treatment required
end with closing quote
When component is not quoted, add escape for:
1. leading quote
2. an escape preceding any meta char
3. an escape at the end of a component
go through characters in component and escape where necessary
leading quote must be escaped
Escape an escape preceding meta characters, or at end.
Other escapes pass through.
escape an ending escape
escape meta strings
escape unescaped separator
no special treatment required
%% comps could shrink in the middle.
normalize according to syntax
posn is number of elements in suffix
startIndex is the starting position in this name
at which to start the comparison. It is calculated by
subtracting 'posn' from size()
"comps" has shrunk.
"comps" has shrunk.
on comm_failure maybe need to give IOR instead of located.
retry from root ior
End of file.
swap flow lists
Handles both SAXNotSupportedException, SAXNotRecognizedException
This handles removal of attributes
Unrecognized attributes do not cause an exception
This is ugly.  We have to collect the attributes and then
later create a DocumentBuilderImpl to verify the attributes.
Create the Map if none existed before
Test the attribute name by possibly throwing an exception
See if it's in the attributes Map
We create a dummy DocumentBuilderImpl in case the attribute
name is not one that is in the attributes map.
assert(name is not recognized or not supported), try feature
Must have been a feature
Not a property or a feature
See if it's in the features map
If this is the secure processing feature, save it then return.
Test the feature by possibly throwing SAX exceptions
setup other properties
setup grammar pool
add schema message formatter to error reporter
add all recognized features and properties and apply their defaults
pass on properties set on SchemaFactory
pre-condition: VALIDATION and SCHEMA_VALIDATION are always true
check if the property is managed by security manager
check if the property is managed by security property manager
fall back to the existing property manager
register component's recognized features
register component's recognized properties
set default values
Mark configuration as fixed.
Remove error resolver and error handler
Set the Locale back to null.
Restore initial security manager
Set the Locale back to null.
Reset feature and property values to their initial values
Do not overwrite values already set on the configuration.
For newly added components who recognize this feature
but did not offer a default value, we need to make
sure these components will get an opportunity to read
the value before parsing begins.
Do not overwrite values already set on the configuration.
For newly added components who recognize this property
but did not offer a default value, we need to make
sure these components will get an opportunity to read
the value before parsing begins.
"prefix:localpart" or "localpart"
get prefix and local part out of content
both prefix (if any) a nd localpart must be valid NCName
resove prefix to a uri, report an error if failed
REVISIT: qname and notation shouldn't support length facets.
now we just return the length of the rawname
Implements java.util.ResourceBundle.handleGetObject; inherits javadoc specification.
lazily load the lookup hashtable.
this class ignores locales
lazily load the lookup hashtable.
key must be non-null String, value must be non-null
both compared as strings
the following 2 cases optimize @attr|.|.. = 'string'
compare(Node, NodeSet) will be invoked
for compare(Node, NodeSet)
At least one argument is of type node, node-set or result-tree
Promote an expression of type node to node-set
If one arg is a node-set then make it the left one
Promote integers to doubles to have fewer compares
not x <-> x xor 1
not x <-> x xor 1
Next, result-tree/string and result-tree/result-tree comparisons
not x <-> x xor 1
x != y <-> x xor y
not x <-> x xor 1
Cast a result tree to a string to use an existing compare
Call the appropriate compare() from the BasisLibrary
$Id: XPathExpressionImpl.java,v 1.3 2005/09/27 09:40:43 sunithareddy Exp $
By default Extension Functions are allowed in XPath Expressions. If
Secure Processing Feature is set on XPathFactory then the invocation of
extensions function need to throw XPathFunctionException
We always need to have a ContextNode with Xalan XPath implementation
To allow simple expression evaluation like 1+1 we are setting
dummy Document as Context Node
Validating parameters to enforce constraints defined by JAXP spec
Throwing NullPointerException as defined in spec
Checking if requested returnType is supported. returnType need to be
defined in XPathConstants
If VariableResolver returns null Or if we get
NullPointerException at this stage for some other reason
then we have to reurn XPathException
For any other exceptions we need to throw
XPathExpressionException ( as per spec )
Checking if requested returnType is supported. returnType need to be
defined in XPathConstants
XPathConstants.NODESET ---ORdered, UNOrdered???
Return the first node, or null
If isSupported check is already done then the execution path
shouldn't come here. Being defensive
this is a special case because the JPasswordField's ancestor hierarchy
includes a class outside of javax.swing, thus we cannot call setUIProperty
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of ToolBarToggleButtonPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of ToolBarToggleButtonPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
calculate the severity prefix and return value
continue after warnings
terminate after errors
terminate after fatal errors
calculate the location message
fail on the first error or fatal error
If the local path is a relative path, then it is resolved against
the "user.dir" system property.
user.dir not accessible from applet
"fix" for Bugzilla Bug 22777
finding substring  before '#', '?', and '/'
return true if there is ':' before '#', '?', and '/'
On Windows, an absolute path starts with "[drive_letter]:\".
Replace space with "%20"
Replace backslash with forward slash
Only process the systemId if it starts with "file:".
Resolve the absolute path if the systemId starts with "file:/"
or "file:/". Don't do anything if it only starts with "file:".
A Windows path containing a drive letter can be relative.
A Unix path starting with "file:/" is always absolute.
cannot be serialized
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of RadioButtonMenuItemPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of RadioButtonMenuItemPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
REVISIT - These should not throw IOException.
Should be handled internally.
property identifier:  ValidationManager
recognized features and properties
xxx: fValidationManager code needs to be added yet!
this starts a new entity and sets the current entity to the document entity.
register current document scanner as a listener for XMLEntityScanner
prepare to look for a TextDecl if external general entity
Don't do this if we're skipping the entity!
if fMarkupDepth has reached 0.
and driver is fTrailingMiscDriver (which
handles end of document in normal case)
set the scanner state of SCANNER_STATE_TERMINATED
set the scanner set to SCANNER_STATE_TERMINATED
else we have reached the end of document prematurely
so throw EOFException.
this is taken care in wrapper which generates XNI callbacks, There are no next events
driver factory methods
root element name
Attempt to locate an external subset with an external subset resolver.
NOTE: I don't like calling the doctypeDecl callback until
end of the *full* doctype line (including internal
subset) is parsed correctly but SAX2 requires that
it knows the root element name and public and system
identifier for the startDTD call. -Ac
is there an internal subset?
next driver is prolog regardless of whether there
is an XMLDecl in this document
NOTE: special case where document starts with a PI
whose name starts with "xml" (e.g. "xmlfoo")
this function should fill the data.. and set the fEvent object to this event.
REVISIT:where else we can set this value to 'true'
return PI event since PI was encountered
standard XML declaration
REVISIT:where else we can set this value to 'true'
REVISIT:where else we can set this value to 'true'
In both case return the START_DOCUMENT. ony difference is that first block will
cosume the XML declaration if any.
premature end of file
from now onwards this would be handled by fContentDriver,in the same next() call
this function fills the data..
scanDoctypeDecl() sends XNI doctypeDecl event that
in SAX is converted to startDTD() event.
allow parsing of entity decls to continue in order to stay well-formed
always return DTD event, the event however, will not contain any entities
handle external subset
This handles the case of a DOCTYPE that had neither an internal subset or an external subset.
Send endDTD() call if:
a) systemId is null or if an external subset resolver could not locate an external subset.
b) "load-external-dtd" and validation are false
c) DTD grammar is cached
in XNI this results in 3 events:  doctypeDecl, startDTD, endDTD
in SAX this results in 2 events: startDTD, endDTD
premature end of file
xxx  what should be returned here.... ???
xxx  what should be returned here.... ???
xxx: remove this hack and align this with reusing DTD components
currently this routine will only be executed from Stax
REVISIT: Should there be a feature for
the "complete" parameter?
end doctype declaration
simply reset the entity store without having to mess around
with the DTD Scanner code
scan external subset next unless we are ignoring DTDs
Check access permission. If the source is resolved by a resolver, the check is skipped.
REVISIT: Should there be a feature for
the "complete" parameter?
skip entity decls
premature end of file
NOTE: These hook methods are added so that the full document
scanner can share the majority of code with this class.
in case continue-after-fatal-error set, should not do this...
call document handler
This inserts a doctypeDecl event into the stream though no
DOCTYPE existed in the instance document.
this could for cases like <foo/>
look at scanRootElementHook
we should have reached the end of the document in
there can't be any element after SCANNER_STATE_TERMINATED or when the parser
has reached the end of document
xxx what to do when the scanner has reached the terminating state.
NOTE: This is the only place we're allowed to reach
the real end of the document stream. Unless the
end of file was reached prematurely.
largest numerical value
These would not be used for EN. Only used for traditional numbering
These only used for mutiplicative-additive numbering
Note that we are using longs and that the last two
multipliers are not supported. This is a known limitation.
Dummy value to associate with an Object in the backing Map
Write out any hidden serialization magic
Write out HashMap capacity and load factor
Write out size
Write out all elements in the proper order.
Read in any hidden serialization magic
Read capacity and verify non-negative.
Read load factor and verify positive and non NaN.
Read size and verify non-negative.
Set the capacity according to the size and load factor ensuring that
the HashMap is at least 25% full but clamping to maximum capacity.
Create backing HashMap
Read in all elements in the proper order.
Documentation in subclasses because of synchro difference
Documentation in subclasses because of synchro difference
let arraycopy report AIOOBE for len < 0
Text is HTML
Text isn't HTML
We shouldn't use current icon and text widths
in maximal widths calculation for complex layout.
If maxLabelWidth is wider
than the widest icon + the widest text + gap,
we should update the maximal text witdh
An item can have an arrow or a check icon at once
Use SourceLoader if available
No SourceLoader or not resolved by SourceLoader
Return if we could not resolve the URL
precedence for the including stylesheet
Reminder: BerEncoder does backward encoding !
The easy work
Allocate the array to receive the encoding.
Encode the pdupacket
Reminder: BerEncoder does backward encoding !
Decode the pdu
bug id 4654066
The easy work
This call requires MBeanPermission 'getClassLoaderFor'
This call requires MBeanPermission 'getClassLoaderRepository'
Make this call just to force the 'getClassLoader'
Registers the MBeanServer identification MBean
These methods are called by the JMX MBeanServerBuilder.
Determine whether to use fair locking for the repository.
Default is true.
This constructor happens to disregard the value of the interceptors
flag - that is, it always uses the default value - false.
This is admitedly a bug, but we chose not to fix it for now
since we would rather not have anybody depending on the Sun private
interceptor APIs - which is most probably going to be removed and
replaced by a public (javax) feature in the future.
JMX OBJECT CLONING
Create new attribute list
Iterate through list and replace non JMX attributes
Iterate through list and replace non JMX attributes
Copyright (c) 1995-96 by Cisco Systems, Inc.
Only call installKeyboardActions as uninstall is not
copy across the sizeVariant property to the editor
add this message to fix bug 21478
Earlier (JDK 1.4 XALAN 2.2-D11) at key code '204' the key name was ER_PRIORITY_NOT_PARSABLE
In latest Xalan code base key name is  ER_VALUE_SHOULD_BE_NUMBER. This should also be taken care
in locale specific files like XSLTErrorResources_de.java, XSLTErrorResources_fr.java etc.
NOTE: Not only the key name but message has also been changed.
Note to translators:  The following message should not normally be displayed
to users.  It describes a situation in which the processor has detected
an internal consistency problem in itself, and it provides this message
for the developer to help diagnose the problem.  The name
'ElemTemplateElement' is the name of a class, and should not be
Note to translators:  The following message should not normally be displayed
to users.  It describes a situation in which the processor has detected
an internal consistency problem in itself, and it provides this message
for the developer to help diagnose the problem.  The substitution text
provides further information in order to diagnose the problem.  The name
'RedundentExprEliminator' is the name of a class, and should not be
This code is shared with warning codes.
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "QNAME" is the XML data-type of
The following codes are shared with the warning codes...
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "ENUM" is the XML data-type of
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "NMTOKEN" is the XML data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "NCNAME" is the XML data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "boolean" is the XSLT data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "number" is the XSLT data-type
End of shared codes...
Note to translators:  A "match pattern" is a special form of XPath expression
that is used for matching patterns.  The substitution text is the name of
a function.  The message indicates that when this function is referenced in
a match pattern, its argument must be a string literal (or constant.)
ER_ARG_LITERAL - new error message for bugzilla 5202
Note to translators:  The following message indicates that two definitions of
a variable.  A "global variable" is a variable that is accessible everywher
in the stylesheet.
ER_DUPLICATE_GLOBAL_VAR - new error message for bugzilla #790
Note to translators:  The following message indicates that two definitions of
a variable were encountered.
ER_DUPLICATE_VAR - new error message for bugzilla #790
Note to translators:  "xsl:template, "name" and "match" are XSLT keywords
which must not be translated.
ER_TEMPLATE_NAME_MATCH - new error message for bugzilla #789
Note to translators:  "exclude-result-prefixes" is an XSLT keyword which
should not be translated.  The message indicates that a namespace prefix
encountered as part of the value of the exclude-result-prefixes attribute
was in error.
ER_INVALID_PREFIX - new error message for bugzilla #788
Note to translators:  An "attribute set" is a set of attributes that can
be added to an element in the output document as a group.  The message
was never defined.
ER_NO_ATTRIB_SET - new error message for bugzilla #782
Note to translators:  This message indicates that there was a reference
Note to translators:  This message indicates that the XSLT instruction
instructions (content) or a "select" attribute.  The word "select" is
an XSLT keyword in this case and must not be translated.
Note to translators:  This message indicates that the value argument
of setParameter must be a valid Java Object.
Following are the new WARNING keys added in XALAN code base after Jdk 1.4 (Xalan 2.2-D11)
Note to translators:  "name" and "xsl:processing-instruction" are keywords
and must not be translated.
Note to translators:  "name" and "xsl:processing-instruction" are keywords
and must not be translated.  "NCName" is an XML data-type and must not be
Note to translators:  This message is reported if the stylesheet that is
being processed attempted to construct an XML document with an attribute in a
place other than on an element.  The substitution text specifies the name of
Check: WHY THERE IS A GAP B/W NUMBERS in the XSLTErrorResources properties file?
Other miscellaneous text used inside the code...
Note to translators:  The following messages provide usage information
for the Xalan Process command line.  "Process" is the name of a Java class,
and should not be translated.
Note to translators: The option name and the parameter name do not need to
be translated. Only translate the messages in parentheses.  Note also that
leading whitespace in the messages is used to indent the usage information
for each option in the English messages.
Do not translate the keywords: XSLTC, SAX, DOM and DTM.
Following are the new options added in XSLTErrorResources.properties files after Jdk 1.4 (Xalan 2.2-D11)
Added by sboag/scurcuru; experimental
AddITIONAL  STRINGS that need L10n
Note to translators:  The following message describes usage of a particular
command-line option that is used to enable the "template inlining"
optimization.  The optimization involves making a copy of the code
generated for a template in another template that refers to it.
================= INFRASTRUCTURE ======================
If we're in a predicate, then this will return non-null.
Can't convolve an IndexColorModel.  Need to expand it
Not much support for ICM
J2SE does not support Xalan interpretive
J2SE does not support Xalan interpretive
First calculate the distance moved in user space when
we move a single unit along the X & Y axes in device space.
Now calculate the (square of the) user space distance
between the anchor points. This value equals:
(UserVec . UserVec)
Now calculate the proportional distance moved along the
vector from p1 to p2 when we move a unit along X & Y in
The length of the projection of the Device Axis Vector is
its dot product with the Unit User Vector:
(DevAxisVec . (UserVec / Len(UserVec))
The "proportional" length is that length divided again
by the length of the User Vector:
(DevAxisVec . (UserVec / Len(UserVec))) / Len(UserVec)
which simplifies to:
((DevAxisVec . UserVec) / Len(UserVec)) / Len(UserVec)
which simplifies to:
(DevAxisVec . UserVec) / LenSquared(UserVec)
We are acyclic
If we are using the acyclic form below, we need
dx to be non-negative for simplicity of scanning
across the scan lines for the transition points.
To ensure that constraint, we negate the dx/dy
values and swap the points and colors.
Check our many preconditions
Okay, now initialize
temporary directory location
file name generation
Use only the file name from the supplied prefix
don't reveal temporary directory location
Add the separator character
read the previous separator char
-- Integration with java.nio.file --
special ACC used to initialize the IIOP stub
the only allowed privilege is SerializablePermission("enableSubclassImplementation")
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of SliderTrackPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of SliderTrackPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
GETTERS AND SETTERS
First remove the reference on the old adaptor server.
Then update the reference to the new adaptor server.
Should never occur...
First remove the reference on the old adaptor server.
Then update the reference to the new adaptor server.
Should never occur...
First remove the reference on the old adaptor server.
Then update the reference to the new adaptor server.
Should never occur...
First remove the reference on the old adaptor server.
Then update the reference to the new adaptor server.
Should never occur...
RFC 1905, Section 4.2.3, p14
Let's build the varBindList for the response pdu
Non-repeaters and first row of repeaters
Now the remaining repeaters
Ok the loop looks a bit strange. But in order to improve the
perf, we try to avoid reference to the limit variable from
within the loop ...
We need to duplicate the SnmpVarBind otherwise it is going
to be overloaded by the next get Next ...
No IOR, can we get a Tie for this stub?
Is the tie already connected?  If it is, check that it's
connected to the same ORB, otherwise connect it.
Thrown when tie is an ObjectImpl and its delegate is not set.
Thrown when tie is a Servant and its delegate is not set.
Get the delegate for the stub from the tie.
ior is initialized, so convert ior to an object, extract
the delegate, and set it on ourself
Package, abstract methods
made this public so it could be implemented and used outside this package -neilg.
Package final methods
made this public so it could be implemented and used outside this package -neilg.
made this public so it could be implemented and used outside this package -neilg.
Protected, abstract methods
Private data members
The type of node. This indicates whether its a leaf or an
operation. Though we also do derived classes for these types,
it is too expensive to use runtime typing to find this out.
This is one of the ContentSpecNode.NODE_XXX types.
The set of NFA states that represent the entry states of this
node in the DFA.
The set of NFA states that can be gotten to from from this
node in the DFA.
The set of NFA states that represent the final states of this
node in the DFA.
The maximum number of states that the NFA has, which means the
max number of NFA states that have to be traced in the state
sets during the building of the DFA. Its unfortunate that it
has to be stored redundantly, but we need to fault in the
state set members and they have to be sized to this size. We
init to to -1 so it will cause an error if its used without
Fall-through for variables that are implemented as methods
The method cloneIterator() also does resetting
-- This file was mechanically generated: Do not edit! --
close previous entry
by default, do NOT use extended timestamps in extra
data, for now.
use default method
store size, compressed size, and crc-32 in LOC header
store size, compressed size, and crc-32 in data descriptor
immediately following the compressed entry data
compressed size, uncompressed size, and crc-32 must all be
set for entries using STORED compression method
verify size, compressed size, and crc-32 settings
we already know that both e.size and e.csize are the same
write central directory
LOC header signature
version needed to extract
general purpose bit flag
last modification time
store size, uncompressed size, and crc-32 in data descriptor
immediately following compressed entry data
ver 4.5 for zip64
version needed to extract
general purpose bit flag
last modification time
headid(2) + size(2) + size(8) + csize(8)
info-zip extended timestamp
headid(2) + size(2) + flag(1) + data
flag + data
EXT header signature
CEN header signature
ver 4.5 for zip64
version made by
version needed to extract
general purpose bit flag
last modification time
+ headid(2) + datasize(2)
cen info-zip extended timestamp only outputs mtime
but set the flag for a/ctime, if present in loc
headid + sz + flag
starting disk number
internal file attributes (unused)
external file attributes (unused)
relative offset of local header
take care of EXTID_ZIP64 and EXTID_EXTT
flag + mtime
zip64 end of central directory record
zip64 END record signature
size of zip64 end
version made by
version needed to extract
number of this disk
central directory start disk
number of directory entires on disk
number of directory entires
length of central directory
offset of central directory
zip64 end of central directory locator
zip64 END locator signature
zip64 END start disk
offset of zip64 END
total number of disks (?)
END record signature
number of this disk
central directory start disk
number of directory entries on disk
total number of directory entries
length of central directory
offset of central directory
zip file comment
A SynthPainter is created per <imagePainter>.  We want the
cache to be shared by all, and we don't use a static because we
don't want it to persist between look and feels.  For that reason
we use a AppContext specific Paint9Painter.  It's backed via
a WeakRef so that it can go away if the look and feel changes.
Whether this Component has had the background erase flag
specified via SunToolkit.disableBackgroundErase(). This is
needed in order to make this function work on X11 platforms,
where currently there is no chance to interpose on the creation
of the peer and therefore the call to XSetBackground.
For strict compliance with prior platform versions, a Component
that doesn't set its name should return null from
NOTE: This method may be called by privileged threads.
This functionality is implemented in a package-private method
to insure that it cannot be overridden by client subclasses.
DO NOT INVOKE CLIENT CODE ON THIS THREAD!
This method is overridden in the Window class to return null,
because the parent field of the Window object contains
the owner of the window, not its parent.
if we have a new one, and we have a peer, add it!
we are top level window or haven't a container, return our bounds
translate the container's bounds to our coordinate space
A disabled lw container is allowed to contain a focus owner.
Don't clear the global focus owner. If transferFocus
fails, we want the focus to stay on the disabled
Component so that keyboard traversal, et. al. still
makes sense to the user.
If this component already has focus, then activate the
input method by dispatching a synthesized focus gained
This is a bound property, so report the change to
any registered listeners.  (Cheap if there are none.)
This is a bound property, so report the change to
any registered listeners.  (Cheap if there are none.)
NOTE: This method may be called by privileged threads.
This functionality is implemented in a package-private method
to insure that it cannot be overridden by client subclasses.
DO NOT INVOKE CLIENT CODE ON THIS THREAD!
This is a bound property, so report the change to
any registered listeners.  (Cheap if there are none.)
This could change the preferred size of the Component.
Fix for 6213660. Should compare old and new fonts and do not
call invalidate() if they are equal.
This is a bound property, so report the change to
any registered listeners.  (Cheap if there are none.)
This could change the preferred size of the Component.
lightweight component location needs to be translated
relative to a native component.
LightwightPeer is an empty stub so can skip peer.reshape
Check peer actualy changed coordinates
fix for 5025858: do not send ComponentEvents for toplevel
windows here as it is done from peer or native code when
the window is really resized or moved, otherwise some
events may be sent twice
Have the parent redraw the area this component occupied.
Have the parent redraw the area this component *now* occupies.
native peer might be offset by more than direct
parent since parent might be lightweight.
If the preferred size was set, use it as the old value, otherwise
use null to indicate we didn't previously have a set preferred
If the minimum size was set, use it as the old value, otherwise
use null to indicate we didn't previously have a set minimum
If the maximum size was set, use it as the old value, otherwise
use null to indicate we didn't previously have a set maximum
There's no parents. Just validate itself.
If there's no validate roots, we'll validate the
This is for a lightweight component, need to
translate coordinate spaces and clip relative
to the parent.
This is for a lightweight component, need to
translate coordinate spaces and clip relative
to the parent.
This is an unsupported hack, but left in for a customer.
Do not remove.
Needs to be translated to parent coordinates since
a parent native container provides the actual repaint
services.  Additionally, the request is restricted to
the bounds of the component.
REMIND : check caps
Try to create a page-flipping strategy
Try a blitting (but still accelerated) strategy
Try an unaccelerated blitting strategy
Code should never reach here (an unaccelerated blitting
strategy should always work)
Destroy old buffers
save the current bounds
dispose the existing backbuffers
... then recreate the backbuffers
if this buffer strategy is not allowed to be v-synced,
change the caps that we pass to the peer but keep on
do not throw IAE here in case it is disallowed, see
ExtendedBufferCapabilities for more info
get the images associated with the draw buffer
component has been resized; recreate the backbuffers
shouldn't be possible
get the buffers from the peer every time since they
might have been replaced in response to a display change event
now validate the backbuffer
shouldn't be possible
backbuffers were recreated, so validate again
Inner class FlipBufferStrategy
save the current bounds
It is possible for the component's width and/or height
to be 0 here.  Force the size of the backbuffers to
be > 0 so that creating the image won't fail.
flush any existing backbuffers
create the backbuffers
Adjust location to be relative to client area.
Not showing, bail
First image copy is in terms of Frame's coordinates, need
to translate to client area.
component has been resized; recreate the backbuffers
now validate the backbuffer
backbuffers were recreated, so validate again
else case means we're called from Swing on the toolkit
thread, don't recreate buffers as that'll deadlock
(creating VolatileImages invokes getting GraphicsConfig
which grabs treelock).
Inner class BltBufferStrategy
This is invoked by Swing on the toolkit thread.
This method is called by Swing on the toolkit thread.
Inner class SingleBufferStrategy
Check that this component belongs to this app-context
Timestamp of a key event is set later in DKFM.preDispatchKeyEvent(KeyEvent).
Invoke the private focus retargeting method which provides
lightweight Component support
Now, with the event properly targeted to a lightweight
descendant if necessary, invoke the public focus retargeting
and dispatching function
MouseWheel may need to be retargeted here so that
AWTEventListener sees the event go to the correct
Component.  If the MouseWheelEvent needs to go to an ancestor,
the event is dispatched to the ancestor, and dispatching here
We need to pass on InputMethodEvents since some host
input method adapters send them through the Java
event queue instead of directly to the component,
and the input context also handles the Java composition window
Otherwise, we only pass on input and focus events, because
a) input methods shouldn't know about semantic or component-level events
b) passing on the events takes time
c) isConsumed() is always true for semantic events.
When non-clients get focus, we need to explicitly disable the native
input method. The native input method is actually not disabled when
the active/passive/peered clients loose focus.
Handling of the PAINT and UPDATE events is now done in the
peer's handleEvent() method so the background can be cleared
selectively for non-native components on Windows only.
- Fred.Ecks@Eng.sun.com, 5-8-98
Filtering needs to really be moved to happen at a lower
level in order to get maximum performance gain;  it is
here temporarily to ensure the API spec is honored.
newEventsOnly will be false for a listenerless ScrollPane, but
MouseWheelEvents still need to be dispatched to it so scrolling
can be done.
if target changed key or modifier values, copy them
back to original event
if focus owner is lightweight then its native container
Coordinates take into account at least
the cursor's position relative to this
Component (e.getX()), and this Component's
position relative to its parent.
fix coordinates to be relative to new event source
Change event to be from new source, with new x,y
For now, just create a new event - yucky
x relative to new source
y relative to new source
When dispatching a wheel event to
ancestor, there is no need trying to find descendant
lightweights to dispatch event to.
If we dispatch the event to toplevel ancestor,
this could encolse the loop: 6480024.
in 1.2, we assume input method support is required for all
components that handle key events, but components can turn off
input methods by calling enableInputMethods(false).
REMIND: remove when filtering is handled at lower level
Always pass on events defined by external programs.
Event source interfaces
if this is a lightweight component, enable focus events
in the native container.
Should only be called while holding the tree lock
One mask or the other, but not neither or both.
Should only be called while holding tree lock
Should only be called while holding the tree lock
if this is a lightweight component, enable key events
in the native container.
if this is a lightweight component, enable mouse events
in the native container.
if this is a lightweight component, enable mouse events
in the native container.
if this is a lightweight component, enable mouse events
in the native container.
if this is a lightweight component, enable mouse events
in the native container.
Need to check non-bootstraps.
First check superclass - we may not need to bother ourselves.
Only occurs on implementations that
do not use null to represent the bootsrap class loader.
Not done already - recurse.
Throws if not overriden.
Not present in this class.
Update both the Component's peer variable and the local
variable we use for thread safety.
This is a lightweight component which means it won't be
able to get window-related events by itself.  If any
have been enabled, then the nearest native container must
It's native. If the parent is lightweight it will need some
Update stacking order
If there is any input context for this component, notify
that this component is being removed. (This has to be done
before hiding peer.)
Hide peer first to stop system events such as cursor moves.
Stop peer updates.
Nullifying compoundShape means that the component has normal shape
(or has no shape at all).
We define these methods so that Container does not need to repeat this
code. Container cannot call super.<method> because Container allows
DOWN_CYCLE_TRAVERSAL_KEY while Component does not. The Component method
would erroneously generate an IllegalArgumentException for
Okay to return Set directly because it is an unmodifiable view
1) Check if the event being dispatched is a system-generated mouse event.
2) Sanity check: if the mouse event component source belongs to the same containing window.
If both the conditions are fulfilled the focus request should be strictly
bounded by the toplevel window. It's assumed that the mouse event activates
the window (if it wasn't active) and this makes it possible for a focus
request with a strong in-window requirement to change focus in the bounds
of the toplevel. If, by any means, due to asynchronous nature of the event
dispatching mechanism, the window happens to be natively inactive by the time
this focus request is eventually handled, it should not re-activate the
toplevel. Otherwise the result may not meet user expectations. See 6981400.
Update most-recent map
Focus this Component
A focus request made from outside EDT should not be associated with any event
and so its time stamp is simply set to the current time.
We have passed all regular checks for focus request,
now let's call RequestFocusController and see what it says.
sometimes most recent focus owner may be null, but focus owner is not
e.g. we reset most recent focus owner if user removes focus owner
Controller is supposed to verify focus transfers and for this it
should know both from and to components.  And it shouldn't verify
transfers from when these components are equal.
we shouldn't call RequestFocusController in case we are
in activation.  We do request focus on component which
has got temporary focus lost and then on component which is
most recent focus owner.  But most recent focus owner can be
changed by requestFocsuXXX() call only, so this transfer has
been already approved.
Swing access this method through reflection to implement InputVerifier's functionality.
Perhaps, we should make this method public (later ;)
For Swing serialization to correctly work Swing needs to
be notified before Component does it's serialization.  This
hack accomodates this.
Swing classes MUST be loaded by the bootstrap class loader,
otherwise we don't consider them.
Find the first override of the compWriteObjectNotify method
We found it, use doPrivileged to make it accessible
Invoke the method
We're done, bail.
These fields are non-transient and rely on default
serialization. However, the default values are insufficient,
so we need to set them explicitly for object data streams prior
skip value for unrecognized key
Read the component's orientation if it's present
JDK 1.1 instances will not have this optional data.
e.eof will be true to indicate that there is no more
data available for this object.
If e.eof is not true, throw the exception as it
might have been caused by reasons unrelated to
skip value for unrecognized key
JDK 1.1/1.2 instances will not have this optional data.
e.eof will be true to indicate that there is no more
data available for this object.
If e.eof is not true, throw the exception as it
might have been caused by reasons unrelated to
hierarchy and hierarchyBounds listeners.
skip value for unrecognized key
pre-1.3 instances will not have this optional data.
e.eof will be true to indicate that there is no more
data available for this object.
If e.eof is not true, throw the exception as it
might have been caused by reasons unrelated to
mouse wheel listeners
This is a bound property, so report the change to
any registered listeners.  (Cheap if there are none.)
This could change the preferred size of the Component.
It is enabled, visible, focusable.
- it is enabled, visible, focusable
- it's parents are all enabled and showing
inner class AccessibleAWTComponentHandler
inner class AccessibleAWTFocusHandler
Components don't have children
Components don't have children
Components don't have children
inner class AccessibleAWTComponent
The Region class has some optimizations. That's why
we should manually check whether it's empty and
substitute the object ourselves. Otherwise we end up
with some incorrect Region object with loX being
greater than the hiX for instance.
Note: the shape is not really copied/cloned. We create
the Region object ourselves, so there's no any possibility
to modify the object outside of the mixing code.
Nullifying compoundShape means that the component has normal shape
(or has no shape at all).
XXX: if we allow LW components to have a shape, this must be changed
XXX: we may take into account a user-specified shape for this component
further traversing may return a component that is not actually
a native sibling of this component and this kind of z-order
request may not be allowed by the underlying system (6852051).
Because applyCompoundShape() ignores such components anyway
First, reapply shapes of my siblings
Second, if my container is non-opaque, reapply shapes of siblings of my container
First, cut my siblings
Second, if my container is non-opaque, cut siblings of my container
We cannot be sure that the peer exists at this point, so we need the argument
to find out whether the hiding component is (well, actually was) a LW or a HW.
This method gets overriden in the Container. Obviously, a plain
non-container components don't need to handle validation.
Note that the method is overriden in the Window class,
a window doesn't need to be updated in the Z-order.
Get the name of these decimal formatting symbols
Check if a set of symbols has already been registered under this name
xsl:decimal-format - except for the NaN and infinity attributes.
Push the format name on the stack for call to addDecimalFormat()
Manufacture a DecimalFormatSymbols on the stack
for call to addDecimalFormat()
Use the US Locale as the default, as most of its settings
are equivalent to the default settings required of
Push the format name, which is empty, on the stack
for call to addDecimalFormat()
Manufacture a DecimalFormatSymbols on the stack for
call to addDecimalFormat().  Use the US Locale as the
default, as most of its settings are equivalent to
the default settings required of xsl:decimal-format -
except for the NaN and infinity attributes.
%REVIEW% Why isn't this just traverse(pos,pos)?
Remember the root of this subtree
%REVIEW% This condition isn't tested in traverse(pos,top)
%OPT% Can we simplify the loop conditionals by adding:
-- or by simply ignoring this case and relying on the fact that
pos will never equal DTM.NULL until we're ready to exit?
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of SpinnerNextButtonPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of SpinnerNextButtonPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
Much of the Metal UI for JFilechooser is just a copy of
the windows implementation, but using Metal themed buttons, lists,
icons, etc. We are planning a complete rewrite, and hence we've
made most things in this class private.
Preferred and Minimum sizes for the dialog box
Labels, mnemonics, and tooltips (oh my!)
ComponentUI Interface Implementation methods
Directory manipulation buttons
Add the top panel to the fileChooser
Must be small enough to not affect total width.
New Directory Button
View button group
FileName label and textfield
Filetype label and combobox
Note: Metal does not use mnemonics for approve and cancel
Obsolete class, not used in this version.
Obsolete class, not used in this version.
Note: Metal does not use mnemonics for approve and cancel
Ancestor was added, set initial focus
PENDING(jeff) - get the name from the directory combobox
PENDING(jeff) - set the name in the directory combobox
Renderer for DirectoryComboBox
DataModel for DirectoryComboxbox
Add the current directory to the model, and make it the
Get the canonical (full) path. This has the side
benefit of removing extraneous chars from the path,
for example /foo/bar/ becomes /foo/bar
Maybe drive is not ready. Can't abort here.
create File instances of each directory leading up to the top
Insert chain at appropriate place in vector
Renderer for Types ComboBox
DataModel for Types Comboxbox
Ensure that the current filter is in the list.
NOTE: we shouldnt' have to do this, since JFileChooser adds
the filter to the choosable filters list when the filter
is set. Lets be paranoid just in case someone overrides
setFileFilter in JFileChooser.
This shouldn't happen. Try to recover gracefully.
Align the width with all other labels in group.
serialVersionUID not constant
Serialization compatibility stuff:
Two serial forms are supported in this class. The selected form depends
on system property "jmx.serial.form":
- "1.0" for JMX 1.0
- any other value for JMX 1.1 and higher
Serial version for old serial form
Serial version for new serial form
Serializable fields in old serial form
Serializable fields in new serial form
Actual serial version and serial form
OK : Too bad, no compat with 1.0
END Serialization compatibility stuff
-param notifKind  1 for creation/removal, 2 for update
-param notifType  type of the notification; either:
for an update, or:
for a creation or removal
-param sourceObj  source object, sending the notification. Will always
be a RelationService object.
-param sequence  sequence number to identify the notification
-param timeStamp  time stamp
-param message  human-readable message describing the notification
-param id  relation id identifying the relation in the Relation
-param typeName  name of the relation type
-param objectName  ObjectName of the relation object if it is an MBean
(null for relations internally handled by the Relation Service)
-param unregMBeanList  list of ObjectNames of MBeans expected to be
removed due to relation removal
-param name  name of the updated role
-param newValue  new value (List of ObjectName objects)
-param oldValue  old value (List of ObjectName objects)
-exception IllegalArgumentException  if:
- no value for the notification type
- incorrect notification type
- no source object
- the source object is not a Relation Service
- no relation id
- no relation type name
- no role name (for role update)
- no role old value (for role update)
- no role new value (for role update)
Despite the fact, that validation in constructor of RelationNotification prohibit
creation of the class instance with null sourceObj its possible to set it to null later
by public setSource() method.
So we should relax validation rules to preserve serialization behavior compatibility.
NPE thrown if we attempt to add null object
Validate fields we just read, throw InvalidObjectException
if something goes wrong
assign deserialized vaules to object fields
Serializes this instance in the old serial form
Serializes this instance in the new serial form
Rollover button implementation.
Initialize instance vars
Clear instance vars
Toolbar specific defaults
ToolBar rollover button borders
added in setFloating
Put focus listener on all components in toolbar
removed in setFloating
Remove focus listener from all components in toolbar
Override createRootPane() to automatically resize
the frame when contents change
Override createRootPane() to automatically resize
the frame when contents change
Put rollover borders on buttons
Put non-rollover borders on buttons. These borders reduce the margin.
Put back the normal borders on buttons
Only set the border if its the default border
Only set the border if its the default border
North  (Base distance on height for now!)
East  (Base distance on height for now!)
West  (Base distance on height for now!)
Revert the button border
Search for JSeparator components and change it's orientation
to match the toolbar and flip it's orientation.
Flip the orientation.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
offset of the mouse cursor inside the DragWindow
Paint the children
copy some parameters
for use in the quadractic equation
test if distance from focus to center is greater than the radius
clamp focus to radius
calculate the solution to be used in the case where X == focusX
constant parts of X, Y user space coordinates
constant second order delta for simple loop
coordinates of UL corner in "user space" relative to center
second order delta calculated in constructor
adjust is (scan-w) of pixels array, we need (scan)
rgb of the 1.0 color used when the distance exceeds gradient radius
these values depend on the coordinates of the start of the row
Quick fill for "out to the left"
Slow fill for "in the heart"
store the color at this point
Quick fill to end of line for "out to the right"
SQRT_LUT_SIZE must be a power of 2 for the test above to work.
constant part of the C factor of the quadratic equation
coefficients of the quadratic equation (Ax^2 + Bx + C = 0)
slope and y-intercept of the focus-perimeter line
intersection with circle X,Y coordinate
constant parts of X, Y coordinates
constants in inner loop quadratic formula
value between 0 and 1 specifying position in the gradient
determinant of quadratic formula (should always be > 0)
sq distance from the current point to focus
sq distance from the intersect point to focus
temp variables for change in X,Y squared
used to index pixels array
incremental index change for pixels array
for every row
user space point; these are constant from column to column
for every column (inner loop begins here)
special case to avoid divide by zero
slope and y-intercept of the focus-perimeter line
use the quadratic formula to calculate the
choose the positive or negative root depending
on where the X coord lies with respect to the focus
Calculate the square of the distance from the current point
to the focus and the square of the distance from the
intersection point to the focus. Want the squares so we can
do 1 square root after division instead of 2 before.
get the percentage (0-1) of the current point along the
store the color at this point
incremental change in X, Y
end inner loop
end outer loop
Child is double slash
"/c:/foo" --> "c:/foo"
"c:/foo/" --> "c:/foo", but "c:/" --> "c:/"
"/foo/" --> "/foo"
Caches for canonicalization results to improve startup performance.
The first cache handles repeated canonicalizations of the same path
name. The prefix cache handles repeated canonicalizations within the
same directory, and must not create results differing from the true
canonicalization algorithm in canonicalize_md.c. For this reason the
prefix cache is conservative and is not used for complex path names.
If path is a drive letter only then skip canonicalization
Run the canonicalization operation assuming that the prefix
(everything up to the last filename) is canonical; just gets
the canonical name of the last element of the path
Best-effort attempt to get parent of this path; used for
optimization of filename canonicalization. This must return null for
any cases where the code in canonicalize_md.c would throw an
exception or otherwise deal with non-simple pathnames like handling
of "." and "..". It may conservatively return null in other
situations as well. Returning null will cause the underlying
(expensive) canonicalization routine to be called.
Punt on pathnames containing . and ..
Punt on pathnames ending in a .
Punt on pathnames containing . and ..
Punt on pathnames containing adjacent slashes
toward the end
Punt on pathnames containing both backward and
Punt on pathnames containing wildcards
Keep canonicalization caches in sync after file deletion
and renaming operations. Could be more clever than this
(i.e., only remove/update affected entries) but probably
not worth it since these entries expire after 30 seconds
Keep canonicalization caches in sync after file deletion
and renaming operations. Could be more clever than this
(i.e., only remove/update affected entries) but probably
not worth it since these entries expire after 30 seconds
returning flavors itself would allow client code to modify
our internal behavior
JCK Test StringSelection0003: if 'flavor' is null, throw NPE
JCK Test StringSelection0007: if 'flavor' is null, throw NPE
Locale for creating a JapaneseImpericalCalendar.
override with covariant return type
Assume that the last JapaneseEra is the current one.
+1 due to the different definitions
override for return type
override for special Japanese behavior
validate era and year-of-era
if only year-of-era and no year then invent era unless strict
if both present, then try to create date
handle the era being changed
only allow if the new date is in the same Jan-Dec as the era change
determine by ensuring either original yoe or result yoe is 1
smart is same as strict
XXX Fix message i18n
Ignore all errors after reaching the limit
Print a warning before the first error
Currently it's two different but equivalent objects.  This only
really impacts proxy generation.  For MBean creation, the
cached PerInterface object for an MBean interface means that
an analyzer will not be recreated for a second MBean using the
Introspect the mbeanInterface and initialize this object's maps.
It's a getter
Check we don't have both isX and getX
It's a setter
It's an operation
Super type comes first: Object, Number, Integer
could assert bret.isAssignableFrom(aret)
We are assuming that you never have very many methods with the
same name, so it is OK to use algorithms that are quadratic
in the number of methods with the same name.
Methods that don't have the same name can't override each other
Methods that have the same name and same signature override
each other. In that case, the second method overrides the first,
due to the way we have sorted them in MethodOrder.
3 in CORBA 2.3.1 13.6.3
Class objects can't occur here; no need to test
and call Class.getName().
replace T[] with T...
Easy case: we don't have generic parameter information.  In
this case, we just return the result of
If we have real parameter data, then we use the
synthetic and mandate flags to our advantage.
If we hit a synthetic or mandated parameter,
use the non generic parameter info.
Otherwise, use the generic parameter info.
Otherwise, use the non-generic parameter data.
Without method parameter reflection data, we have
no way to figure out which parameters are
synthetic/mandated, thus, no way to match up the
TODO: This may eventually need to be guarded by security
mechanisms similar to those in Field, Method, etc.
Need to copy the cached array to prevent users from messing
with it.  Since parameters are immutable, we can
TODO: is there a way to synthetically derive the
modifiers?  Probably not in the general case, since
we'd have no way of knowing about them, but there
may be specific cases.
Use tmp to avoid multiple writes to a volatile.
Otherwise, go to the JVM to get them
If we get back nothing, then synthesize parameters
If this somehow gets called before parameters gets
initialized, force it into existence.
Needed by reflectaccess
the type of items in the list
construct a list datatype validator
Check each token in list against base type
it MUST be a power of two
special object for null key
table's length MUST be a power of two
the next size value at which to resize
the number of key-value mappings
unsynchronized search improves performance
the null value does not mean that there are no needed entry
synchronized search improves stability
we must create and add new value if there are no needed entry
If ignoring null elements and processing ref queue caused massive
shrinkage, then restore old table.  This should be rare, but avoids
unbounded expansion of garbage-filled tables.
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of CheckBoxMenuItemPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of CheckBoxMenuItemPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
limit to valid range
Max quantizer for 12 bits
-- This file was mechanically generated: Do not edit! --
Programmer's assert.  (And, no, I don't want the method to be abstract).
no default action
the second argument node-set is empty
System.err.println("arg2FirstNode name: "
+ dom.getNodeName(arg2FirstNode )+"["
%OPT% Optimization to cache the stylesheet DOM.
The stylesheet DOM is built once and cached
in the Templates object.
If the cached dom exists, we need to migrate it
to the new DTMManager and create a DTMAxisIterator
for the document.
Prepend URI base to URI (from context)
Return an empty iterator if the URI is clearly invalid
(to prevent some unncessary MalformedURL exceptions).
Check if this DOM has already been added to the multiplexer
Check if we can get the DOM from a DOMCache
Parse the input document and construct DOM object
Trust the DTMManager to pick the right parser and
set up the DOM correctly.
Cache the stylesheet DOM in the Templates object
Wrap the DOM object in a DOM adapter and add to multiplexer
Create index for any key elements
Return a singleton iterator containing the root node
document(node-set) if true;  document(node-set,node-set) if false
Need to migrate the cached DTM to the new DTMManager
Wrap the DOM object in a DOM adapter and add to multiplexer
Create index for any key elements
Return a singleton iterator containing the root node
Initializing the Character Flag Array
Code generated by: XML11CharGenerator.
Fill 8 of value (byte) 17
Fill 2 of value (byte) 17
Fill 18 of value (byte) 17
Fill 5 of value (byte) 33
Fill 6 of value (byte) 33
Fill 2 of value (byte) -87
Fill 10 of value (byte) -87
Fill 4 of value (byte) 33
Fill 26 of value (byte) -19
Fill 2 of value (byte) 33
Fill 26 of value (byte) -19
Fill 4 of value (byte) 33
Fill 6 of value (byte) 17
Fill 26 of value (byte) 17
Fill 23 of value (byte) 33
Fill 8 of value (byte) 33
Fill 23 of value (byte) -19
Fill 31 of value (byte) -19
Fill 520 of value (byte) -19
Fill 112 of value (byte) -87
Fill 14 of value (byte) -19
Fill 7297 of value (byte) -19
Fill 12 of value (byte) 33
Fill 2 of value (byte) -19
Fill 26 of value (byte) 33
Fill 22 of value (byte) 33
Fill 2 of value (byte) -87
Fill 47 of value (byte) 33
Fill 288 of value (byte) -19
Fill 2672 of value (byte) 33
Fill 1008 of value (byte) -19
Fill 17 of value (byte) 33
Fill 43007 of value (byte) -19
Fill 6400 of value (byte) 33
Fill 1232 of value (byte) -19
Fill 32 of value (byte) 33
Fill 526 of value (byte) -19
Public static methods
next node in stack
the node matched to this
to control park/unpark
data; or null for REQUESTs
Note: item and mode fields don't need to be volatile
since they are always written before, and read after,
other volatile/atomic operations.
waiters need at most one unpark
constructed/reused as needed
empty or same-mode
pop cancelled node
wait was cancelled
help s's fulfiller
try to fulfill
pop and retry
loop until matched or waiters disappear
m is s's match
all waiters are gone
pop fulfill node
use new node next time
restart main loop
pop both s and m
help a fulfiller
m is h's match
waiter is gone
pop fulfilling node
pop both h and m
establish waiter so can park next iter
Absorb cancelled nodes at head
Unsplice embedded nodes
next node in queue
CAS'ed to or from null
to control park/unpark
initialize to dummy node.
forget old next
constructed/reused as needed
saw uninitialized value
empty or same-mode
failed to link in
swing tail and wait
wait was cancelled
not already unlinked
unlink if head
and forget fields
node to fulfill
m already fulfilled
dequeue and retry
Return early if already unlinked
Absorb cancelled first node as head
Ensure consistent read for tail
If not tail, try to unsplice
Try unlinking previous cancelled node
d is gone or
d is off list or
d not cancelled or
d not tail and
that is on list
s is already saved node
Postpone cleaning s
Convert Exception to corresponding Error
base of tmp array slice
length of tmp array slice
Number of pending runs on stack
Allocate temp storage (which may be increased later if necessary)
Arrays of size 0 and 1 are always sorted
If array is small, do a "mini-TimSort" with no merges
Identify next run
If run is short, extend to min(minRun, nRemaining)
Push run onto pending-run stack, and maybe merge
Advance to find next run
Merge all remaining runs to complete sort
Set left (and right) to the index where a[start] (pivot) belongs
The number of elements to move
Switch is just an optimization for arraycopy in default case
Find end of run, and reverse range if descending
Becomes 1 if any 1 bits are shifted off
Invariant is established
Merge remaining runs, using tmp array with min(len1, len2) elements
Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
Make offsets relative to base
key <= a[base + hint]
Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
Make offsets relative to base
a[base + m] < key
key <= a[base + m]
so a[base + ofs - 1] < key <= a[base + ofs]
Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
Make offsets relative to b
a[b + hint] <= key
Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
Make offsets relative to b
key < a[b + m]
a[b + m] <= key
so a[b + ofs - 1] <= key < a[b + ofs]
Copy first run into temp array
Indexes into tmp array
Indexes int a
Indexes int a
Move first element of second run and deal with degenerate cases
Last elt of run 1 to end of merge
Use local variable for performance
Number of times in a row that first run won
Number of times in a row that second run won
len1 == 1 || len1 == 0
Penalize for leaving gallop mode
End of "outer" loop
Write back to field
Last elt of run 1 to end of merge
Copy second run into temp array
Indexes into a
Indexes into tmp array
Indexes into a
Move last element of first run and deal with degenerate cases
Use local variable for performance
Number of times in a row that first run won
Number of times in a row that second run won
len2 == 1 || len2 == 0
Penalize for leaving gallop mode
End of "outer" loop
Write back to field
Move first elt of run2 to front of merge
Compute smallest power of 2 > minCapacity
Not bloody likely!
MenuShortcut wasn't found
Is it a key event?
Is the accelerator modifier key pressed?
Pass MenuShortcut on to child menus.
HeadlessException will be thrown from MenuComponent's readObject
Make no net change to g
get Accelerator text
layout the text and icon
Paint the Check
Paint the Icon
Use default icon
Draw the Text
Once BasicHTML becomes public, use BasicHTML.propertyKey
instead of the hardcoded string below!
Draw the Accelerator Text
Get the maxAccWidth from the parent to calculate the offset.
Calculate the offset, with which the accelerator texts will be drawn with.
Paint the Arrow
Position the Accelerator text rect
Position the Check and Arrow Icons
Position the Accelerator text rect
Position the Check and Arrow Icons
Align the accelertor text and the check and arrow icons vertically
with the center of the label rect.
shadowed button region
javadoc inherited from Throwable.java
indicates if Class-Path attribute present (only valid if hasCheckedSpecialAttributes true)
true if manifest checked for special attributes
Set up JavaUtilJarAccess in SharedSecrets
If found then load the manifest
Assume since we found a signature-related file
that the jar is signed and that we therefore
need a JarVerifier and Manifest
No signature-related files; don't instantiate a
Verify "META-INF/" entries...
if we had an error parsing any blocks, just
treat the jar file as being unsigned
if after initializing the verifier we have nothing
signed, we null it out.
could be set to null after a call to
initializeVerifier if we have nothing to
wrap a verifier stream around the real stream
Statics for hand-coded Boyer-Moore search
The bad character shift for "class-path"
The good suffix shift for "class-path"
First look up manifest entry using standard name
If not found, then iterate through all the "META-INF/"
entries to find a match.
Optimize away even scanning of manifest for jar files we
deliver which don't have a class-path attribute. If one of
these jars is changed to include such an attribute this code
must be changed.
screen out entries which are never signed
Keep track of the composed text
ignore temporary focus event
if there is a composed text, process it first
Give it a chance to reformat.
Assumed to be valid
Attempt to commit the value
value not committed, don't notify ActionListeners
SAX DTD handler.
No warranty; no copyright -- use this as you will.
$Id: DTDHandler.java,v 1.2 2004/11/03 22:44:51 jsuttor Exp $
end of DTDHandler.java
End of file.
Initialize everything for a first/second run.
Can only enter DTD state once. Once we're out of DTD
state, can no longer re-enter it.
Only works if we're going out of DTD mode.
The line consists of the text accumulated in _line,
followed by one or more spaces as counted by _spaces,
followed by more space accumulated in _text:
-  Text is printed and accumulated into _text.
-  A space is printed, so _text is added to _line and
a space is counted.
-  More text is printed and accumulated into _text.
-  A space is printed, the previous spaces are added
to _line, the _text is added to _line, and a new
space is counted.
If text was accumulated with printText(), then the space
means we have to move that text into the line and
start accumulating new text with printText().
If the text breaks a line bounary, wrap to the next line.
The printed line size consists of the indentation we're going
to use next, the accumulated line so far, some spaces and the
accumulated text so far.
Print line and new line, then zero the line contents.
We don't throw an exception, but hold it
until the end of the document.
Add as many spaces as we accumulaed before.
At the end of this loop, _spaces is zero.
Starting a new word: accumulate the text between the line
and this new word; not a new word: just add another space.
Equivalent to calling printSpace and forcing a flushLine.
Print line and new line, then zero the line contents.
We don't throw an exception, but hold it
until the end of the document.
Make sure the indentation does not blow us away.
Print the indentation as spaces and set the current
indentation to the next expected indentation.
There is no need to print the spaces at the end of the line,
they are simply stripped and replaced with a single line
We don't throw an exception, but hold it
until the end of the document.
We don't throw an exception, but hold it
until the end of the document.
If there is no current line and we're de-identing then
this indentation level is actually the next level.
We can't be here since we implement Cloneable.
We can't be here since we implement Cloneable.
Used to establish initial head or SHARED marker
Used by addWaiter
Used by Condition
See below for intrinsics setup to support this
Try the fast path of enq; backup to full enq on failure
loop to recheck cases
loop on failed CAS
loop if head changed
Record old head for check below
Utilities for various versions of acquire
Ignore if node doesn't exist
Skip cancelled predecessors
predNext is the apparent node to unsplice. CASes below will
fail if not, in which case, we lost race vs another cancel
or signal, so no further action is necessary.
Can use unconditional write instead of CAS here.
After this atomic step, other Nodes can skip past us.
Before, we are free of interference from other threads.
If we are the tail, remove ourselves.
If successor needs signal, try to set pred's next-link
so it will get one. Otherwise wake it up to propagate.
Main exported methods
Queue inspection methods
handle only fast path, else relay
The correctness of this depends on head being initialized
before tail and on head.next being accurate if the current
thread is first in queue.
Read fields in reverse initialization order
Instrumentation and monitoring methods
Internal support methods for Conditions
If has successor, it must be on queue
Instrumentation methods for conditions
If lastWaiter is cancelled, clean out.
clean up if cancelled
support for instrumentation
this shouldn't happen, since we are Cloneable
name treated as AVT (7.1.3)
specified name is not AVT
Ignore attribute if preceeded by some other type of element
These three objects result in one or more attribute output
These objects _can_ result in one or more attribute
The output handler will generate an error if not (at runtime)
Report warning but do not ignore attribute
Get namespace from namespace attribute?
Get namespace from prefix in name attribute?
Common handling for namespaces:
Generate prefix if we have none
Compile code that emits any needed namespace declaration
public void attribute(final String name, final String value)
if the qname is an AVT, then the qname has to be checked at runtime if it is a valid qname
store the name into a variable first so _name.translate only needs to be called once
call checkQName if the name is an AVT
Save the current handler base on the stack
first arg to "attributes" call
load name value again
Save the current handler base on the stack
first arg to "attributes" call
Push attribute name
Push attribute value - shortcut for literal strings
translate contents with substituted handler
get String out of the handler
Set the HTML flags
Restore old handler base from stack
The width and height of a title pane button
17 + 1 pixel border
Get around protected method in superclass
Forward mouse events to titlebar for moves.
largest numerical value
These would not be used for EN. Only used for traditional numbering
These only used for mutiplicative-additive numbering
Any remaining milliseconds after determining the year and month are discarded.
Short cuts to constant pool
Get name and signature from constant pool
read and discard the repository ID
write the repository ID
initialize log status
BEGIN: Keys needed for exception messages of  JAXP 1.3 XPath API implementation
END: Keys needed for exception messages of  JAXP 1.3 XPath API implementation
Note to translators:  A relative location path is a form of XPath expression.
The message indicates that such an expression was expected following the
characters '/' or '', but was not found.
Note to translators:  A location path is a form of XPath expression.
The message indicates that syntactically such an expression was expected,but
the characters specified by the substitution text were encountered instead.
Note to translators:  A location path is a form of XPath expression.
The message indicates that syntactically such a subexpression was expected,
but no more characters were found in the expression.
Note to translators:  A location step is part of an XPath expression.
The message indicates that syntactically such an expression was expected
following the specified characters.
Note to translators:  A node test is part of an XPath expression that is
used to test for particular kinds of nodes.  In this case, a node test that
consists of an NCName followed by a colon and an asterisk or that consists
of a QName was expected, but was not found.
Note to translators:  A step pattern is part of an XPath expression.
The message indicates that syntactically such an expression was expected,
but the specified character was found in the expression instead.
Note to translators: A relative path pattern is part of an XPath expression.
The message indicates that syntactically such an expression was expected,
but was not found.
Note to translators:  The substitution text is the name of a data type.  The
message indicates that a value of a particular type could not be converted
to a value of type boolean.
Note to translators: Do not translate ANY_UNORDERED_NODE_TYPE and
Note to translators: Do not translate UNORDERED_NODE_SNAPSHOT_TYPE and
Note to translators: This message indicates that the document being operated
upon changed, so the iterator object that was being used to traverse the
document has now become invalid.
Note to translators:  The substitution text is the name of a data type.  The
message indicates that a value of a particular type could not be converted
to a value of type string.
Note to translators: Do not translate snapshotItem,
UNORDERED_NODE_SNAPSHOT_TYPE and ORDERED_NODE_SNAPSHOT_TYPE.
Note to translators:  XPathEvaluator is a Java interface name.  An
XPathEvaluator is created with respect to a particular XML document, and in
this case the expression represented by this object was being evaluated with
respect to a context node from a different document.
Note to translators:  The XPath expression cannot be evaluated with respect
to this type of node.
BEGIN:  Definitions of error keys used  in exception messages of  JAXP 1.3 XPath API implementation
END:  Definitions of error keys used  in exception messages of  JAXP 1.3 XPath API implementation
Other miscellaneous text used inside the code...
================= INFRASTRUCTURE ======================
if we haven't got too many attributes let the
super class look it up
we have too many attributes and the super class is slow
so find it quickly using our Map.
(index + 1) is now the number of attributes
so either compare (index+1) to MAX, or compare index to (MAX-1)
Add quick look-up to find with uri/local name pair
if we have had enough attributes and are
using the Map, then clear the Map too.
we've let the super class add the attributes, but
we need to keep the hash table up to date ourselves for the
potentially new qName/index pairs for quick lookup.
if we haven't got too many attributes let the
super class look it up
we have too many attributes and the super class is slow
so find it quickly using our Map.
Loader is null when context class loader is set to null
and no loader has been provided in map.
com.sun.jmx.remote.util.Service class extracted from j2se
provider search algorithm doesn't handle well null classloader.
the serialized object is from a version without JDK-8019292 fix
trace creates and disposes
show reuse hits/misses
show bad params, misc.
Listen for Focus events
When focus is lost, repaint if
the focus information is painted
Make sure we aren't armed!
Fix for bug #4482165
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Fix for 4848220 moved here to avoid major memory leak
Here we will fire the event in case of JMenuItem
See bug 4910323 for details [zav]
Fix for 4848220 moved here to avoid major memory leak
Here we will fire the event in case of JMenu
See bug 4910323 for details [zav]
inner class AccessibleJMenuItem
-- This file was mechanically generated: Do not edit! --
these declarations are here as documentation
--- Methods to support CharSequence ---
added serialver computed by the tool
if databse does not exist, create it otherwise read it in
export the repository
check if server already registered
generate a new server id
add server def to the database
verify that the entry is valid
check to see if the server is registered
remove server from the database
See Bug 4396928 for more information about why we are
initializing the ORBClass to PIORB (now ORBImpl, but see the bug).
create the repository object
wait for shutdown
initialize the Server Id counter and hashtable.
the lower id range is reserved for system servers
menu was canceled -- hide mnemonics
private objects to cache the locale and resource bundle
memorize the most-recent locale
Process XSLT stylesheets in a secure manner
Force Xalan to use \n as line separator on all OSes. This
avoids OS specific signature validation failures due to line
separator differences in the transformed output. Unfortunately,
this is not a standard JAXP property so will not work with non-Xalan
to treat this class like Object as far as databinding is concerned (proposed JAXB 2.1 feature)
Default constructor to be only called by derived types.
Compiler says we must have at least two arguments.
Note: These attribute methods were shamelessly lifted from
com.sun.imageio.plugins.png.PNGMetadata and modified.
Shorthand for throwing an IIOInvalidTreeException
Get an integer-valued attribute
Get an integer-valued attribute
Get a float-valued attribute
Get a required integer-valued attribute
Get a required float-valued attribute
Get a boolean-valued attribute
Allow lower case booleans for backward compatibility, #5082756
Get a required boolean-valued attribute
Get an enumerated attribute as an index into a String array
Get a required enumerated attribute as an index into a String array
Get a String-valued attribute
Get a required String-valued attribute
Instance variables initialized at installation
Draw unbroken line if tabs are not on TOP, OR
selected tab is not visible (SCROLL_TAB_LAYOUT)
Break line to show visual connection to selected tab
Draw unbroken line if tabs are not on BOTTOM, OR
selected tab is not visible (SCROLL_TAB_LAYOUT)
Break line to show visual connection to selected tab
Draw unbroken line if tabs are not on RIGHT, OR
selected tab is not visible (SCROLL_TAB_LAYOUT)
Break line to show visual connection to selected tab
Ensure that runover lay is not more than insets
2 pixel offset is set from insets to each run
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of RadioButtonPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of RadioButtonPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
lock using when loading providers
used to avoid recursive loading of instaled providers
loads all installed providers
ServiceConfigurationError may be throw here
add to list if the provider is not "file" and isn't a duplicate
ensure default provider is initialized
insert the default provider at the start of the list
All OpenOption values except for APPEND and WRITE are allowed
normal case first (early return is an optimization)
ensure minimal change (early return is an optimization)
if have zone and instant, calculation is simple, defaulting chrono if necessary
block changing zone on OffsetTime, and similar problem cases
check for date fields other than epoch-day, ignoring case of converting null to ISO
combine available data
this is a non-standard temporal that is almost a pure delegate
this better handles map-like underlying temporal instances
Inform stylesheet to instantiate a DecimalFormat object
Users can extend this class to get access to current Max value
Users can extend this class to get access to current Min value
We are computing Standard Deviation from two different methods
for comparison. So, the values will not be the exact same to the last
few digits. So, we are taking the difference and making sure that
the difference is not greater than 1.
this should never happen as we are in control of all
calls into this method and only ever pass in simple
transforms of rotate, flip and translates
use image if we are printing to a Java 1.1 PrintGraphics as
it is not a instance of Graphics2D
if the background color of the component is 100% transparent
then we should not paint any background graphics. This is a solution
for there being no way of turning off Nimbus background painting as
basic components are all non-opaque by default.
Don't RTL flip JSpliders as they handle it internaly
horizontal and right-to-left orientation
horizontal and right-to-left orientation
horizontal and right-to-left orientation
assume that the painter is arranged with the arrow pointing... LEFT?
The hard coding for spinners here needs to be replaced by a more
general method for disabling rotation
no need to sync in the future
Check if the pool is empty.
Create a new object if so.
Remove object from end of free pool.
Check if the pool is empty.
Create a new object if so.
Remove object from end of free pool.
'[:' in a character class
'-[' in a character class
In a character class, this.chardata has one character, that is to say,
a pair of surrogates is composed and stored to this.chardata.
Allow character class subtraction (regardless of whether we are in
XML Schema mode or not)
this.offsets points the next of '('.
X+ -> XX*
X? -> X|
this.offset points the next of '('
Parses a condition.
this.offset points the next of '?'.
modifiers ::= [imsw]* ('-' [imsw]*)? ':'
'-' or ':'?
such as (?-i)
Must be in 0x0040-0x005f
(?modifiers ... )
handle category escape
\ + c
POSIX Character class such as [:alnum:]
Exit this loop
if not shorthands...
Here is no '-'.
FORM FEED U+000C
LINE FEED U+000A
CRRIAGE RETURN U+000D
HORIZONTAL TABULATION U+0009
case 'v':  c = 0x0b;  break;  VERTICAL TABULATION U+000B
REMIND: This needs some work...
Bias the dx and dy by the height and width of the oval.
Note: reversing the Y equations negates the angle to adjust
for the upside down coordinate system.
Also we should bias atans by the height and width of the oval.
0-3 are the four quadrants
4 is start angle
5 is end angle
IEEEremainder can return -180 here for some input values...
IEEEremainder can return -180 here for some input values...
Normalize the coordinates compared to the ellipse
having a center at 0,0 and a radius of 0.5.
CHORD and OPEN behave the same way
point must be outside the "pie triangle"
point must be inside the "pie triangle"
The point is inside the pie triangle iff it is on the same
side of the line connecting the ends of the arc as the center.
extract necessary data
0 and 180
90 and 270
for PIE: try to find intersections with pie slices
for CHORD and OPEN: try to find intersections with chord
finally check the rectangle corners inside the arc
If the shape is convex then we have done all the testing
we need.  Only PIE arcs can be concave and then only if
the angular extents are greater than 180 degrees.
For a PIE shape we have an additional test for the case where
the angular extents are greater than 180 degrees and all four
rectangular corners are inside the shape but one of the
rectangle edges spans across the "missing wedge" of the arc.
We can test for this case by checking if the rectangle intersects
either of the pie angle segments.
This file was generated AUTOMATICALLY from a template file Fri Jul 21 22:00:52 PDT 2017
Java supradecimal digit
map overflow characters
The following tables and code generated using:
java GenerateCharacter -template c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/jdk/make/data/characterdata/CharacterDataLatin1.java.template -spec c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/jdk/make/data/unicodedata/UnicodeData.txt -specialcasing c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/jdk/make/data/unicodedata/SpecialCasing.txt -proplist c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/jdk/make/data/unicodedata/PropList.txt -o c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/build/windows-amd64/jdk/gensrc/java/lang/CharacterDataLatin1.java -string -usecharforbyte -latin1 8
The A table has 256 entries for a total of 1024 bytes.
The B table has 256 entries for a total of 512 bytes.
In all, the character property tables require 1024 bytes.
THIS CODE WAS AUTOMATICALLY CREATED BY GenerateCharacter:
-- This file was mechanically generated: Do not edit! --
read and discard the repository ID
write the repository ID
--- HighlightPainter methods ---------------------------------------
--- determine locations ---
--- render ---
same line, render a rectangle
--- LayerPainter methods ----------------------------
Contained in view, can just use bounds.
Should only render part of View.
--- determine locations ---
Only if exception
UnsupportedEncodingException should be thrown
save print stream for error propagation
When the caller's loader is the boot class loader, cl is null
here. In that case, ClassLoader.getSystemClassLoader() may
return the same class loader that the application is
using. We therefore use a wrapper ClassLoader to create a
separate scope for bundles loaded on behalf of the Java
runtime so that these bundles cannot be returned from the
cache to the application (5048280).
These three are the actual keys for lookup in Map.
bundle format which is necessary for calling
These time values are in CacheKey so that NONEXISTENT_BUNDLE
doesn't need to be cloned for caching.
The time when the bundle has been loaded
The time when the bundle expires in the cache, or either
Control.TTL_DONT_CACHE or Control.TTL_NO_EXPIRATION_CONTROL.
Placeholder for an error report by a Throwable
Hash code value cache to avoid recalculating the hash code
of this instance.
quick check to see if they are not equal
are the names the same?
are the locales the same?
are refs (both non-null) or (both null)?
with a null reference we can no longer find
out which class loader was referenced; so
treat it as unequal
Clear the reference to a Throwable
this should never happen
Override the cause if the previous one is
We create a CacheKey here for use by this call. The base
name and loader will never change during the bundle loading
process. We have to make sure that the locale is set before
using it as a cache key.
Quick lookup of the cache.
If this bundle and all of its parents are valid (not expired),
then return this bundle. If any of the bundles is expired, we
don't call control.needsReload here but instead drop into the
complete loading process below.
No valid bundle was found in the cache, so we need to load the
resource bundle and its parents.
If the loaded bundle is the base bundle and exactly for the
requested locale or the only candidate locale, then take the
bundle as the resulting one. If the loaded bundle is the base
bundle, it's put on hold until we finish processing all
If the base bundle has been loaded, keep the reference in
baseBundle so that we can avoid any redundant loading in case
the control specify not to cache bundles.
Before we do the real loading work, see whether we need to
do some housekeeping: If references to class loaders or
resource bundles have been nulled out, remove all related
information from the cache.
flag indicating the resource bundle has expired in the cache
First, look up the cache to see if it's in the cache, without
attempting to load bundle.
If its parent is the one asked for by the candidate
locales (the runtime lookup path), we can take the cached
one. (If it's not identical, then we'd have to check the
parent's parents to be consistent with what's been
Otherwise, remove the cached one since we can't keep
the same bundles having different parents.
Put NONEXISTENT_BUNDLE in the cache as a mark that there's no bundle
instance for the locale.
Here we actually load the bundle in the order of formats
specified by the getFormats() value.
We need to handle the LinkageError case due to
inconsistent case-sensitivity in ClassLoader.
See 6572242 for details.
Set the format in the cache key so that it can be
used when calling needsReload later.
Bundle provider might reuse instances. So we should make
sure to clear the expired flag here.
If the cause is a MissingResourceException, avoid creating
a long chain. (6355009)
If the parent has expired, then this one must also expire. We
check only the immediate parent because the actual loading is
done from the root (base) to leaf (child) and the purpose of
checking is to propagate expiration towards the leaf. For
example, if the requested locale is ja_JP_JP and there are
bundles for all of the candidates in the cache, we have a list,
base <- ja <- ja_JP <- ja_JP_JP
If ja has expired, then it will reload ja and the list becomes a
base <- ja (new)
"   <- ja (expired) <- ja_JP <- ja_JP_JP
When looking up ja_JP in the cache, it finds ja_JP in the cache
which references to the expired ja. Then, ja_JP is marked as
expired and removed from the cache. This will be propagated to
Now, it's possible, for example, that while loading new ja_JP,
someone else has started loading the same bundle and finds the
base bundle has expired. Then, what we get from the first
getBundle call includes the expired base bundle. However, if
someone else didn't start its loading, we wouldn't know if the
base bundle has expired at the end of the loading process. The
expiration control doesn't guarantee that the returned bundle and
its parents haven't expired.
We could check the entire parent chain to see if there's any in
the chain that has expired. But this process may never end. An
extreme case would be that getTimeToLive returns 0 and
needsReload always returns true.
its TTL period has expired.
Synchronize here to call needsReload to avoid
redundant concurrent calls for the same bundle.
If the bundle needs to be reloaded, then
remove the bundle from the cache, but
return the bundle with the expired flag
Update the expiration control info. and reuse
the same bundle instance
We just remove NONEXISTENT_BUNDLE from the cache.
Put the bundle in the cache if it's not been in the cache.
If someone else has put the same bundle in the cache before
us and it has not expired, we should use the one in the cache.
Clear the back link to the cache key
Clear the reference in the BundleReference so that
it won't be enqueued.
Replace the invalid (garbage collected or expired)
instance with the valid one.
If any expiration time is specified, set the time to be
expired in the cache.
Special handling for Norwegian
Insert a locale replacing "nb" with "no" for every list entry
Insert no_NO_NY, no_NO, no after nn
Special handling for Chinese
Supply script for users who want to use zh_Hans/zh_Hant
as bundle names (recommended for Java7+)
Supply region(country) for users who still package Chinese
bundles using old convension.
With script, after truncating variant, region and script,
start over without script.
Add root locale at the end
If the class isn't a ResourceBundle subclass, throw a
Disable caches to get fresh data for
disable caches to get the correct data
ignore other exceptions
application protocol check
"" rather than null, for BeanBox
disabled icon is generated by LF so it should be unset here
index out of range
Don't use getDisabledIcon, will trigger creation of icon if icon
Check where the AccessibleContext's relation
set already contains a LABEL_FOR relation.
There is no caret.
Text cannot be selected.
Text cannot be selected.
Text cannot be selected.
before we return string we have to make sure it is correct URI as per spec.
for some types (string and derived), they just return the string itself
check 3.2.17.c0 must: URI (rfc 2396/2723)
encode special characters using XLink 5.4 algorithm
Support for relative URLs
According to Java 1.1: URLs may also be specified with a
String and the URL object that it is related to.
REVISIT: do we need to return the new URI object?
which ASCII characters need to be escaped
the first hex character if a character needs to be escaped
the second hex character if a character needs to be escaped
initialize the above 3 arrays
To encode special characters in anyURI, by using %HH to represent
special ASCII characters: 0x00~0x1F, 0x7F, ' ', '<', '>', etc.
and non-ASCII characters (whose value >= 128).
for each character in the anyURI
if it's not an ASCII character, break here, and use UTF-8 encoding
we saw some non-ascii character
get UTF-8 bytes for the remaining sub-string
should never happen
for each byte
for non-ascii character: make it positive, then escape
otherwise, return the orginal one.
Read in a block at a time, mapping \r\n to \n, as well as single
\r's to \n's. If a \r\n is encountered, \r\n will be set as the
newline string for the document, if \r is encountered it will
be set as the newline character, otherwise the newline property
for the document will be removed.
else nothing to do, can skip \r, next write will
There is an end of line string that isn't \n, have to iterate
through and find all \n's and translate to end of line string.
Just write out text, will already have \n, no mapping to
--- names of well-known actions ---------------------------
--- Action implementations ---------------------------------
last word in the paragraph
for last position remove last \n
remove to the end of the paragraph
there is no previous word in the paragraph
for first position remove previous \n
remove to the start of the paragraph
We want to scroll by a multiple of caret height,
rounding towards lower integer
Dot is currently visible, base the new
location off the old, or
Dot isn't visible, choose the top or the bottom
for the new location.
Make sure the new visible location contains
the location of dot, otherwise Caret will
cause an additional scroll.
Change index and correct newVis.y only if won't cause scrolling upward
we should first move to the end of the
previous paragraph (bug #4278839)
we should first move to the end of current
paragraph (bug #4278839)
End of file.
draw shadow shape
draw outline to img2
draw final image
-- This file was mechanically generated: Do not edit! --
Special case, not in native
See note 1
See note 1
See note 1
See note 1
See note 1
Note 1: The INACTIVE frame button states apply when the frame
is inactive. They are not defined in tmschema.h
Fix for 6316538: Vista has five frame button states
States for Slider (trackbar)
States for Tabs
only draw the border area of the image
the number of state images in an imagefile
the size of the border line for bgtype=BorderFill
size of progress control chunks
size of progress control spaces
where char shadows are drawn, relative to orig. chars
size of dest rect that exactly source
margins used for 9-grid sizing
margins that define where content can be placed
margins that define where caption text can be placed
color of borders for BorderFill
color of bg fill
color text is drawn in
color of text shadow
basic drawing type for each part
type of shadow to draw with text
Using HashMap, since synchronization should be done by the calling
REVISIT - NOT USED.
The ServerStartupDelay is the delay added after the Server registers
end point information. This is to allow the server to completely
initialize after ORB is instantiated.
Just use the default 1000 milliseconds as the default
locate the server
We call getEntry here so that state of the entry is
checked for validity before we actually go and locate a server
orbId is ignored for now
unlike vectors, list is not synchronized
get an entry
collect the active entries
if server location is desired, then wait for the server
to register back, then return location
if server location is desired, then wait for the server
to register back, then return location
this is to see if the server has any listeners
passing in entry to eliminate multiple lookups for
the same entry in some cases
passing in entry to eliminate multiple lookups for
the same entry in some cases
we need to get the serverid and the orbid from the object key
get the ORBName corresponding to the orbMapid, that was
first registered by the server
we received a list of ports corresponding to an ORB in a
particular server, now retrieve the one corresponding
to IIOP_CLEAR_TEXT, and for other created the tagged
components to be added to the IOR
create a new IOR with the correct port and correct tagged
This delay is required in case of Server is activated or
re-activated the first time. Server needs some time before
handling all the requests.
(Talk to Ken to see whether there is a better way of doing this).
Calling thread doesn't have necessary priviledges.
Delegate to DesktopBrowse so that it can work in
Not in webstart/applet, throw the exception.
won't reach here.
-- This file was mechanically generated: Do not edit! --
Define system property "jaxp.debug" to get output
Use try/catch block to support applets, which throws
SecurityException out of this code.
Allow simply setting the prop to turn on debug
Use current class loader - should always be bootstrap CL
make sure we have access to restricted packages
Extra check to avoid computing cl strings
Use the system property first
try to read from $java.home/lib/jaxp.properties
Try Jar Service Provider Mechanism
It is not possible to wrap an error directly in
FactoryConfigurationError - so we need to wrap the
ServiceConfigurationError in a RuntimeException.
The alternative would be to modify the logic in
FactoryConfigurationError to allow setting a
Throwable as the cause, but that could cause
compatibility issues down the road.
add default recognized properties
configure DTD pipeline
configure XML document pipeline: insert after DTDValidator and
before XML Schema validator
we don't have to worry about fSchemaValidator being null, since
super.configurePipeline() instantiated it if the feature was set
Otherwise, insert after the last component in the pipeline
configure XML 1.1. DTD pipeline
configure XML document pipeline: insert after DTDValidator and
before XML Schema validator
we don't have to worry about fSchemaValidator being null, since
super.configurePipeline() instantiated it if the feature was set
Otherwise, insert after the last component in the pipeline
Type-specific CORBA::Object operations
largest numerical value
These would not be used for EN. Only used for traditional numbering
These only used for mutiplicative-additive numbering
end of Action.java
true list falls through
read and discard the repository ID
write the repository ID
Explicitly check MBeanPermission for addNotificationListener
6238731: set the default domain if no domain is set.
Tread carefully because if set.size() == 1 it may be the
Collections.singleton we make here, which is unmodifiable.
Explicitly check MBeanPermission for removeNotificationListener
Give back the first exception
Tread carefully because if set.size() == 1 it may be a
Collections.singleton, which is unmodifiable.
We proceed in two stages here, to avoid holding the listenerMap
lock while invoking the filters (which are user code).
We don't synchronize on targetedNotifs, because it is a local
variable of our caller and no other thread can see it.
The standard RMI connector client will register a listener on the MBeanServerDelegate
in order to be told when MBeans are unregistered.  We snoop on fetched notifications
so that we can know too, and remove the corresponding entry from the listenerMap.
This is a notification from the MBeanServerDelegate.
Fix for IE bug - crashing
-- This file was mechanically generated: Do not edit! --
!!! add text nodes
!!! take care of value templates
Color types for IHDR chunk
Bit depths for IHDR chunk
Compression methods for IHDR chunk
Filter methods for IHDR chunk
Interlace methods for IHDR chunk
Compression methods for iCCP chunk
Compression methods for zTXt chunk
"Unknown" unit for pHYs chunk
"Meter" unit for pHYs chunk
Unit specifiers for pHYs chunk
Rendering intents for sRGB chunk
Color space types for Chroma->ColorSpaceType node
0 == none, 1 == adam7
If non-null, used to reorder palette entries during encoding in
order to minimize the size of the tRNS chunk.  Thus an index of
'i' in the source should be encoded as index 'PLTE_order[i]'.
PLTE_order will be null unless 'initialize' is called with an
IndexColorModel image type.
If external (non-PNG sourced) data has red = green = blue,
always store it as gray and promote when writing
PNG_COLOR_GRAY, _RGB, or _PALETTE
0 == unknown, 1 == meter
PNG_COLOR_GRAY, _GRAY_ALPHA, _RGB, _RGB_ALPHA
8 or 16
If external (non-PNG sourced) data has red = green = blue,
always store it as gray and promote when writing
PNG_COLOR_GRAY, _RGB, or _PALETTE
May have fewer entries than PLTE_red, etc.
TODO -- implement
Choose max bit depth over all channels
Fixes bug 4413109
Multi-channel images must have a bit depth of 8 or 16
Round bit depth up to a power of 2
Determine whether the color tables are actually a gray ramp
if the color type has not been set previously
Determine whether transparency exists
Reorder the palette so that non-opaque entries
come first.  Since the tRNS chunk does not have
to store trailing 255's, this can save a
considerable amount of space when encoding
images with only one transparent pixel value,
e.g., images from GIF sources.
Scan for non-opaque entries and assign them
positions starting at 0.
Scan for opaque entries and assign them
positions following the non-opaque entries.
Reorder the palettes
All have the same length
Copy only the transparent entries into tRNS_alpha
unknownChunkData needs deep clone
IHDR_compressionMethod must be 0 in PNG 1.1
IHDR_filterMethod must be 0 in PNG 1.1
Determine number of channels
Be careful about palette color with transparency
sBIT_colorType == PNGImageReader.PNG_COLOR_RGB ||
sBIT_colorType == PNGImageReader.PNG_COLOR_RGB_ALPHA
Shorthand for throwing an IIOInvalidTreeException
Get an integer-valued attribute
Get an integer-valued attribute
Get a float-valued attribute
Get a required integer-valued attribute
Get a required float-valued attribute
Get a boolean-valued attribute
Allow lower case booleans for backward compatibility, #5082756
Get a required boolean-valued attribute
Get an enumerated attribute as an index into a String array
Get a required enumerated attribute as an index into a String array
Get a String-valued attribute
Get a required String-valued attribute
Guard against partial overwrite
silently skip invalid text entry
Guard against partial overwrite
Guard against partial overwrite
not printable. Check whether this is an allowed
Use Adam7 if NumProgressiveScans > 1
Find a reasonable rational approximation
Just ignore this node, PNG requires keywords
Use a zTXt node
Use a tEXt node
Use an iTXt node
Reset all instance variables to their initial state
Row/Column algorithm only applies to siblings. If 'a' and 'b'
aren't siblings, then we need to find their most inferior
ancestors which share a parent. Compute the ancestory lists for
each Component and then search from the Window down until the
'a' is not part of a Window hierarchy. Can't cope.
'b' is not part of a Window hierarchy. Can't cope.
a is an ancestor of b
b is an ancestor of a
LT - Western Europe (optional for Japanese, Chinese, Korean)
RT - Middle East (Arabic, Hebrew)
TL - Mongolian
TR - Japanese, Chinese, Korean
CatalogException.java - Catalog exception
-- This file was mechanically generated: Do not edit! --
Fall through to malformed-input case
Skip erroneous input either way
Ensure progress; n might be 0!
Shared UI object
Log wrapper class for Sun private system exceptions in group POA
Generated by MC.java version 1.0, DO NOT EDIT BY HAND!
Generated from input file c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/corba/src/share/classes/com/sun/corba/se/spi/logging/data/POA.mc on Fri Jul 21 21:58:45 PDT 2017
no need to sychronize again
get the node data
get the entity data
encoding and version DOM L3
baseURI, actualEncoding DOM L3
no need to synchronize again
The max value for a counter64 variable is 2^64 - 1.
The max value for a Long is 2^63 - 1.
All the allowed values for a conuter64 variable cannot be covered !!!
Finally get the string from the constant pool
Type-specific CORBA::Object operations
If we replace Integer with int...
* <p>Constructs a <code>TargetedNotification</code> object.  The
* object contains a pair (Notification, Listener ID).
* The Listener ID identifies the client listener to which that
* notification is targeted. The client listener ID is one
* previously returned by the connector server in response to an
* <code>addNotificationListener</code> request.</p>
* @param notification Notification emitted from the MBean server.
* @param listenerID   The ID of the listener to which this
*        notification is targeted.
public TargetedNotification(Notification notification,
If we replace integer with int...
Needed if we use int instead of Integer...
if (id == null) throw new
Returns the name of a node in the DOM
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of EditorPanePainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of EditorPanePainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
Defaults to 0
REVISIT: need to close connection.
End of file.
We only go into the else block in forward-compatibility mode, when
the unsupported element has no fallback.
If the unsupported element does not have any fallback child, then
at runtime, a runtime error should be raised when the unsupported
element is instantiated. Otherwise, no error is thrown.
to mask ints
to mask longs
some special values
The following unpacking methods are usually manually inlined
base of next state
adjustment to state
not 1st registration
wait out advance
1st root registration
1st sub registration
recheck under lock
finish registration whenever parent registration
succeeded, even when racing with termination,
since these are part of the same "transaction".
CAS to root phase with current parties, tripping unarrived
Specialization of doArrive+awaitAdvance eliminating some reads/paths
base of next state
Only need to change root state
signal all threads
Waiters on evenQ
Waiters on oddQ
first element of queue
ensure old queue clean
true when node is enqueued
to increase spins upon change
spinning in noninterruptible mode
need node to record intr
done or aborted
push onto queue
avoid stale enq
avoid need for unpark()
possibly clean up on abort
nulled to cancel wait
the node this map belongs to
Insert point (may be end of list)
If we can't find by namespaceURI, localName, then we find by
nodeName so we know where to insert.
Insert point (may be end of list)
not-found has to be encoded.
This is a linear search through the same nodes ArrayList.
The ArrayList is sorted on the DOM Level 1 nodename.
The DOM Level 2 NS keys are namespaceURI and Localname,
so we must linear search thru it.
In addition, to get this to work with nodes without any namespace
(namespaceURI and localNames are both null) we then use the nodeName
as a secondary key.
compare 2 nodes in the map.  If a precedes b, return true, otherwise
If we can't find by namespaceURI, localName, then we find by
nodeName so we know where to insert.
Insert point (may be end of list)
If the write fails for some reason ensure
that we restore the original object.
When the first argument is a DOM we want the whole
DOM and not just a single node - that would not make sense.
Only generate ID if node exists
Otherwise return an empty string
-- Begin utility functions
String value must be the same if both nodes are the same
Assume we're comparing document order here
Assume we're comparing document order here
If node-boolean comparison -> convert node to boolean
compare them as strings
swap operands and operator
language for context node (if any)
compare context node's language agains test language
Set max fraction digits so that truncation does not occur. Setting
the max to Integer.MAX_VALUE may cause problems with some JDK's.
This formatter is used to convert numbers according to the XPath
1.0 syntax which ignores locales (http:www.w3.org/TR/xpath#NT-Number)
Remove leading zeros.
Convert -0.0 to +0.0 other values remains the same
Use the XPath formatter to ignore locales
bugzilla fix 12813
Convert var/param -> node
Convert var/param -> node-set
handles Integer and Double
handles Integer and Double
Create a dummy NodeList which only contains the given node to make
use of the nodeList2Iterator() interface.
First pass: build w3c DOM for all nodes not proxied from our DOM.
Notice: this looses some (esp. parent) context for these nodes,
so some way to wrap the original nodes inside a DTMAxisIterator
might be preferable in the long run.
allow for change in list length, just in case.
invalid node handle, so definitely not our doc
Use one dummy element as container for each node of the
list. That way, it is easier to detect resp. avoid
funny things which change the number of nodes,
e.g. auto-concatenation of text nodes.
The mid element also serves as a container for
attributes, avoiding problems with conflicting
attributes or node order.
Better play it safe for all types we aren't sure we know
how to deal with.
w3cDOM -> DTM -> DOMImpl
Create DOMAdapter and register with MultiDOM
Second pass: find DTM handles for every node in the list.
Should not happen, as first run should have got all these
For now, play it self and perform extra checks:
or call stringF()
even though the orignal prefix is ignored, it should still get checked for valid NCName
prefix must be a valid NCName
local name must be a valid NCName and must not be XMLNS
Get prefix from qname
Handle case when prefix is not known at compile time
not sure if this line of code ever works
need to flush or else can't get namespacemappings
Need to generate a prefix?
All error messages are localized and are stored in resource bundles.
-- End utility functions
Message keys used by the serializer
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The localname is the portion after the optional colon; the message indicates
that there is a problem with that part of the QNAME.
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The prefix is the portion before the optional colon; the message indicates
that there is a problem with that part of the QNAME.
noop. don't let caching to happen
noop. cache is read-only.
noop. this pool is always read-only
noop. this pool is always read-only.
need check if escaped.
The line below is equivalent to calling a
flip the preceding backslash flag
skip the leading whitespace characters in following line
Read the xxxx
Handle common case first, selecting largest block that
avoids the specials below
Get the class name from the namespace uri
Get the method name from the argument to function-available
Replace the '-' characters in the method name
This is the only information we can provide in a pipeline.
REVISIT: Forbid serialization of PSVI DOM until
we support object serialization of grammars -- mrglavas
this is debatable to initiate at an acceptable event,
but it's neccessary in order to pass the TCK and yet avoid skipping element
although it seems that IllegalStateException should be thrown when next() is called
on a stream that has no more items, we have to assume END_DOCUMENT is always accepted
in order to pass the TCK
A result tree is always 'true' when converted to a boolean value,
since the tree always has at least one node (the root).
don't need the DOM reference
push 'true' on the stack
Push required parameters
Create a new instance of a StringValueHandler
Store new Handler into a local variable
Call the method that implements this result tree
Restore new handler and call getValue()
Push required parameters
Create new instance of DOM class (with RTF_INITIAL_SIZE nodes)
Store new DOM into a local variable
Overwrite old handler with DOM handler
index = cpg.addMethodref(DOM_IMPL,
Store DOM handler in a local in order to call endDocument()
Call startDocument on the new handler
Call the method that implements this result tree
Call endDocument on the DOM handler
Push the new DOM on the stack
Put an extra copy of the result tree (DOM) on the stack
DOM adapters containing a result tree are not initialised with
translet-type to DOM-type mapping. This must be done now for
XPath expressions and patterns to work for the iterator we create.
get names array
get uris array
get types array
get namespaces array
Pass the type mappings to the DOM adapter
Create an iterator for the root node of the DOM adapter
basic insertion/extraction methods
insertion/extraction of streamables
will never happen
Convenience methods for creating AttributedCharacterIterators from
Proclaim serial compatibility with 1.4 FCS
-- This file was mechanically generated: Do not edit! --
For memory-mapped buffers -- invoked by FileChannelImpl via reflection
For duplicates and slices
ARGHH!!  JAXP Uses Xerces without setting the namespace processing to ON!
Use "" instead of null, as Xerces likes "" for the
name of the default namespace.  Fix attributed
to "Steven Murray" <smurray@ebt.com>.
Use "" instead of null, as Xerces likes "" for the
name of the default namespace.  Fix attributed
to "Steven Murray" <smurray@ebt.com>.
use the current class loader
if this factory supports the given schemalanguage return this factory else thrown exception
pieces of information needed to make this usable as a Grammar key
if we know the root of this grammar, here's its name:
if we don't know the root name, this stores all elements that
could serve; fPossibleRoots and fRootName cannot both be non-null
init(String, String, String, String, String)
assume it's a DTDDescription
if we got this far we've got a root match... try other two fields,
since so many different DTD's have roots in common:
give up; hope .equals can handle it:
TR9401CatalogReader.java - Read OASIS Catalog files
this is not meant to be a recognized feature, but we need it here to use
if it is already a recognized feature for the pipeline
track the version of the document being parsed
temporary buffer for sending normalized values
REVISIT: what should be the size of the buffer?
allows us to keep track of whether an attribute has
been declared twice, so that we can avoid exposing the
second declaration to any registered DeclHandler
it wasn't a recognized feature, so we don't worry about it
the version need only be set once; if
document's XML 1.0|1.1, that's how it'll stay
is there a DeclHandler?
Only report startEntity if this entity was actually read.
report skipped entity to content handler
Only report endEntity if this entity was actually read.
REVISIT: should we support schema-normalized-value for SAX1 events
send prefix mapping events
REVISIT: It should not be necessary to iterate over the attribute
list when the set of [namespace attributes] is empty for this
element. This should be computable from the NamespaceContext, but
since we currently don't report the mappings for the xml prefix
we cannot use the declared prefix count for the current context
to skip this section. -- mrglavas
remove namespace declaration attributes
localpart should be empty string as per SAX documentation:
if type is union (XML Schema) it is possible that we receive
character call with empty data
REVISIT: should we support schema-normalized-value for SAX1 events
REVISIT - I keep running into SAX apps that expect
null data to be an empty string, which is contrary
to the comment for this method in the SAX API.
Only report startEntity if this entity was actually read.
report skipped entity to content handler
Only report endEntity if this entity was actually read.
used as a key to detect duplicate attribute definitions.
we aren't permitted to return duplicate attribute definitions
attributeDecl(String,String,String,String[],String,XMLString, XMLString, Augmentations)
unparsedEntityDecl(String,XMLResourceIdentifier, String, Augmentations)
SAX1 and SAX2
help out the GC
Parser and XMLReader methods
wrap XNI exceptions as SAX exceptions
must be a parser exception; mine it for locator info and throw
since XMLParseExceptions know nothing about encoding,
we cannot return anything meaningful in this context.
We *could* consult the LocatorProxy, but the
application can do this itself if it wishes to possibly
why did we create an XMLParseException?
wrap XNI exceptions as SAX exceptions
must be a parser exception; mine it for locator info and throw
since XMLParseExceptions know nothing about encoding,
we cannot return anything meaningful in this context.
We *could* consult the LocatorProxy, but the
application can do this itself if it wishes to possibly
why did we create an XMLParseException?
REVISIT:this methods is not part of SAX2 interfaces, we should throw exception
if any application uses SAX2 and sets locale also. -nb
controls the reporting of raw prefixed names and Namespace
declarations (xmlns* attributes): when this feature is false
(the default), raw prefixed names may optionally be reported,
and xmlns* attributes must not be reported.
controls the use of java.lang.String#intern() for strings
passed to SAX handlers.
controls whether the beginning and end of parameter entities
will be reported to the LexicalHandler.
controls whether system identifiers will be absolutized relative to
their base URIs before reporting.
controls whether Unicode normalization checking is performed
as per Appendix B of the XML 1.1 specification
REVISIT: Allow this feature to be set once Unicode normalization
checking is supported -- mrglavas.
controls whether the parser reports that namespace declaration
attributes as being in the namespace: http:www.w3.org/2000/xmlns/
controls whether the methods of an object implementing
org.xml.sax.ext.EntityResolver2 will be used by the parser.
Refresh EntityResolver wrapper.
Read only features.
reports whether the document specified a standalone document declaration.
reports whether Attributes objects passed to startElement also implement
the org.xml.sax.ext.Attributes2 interface.
reports whether Locator objects passed to setDocumentLocator also implement
the org.xml.sax.ext.Locator2 interface.
reports whether the parser supports both XML 1.1 and XML 1.0.
Drop through and perform default processing
controls the reporting of raw prefixed names and Namespace
declarations (xmlns* attributes): when this feature is false
(the default), raw prefixed names may optionally be reported,
and xmlns* attributes must not be reported.
controls the use of java.lang.String#intern() for strings
passed to SAX handlers.
reports whether the document specified a standalone document declaration.
reports whether the parser supports both XML 1.1 and XML 1.0.
controls whether the beginning and end of parameter entities
will be reported to the LexicalHandler.
controls whether system identifiers will be absolutized relative to
their base URIs before reporting.
controls whether the parser reports that namespace declaration
attributes as being in the namespace: http:www.w3.org/2000/xmlns/
controls whether Unicode normalization checking is performed
as per Appendix B of the XML 1.1 specification
REVISIT: Allow this feature to be set once Unicode normalization
checking is supported -- mrglavas.
controls whether the methods of an object implementing
org.xml.sax.ext.EntityResolver2 will be used by the parser.
reports whether Attributes objects passed to startElement also implement
the org.xml.sax.ext.Attributes2 interface.
reports whether Locator objects passed to setDocumentLocator also implement
the org.xml.sax.ext.Locator2 interface.
Drop through and perform default processing
SAX2 core properties
Value type: org.xml.sax.ext.LexicalHandler
Access: read/write, pre-parse only
Set the lexical event handler.
Value type: org.xml.sax.ext.DeclHandler
Access: read/write, pre-parse only
Set the DTD declaration event handler.
Value type: DOM Node
Get the DOM node currently being visited, if the SAX parser is
iterating over a DOM tree.  If the parser recognises and
supports this property but is not currently visiting a DOM
node, it should return null (this is a good way to check for
availability before the parse begins).
Value type: java.lang.String
The literal string describing the actual XML version of the document.
Drop through and perform default processing
Perform default processing
SAX2 core properties
Value type: java.lang.String
The literal string describing the actual XML version of the document.
Value type: org.xml.sax.ext.LexicalHandler
Access: read/write, pre-parse only
Set the lexical event handler.
Value type: org.xml.sax.ext.DeclHandler
Access: read/write, pre-parse only
Set the DTD declaration event handler.
Value type: DOM Node
Get the DOM node currently being visited, if the SAX parser is
iterating over a DOM tree.  If the parser recognises and
supports this property but is not currently visiting a DOM
node, it should return null (this is a good way to check for
availability before the parse begins).
we are not iterating a DOM tree
Drop through and perform default processing
Perform default processing
SAX2 core properties
REVISIT: this hides the fact that internally we use
null instead of empty string
SAX requires URI to be a string or an empty string
REVISIT: Localize exception messages. -- mrglavas
Stateless intermediate ops from DoubleStream
We can do better that this too; optimize for depth=0 case and just grab spliterator and forEach it
Stateful intermediate ops from DoubleStream
While functional and quick to implement, this approach is not very efficient.
An efficient version requires a double-specific map/set implementation.
Terminal ops from DoubleStream
Optimized sequential terminal operations for the head of the pipeline
End of file.
attribute must not be null
Extract the requested attribute from file
Now we will always fail:
Either because the attribute is null or because it is not
accessible (or does not exist).
This is a hack: we call getAttribute in order to generate an
AttributeNotFoundException if the attribute does not exist.
If we reach this point, we know that the requested attribute
exists. However, since all attributes are read-only, we throw
If attributes is null, the get all attributes.
Prepare the result list.
Get each requested attribute.
Skip the attribute that couldn't be obtained.
Finally return the result.
Check that operation name is not null.
hack for XSLTC with finding URI for default namespace
the elements URI is not known yet, and it
doesn't have a prefix, and we are currently
setting the uri for prefix "", so we have
the uri for the element... lets remember it
Cache call to setVersion()
null if not known
null if not known
null if not known
if there are attributes, then lets make the flush()
call the startElement on the handler and send the
attributes on their way.
this is not the first element, but a later one, so just
send it on its way.
Try to rule out if this is an not to be an HTML document based on prefix
create an HTML output handler, and initialize it
keep a reference to the old handler, ... it will soon be gone
The factory should be returning a ToStream
Don't know what to do if it doesn't
i.e. the user has over-ridden the content-handler property
need to copy things from the old handler to the new one here
Call startDocument() if necessary
the wrapped handler is now fully initialized
Output first tag
don't need the collected attributes of the first element anymore.
Output namespaces of first tag
is the first tag html, not considering the prefix ?
Try to rule out if this is not to be an HTML document based on URI
the <html> element has a non-trivial namespace
Try to rule out if this is an not to be an HTML document based on prefix
The first element has a prefix, so it can't be <html>
convert the StringBuffer to a char array and
emit the trace event that these characters "might"
Skip the id
default transform will be changed
Only the transform is required
Delegate most of our fitness test to Default so that we only have to
code the algorithm once.
JTable only has ancestor focus bindings, we thus force it
to be focusable by returning true here.
Delegate to the fitnessTestPolicy, this will test for the
case where the developer has overriden isFocusTraversable to
Create our own subclass and change accept to public so that we can call
Initialize CRC table
length, will backpatch
Return to end of chunk and flush to minimize buffering
Empty finalizer (for improved performance; no need to call
super.finalize() in this case)
Compress output and write as a series of 'IDAT' chunks of
length, will backpatch
Return to end of chunk and flush to minimize buffering
Empty finalizer (for improved performance; no need to call
super.finalize() in this case)
Factors from the ImageWriteParam
Per-band scaling tables
After the first call to initializeScaleTables, either scale and scale0
will be valid, or scaleh and scalel will be valid, but not both.
The tables will be designed for use with a set of input but depths
given by sampleSize, and an output bit depth given by scalingBitDepth.
Sample size per band, in bits
Output bit depth of the scaling tables
Tables for 1, 2, 4, or 8 bit output
8 bit table
equivalent to scale[0]
Tables for 16 bit output
High bytes of output
Low bytes of output
Total number of pixels to be written by write_IDAT
Running count of pixels written by write_IDAT
TODO - deal with imageType
Write IHDR chunk
PLTE cannot occur in a gray image
Special case: image is RGB and chunk is Gray
Promote chunk contents to RGB
Special case: image is RGB(A) and chunk is Gray
Promote chunk contents to RGB
Make a gray bKGD chunk look like RGB
Ignore status of alpha in colorType
colorType == PNGImageReader.PNG_COLOR_RGB ||
colorType == PNGImageReader.PNG_COLOR_RGB_ALPHA
sampleDepth == 16
Adjust offsets and skips based on source subsampling factors
Early exit if no data for this pass
Convert X offset and skip from pixels to samples
Create row buffers
reserve space for alpha samples
will be used to calculate alpha value for the pixel
Reorder palette data if necessary
leave first 'bpp' bytes zero
Image can only have a single band
Left shift the last byte
Swap current and previous rows
processWriteAborted will be called later
Use sourceXOffset, etc.
Check two int arrays for value equality, always returns false
if either array is null
Initialize the scale/scale0 or scaleh/scalel arrays to
hold the results of scaling an input value to the desired
output bit depth
If the existing tables are still valid, just return
Compute new tables
bitDepth == 16
Divide scaling table into high and low bytes
Set source region and subsampling to default values
Get source region and subsampling factors
Clip to actual image bounds
Adjust for subsampling offsets
Get subsampling factors
Compute output dimensions
Compute total number of pixels for progress notification
Use Adam7 interlacing if set in write param
MODE_COPY_FROM_METADATA should alreay be taken care of
MODE_EXPLICIT is not allowed
Initialize bitDepth and colorType
Overwrite IHDR width and height values with values from image
Initialize scaling tables for this image
Finish up and inform the listeners we are done
build the tables
The inverse transform is needed to go from device to user space.
Get all the components of the inverse transform matrix.
the following assumes that the caller has copied the incoming
transform and is not concerned about it being modified
just use identity transform in this case; better to show
(incorrect) results than to throw an exception and/or no-op
copy some flags
we can avoid copying this array since we do not modify its values
note that only one of these values can ever be non-null (we either
store the fast gradient array or the slow one, but never both
at the same time)
we need to (re)create the appropriate values
now cache the calculated values in the
MultipleGradientPaint instance for future use
only cache the fast array
only cache the slow array
use the values cached in the MultipleGradientPaint instance
create a new colors array
convert the colors using the lookup table
we can just use this array by reference since we do not
modify its values in the case of SRGB
this will store the intervals (distances) between gradient stops
convert from fractions into intervals
interval distance is equal to the difference in positions
initialize to be fully opaque for ANDing with colors
array of interpolation arrays
find smallest interval
Estimate the size of the entire gradients array.
This is to prevent a tiny interval from causing the size of array
to explode.  If the estimated size is too large, break to using
separate arrays for each interval, and using an indexing scheme at
use the most "economical" model
set the flag so we know later it is a simple (fast) lookup
2 colors to interpolate
the eventual size of the single array
for every interval (transition between 2 colors)
create an array whose size is based on the ratio to the
the 2 colors (keyframes) to interpolate between
fill this array with the colors in between rgb1 and rgb2
if the colors are opaque, transparency should still
put all gradients in a single array
if interpolation occurred in Linear RGB space, convert the
gradients back to sRGB using the lookup table
set the flag so we know later it is a non-simple lookup
2 colors to interpolate
for every interval (transition between 2 colors)
create an array of the maximum theoretical size for
get the the 2 colors
fill this array with the colors in between rgb1 and rgb2
if the colors are opaque, transparency should still
if interpolation occurred in Linear RGB space, convert the
gradients back to SRGB using the lookup table
step between interpolated values
extract color components from packed integer
calculate the total change in alpha, red, green, blue
for each step in the interval calculate the in-between color by
multiplying the normalized current position by the total color
change (0.5 is added to prevent truncation round-off error)
extract red, green, blue components
use the lookup table
re-compact the components
first, manipulate position value depending on the cycle method
upper bound is 1
lower bound is 0
get the fractional part
(modulo behavior discards integer component)
position should now be between -1 and 1
force it to be in the range 0-1
cycleMethod == CycleMethod.REFLECT
take absolute value
get the integer part
get the fractional part
integer part is odd, get reflected color instead
now, get the color based on this 0-1 position...
easy to compute: just scale index by array size
more complicated computation, to save space
for all the gradient interval arrays
this is the array we want
this is the interval we want
If working raster is big enough, reuse it. Otherwise,
build a large enough new one.
Access raster internal int array. Because we use a DirectColorModel,
we know the DataBuffer is of type DataBufferInt and the SampleModel
Adjust for initial offset in DataBuffer and also for the scanline
These calls make the DataBuffer non-acceleratable, but the
Raster is never Stable long enough to accelerate anyway...
delegate to subclass
instantiate Mode if needed, cache (apply temp) function name
check if sorting nodes is required
Push a new parameter frame
The 'select' expression is a result-tree
<xsl:sort> cannot be applied to a result tree - issue warning
Put the result tree (a DOM adapter) on the stack
Get back the DOM and iterator (not just iterator!!!)
compute node iterator for applyTemplates
!!! need to instantiate all needed modes
unmap parameters to release temporary result trees
Pop parameter frame
Note that info is shared across multiple threads
using the same subcontract, each of which may
have its own operation.  Therefore we need to clone it.
don't do anything.
don't do anything.
don't do anything.
don't do anything.
The stub could not be connected because it
has an invalid IOR...
This is an implementation object which has not been
exported to IIOP OR is a JRMP stub or implementation
object which cannot be marshalled into an ORB stream...
Didn't need to do anything, just return the input...
Have we tried to find this guy before?
No, so try it...
First try the classname...
If we don't have a valid tie at this point,
walk up the parent chain until we either
load a tie or encounter PortableRemoteObject
Did we get it?
Nope, so cache that fact...
Yes, so cache it...
Yes, return a new instance or fail again if
it was a miss last time...
Sequence finding of the stubs according to spec
If-else is put here for speed up of J2EE.
According to the OMG spec, the if clause is not dead code.
It can occur if some compiler has allowed generation
into org.omg.stub hierarchy for non-offending
classes. This will encourage people to
produce non-offending class stubs in their own hierarchy.
If no class was loaded, or if the loaded class is not of the
correct type, make a further attempt to load the correct class
using the classloader of the expected type.
_REVISIT_ Is this step necessary, or should the Util,loadClass
algorithm always produce a valid class if the setup is correct?
Does the OMG standard algorithm need to be changed to include
If no class was not loaded, or if the loaded class is not of the
correct type, make a further attempt to load the correct class
using the classloader of the related type.
_REVISIT_ Is this step necessary, or should the Util,loadClass
algorithm always produce a valid class if the setup is correct?
Does the OMG standard algorithm need to be changed to include
no repId or unrecognized repId
Try other way
no repId or unrecognized repId
if earlier search found a non-default factory, or the same default
factory that loadClassForClass would return, bale out now...
Do we already have it cached?
No, so go try to load it...
Yes, is it a stub?  If not, it was a miss last
time, so return null again...
It's a stub.
Does the cached stub meet the requirements
of the caller? If the caller does not require
the most derived stub and does not require
a specific stub type, we don't have to check
any further because the cached type is good
We must reload because we do not have
the most derived cached already...
The stubFactory arg must be null here
to force onlyMostDerived=true to work
We do not have exactly the right stub. First, try to
upgrade the cached stub by forcing it to the most
If that failed, try again with the exact type
Use the cached stub. Is the delegate set?
No, so set it if we can...
This will throw an exception if the tie
is not a Servant.  XXX Handle this better?
Now walk all the RepIDs till we find a stub or fail...
Stub == null, so cache the miss...
The tie does not have a delegate set, so stash
this tie away using the stub as a key so that
later, when the stub is connected, we can find
and connect the tie as well...
Tie extends Servant
Exception is caught because of any of the
1) POA is not associated with the TIE
2) POA Policies for the tie-associated POA
does not support _this_object() call.
Update the cache...
Convert the typeid to a RepositoryId instance, get
the className and mangle it as needed...
Get the codebase from the delegate to use when loading
the new stub, if possible...
We can't assume that narrowFrom is a CORBA_2_3 stub, yet
it may have a 2_3 Delegate that provides a codebase.  Swallow
the ClassCastException otherwise.
Get the repID and check for "" special case.
We should never be called with it (See CDRInputStream
and the loadStub() method)...
Get the stubname from the repID and load
the class. If we have a valid 'sender', fall
back to using its codebase if we need to...
List of registered JDBC drivers
Used in println() to synchronize logWriter
Walk through the loaded registeredDrivers attempting to locate someone
who understands the given URL.
If the caller does not have permission to load the driver then
Drop through and try the next driver.
This is for compatibility with the original DriverManager
If a DriverAction was specified, Call it to notify the
driver that it has been deregistered
If the caller does not have permission to load the driver then
throw a SecurityException.
Walk through the loaded registeredDrivers.
If the caller does not have permission to load the driver then
automatic flushing is never enabled, so we must do it ourselves
Indicates whether the class object that would be created if the code calling
DriverManager is accessible.
If the driver is packaged as a Service Provider, load it.
Get all the drivers through the classloader
exposed as a java.sql.Driver.class service.
ServiceLoader.load() replaces the sun.misc.Providers()
Worker method called by the public getConnection() methods.
synchronize loading of the correct classloader.
Walk through the loaded registeredDrivers attempting to make a connection.
Remember the first exception that gets raised so we can reraise it.
If the caller does not have permission to load the driver then
if we got here nobody could connect.
The code that once lived directly in CDROutputStream.grow()
has been moved ByteBufferWithInfo.growBuffer().
Grow ByteBufferWithInfo to a larger size.
Must be false for the grow case
Get the output filename from the 'file' attribute
If the 'append' attribute is set to "yes" or "true",
the output is appended to the file.
Verify that the filename is in fact set
Save filename as an attribute value template
Save the current output handler on the stack
Create the new output handler (leave it on stack)
Overwrite current handler
Translate contents with substituted handler
Close the output handler (close file)
Restore old output handler from stack
---- Highlighter methods ----------------------------------------------
PENDING(prinz) - should cull ranges not visible
Avoid allocing unless we need it.
Mark the highlights region as invalid, it will reset itself
next time asked to paint.
---- member variables --------------------------------------------
--- HighlightPainter methods ---------------------------------------
--- determine locations ---
--- render ---
same line, render a rectangle
--- LayerPainter methods ----------------------------
Contained in view, can just use bounds.
Should only render part of View.
--- determine locations ---
If we are asked to highlight, we should draw something even
if the model-to-view projection is of zero width (6340106).
Restrict the region to what we represent
Paint the appropriate region using the painter and union
the effected region with our bounds.
the Document should be the same to properly
-- This file was mechanically generated: Do not edit! --
OK : Move to next block as baseURL could not be initialized.
OK : Move to next block as baseURL could not be initialized.
GETTERS AND SETTERS
------------------------- JDBC 4.0 -----------------------------------
------------------------- JDBC 4.1 -----------------------------------
------------------------- JDBC 4.2 -----------------------------------
%OPT% !!! FSB has to be updated to take partial fsb's for append.
/** NEEDSDOC Field strCount */
/** NEEDSDOC Field xtable */
if (null == xtable.get(str))
%OPT% Need to call this on FSB when it is implemented.
%UNTESTED% (I don't think anyone calls this yet?)
In order to handle the 'all' semantics of
nodeset comparisons, we always call the
Commenting this out because in JDK1.1.8 and VJ++
we don't match XMLStrings. Defaulting to the super
causes us to create a string, but at this point
this only seems to get called in key processing.
Maybe we can live with it?
Note: toffset might be near -1>>>1.
Note: fromIndex might be near -1>>>1.
%OPT% Make an FSB here?
Take the easy way out for now.
The following are permitted in the Double.valueOf, but not by the XPath spec:
- a plus sign
- The use of e or E to indicate exponents
- trailing f, F, d, or D
See function comments; not sure if this is slower than actually doing the
conversion ourselves (as was before).
This should catch double periods, empty strings.
Uses O(n^2) algorithm that is only appropriate
for small sets, which CopyOnWriteArraySets should be.
Use a single snapshot of underlying array
Mark matched elements to avoid re-checking
Opcode              Char       Opdata/Operand  Meaning
----------          ---------- --------------- --------------------------------------------------
end of program
match only if at beginning of line
match only if at end of line
match any single character except newline
count/ranges    match any char in the list of ranges
node            match this alternative or the next one
length/string   length of string followed by string itself
node            kleene closure
node            positive closure
node            optional closure
escape          special escape code char class (escape is E_* code)
number          nth opening paren
number          nth closing paren
number          reference nth already matched parenthesized string
nothing but a (back-)pointer
match null string such as in '(a|)'
none/expr       reluctant '*' (mnemonic for char is unshifted '*')
none/expr       reluctant '+' (mnemonic for char is unshifted '+')
none/expr       reluctant '?' (mnemonic for char is unshifted '?')
classid         one of the posix character classes
Posix character classes
Java identifier start
Java identifier part
Maximum number of nodes in a program
Number of paren pairs (only 9 can be backrefs)
Node layout constants
Opcode offset (first character)
Opdata offset (second char)
Next index offset (third char)
Node size (in chars)
State of current program
Compiled regular expression 'program'
The string being matched against
Match behaviour flags
Number of subexpressions matched (num open parens + 1)
Cache of start[0]
Cache of start[0]
Cache of start[1]
Cache of start[1]
Cache of start[2]
Cache of start[2]
Lazy-alloced array of sub-expression starts
Lazy-alloced array of sub-expression ends
Lazy-alloced array of backref starts
Lazy-alloced array of backref ends
Allocate arrays for subexpressions
Set sub-expression pointers to invalid values
Our current place in the string
Loop while node is valid
Try to match the rest without using the reluctant subexpr
Try to match the rest without using the reluctant subexpr
Try to match the rest without using the reluctant subexpr
Increase valid paren count
Don't set paren if already set later on
Done matching subexpression
Increase valid paren count
Don't set paren if already set later on
starting or ending the matching of a subexpression which has no backref.
Get the start and end of the backref
We don't know the backref yet
The backref is empty size
Get the length of the backref
If there's not enough input left, give up.
Case fold the backref?
Compare backref to input
Fail if we're not at the start of the string
If we're multiline matching, we could still be at the start of a line
If not at start of line, give up
If we're not at the end of string
If we're multi-line matching
Give up if we're not at the end of a line
Word boundary match
Alpha-numeric, digit, space, javaLetter, javaLetterOrDigit
Give up if out of input
Switch on escape
Match anything but a newline
Match an atom value
Get length of atom and starting index
Give up if not enough input remains to have a match
Match atom differently depending on casefolding flag
Out of input?
JWL - bugbug: is this right??
JWL - bugbug???
JWL - bugbug??
Out of input?
Get character to match against character class and maybe casefold
Loop through character class checking our match character
Get start, end and match characters
Fail if we didn't match the character class
Check for choices
If there aren't any other choices, just evaluate this branch.
Try all available branches
Try matching the branch against the string
Go to next branch (if any)
Failed to match any branch!
Just advance to the next node without doing anything
Match has succeeded!
Advance to the next node in the program
We "should" never end up here
Initialize start pointer, paren cache and paren count
Allocate backref arrays (unless optimizations indicate otherwise)
Match against string
There is no compiled program to search with!
This should be uncommon enough to be an error case rather
than an exception (which would have to be handled everywhere)
Save string to search
Can we optimize the search by looking for a prefix string?
Unprefixed matching must try for a match at each character
Try a match at index i
Prefix-anchored matching is possible
If there's a mismatch of any character in the prefix, give up
See if the whole prefix string matched
We matched the full prefix at firstChar, so try it
Create new vector
Start at position 0 and search the whole string
Try a match at each position
Get start of match
Get end of match
Check if no progress was made
Move to new position
Push remainder if it's not empty
Return vector as an array of strings
String to return
Start at position 0 and search the whole string
Try a match at each position
Append string before match
Append everything between the beginning of the
substitution string and the current $ sign
Append everything between the last and the current $ sign
Append the parenthesized expression
Note: if a parenthesized expression of the requested
index is not available "null" is added to the string
Move forward, skipping past match
Append everything after the last $ sign
Append substitution without processing backreferences
Move forward, skipping past match
We always want to make progress!
Try new position
Break out if we're only supposed to replace one occurrence
If there's remaining input, append it
Return string buffer as string
Create new vector to hold return items
Traverse array of objects
Get next object as a string
If it matches this regexp, add it to the list
Return vector as an array of strings
it's not here
it's not here
Only count listeners of correct type
Skip nulls, instances of wrong class
REVISIT - think about this some more.
This connection normally is accessed from the message mediator.
However, giop input needs to get code set info from the connetion
XREVISIT - Should the header be kept in the stream or the
message mediator?  Or should we not have a header and
have the information stored in the message mediator
Unmarshal the extended GIOP message from the buffer.
If the connection doesn't have its negotiated
code sets by now, fall back on the defaults defined
If the connection doesn't have its negotiated
code sets by now, we have to throw an exception.
See CORBA formal 00-11-03 13.9.2.6.
For GIOP 1.2 and UTF-16, use big endian if there is no byte
order marker.  (See issue 3405b)
For GIOP 1.1 and UTF-16, use the byte order the stream if
there isn't (and there shouldn't be) a byte order marker.
GIOP 1.0 doesn't have wchars.  If we're talking to a legacy ORB,
we do what our old ORBs did.
If we're local and don't have a Connection, use the
local code sets, otherwise get them from the connection.
If the connection doesn't have negotiated code sets
yet, then we use ISO8859-1 for char/string and wchar/wstring
Below this point are commented out methods with features
from the old stream.  We must find ways to address
these issues in the future.
End of file.
Type-specific CORBA::Object operations
assert policies.retainServants() && policies.useActiveObjectMapOnly()
Check for an ObjectAlreadyActive error
Default does nothing, but the USE_SERVANT_MANAGER case
must handle etherealization
XXX needs to handle call from an invocation on this POA
assert !isUnique || (servant not in activateObjectMap)
This can't occur here, since id is always brand new.
The Comparable interface says that this
method throws a ClassCastException if the
given object's type prevents it from being
Ensure that we either set both of these or neither
clone because byte arrays are modifiable
Check that the test date is within the validity interval:
[ thisUpdate - MAX_CLOCK_SKEW,
nextUpdate + MAX_CLOCK_SKEW ]
Try to get InputSource from SAXSource input
Pass the SAX parser to the compiler
Incase there is an exception thrown
resort to JAXP
Try to get SAX InputSource from DOM Source.
get sax InputSource from StAXSource
Try to get InputStream or Reader from StreamSource
Clear old XML reader
Create InputSource from Reader or InputStream in Source
-- This file was mechanically generated: Do not edit! --
A new ORB started server registers itself with the Activator
Install a particular kind of endpoint
list active servers
If the server is not running, start it up.
If the server is running, shut it down
currently running, this method will activate it.
list all registered ORBs for a server
After this hook completes, the server may still be running.
Starts the server if it is not already running.
Starts the server if it is not already running.
get the port for the endpoint of the locator
to pick a particular port type.
Type-specific CORBA::Object operations
initialize map with the defaults
replacing an Attribute with itself does nothing
make sure it won't be mistaken with defaults in case it's reused
Insert point (may be end of list)
If the new attribute is not normalized,
the owning element is inherently not normalized.
replacing an Attribute with itself does nothing
make sure it won't be mistaken with defaults in case it's reused
If we can't find by namespaceURI, localName, then we find by
nodeName so we know where to insert.
Insert point (may be end of list)
If the new attribute is not normalized,
the owning element is inherently not normalized.
If there's a default, add it instead
we must rely on the name to find a default attribute
("test:attr"), but while copying it from the DOCTYPE
we should not loose namespace URI that was assigned
to the attribute in the instance document.
remove reference to owner
make sure it won't be mistaken with defaults in case it's
If there's a default, add it instead
we must rely on the name to find a default attribute
("test:attr"), but while copying it from the DOCTYPE
we should not loose namespace URI that was assigned
to the attribute in the instance document.
remove reference to owner
make sure it won't be mistaken with defaults in case it's
update id table if needed
remove any existing default
add the new defaults
If we can't find by namespaceURI, localName, then we find by
nodeName so we know where to insert.
Insert point (may be end of list)
Various constructors that allow different levels of
specificity. If the Shape is missing the whole renderable area
is assumed. If hints is missing no hints are assumed.
End of file.
workaround for 4530952
The preferred and minimum sizes are overriden and padded by
4 to keep the size as it previously was.  Refer to bugs
4775789 and 4517214 for details.
default impl. delegates to StrictMath
default impl. delegates to StrictMath
default impl. delegates to StrictMath
default impl. delegates to StrictMath
default impl. delegates to StrictMath
default impl. delegates to StrictMath
default impl. delegates to StrictMath
default impl. delegates to StrictMath
default impl. delegates to StrictMath
default impl. delegates to StrictMath
Note that hardware sqrt instructions
frequently can be directly used by JITs
and should be much faster than doing
Math.sqrt in software.
delegate to StrictMath
default impl. delegates to StrictMath
default impl. delegates to StrictMath
default impl. delegates to StrictMath
default impl. delegates to StrictMath
default impl. delegates to StrictMath
shift >= 0 && shift < 32
a is a finite number such that pow(2,-32) <= ulp(a) < 1
In the comments below each Java expression evaluates to the value
the corresponding mathematical expression:
(r) evaluates to a / ulp(a)
(r >> shift) evaluates to floor(a * 2)
((r >> shift) + 1) evaluates to floor((a + 1/2) * 2)
(((r >> shift) + 1) >> 1) evaluates to floor(a + 1/2)
a is either
- a finite number with abs(a) < exp(2,FloatConsts.SIGNIFICAND_WIDTH-32) < 1/2
- a finite number with ulp(a) >= 1 and hence a is a mathematical integer
- an infinity or NaN
shift >= 0 && shift < 64
a is a finite number such that pow(2,-64) <= ulp(a) < 1
In the comments below each Java expression evaluates to the value
the corresponding mathematical expression:
(r) evaluates to a / ulp(a)
(r >> shift) evaluates to floor(a * 2)
((r >> shift) + 1) evaluates to floor((a + 1/2) * 2)
(((r >> shift) + 1) >> 1) evaluates to floor(a + 1/2)
a is either
- a finite number with abs(a) < exp(2,DoubleConsts.SIGNIFICAND_WIDTH-64) < 1/2
- a finite number with ulp(a) >= 1 and hence a is a mathematical integer
- an infinity or NaN
HD 2-12 Overflow iff both arguments have the opposite sign of the result
HD 2-12 Overflow iff both arguments have the opposite sign of the result
HD 2-12 Overflow iff the arguments have different signs and
the sign of the result is different than the sign of x
HD 2-12 Overflow iff the arguments have different signs and
the sign of the result is different than the sign of x
Some bits greater than 2^31 that might cause overflow
Check the result using the divide operator
and check for the special case of Long.MIN_VALUE * -1
if the signs are different and modulo not zero, round down
if the signs are different and modulo not zero, round down
Use raw bit-wise conversions on guaranteed non-NaN arguments.
a is NaN
Raw conversion ok since NaN can't map to -0.0.
a is NaN
Raw conversion ok since NaN can't map to -0.0.
a is NaN
Raw conversion ok since NaN can't map to -0.0.
a is NaN
Raw conversion ok since NaN can't map to -0.0.
NaN or infinity
zero or subnormal
ulp(x) is usually 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))
return a subnormal result; left shift integer
representation of Double.MIN_VALUE appropriate
number of positions
NaN or infinity
zero or subnormal
ulp(x) is usually 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))
return a subnormal result; left shift integer
representation of FloatConsts.MIN_VALUE appropriate
number of positions
First check for NaN values
return a NaN derived from the input NaN(s)
start > direction or start < direction
Add +0.0 to get rid of a -0.0 (+0.0 + -0.0 => +0.0)
then bitwise convert start to integer.
Calculate next greater value
Calculate next lesser value
First check for NaN values
return a NaN derived from the input NaN(s)
start > direction or start < direction
Add +0.0 to get rid of a -0.0 (+0.0 + -0.0 => +0.0)
then bitwise convert start to integer.
Calculate next greater value
Calculate next lesser value
magnitude of a power of two so large that scaling a finite
nonzero value by it would be guaranteed to over or
underflow; due to rounding, scaling down takes takes an
additional power of two which is reflected here
Make sure scaling factor is in a reasonable range
Calculate (scaleFactor % +/-512), 512 = 2^9, using
technique from "Hacker's Delight" section 10-2.
magnitude of a power of two so large that scaling a finite
nonzero value by it would be guaranteed to over or
underflow; due to rounding, scaling down takes takes an
additional power of two which is reflected here
Make sure scaling factor is in a reasonable range
Constants used in scalb
serialVersionUID not constant
Serialization compatibility stuff:
Two serial forms are supported in this class. The selected form depends
on system property "jmx.serial.form":
- "1.0" for JMX 1.0
- any other value for JMX 1.1 and higher
Serial version for old serial form
Serial version for new serial form
Serializable fields in old serial form
Serializable fields in new serial form
Actual serial version and serial form
OK: exception means no compat with 1.0, too bad
END Serialization compatibility stuff
Read an object serialized in the old serial form
Read an object serialized in the new serial form
Serializes this instance in the old serial form
Serializes this instance in the new serial form
For code simplicity, copy these constants to our namespace
and cast them to byte constants for easy storage.
ensure > 6 (cubics)
hard overflow failure - we can't even accommodate
new items without overflowing
growth algorithm computation
overflow in growth algorithm computation
try allocating the larger array
hard overflow failure - we can't even accommodate
new items without overflowing
growth algorithm computation
overflow in growth algorithm computation
try allocating the larger array
Count should always be a multiple of 2 here.
Count should always be a multiple of 2 here.
Count should always be a multiple of 2 here.
Collapse out initial moveto/lineto
Note: It would be nice to have this return Path2D
but one of our subclasses (GeneralPath) needs to
offer "public Object clone()" for backwards
compatibility so we cannot restrict it further.
REMIND: Can we do both somehow?
hard overflow failure - we can't even accommodate
new items without overflowing
growth algorithm computation
overflow in growth algorithm computation
try allocating the larger array
Count should always be a multiple of 2 here.
Count should always be a multiple of 2 here.
Count should always be a multiple of 2 here.
Collapse out initial moveto/lineto
Note: It would be nice to have this return Path2D
but one of our subclasses (GeneralPath) needs to
offer "public Object clone()" for backwards
compatibility so we cannot restrict it further.
REMIND: Can we do both somehow?
Note: It would be nice to have this return Path2D
but one of our subclasses (GeneralPath) needs to
offer "public Object clone()" for backwards
compatibility so we cannot restrict it further.
REMIND: Can we do both somehow?
Should never happen
The subclass calls this method with the storage type that
they want us to use (storedbl) so we ignore the storage
method hint from the stream.
This is the only information we can provide in a pipeline.
REVISIT: Forbid serialization of PSVI DOM until
we support object serialization of grammars -- mrglavas
If an instanceof MetalLookAndFeel hasn't been inited yet, we
don't want to trigger loading of a UI by asking the UIManager
for a property, assume the user wants system fonts. This will
be properly adjusted when install is invoked on the
this key defines which of the various cues to render
This is disabled until sound bugs can be resolved.
Text (Note: many are inherited)
passwordField.font should actually map to
win.ansiFixed.font.height on windows.
TextArea.font should actually map to win.ansiFixed.font.height
margin is 2 all the way around, BasicBorders.RadioButtonBorder
(checkbox uses RadioButtonBorder) is 2 all the way around too.
margin is 2 all the way around, BasicBorders.RadioButtonBorder
is 2 all the way around too.
Internal Frame Defaults
Internal Frame Auditory Cue Mappings
grid line color
Menu Item Auditory Cue Mapping
Option Pane Auditory Cue Mappings
Option Pane Special Dialog Colors, used when MetalRootPaneUI
is providing window manipulation widgets.
OptionPane fonts are defined below
Popup Menu Auditory Cue Mappings
CB & RB Menu Item
Tree.font was mapped to system font pre 1.4.1
These bindings are only enabled when there is a default
button set on the rootpane.
Remove old listeners
PENDING: move this to initialize when API changes are allowed
NOTE: because you need to recreate the look and feel after
this step, we don't bother blowing away any potential windows
This will happen in two cases:
. When MetalLookAndFeel is first being initialized.
. When a new AppContext has been created that hasn't
triggered UIManager to load a LAF. Rather than invoke
a method on the UIManager, which would trigger the loading
of a potentially different LAF, we directly set the
Create the default theme. We prefer Ocean, but will
use DefaultMetalTheme if told to.
From the JLF Design Guidelines:
Metal doesn't spec this.
Fall through to related.
When toggle buttons are exclusive (that is,
they form a radio button set), separate
them with 2 pixels. This rule applies
whether the toggle buttons appear in a
toolbar or elsewhere in the interface.
Note: this number does not appear to
include any borders and so is not adjusted
by the border of the toggle button
When toggle buttons are independent (like
checkboxes) and used outside a toolbar,
separate them with 5 pixels.
Insert 12 pixels between the trailing edge of a
label and any associated components. Insert 12
pixels between the trailing edge of a label and the
component it describes when labels are
right-aligned. When labels are left-aligned, insert
12 pixels between the trailing edge of the longest
label and its associated component
Include 11 pixels between the bottom and right
borders of a dialog box and its command
buttons. (To the eye, the 11-pixel spacing appears
to be 12 pixels because the white borders on the
lower and right edges of the button components are
not visually significant.)
NOTE: this last text was designed with Steel in mind,
Insert 12 pixels between the edges of the panel and the
titled border. Insert 11 pixels between the top of the
title and the component above the titled border. Insert 12
pixels between the bottom of the title and the top of the
first label in the panel. Insert 11 pixels between
component groups and between the bottom of the last
component and the lower border.
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Don't add if it is already a listener
--- Scrolling support -----------------------------------
convert to coordinate system of the bounded range
Scroll to the left
Scroll to the right
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
--- variables -------------------------------------------
--- Action implementations -----------------------------------
Note that JFormattedTextField.CommitAction extends this
-- This file was mechanically generated: Do not edit! --
Cached unsafe-access object
Cached array base offset
Cached unaligned-access capability
Base address, used in all indexing calculations
NOTE: moved up to Buffer.java for speed in JNI GetDirectBufferAddress
An object attached to this buffer. If this buffer is a view of another
buffer then we use this field to keep a reference to that buffer to
ensure that its memory isn't freed before we are done with it.
For duplicates and slices
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of TabbedPanePainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of TabbedPanePainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
All drawing is done to a BufferStrategy.  At the end of painting
(endPaint) the region that was painted is flushed to the screen
PaintManager.show is overriden to show directly from the
BufferStrategy (when using blit), if successful true is
returned and a paint event will not be generated.  To avoid
showing from the buffer while painting a locking scheme is
implemented.  When beginPaint is invoked the field painting is
set to true.  If painting is true and show is invoked we
immediately return false.  This is done to avoid blocking the
toolkit thread while painting happens.  In a similar way when
show is invoked the field showing is set to true, beginPaint
will then block until showing is true.  This scheme ensures we
only ever have one thread using the BufferStrategy and it also
ensures the toolkit thread remains as responsive as possible.
If we're using a flip strategy the contents of the backbuffer may
have changed and so show only attempts to show from the backbuffer
if we get a blit strategy.
Methods used to create BufferStrategy for Applets.
Region that we need to flush.  When beginPaint is called these are
reset and any subsequent calls to paint/copyArea then update these
fields accordingly.  When endPaint is called we then try and show
the accumulated region.
These fields are in the coordinate system of the root.
The following fields are set by prepare
dipose can be invoked at any random time. To avoid
threading dependancies we do the actual diposing via an
Don't show from backbuffer while in the process of
Mark the buffer as needing to be repainted.  We don't
immediately do a repaint as this method will return false
indicating a PaintEvent should be generated which will
trigger a complete repaint.
BufferStrategy may have already constrained the Graphics. To
account for that we revert the constrain, then apply a
constrain for Swing on top of that.
Assume they are going to eventually render to the screen.
This disables showing from backbuffer until a complete
Fall through to old rendering.
Invalid root, do what Swing has always done.
Note: this method is only called internally and we know that
g is from a heavyweight Component, so no check is necessary as
it is in paint() above.
If the buffer isn't in sync there is no point in doing a copyArea,
it has garbage.
Prepare failed, or not in sync. By calling super.copyArea
we'll copy on screen. We need to flush any pending paint to
the screen otherwise we'll do a copyArea on the wrong thing.
Flush failed, copyArea will be copying garbage,
force repaint of all.
Make sure another thread isn't attempting to show from
the back buffer.
Reset the area that needs to be painted.
Contents lost twice in a row, punt.
In case we've left junk on the screen, force a repaint.
Shown region was bogus, mark buffer as out of sync.
This will only happen on the EDT.
Make sure another thread isn't attempting to show from
the back buffer.
We're in the process of painting and the user grabbed
the Graphics. If we dispose now, endPaint will attempt
to show a bogus BufferStrategy. Set a flag so that
endPaint knows it needs to dispose this buffer.
Couldn't create BufferStrategy, fallback to normal
We either recreated the BufferStrategy, or the contents
of the buffer strategy were restored.  We need to
repaint the root pane so that the back buffer is in sync
Contents lost twice in a row, punt
We've encountered two hws now and may have
a containment hierarchy with lightweights containing
heavyweights containing other lightweights.
Heavyweights poke holes in lightweight
rendering so that if we call show on the BS
(which is associated with the Window) you will
not see the contents over any child
heavyweights.  If we didn't do this when we
went to show the descendants of the nested hw
you would see nothing, so, we bail out here.
We're in a Swing heavyeight (JFrame/JWindow...), use double
buffering if double buffering enabled on the JRootPane and
the JRootPane wants true double buffering.
Whether or not a component is double buffered is a
bit tricky with Swing. This gives a good approximation
of the various ways to turn on double buffering for
Don't do true double buffering.
NOTE: This class does NOT hold a direct reference to the root, if it
did there would be a cycle between the BufferPerWindowPaintManager
and the Window so that it could never be GC'ed
Reference to BufferStrategy is referenced via WeakReference for
Indicates whether or not the backbuffer and display are in sync.
This is set to true when a full repaint on the rootpane is done.
Indicates the contents were lost during and expose event.
Indicates we need to generate a paint event on expose.
Component has a different BS, dispose ours.
We do this for two reasons:
1. So that we know we can cast to SubRegionShowable and
invoke show with the minimal region to update
2. To avoid the possibility of invoking client code
on the toolkit thread.
Creates and returns a buffer strategy.  If
there is a problem creating the buffer strategy this will
eat the exception and return null.
Type is not supported
Type not supported
We mark the buffer as needing to be painted on a hide/iconify
because the developer may have conditionalized painting based on
Ideally we would also move to having the BufferStrategy being
a SoftReference in Component here, but that requires changes to
Component and the like.
This case will only happen if a developer calls
hide immediately followed by show.  In this case
the event is delivered after show and the window
will still be visible.  If a developer altered the
contents of the window between the hide/show
invocations we won't recognize we need to paint and
the contents would be bogus.  Calling repaint here
fixs everything up.
On a dispose we chuck everything.
Make sure we're not showing.
REMIND: synchronize instead of relying on volatile?
check common case first
nested lookup call already set future
field mismatches impossible when matching local fields vs. self
reassign to matched fields so as to reflect local unshared settings
should not occur, as access checks have been suppressed
should not occur, as access checks have been suppressed
should not occur, as access checks have been suppressed
should not occur, as access checks have been suppressed
should not occur, as access checks have been suppressed
should not occur, as access checks have been suppressed
REMIND: synchronize instead of relying on volatile?
locate closest non-serializable superclass
search up inheritance hierarchy for class with matching name
add "no data" slot for each unmatched class below match
record descriptor/class pairing
add "no data" slot for any leftover unmatched classes
order slots from superclass -> subclass
REMIND: dynamically generate these?
class irrelevant if no fields
check common case first
Stub class generated by rmic, do not edit.
Contents subject to change without notice.
methods from remote interfaces
implementation of getVersion()
implementation of newClient(Object)
assign our local reference to the attribute stream
init the index point before the head of the stream
set the map
Methods for reading attributes from the stream of SQL data.
These methods correspond to the column-accessor methods of
Methods for reading items of SQL user-defined types from the stream.
look up the class in the map
create new instance of the class
get the attributes from the struct
create the SQLInput "stream"
read the values...
---------------------------- JDBC 4.0 -------------------------
defaults for constructors
Smallest values for digits (Maximum is Integer.MAX_VALUE)
any error here is a string format problem
could be -1
where value starts
the other parameters cannot be invalid if we got here
no need for .equals()
read in all fields
validate possibly bad fields
can't use valueOf which throws IllegalArgumentException
Refer to note in getAcceleratorString about this field.
fix for bug 4153892
NOTE: This requires the tip field to be set before this is invoked.
As MetalToolTipUI is shared between all JToolTips the tip field is
set appropriately before this is invoked. Unfortunately this means
that subclasses that randomly invoke this method will see varying
results. If this becomes an issue, MetalToolTipUI should no longer be
Call two argument add method.
Call two argument remove method.
ignore exceptions that occur during rolling back
rethrow the veto exception
The table holding the mapping between the programmatic keys
and the display strings for the en_US locale.
END OF MATERIAL TO LOCALIZE
delegate to the superclass to install defaults such as background,
foreground, font, and opaque onto the swing component.
a non-null values object is the flag we use to determine whether
to reparse from UIManager.
reconstruct this NimbusStyle based on the entries in the UIManager
and possibly based on any overrides within the component's
client properties (assuming such a component exists and contains
inspect the client properties for the key "Nimbus.Overrides". If the
value is an instance of UIDefaults, then these defaults are used
in place of, or in addition to, the defaults in UIManager.
We know component.get() is non-null here, as if the component
were GC'ed, we wouldn't be processing its style.
a list of the different types of states used by this style. This
list may contain only "standard" states (those defined by Synth),
or it may contain custom states, or it may contain only "standard"
states but list them in a non-standard order.
a map of state name to code
This is a list of runtime "state" context objects. These contain
the values associated with each state.
determine whether there are any custom states, or custom state
order. If so, then read all those custom states and define the
"values" stateTypes to be a non-null array.
Otherwise, let the "values" stateTypes be null to indicate that
there are no custom states or custom state ordering
this is a non-standard state name, so look for the
custom state associated with it
if there were any states defined, then set the stateTypes array
to be non-null. Otherwise, leave it null (meaning, use the
standard synth states).
assign codes for each of the state types
since there were no custom states defined, setup the list of
standard synth states. Note that the "v.stateTypes" is not
being set here, indicating that at runtime the state selection
routines should use standard synth states instead of custom
states. I do need to popuplate this temp list now though, so that
the remainder of this method will function as expected.
assign codes for the states
Now iterate over all the keys in the defaults table
The key is something like JButton.Enabled.backgroundPainter,
or JButton.States, or JButton.background.
Remove the "JButton." portion of the key
if there is a " or : then we skip it because it is a subregion
of some kind
remove the separator
At this point, temp may be any of the following:
parse out the states and the property
there is not a state string, so property = temp
now that I have the state (if any) and the property, get the
value for this property and install it where it belongs
there was no state, just a property. Check for the custom
"contentMargins" property (which is handled specially by
Synth/Nimbus). Also check for the property being "States",
in which case it is not a real property and should be ignored.
otherwise, assume it is a property and install it on the
it is possible that the developer has a malformed UIDefaults
entry, such that something was specified in the place of
the State portion of the key but it wasn't a state. In this
case, skip will be set to true
this variable keeps track of the int value associated with
the state. See SynthState for details.
Multiple states may be specified in the string, such as
For each state, we need to find the State object associated
with it, or skip it if it cannot be found.
Was not a state. Maybe it was a subregion or something
find the RuntimeState for this State
couldn't find the runtime state, so create a new one
check for a couple special properties, such as for the
painters. If these are found, then set the specially on
the runtime state. Else, it is just a normal property,
so put it in the UIDefaults associated with that runtime
now that I've collected all the runtime states, I'll sort them based
on their integer "state" (see SynthState for how this works).
finally, set the array of runtime states on the values object
Account for scale
The key "JComponent.sizeVariant" is used to match Apple's LAF
map FOREGROUND as TEXT_FOREGROUND
if all else fails, return a default color (which is a ColorUIResource)
Account for scale
The key "JComponent.sizeVariant" is used to match Apple's LAF
Force Table CellRenderers to be opaque
strip off the prefix, if there is one.
check the cache
Search exact matching states and then lesser matching states
Search Region Defaults
return found object
Search UIManager Defaults
Search Synth Defaults for InputMaps
if all we got was a null, store this fact for later use
return found object
check the cache
not in cache, so lookup and store in cache
check the cache
not in cache, so lookup and store in cache
check the cache
not in cache, so lookup and store in cache
check for the Nimbus.State client property
Performance NOTE: getClientProperty ends up inside a synchronized
block, so there is some potential for performance issues here, however
I'm not certain that there is one on a modern VM.
standard states only
if there are no custom states defined, then simply return the
state that Synth reported
there are custom states on this values, so I'll have to iterate
over them all and return a custom extended state
Use the StateInfo with the most bits that matches that of state.
If there are none, then fallback to
the StateInfo with a state of 0, indicating it'll match anything.
Consider if we have 3 StateInfos a, b and c with states:
SELECTED, SELECTED | ENABLED, 0
Input                          Return Value
SELECTED | ENABLED             b
SELECTED | ENABLED | FOCUSED   b
if xstate is 0, then search for the runtime state with component
state of 0. That is, find the exact match and return it.
an exact match couldn't be found, so there was no match.
xstate is some value != 0
determine from which index to start looking. If lastState[0] is -1
then we know to start from the end of the state array. Otherwise,
we start at the lastIndex - 1.
This is key, we need to make sure all bits of the
StateInfo match, otherwise a StateInfo with
SELECTED | ENABLED would match ENABLED, which we
This comes from BigInteger.bitCnt
Note that DST was added in 1.4 so it is numbered out of order...
Rule 9 is DST which is defined above where it fits into the
list logically, rather than numerically
Installs the text cursor on the component
Overriden to do nothing, all our painting is done from update/paint.
m01 = m10 = m02 = m12 = 0.0;         /* Not needed. */
state = APPLY_IDENTITY;              /* Not needed. */
type = TYPE_IDENTITY;                /* Not needed. */
Transformed unit vectors are not perpendicular...
sgn(M0) == sgn(M1) therefore sgn(M2) == -sgn(M3)
This is the "unflipped" (right-handed) state
sgn(M0) == -sgn(M1) therefore sgn(M2) == sgn(M3)
This is the "flipped" (left-handed) state
Different signs - simple 90 degree rotation
Same signs - 90 degree rotation plus an axis flip too
Both scaling factors non-negative - simple scale
Note: APPLY_SCALE implies M0, M1 are not both 1
Both scaling factors negative - 180 degree rotation
Scaling factor signs different - flip about some axis
Utility methods to optimize rotate methods.
These tables translate the flags during predictable quadrant
rotations where the shear and scale values are swapped and negated.
If there was a shear, then this rotation has no
effect on the state.
No shear means the SCALE state may toggle when
m00 and m11 are negated.
REMIND: Simple for now - optimize later
If vecx > 0.0 - no rotation
If vecx == 0.0 - undefined rotation - treat as no rotation
vecy must be < 0.0
REMIND: Simple for now - optimize later
If Tx has more than one attribute, it is not worth optimizing
all of those cases...
Tx is IDENTITY...
Tx is TRANSLATE, this has no TRANSLATE
Tx is TRANSLATE, this has one too
Only these two existing states need a new state
Tx is SCALE, this is anything
Tx is SHEAR, this is anything
If Tx has more than one attribute, it is not worth optimizing
all of those cases...
Copy source coords into local variables in case src == dst
Copy source coords into local variables in case src == dst
If the arrays overlap partially with the destination higher
than the source and we transform the coordinates normally
we would overwrite some of the later source coordinates
with results of previous transformations.
To get around this we use arraycopy to copy the points
to their final destination with correct overwrite
handling and then transform them in place in the new
srcPts = dstPts;          They are known to be equal.
If the arrays overlap partially with the destination higher
than the source and we transform the coordinates normally
we would overwrite some of the later source coordinates
with results of previous transformations.
To get around this we use arraycopy to copy the points
to their final destination with correct overwrite
handling and then transform them in place in the new
srcPts = dstPts;          They are known to be equal.
Copy source coords into local variables in case src == dst
If the arrays overlap partially with the destination higher
than the source and we transform the coordinates normally
we would overwrite some of the later source coordinates
with results of previous transformations.
To get around this we use arraycopy to copy the points
to their final destination with correct overwrite
handling and then transform them in place in the new
srcPts = dstPts;          They are known to be equal.
Copy source coords into local variables in case src == dst
If the arrays overlap partially with the destination higher
than the source and we transform the coordinates normally
we would overwrite some of the later source coordinates
with results of previous transformations.
To get around this we use arraycopy to copy the points
to their final destination with correct overwrite
handling and then transform them in place in the new
srcPts = dstPts;          They are known to be equal.
Round values to sane precision for printing
Note that Math.sin(Math.PI) has an error of about 10^-16
this shouldn't happen, since we are Cloneable
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of SliderPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of SliderPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
Note - markDirty is probably unnecessary since icr is brand new
Hidden operations to be implemented in a subclass.
Table of stack map entries
signature for the type
Remember position in string, see getArgumentTypes
Recurse, but just once, if the signature is ok
type == T_REFERENCE
Look for closing `;'
"Lblabla;" `L' and `;' are removed
Read return type after `)'
Should never occur
Read all declarations between for `(' and `)'
current string position
Should never occur
serialVersionUID not constant
Serialization compatibility stuff:
Two serial forms are supported in this class. The selected form depends
on system property "jmx.serial.form":
- "1.0" for JMX 1.0
- any other value for JMX 1.1 and higher
Serial version for old serial form
Serial version for new serial form
Serializable fields in old serial form
Serializable fields in new serial form
Actual serial version and serial form
OK: No compat with 1.0
END Serialization compatibility stuff
New serial form ignores extra field "msgStr"
Serializes this instance in the old serial form
Serializes this instance in the new serial form
should not happen as this class is cloneable
For html on widgets the header is not visible, skip it.
For html on widgets the header is not visible, skip it.
don't want to die in static initialization...
just display things wrong.
initially layout to the preferred size
width currently laid out to
Read tag byte
-- This file was mechanically generated: Do not edit! --
For duplicates and slices
added for the Nimbus look and feel, where the tab area is painted differently depending on the
state for the selected tab
added for the Nimbus LAF to ensure that the labels don't move whether the tab is selected or not
Add properties other than JComponent colors, Borders and
opacity settings here:
added for Nimbus LAF so that it can use the basic arrow buttons
UIManager is queried directly here because this is called before
updateStyle is called so the style can not be queried directly
Clicking on selected tab
TODO need to just repaint the tab area!
forward the event (this will set the selected index, or none at all
TODO need to just repaint the tab area!
forward the event
hack: The super method *should* be setting the mouse-over property correctly
here, but it doesn't. That is, when the mouse is released, whatever tab is below the
released mouse should be in rollover state. But, if you select a tab and don't
move the mouse, this doesn't happen. Hence, forwarding the event.
Paint tab area
If scrollable tabs are enabled, the tab area will be
painted by the scrollable tab panel instead.
Paint content border
This can be invoked from ScrollabeTabPanel
if the tab area's states should match that of the selected tab, then
first update the selected tab's states, then set the state
for the tab area to match
otherwise, restore the tab area's state to ENABLED (which is the
only supported state otherwise).
Paint the tab area.
Paint tabRuns of tabs from back to front
TODO need to just repaint the tab area!
paint this tab such that its edge closest to the base is equal to
edge of the selected tab closest to the base. In terms of the TOP
tab placement, this will cause the bottom of each tab to be
painted even with the bottom of the selected tab. This is because
in each tab placement (TOP, LEFT, BOTTOM, RIGHT) the selected tab
is closest to the base.
don't use tabbedpane focus state
individual tab has focus
shift all the tabs, if necessary
left-to-right/right-to-left only affects layout
when placement is TOP or BOTTOM
xshift and yshift represent the amount &
direction to shift the tab in their
configure xshift and y shift based on tab
position and ltr/rtl
This file contains some utility methods that
originally were in the OSC in the RMI-IIOP
code delivered by IBM.  They don't make
sense there, and hence have been put
here so that they can be factored out in
an attempt to eliminate redundant code from
ObjectStreamClass.  Eventually the goal is
to move to java.io.ObjectStreamClass, and
class is package private for security reasons
FIXME: make this public in MR1
FIXME: make this public in MR1
-- This file was mechanically generated: Do not edit! --
--- Methods to support CharSequence ---
the header clip height can be set once since it's unchanging
derive the header and footer font from the table's font
for easy access to these values
to pass the page number when formatting the header and footer text
fetch the formatted header text, if any
fetch the formatted footer text, if any
to store the bounds of the header and footer text
the amount of vertical space needed for the header and footer text
the amount of vertical space available for printing the table
if there's header text, find out how much space is needed for it
and subtract that from the available space
if there's footer text, find out how much space is needed for it
and subtract that from the available space
depending on the print mode, we may need a scale factor to
fit the table's entire width on the page
if not, we would have thrown an acception previously
it must be, according to the if-condition, since imgWidth > 0
dictated by the previous two assertions
This is in a loop for two reasons:
First, it allows us to catch up in case we're called starting
with a non-zero pageIndex. Second, we know that we can be called
for the same page multiple times. The condition of this while
loop acts as a check, ensuring that we don't attempt to do the
calculations again when we are called subsequent times for the
if we are finished all columns in all rows
rather than multiplying every row and column by the scale factor
in findNextClip, just pass a width and height that have already
been divided by it
calculate the area of the table to be printed for this page
create a copy of the graphics so we don't affect the one given to us
translate into the co-ordinate system of the pageFormat
to save and store the transform
if there's footer text, print it at the bottom of the imageable area
if there's header text, print it at the top of the imageable area
and then translate downwards
constrain the table output to the available space
if we have a scale factor, scale the graphics object to fit
the entire width
otherwise, ensure that the current portion of the table is
store the old transform and clip for later restoration
if there's a table header, print the current section and
then translate downwards
restore the original transform and clip
print the current section of the table
restore the original transform and clip
draw a box around the table
dispose the graphics copy
if the text is small enough to fit, center it
otherwise, if the table is LTR, ensure the left side of
the text shows; the right can be clipped
otherwise, ensure the right side of the text shows
if we're ready to start a new set of rows
adjust clip to the left of the first column
adjust clip to the right of the first column
adjust clip to the top of the next set of rows
adjust clip width and height to be zero
fit as many rows as possible, and at least one
we can short-circuit for JTable.PrintMode.FIT_WIDTH since
we'll always fit all columns on the page
adjust clip to the left of the next set of columns
adjust clip width to be zero
fit as many columns as possible, and at least one
reset col to 0 to indicate we're finished all columns
Type-specific CORBA::Object operations
end of LookAheadIterator
Parse the host name.  A name has up to three components, the
hostname, a port number, or two numbers representing a port
range.   "www.sun.com:8080-9090" is a valid host name.
With IPv6 an address can be 2010:836B:4179::836B:4179
An IPv6 address needs to be enclose in []
For ex: [2010:836B:4179::836B:4179]:8080-9090
Refer to RFC 2732 for more information.
first separate string into two fields: hoststr, portstr
check for IPv6 address
need to normalize hoststr now
not IPv6 therefore ':' is the port separator
is this a domain wildcard specification?
check if ipv4 (if rightmost label a number)
The normal way to specify ipv4 is 4 decimal labels
but actually three, two or single label formats valid also
So, we recognise ipv4 by just testing the rightmost label
being a number.
regular domain name
these shouldn't leak outside the implementation
score = executePredicates( xctxt, prevStep, SCORE_OTHER,
score = executePredicates( xctxt, prevStep, SCORE_OTHER,
Type-specific CORBA::Object operations
DOM and DTD handler references
Initialise statistics variables
The build time can be used for statistics for a better
priority algorithm (currently round robin).
Create a SAX parser and get the XMLReader object it uses
Check for a "file:" URI (courtesy of Brian Ewins)
get 0 for local URI
Brutal handling of all exceptions
Insert out URI in circular buffer
Remove oldest URI from reference map
Insert our URI in circular buffer
Try to get the document from the cache first
better error handling needed!!!
If the document is in the cache we must check if it is still valid
Has the modification time for this file been checked lately?
Reload document if it has been modified since last download
Get the references to the actual DOM and DTD handler
The dom reference may be null if the URL pointed to a
Give the translet an early opportunity to extract any
information from the DOM object that it would like.
if null, non-null Ts are considered equal
When both pubId and sysId are null, the user's entity resolver
can do nothing about it. We'd better not bother calling it.
This happens when the resourceIdentifier is a GrammarDescription,
which describes a schema grammar of some namespace, but without
any schema location hint. -Sg
resolve entity using SAX entity resolver
error resolving entity
unable to resolve entity
------------------------- JDBC 3.0 -----------------------------------
------------------------- JDBC 4.0 -----------------------------------
------------------------- JDBC 4.2 -----------------------------------
Array size is num components
All attributes are optional, so setup defaults first
If samplePrecision is present, it must be 8.
This just checks.  We don't bother to assign the value.
We don't write SOF segments; the IJG library does.
Parent already did a loadBuf
the length of the paragraph
If there is a single Decoration for the whole paragraph, it
is stored here.  Otherwise this field is ignored.
If there is a single Font or GraphicAttribute for the whole
paragraph, it is stored here.  Otherwise this field is ignored.
If there are multiple Decorations in the paragraph, they are
stored in this Vector, in order.  Otherwise this vector and
the decorationStarts array are null.
If there are multiple Decorations in the paragraph,
decorationStarts[i] contains the index where decoration i
starts.  For convenience, there is an extra entry at the
end of this array with the length of the paragraph.
If there are multiple Fonts/GraphicAttributes in the paragraph,
stored in this Vector, in order.  Otherwise this vector and
the fontStarts array are null.
If there are multiple Fonts/GraphicAttributes in the paragraph,
fontStarts[i] contains the index where decoration i
starts.  For convenience, there is an extra entry at the
end of this array with the length of the paragraph.
Add extra entries to starts arrays with the length
of the paragraph.  'this' is used as a dummy value
in the Vector.
If the styles at insertPos match those at insertPos-1,
oldParagraph will be reused.  Otherwise we create a new
insert into existing paragraph
We will reuse oldParagraph unless there was a length-1 run
at deletePos.  We could do more work and check the individual
Font and Decoration runs, but we don't right now...
This is done here instead of in installDefaults as I was worried
that the BasicInternalFrameUI might not be fully initialized, and
that if this resets the closable state the BasicInternalFrameUI
Listeners that get notified might be in an odd/uninitialized state.
The palette close icon isn't opaque while the regular close icon is.
This makes sure palette close buttons have the right background.
SystemMenuBar forces the icon to be 16x16 or less.
assumes all buttons have the same dimensions
these dimensions include the borders
Don't change the closable state unless in an JOptionPane.
Array size is numScanComponents
Now the children
We don't write SOS segments; the IJG library does.
Parent already loaded the buffer
The chained value isn't a RowSetWarning.
This is a programming error by whoever added it to
the RowSetWarning chain.  We throw a Java "Error".
create storage for recognized features and properties
create table for features and properties
add recognized features
check and store
check and store
TODO: reasonable default?
Attributes.java - attribute list with Namespace support
Written by David Megginson
NO WARRANTY!  This class is in the public domain.
$Id: Attributes.java,v 1.2 2004/11/03 22:44:51 jsuttor Exp $
end of Attributes.java
Check that the function was passed exactly two arguments
The first argument must be a literal String
Second argument must be of type reference or object
If host is blank (as returned by "file:" URL in 1.0.2 used in
java.rmi.Naming), try to convert to real local host name so
that the RegistryImpl's checkAccess will not fail.
If that failed, at least try "" (localhost) anyway...
Methods for writing attributes to the stream of SQL data.
These methods correspond to the column-accessor methods of
Methods for writing items of SQL user-defined types to the stream.
These methods pass objects to the database as values of SQL
Structured Types, Distinct Types, Constructed Types, and Locator
Types.  They decompose the Java object(s) and write leaf data
items using the methods above.
--------------------------- JDBC 3.0 ------------------------
--------------------------- JDBC 4.0 ------------------------
--------------------------JDBC 4.2 -----------------------------
NOTE: this uses setOpaque vs LookAndFeel.installProperty as there
is NO reason for the RootPane not to be opaque. For painting to
work the contentPane must be opaque, therefor the RootPane can
also be opaque.
everything is in the new parent, AccessibleAWTWindow
Uses protected field.
treat anything < 0 as NOT_SPECIFIED
demo code in old Java Sound Demo used a wrong buffer calculation
that would lead to arbitrary negative values
terminology for OMG IDL type package name
name of element within module
Note that this should probably be makeConcatenatedName( '/', true )
for spec compliance,
but rmic does it this way, so we'll leave this.
The effect is that an overloaded method like
void foo( bar.typedef.Baz )
will get an IDL name of foo__bar_typedef_Baz instead of
foo__bar__typedef_Baz (note the extra _ before typedef).
Here we will check for IDL keyword collisions (see bug 5010332).
This means that the repository ID for
"IDL:foo/_exception/SomeEx:1.0" (note the underscore in front
of the exception module name).
See bug 4989312: we must always add the Ex.
enable InputMethodEvent for on-the-spot pre-editing
layout is managed by View hierarchy
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Set the document's run direction property to match the
component's ComponentOrientation property.
Override of Component.setComponentOrientation
Set the document's run direction property to match the
viewToModel currently returns null for some HTML content
when the point is within the component's top inset
Locate the current KeymapWrapper.
Found it, tweak the InputMap that points to it, as well
as anything it points to.
Couldn't find it.
Set the parent of WHEN_FOCUSED InputMap to be the new one.
Do the same thing with the ActionMap
Found it, tweak the Actionap that points to it, as well
as anything it points to.
Couldn't find it.
Set the parent of ActionMap to be the new one.
add a named keymap, a class of bindings
initialize default keymap
Fix for 4341002: value of FOCUS_ACCELERATOR_KEY is wrong.
So we fire both FOCUS_ACCELERATOR_KEY, for compatibility,
and the correct event here.
--- java.awt.TextComponent methods ------------------------
argument adjustment done by java.awt.TextComponent
--- Tooltip Methods ---------------------------------------------
--- Scrollable methods ---------------------------------------------
the printing is done successfully or otherwise.
dialog is hidden if needed.
Fire a ACCESSIBLE_VISIBLE_DATA_PROPERTY PropertyChangeEvent
when the text component moves (e.g., when scrolling).
Using an anonymous class since making AccessibleJTextComponent
implement ComponentListener would be an API change.
the caret moved
there is a selection
--- interface AccessibleText methods ------------------------
TIGER - 4170173
begin AccessibleEditableText methods -----
Fixes bug 4487492
----- end AccessibleEditableText methods
----- begin AccessibleExtendedText methods
Probably should replace the helper method getAtIndex() to return
instead an AccessibleTextSequence also for LINE & ATTRIBUTE_RUN
and then make the AccessibleText methods get[At|After|Before]Point
call this new method instead and return only the string portion
direction must be 1, 0, or -1
we are intentionally silent; our contract says we return
null if there is any failure in this method
else we leave rangeSequence set to null
we are intentionally silent; our contract says we return
null if there is any failure in this method
already validated 'direction' above...
we are intentionally silent; our contract says we return
null if there is any failure in this method
assumptions: (1) that all characters in a single element
share the same attribute set; (2) that adjacent elements
going backwards, so find left edge of this run -
that'll be the end of the previous run
now set ourselves up to find the left edge of the
going forward, so find right edge of this run -
that'll be the start of the next run
now set ourselves up to find the right edge of the
interested in the current run, so nothing special to
set up in advance...
only those three values of direction allowed...
set the unset edge; if neither set then we're getting
both edges of the current run around our 'index'
we are intentionally silent; our contract says we return
null if there is any failure in this method
locate the Element at index
locate the Element at our index/offset
test for initialization
cache the AttributeSet and parentElement atindex
find the first Element before/after ours w/the same AttributeSet
if we are already at edge of the first element in our parent
then return that edge
we already caught this case earlier; this is to satisfy
getTextRange() not needed; defined in AccessibleEditableText
----- end AccessibleExtendedText methods
--- interface AccessibleAction methods ------------------------
----- end AccessibleAction methods
--- serialization ---------------------------------------------
--- member variables ----------------------------------
this may throw an IllegalStateException,
but it will be caught and handled in the
action that invoked this method
member variables used for on-the-spot input method
editing style support
Determine local bindings first.
See if the parent has any.
Remove any bindings defined in the parent that
are locally defined.
There may be some duplication here...
There may be some duplication here...
Implies this is a KeyTyped event, use the default
There may be some duplication here...
There may be some duplication here...
Try the Keymap.
This is a little iffy, technically an Action is
a valid Key. We're assuming the Action came from
the InputMap though.
--- CaretEvent methods -----------------------
--- ChangeListener methods -------------------
--- FocusListener methods -----------------------------------
--- MouseListener methods -----------------------------------
Process any input method events that the component itself
recognizes. The default on-the-spot handling for input method
composed(uncommitted) text is done here after all input
method listeners get called for stealing the events.
let listeners handle the events
Overrides this method to become an active input method client.
Overrides this method to watch the listener installed.
Default implementation of the InputMethodRequests interface.
--- InputMethodRequests methods ---
--- DocumentListener methods ---
Replaces the current input method (composed) text according to
the passed input method event. This method also inserts the
committed text into the document.
old composed text deletion
committed text insertion
Remember latest committed text start index
Need to generate KeyTyped events for the committed text for components
that are not aware they are active input method clients.
map it to an ActionEvent
Remember latest committed text end index
new composed text insertion
Save the latest committed text information
create attributed string with no attributes
Map committed text to an ActionEvent. If the committed text length is 1,
treat it as a KeyStroke, otherwise or there is no KeyStroke defined,
treat it just as a default action.
Sets the caret position according to the passed input method
event. Also, sets/resets composed text caret appropriately.
Sets composed text caret
Scroll the component if needed so that the composed text
Restores original caret
Checks whether the client code overrides processInputMethodEvent.
If it is overridden, need not to generate KeyTyped events for committed text.
If it's not, behave as an passive input method client.
Checks whether a composed text in this text component
Caret implementation for editing the composed text.
Get the background color of the component
Draw caret in XOR mode.
can't render I guess
If some area other than the composed text is clicked by mouse,
issue endComposition() to force commit the composed text.
Post a caret positioning runnable to assure that the positioning
occurs *after* committing the composed text.
Runnable class for invokeLater() to set caret position later.
Methods overridden from AbstractList
We also override subList so that the result is a FreezableList.
If the m_throwExceptionOnError flag is true, rethrow the exception.
Otherwise report the error to System.err.
If the m_throwExceptionOnError flag is true, rethrow the exception.
Otherwise report the error to System.err.
Try to find the locator closest to the cause.
Try to find the locator closest to the cause.
Construct a ByteBufferPool for a pool of NIO ByteBuffers
of ORB fragment size.
If the requested ByteBuffer size is less than or equal to
the ORB fragment size, and we have not disabled use of
direct byte buffers (normally for debugging purposes)
then get a DirectByteBuffer from the
pool if there is one, if there is not one in the pool,
then allocate a a DirectByteBuffer of ORB fragment size.
If the request ByteBuffer size is greater than the ORB fragment
size, allocate a new non-direct ByteBuffer.
check if there's one in the pool, if not allocate one.
clear ByteBuffer before returning it
NOTE: Moved the 'else' part of the above if statement
outside the synchronized block since it is likely
less expensive to check poolSize than to allocate a
DirectByteBuffer in the synchronized block.
increment the number of ByteBuffers gotten from pool
IMPORTANT: Since this counter is used only for information
purposes, it does not use synchronized access.
Requested ByteBuffer size larger than the pool manages.
Just allocate a non-direct ByteBuffer
If the ByteBuffer is a DirectByteBuffer, add it to the pool.
Otherwise, set its reference to null since it's not kept in
the pool and caller is saying he/she is done with it.
NOTE: The size of the ByteBuffer is not checked with the
this pool's ByteBuffer size since only DirectByteBuffers
ever allocated. Hence, only DirectByteBuffer are checked
here. An additional check could be added here for that though.
use with debug to determine if byteBuffer is already
in the pool.
Check to make sure we don't have 'thebb' reference
already in the pool before adding it.
NOTE: The else part of this if will only get called
if debug = true and refInPool = true, see logic above.
add ByteBuffer back to the pool
otherwise, log a stack trace with duplicate message
decrement the count of ByteBuffers released
IMPORTANT: Since this counter is used only for information
purposes, it does not use synchronized access.
ByteBuffer not pooled nor needed
Get a count of the outstanding allocated DirectByteBuffers.
(Those allocated and have not been returned to the pool).
IMPORTANT: Since this counter is used only for information
purposes, it does not use synchronized access.
End of file.
override for covariant return type
inline TemporalAccessor.super.query(query) as an optimization
non-JDK classes are not permitted to make this optimization
Do the time check first, it is cheaper than computing EPOCH day.
Constants returned by acceptNode
Constants for whatToShow
DN being parsed
characters in LDAP name being parsed
length of "chars"
index of first unconsumed char in "chars"
ArrayList<Rdn> rdns =
new ArrayList<Rdn>(len / 3 + 10);   leave room for growth
leave room for growth
Back out any trailing spaces.
consume backslash, then what follows
no closing quote
consume closing quote
index of the most recently escaped character
consume backslash, then what follows
'twas backslash followed by nothing
Trim off (unescaped) trailing whitespace.
area for border
The progress bar border is painted according to a light source.
This light source is stationary and does not change when the
component orientation changes.
Draw light line lengthwise across the progress bar.
Draw darker lengthwise line over filled area.
Draw a line across the width.  The color is determined by
the code above.
Draw light line lengthwise across the progress bar.
Draw darker lengthwise line over filled area.
Draw a line across the width.  The color is determined by
the code above.
area for border
The progress bar border is painted according to a light source.
This light source is stationary and does not change when the
component orientation changes.
Draw light line lengthwise across the progress bar.
Draw darker lengthwise line over filled area.
Draw light line lengthwise across the progress bar.
Draw darker lengthwise line over filled area.
Flags needed to keep the indexes of the objects in the array.
Stop the timer.
Start the TimerAlarmClock.
Send or not past notifications depending on the flag.
Update the date and the number of occurrences of past notifications
to make them later than the current date.
Update and start all the TimerAlarmClocks.
Here, all the notifications in the timer table are later than the current date.
Retrieve the date notification and the TimerAlarmClock.
Update all the TimerAlarmClock timeouts and start them.
Set the state to ON.
Stop the TimerAlarmClock.
Stop all the TimerAlarmClock.
Wait until the thread die.
Remove the reference on the TimerAlarmClock.
Set the state to OFF.
NPCTE fix for bugId 4464388, esc 0,  MR, to be added after modification of jmx spec
public synchronized Integer addNotification(String type, String message, Serializable userData,
Date date, long period, long nbOccurences)
end of NPCTE fix for bugId 4464388
Check that all the timer notification attributes are valid.
Invalid timer period value exception:
Check that the period and the nbOccurences are POSITIVE VALUES.
Update the date if it is before the current date.
Create and add the timer notification into the timer table.
The sequenceNumber and the timeStamp attributes are updated
when the notification is emitted by the timer.
Fix bug 00417.B
The date registered into the timer is a clone from the date parameter.
Update and start the TimerAlarmClock.
NPCTE fix for bugId 4464388, esc 0,  MR , to be added after modification of jmx spec
public synchronized Integer addNotification(String type, String message, Serializable userData,
Date date, long period)
end of NPCTE fix for bugId 4464388 */
NPCTE fix for bugId 4464388, esc 0,  MR , to be added after modification of jmx spec
public synchronized Integer addNotification(String type, String message, Serializable userData,
Date date, long period)
end of NPCTE fix for bugId 4464388 */
NPCTE fix for bugId 4464388, esc 0,  MR, to be added after modification of jmx spec
public synchronized Integer addNotification(String type, String message, Serializable userData, Date date)
end of NPCTE fix for bugId 4464388
Check that the notification to remove is effectively in the timer table.
Stop the TimerAlarmClock.
Wait until the thread die.
Remove the reference on the TimerAlarmClock.
Remove the timer notification from the timer table.
Stop the TimerAlarmClock.
Wait until the thread die.
Remove the reference on the TimerAlarmClock.
Remove all the timer notifications from the timer table.
Reset the counterID.
GETTERS AND SETTERS
5089997: return is Vector<Integer> not Vector<TimerNotification>
NPCTE fix for bugId 4464388, esc 0, MR, 03 sept 2001, to be added after modification of jmx spec
end of NPCTE fix for bugId 4464388
Retrieve the timer notification and the date notification.
Update the timer notification while:
- the timer notification date is earlier than the current date
- the timer notification has not been removed from the timer table.
Update the date and the number of occurrences of the timer notification.
Retrieve the timer notification and the TimerAlarmClock.
Update the date and the number of occurrences of the timer notification
and the TimerAlarmClock time out.
nbOccurences = 0 notifies an infinite periodicity.
nbOccurences = 1 notifies a finite periodicity that has reached its end.
nbOccurences > 1 notifies a finite periodicity that has not yet reached its end.
Wait until the thread die.
Wait until the thread die.
Retrieve the timer notification associated to the alarm-clock.
Notify the timer.
Update the notification and the TimerAlarmClock timeout.
First make sure the DTMIterator val has a cache,
so if it doesn't have one, make one.
Get the cache from val and use it ourselves (we share it).
I guess we'll have to get a static instance of the DTM manager...
* Cast result object to a result tree fragment.
* @param support The XPath context to use for the conversion
* @return the nodeset as a result tree fragment.
public DocumentFragment rtree(XPathContext support)
while (DTM.NULL != (node = nl.nextNode()))
Creating a DTMNodeList has the side-effect that it will create a clone
XNodeSet with cache and run m_iter to the end. You cannot get any node
from m_iter after this call. As a fix, we call SetVector() on the clone's
cache. See Bugzilla 14406.
* Return a java object that's closest to the representation
* that should be handed to an extension.
* @return The object that this class wraps
public Object object()
don't bother to clone... won't do any good!
don't bother to clone... won't do any good!
%OPT% This should be XMLString based instead of string based...
If both objects to be compared are node-sets, then the comparison
will be true if and only if there is a node in the first node-set
and a node in the second node-set such that the result of performing
the comparison on the string-values of the two nodes is true.
Note this little gem from the draft:
NOTE: If $x is bound to a node-set, then $x="foo"
does not mean the same as not($x!="foo"): the former
is true if and only if some node in $x has the string-value
foo; the latter is true if and only if all nodes in $x have
the string-value foo.
If one object to be compared is a node-set and the other is a boolean,
then the comparison will be true if and only if the result of
performing the comparison on the boolean and on the result of
converting the node-set to a boolean using the boolean function
If one object to be compared is a node-set and the other is a number,
then the comparison will be true if and only if there is a
node in the node-set such that the result of performing the
comparison on the number to be compared and on the result of
converting the string-value of that node to a number using
the number function is true.
If one object to be compared is a node-set and the other is a
string, then the comparison will be true if and only if there
is a node in the node-set such that the result of performing
the comparison on the string-value of the node and the other
string is true.
Reached a DirContext; return result.
Resolve all the way using lookup().  This may allow the operation
to succeed if it doesn't require the penultimate context.
Reached a DirContext; return result.
Resolve all the way using lookup().  This may allow the operation
to succeed if it doesn't require the penultimate context.
Store the element index and position
Leaf nodes are never nullable unless its an epsilon node
If we are an epsilon node, then the first pos is an empty set
Otherwise, its just the one bit of our position
If we are an epsilon node, then the last pos is an empty set
Otherwise, its just the one bit of our position
When -Xrs is specified the user is responsible for
ensuring that shutdown hooks are run by calling
request extensions; single extensions not supported
deep-copy the encoded responses, since they are mutable
Initialized just before the value is used. See parse().
month is 0-based. So we have to normalize month to support Long.MAX_VALUE.
month is 0-based. So we have to normalize month to support Long.MAX_VALUE.
Use a Date instance to perform normalization. Its fastTime
is the UTC value after the normalization.
plus means east of GMT
Handle two-digit years < 70 (70-99 handled above).
Parse 2-digit years within the correct default century.
no time zone specified, have to use local
no time zone
adjust 1-based to 0-based
adjust 0-based to 1-based month numbering
d MMM yyyy HH:mm:ss 'GMT'
convert to minutes
Normalize cdate with the TimeZone in cdate first. This is
required for the compatible behavior.
If the default TimeZone has changed, then recalculate the
fields with the new TimeZone.
fastTime and the returned data are in sync upon return.
If the specified year can't be handled using a long value
in milliseconds, GregorianCalendar is used for full
compatibility with underflow and overflow. This is required
by some JCK tests. The limits are based max year values -
years that can be represented by max values of d, hh, mm,
ss and ms. Also, let GregorianCalendar handle the default
cutover year so that we don't need to worry about the
Perform the GregorianCalendar-style normalization.
In case the normalized date requires the other calendar
system, we need to recalculate it using the other one.
Quickly check if the time stamp given by `utc' is the Epoch
or later. If it's before 1970, we convert the cutover to
local time to compare.
End of file.
Legacy methods which first appeared in javax.swing.FocusManager.
Client code is most likely to invoke these methods.
Make sure that we delegate all new methods in KeyboardFocusManager
as well as the legacy methods from Swing. It is theoretically possible,
although unlikely, that a client app will treat this instance as a
new-style KeyboardFocusManager. We might as well be safe.
The JLS won't let us override the protected methods in
KeyboardFocusManager such that they invoke the corresponding methods on
the delegate. However, since client code would never be able to call
those methods anyways, we don't have to worry about that problem.
Will be null when invoked from supers constructor.
layout the text and icon
Paint the Icon
Draw the Text
draw the dashed focus line.
Use selected icon
dst array size
dst array size
1 or 2 leftover bytes
scan all bytes to fill out all non-alphabet. a performance
trade-off of pre-scan or Arrays.copyOf
pos of first byte of 4-byte atom
padding byte '='
=     shiftto==18 unnecessary padding
x=    shiftto==12 a dangling single x
x     to be handled together with non-padding case
xx=   shiftto==6&&sp==sl missing last =
xx=y  shiftto==6 last is not =
skip if for rfc2045
reached end of byte array or hit padding '=' characters.
dangling single "x", incorrectly encoded.
anything left is invalid, if is not MIME.
if MIME, ignore all non-base64 character
line separator, if needed
whether or not to pad
base64 -> byte mapping
24-bit buffer for decoding
-> 18, 12, 6, 0
-> 8, 0, -8 (no byte for output)
eof and no leftover
leftover output byte(s) in bits buf
treat ending xx/xxx without padding character legal.
same logic as v == '=' below
only one padding byte
no enough output space
shift to lowest byte
=     shiftto==18 unnecessary padding
x=    shiftto==12 dangling x, invalid unit
xx=   shiftto==6 && missing last '='
xx=y  or last is not '='
only one padding byte
no enough output space
shift to lowest byte
skip if for rfc2045
clear for next
don't clean "bits"
serialVersionUID is not constant
Serialization compatibility stuff:
Two serial forms are supported in this class. The selected form depends
on system property "jmx.serial.form":
- "1.0" for JMX 1.0
- any other value for JMX 1.1 and higher
Serial version for old serial form
Serial version for new serial form
Serializable fields in old serial form
Serializable fields in new serial form
Actual serial version and serial form
OK: exception means no compat with 1.0, too bad
END Serialization compatibility stuff
New serial form ignores extra field "sourceObjectName"
Serializes this instance in the old serial form
Serializes this instance in the new serial form
The following warnings are converted to strings when used
as keys to get localized resources from JPEGImageReaderResources
and its children.
The following is copied out from C after reading the header.
Unlike metadata, which may never be retrieved, we need this
if we are to read an image at all.
Number of passes
Read the first header
This reads the tables-only image twice, once from C
and once from Java, but only if ignoreMetadata is false
Now we are at the first image if there are any, so add it
to the list
Not tables only, so add original pos to the list
And set current image since we've read it now
Otherwise we have to read the entire stream
FALL THROUGH to decrement buffer vars
This first set doesn't have a length
not a marker, just a data 0xff
All the others have a length
length includes itself
Search is necessary for JPEG
read to start of image, saving positions
First seek to the last position we already have, and skip the
Now add all intervening positions, skipping images
Is there an image?
Otherwise we are where we want to be
No way is native buffer still valid
We hit the end of the stream before we hit an SOI, so no image
The buffer is clear after this, so no need to set haveSeeked.
verify new color space
/ Color Conversion and Image Types
Returns null if it can't be represented
We return an iterator containing the default, any
conversions that the library provides, and
all the other default types with the same number
of components, as we can do these as a post-process.
As we convert Rasters rather than images, images
with alpha cannot be converted in a post-process.
If this image can't be interpreted, this method
returns an empty Iterator.
Get the raw ITS, if there is one.  Note that this
won't always be the same as the default.
Given the encoded colorspace, build a list of ITS's
representing outputs you could handle starting
with the default.
Might be null if PYCC.pf not installed
Might be null if PYCC.pf not installed
As there is no YCbCr ColorSpace, we can't support
the raw type.
due to 4705399, use RGB as default in order to avoid
slowing down of drawing operations with result image.
Assume it's for RGB
Default is to convert to RGBA
As there is no YCbCr ColorSpace, we can't support
the raw type.
If we are rearranging channels at all, the default
conversions remain in place.  If the user wants
raw channels then he should do this while reading
Accept default conversions out of decoder, silently
XXX - We do not currently support any indexed color models,
though we could, as IJG will quantize for us.
This is a performance and memory-use issue, as
users can read RGB and then convert to indexed in Java.
Now check the ColorSpace type against outColorSpaceCode
We may want to tweak the default
Its gray in the file
We want RGB
IJG can do this for us more efficiently
Update java state according to changes
in the native part of decoder.
IJG wants to go to RGB
We want gray
If the jpeg space is YCbCr, IJG can do it
Update java state according to changes
in the native part of decoder.
We have an ICC profile but it isn't used in the dest
image.  So convert from the profile cs to the target cs
Leave IJG conversion in place; we still need it
Target isn't sRGB, so convert from sRGB to the target
No conversions available; image must be RGBA
We can't do YCC at all
No conversions available; image must be YCCA
We can't do YCC at all
Anything else we can't handle at all
/ End of Color Conversion & Image Types
imageMetadataIndex will always be either a valid index or
-1, in which case imageMetadata will not be null.
So we can leave checking imageIndex for gotoImage.
don't keep a reference here
Can we read this image?
The destination may still be incompatible.
Check whether we can handle any implied color conversion
Throws IIOException if the stream and the image are
incompatible, and sets convert if a java conversion
Check the source and destination bands in the param
Set the output color space equal to the input colorspace
This disables all conversions
Create an intermediate 1-line Raster that will hold the decoded,
subsampled, clipped, band-selected image data in a single
byte-interleaved buffer.  The above transformations
will occur in C for performance.  Every time this Raster
is filled we will call back to acceptPixels below to copy
this to whatever kind of buffer our image has.
ignore dest bands for Raster
Now that we have the Raster we'll decode to, get a view of the
target Raster that will permit a simple setRect for each scanline
Check for update listeners (don't call back if none)
Set up progression data
if we have a metadata object, we can count the scans
and set knownPassCount
We have metadata
Finally, we are ready to read
Note that getData disables acceleration on buffer, but it is
just a 1-line intermediate data transfer buffer that will not
affect the acceleration of the resulting image.
Use the range of allowed progressive passes
Assume there are a minimum of MIN_ESTIMATED_PASSES
and that there is always one more pass
Compute the percentage as the percentage at the end
of the previous pass, plus the percentage of this
pass scaled to be the percentage of the total remaining,
assuming a minimum of MIN_ESTIMATED_PASSES passes and
that there is always one more pass.  This is monotonic
and asymptotic to 1.0, which is what we need.
including this one
Provide access to protected superclass method
Provide access to protected superclass method
For Rasters, destination offset is logical, not physical, so
set it to 0 before calling computeRegions, so that the destination
region is not clipped.
Apply the destination offset, if any, as a logical offset
checks iis state for us
Now check the jfif segments
Now we know that there is a jfif segment
Now we know that there is a jfif segment
Now we know that there is a jfif segment and that iis is good
reset C structures
reset local Java structures
it looks like that this reader instance is used
by multiple threads.
whether to validate against facets
whether to do extra id/idref/entity checking
whether we need to normalize the value that is passed!
are namespaces relevant in this context?
get symbol from symbol table
-- This file was mechanically generated: Do not edit! --
For duplicates and slices
add new namespace context
search for new namespace bindings
when it's of form xmlns="..." or xmlns:prefix="...",
it's a namespace declaration. but prefix:xmlns="..." isn't.
get the internalized value of this attribute
1. "xmlns" can't be bound to any namespace
2. the namespace for "xmlns" can't be bound to any prefix
3. "xml" can't be bound to any other namespace than it's own
4. the namespace for "xml" can't be bound to any other prefix
Declare prefix in context. Removing the association between a prefix and a
namespace name is permitted in XML 1.1, so if the uri value is the empty string,
the prefix is being unbound. -- mrglavas
bind the element
bind the attributes
verify that duplicate attributes don't exist
Example: <foo xmlns:a='NS' xmlns:b='NS' a:attr='v1' b:attr='v2'/>
The attributes value (literate string).
this timer is used to cause repaint on animated components
30 repaints per second should give smooth animation affect
we need to dispose the controller on l&f change
idk: we can not handle tabs animation because
the same (component,part) is used to handle all the tabs
and we can not track the states
Vista theme might have transition duration for toolbar buttons
but native application does not seem to animate them
it seems for DEFAULTED button state Vista does animation from
Only button might have DEFAULTED state
idk: do not know how to get the value from Vista
one second seems plausible value
for scrollbar up, down, left and right button pictures are
defined by states.  It seems that theme has duration defined
only for up button states thus we doing this translation here.
animation is done for the component
animation duration in nanoseconds
animatin start time in nanoseconds
direction the alpha value is changing
forward  - from 0 to 1
!forward - from 1 to 0
if isForwardAndReverse the animation continually goes
forward and reverse. alpha value is changing from 0 to 1 then
from 1 to 0 and so forth
in case time was reset
Common UI methods
We don't need to paint empty strings
Metacity handles painting of text on internal frame title,
We don't need to paint empty strings
when drawing the focus, we need to expand that bounding
box by "focus-line-width" plus "focus-padding".  Note that
the layout process for these components will have already
taken these values into account, so there should always
be enough space allocated for drawing the focus indicator.
REMIND: This assumes the ordering: RGB[A]
REMIND: This assumes the ordering: RGB[A]
Check to see if it is all valid
Note that we adjust the mask so that our masking behavior here
is consistent with that of our native rendering loops.
Note that pixels are stored at lookupcache[2*i]
and the rgb that was searched is stored at
lookupcache[2*i+1].  Also, the pixel is first
inverted using the unary complement operator
before storing in the cache so it can never be 0.
IndexColorModel objects are all tagged as
non-premultiplied so ignore the alpha value
of the incoming color, convert the
non-premultiplied color components to a
grayscale value and search for the closest
gray value in the palette.  Since all colors
in the palette are gray, we only need compare
to one of the color components for a match
using a simple linear distance formula.
For allgrayopaque colormaps, entries are 0
iff they are an invalid color and should be
ignored during color searches.
IndexColorModel objects are all tagged as
non-premultiplied so ignore the alpha value
of the incoming color and search for closest
color match independently using a 3 component
Euclidean distance formula.
For opaque colormaps, palette entries are 0
iff they are an invalid color and should be
ignored during color searches.
As an optimization, exact color searches are
likely to be fairly common in opaque colormaps
so first we will do a quick search for an
Special case - transparent color maps to the
specified transparent pixel, if there is one
IndexColorModel objects are all tagged as
non-premultiplied so use non-premultiplied
color components in the distance calculations.
Look for closest match using a 4 component
Euclidean distance formula.
REMIND: Needs to change if different color space
Transfer type must be the same
Must call getInputStream before GetHeaderField gets called
so that FileNotFoundException has a chance to be thrown up
from here without being caught.
Must call getInputStream before GetHeaderField gets called
so that FileNotFoundException has a chance to be thrown up
from here without being caught.
make sure we canonicalize the class name: all lower case
If we can't read ahead safely, just give up on guessing
next two bytes are version number, currently 0x00 0x05
big and little (identical) endian UTF-8 encodings, with BOM
big and little endian UTF-16 encodings, with byte order mark
big and little endian UTF-32 encodings, with BOM
.au format, big endian
.au format, little endian
Mark the stream so we can reset it. 0x100 is enough for the first
few reads, but the mark will have to be reset and set again once
the offset to the root directory entry is computed. That offset
can be very large and isn't know until the stream has been read from
Get the byte ordering located at 0x1E. 0xFE is Intel,
0xFF is other
Reset back to the beginning
intel byte order
non-intel byte order
fill the passed in int array
check if EOF is reached
Allocate the array and copy the data reference
Need to alloc a new destination array
Apply one LUT to all channels
Need to alloc a new destination array
Apply one LUT to all channels
* Create a NodeSetDTM, and copy the members of the
* given nodelist into it.
* @param nodelist List of Nodes to be made members of the new set.
public NodeSetDTM(NodeList nodelist)
Do not reorder or strip duplicate nodes from the given DOM nodelist
no-op, I guess...  (-sb)
no action for right now.
* Copy NodeList members into this nodelist, adding in
* document order.  If a node is null, don't add it.
* @param nodelist List of nodes which should now be referenced by
* this NodeSetDTM.
* @throws RuntimeException thrown if this NodeSetDTM is not of
* a mutable type.
public void addNodes(NodeList nodelist)
if (null != nodelist)   defensive to fix a bug that Sanjiva reported.
for (int i = 0; i < nChildren; i++)
if (null != obj)
* <p>Copy NodeList members into this nodelist, adding in
* nulls appearing in the source NodeSetDTM will
* not be added to this one. </p>
* <p> In case you're wondering why this function is needed: NodeSetDTM
* implements both DTMIterator and NodeList. If this method isn't
* provided, Java can't decide which of those to use when addNodes()
* is invoked. Providing the more-explicit match avoids that
* @param ns NodeSetDTM whose members should be merged into this NodeSetDTM.
* @throws RuntimeException thrown if this NodeSetDTM is not of
* a mutable type.
public void addNodes(NodeSetDTM ns)
defensive to fix a bug that Sanjiva reported.
* Copy NodeList members into this nodelist, adding in
* document order.  If a node is null, don't add it.
* @param nodelist List of nodes to be added
* @param support The XPath runtime context.
* @throws RuntimeException thrown if this NodeSetDTM is not of
* a mutable type.
public void addNodesInDocOrder(NodeList nodelist, XPathContext support)
for (int i = 0; i < nChildren; i++)
if (null != node)
* Add the node list to this node set in document order.
* @param start index.
* @param end index.
* @param testIndex index.
* @param nodelist The nodelist to add.
* @param support The XPath runtime context.
* @return false always.
* @throws RuntimeException thrown if this NodeSetDTM is not of
* a mutable type.
private boolean addNodesInDocOrder(int start, int end, int testIndex,
NodeList nodelist, XPathContext support)
for (i = end; i >= start; i--)
if (child == node)
i = -2;   Duplicate, suppress insert
if (!support.getDOMHelper().isNodeAfter(node, child))
if (testIndex > 0)
boolean foundPrev = addNodesInDocOrder(0, i, testIndex, nodelist,
if (i == -1)
This needs to do a binary search, but a binary search
is somewhat tough because the sequence test involves
Duplicate, suppress insert
end addNodeInDocOrder(Vector v, Object obj)
end addNodeInDocOrder(Vector v, Object obj)
because nextNode always increments
But watch out for copy29, where the root iterator didn't
have nextNode called on it.
HACK: I think this is a bit of a hack.  -sb
Note that this repository ID must reflect the implementation
of the abstract valuetype (that is, this class), not the
repository ID of the org.omg.PortableInterceptor.ObjectReferenceFactory
class.  This allows for multiple independent implementations
of the abstract valuetype, should that become necessary.
check that values are in the proper range and progress
in increasing order from 0 to 1
We have to deal with the cases where the first gradient stop is not
equal to 0 and/or the last gradient stop is not equal to 1.
In both cases, create a new point and replicate the previous
extreme point's color.
first stop is not equal to zero, fix this condition
last stop is not equal to one, fix this condition
copy some flags
copy the gradient transform
Listeners that are attached to the JTable
The column header over which the mouse currently is.
The column that should be highlighted when the table header has the focus.
Read ONLY via getSelectedColumnIndex!
First find which header cell was hit
The last 3 pixels + 3 pixels of next column are for resizing
Cache the selected column.
Now do the move.
Update the selected index.
Protected & Private Methods
Factory methods for the Listeners
The installation/uninstall procedures and support
Support for mouse rollover
Support for keyboard and mouse access
Test whether the header is in a scroll pane and has a table.
Now scroll, if necessary.
Paint Methods and support
This should never happen.
If the table does not have enough columns to fill the view we'll get -1.
Replace this with the index of the last column.
Paint the dragged column if we are dragging.
Draw a gray well in place of the moving column.
Fill the background.
Remove all components in the rendererPane.
Configuring the header renderer to calculate its preferred size
is expensive. Optimise this by assuming the default renderer
always has the same height as the first non-zero height that
it returns for a non-null/non-empty value.
None of the callers include the intercell spacing, do it here.
we'd do the move if asked
End of Class BasicTableHeaderUI
Remove values from the parent's Client Properties.
Some places assume margins are non-null.
Refetch the appropriate check indicator for the current state
couldn't create a component... fall through to the
couldn't load representation.
PENDING(prinz) get some artwork and return something
quit for now
found a property parameter
read-only property. ignore
zero or more than one argument, ignore
Decrement count; signal when transition to zero
Bits not (yet) exposed in the public API either because they
have different meanings for fields and methods and there is no
way to distinguish between the two in this class, or because
they are not Java programming language keywords
Note on the FOO_MODIFIERS fields and fooModifiers() methods:
the sets of modifiers are not guaranteed to be constants
across time and Java SE releases. Therefore, it would not be
appropriate to expose an external interface to this information
that would allow the values to be treated as Java-level
constants since the values could be constant folded and updates
to the sets of modifiers missed. Thus, the fooModifiers()
methods return an unchanging values for a given release, but a
value that can potentially change over time.
can't render I guess
we don't allow instantiation
EntityResolver2.java - Extended SAX entity resolver.
No warranty; no copyright -- use this as you will.
$Id: EntityResolver2.java,v 1.2 2004/11/03 22:49:08 jsuttor Exp $
Note: classNames is guaranteed by the constructor to be non-null.
TODO: resurrect this once we introduce external annotations
* Obtain a new instance of a <tt>JAXBContext</tt> class.
* The client application must supply a list of classes that the new
* context object needs to recognize.
* Not only the new context will recognize all the classes specified,
* but it will also recognize any classes that are directly/indirectly
* referenced statically from the specified classes.
* For example, in the following Java code, if you do
* will recognize both <tt>Foo</tt> and <tt>Bar</tt>, but not <tt>Zot</tt>:
* Therefore, a typical client application only needs to specify the
* top-level classes, but it needs to be careful.
* TODO: if we are to define other mechanisms, refer to them.
* @param externalBindings
*      list of external binding files. Can be null or empty if none is used.
*      when specified, those files determine how the classes are bound.
* @param classesToBeBound
*      spec-defined classes will be returned.
*      A new instance of a <tt>JAXBContext</tt>. Always non-null valid object.
* @throws JAXBException
*      if an error was encountered while creating the
*      <tt>JAXBContext</tt>, such as (but not limited to):
*  <li>No JAXB implementation was discovered
*  <li>Classes use JAXB annotations incorrectly
*  <li>Classes have colliding annotations (i.e., two classes with the same type name)
*  <li>Specified external bindings are incorrect
*  <li>The JAXB implementation was unable to locate
*      provider-specific out-of-band information (such as additional
*      files generated at the development time.)
* @throws IllegalArgumentException
* @since JAXB2.0
public static JAXBContext newInstance( Source[] externalBindings, Class... classesToBeBound )
empty class list is not an error, because the context will still include
spec-specified classes like String and Integer.
but it is an error to have nulls in it.
for( int i=classesToBeBound.length-1; i>=0; i-- )
but it is an error to have nulls in it.
to make JAXB 1.0 implementations work, this method must not be
to make JAXB 1.0 implementations work, this method must not be
to make JAXB 1.0 implementations work, this method must not be
We do the counter wrap in a lazt way. Each time Engine is asked for his time it checks. So if nobody use the Engine, the time can wrap and wrap again without incrementing nb boot. We can imagine that it is irrelevant due to the amount of time needed to wrap.
67 years of running. That is a great thing!
Can't do anything with this counter.
Store for future use.
Do some check and store the nb boots value.
Initialize internal status.
Initialize the engineID.
Set the background and foreground to the combobox colors.
Paint the button as usual
Paint the icon
Paint the focus
With Ocean the button only paints the arrow, bail.
Let the renderer paint
Fix for 4238829: should lay out the JPanel.
End of file.
-- This file was mechanically generated: Do not edit! --
Static data cache
create new array
create new array
create new array
create new array
add more if necessary.
This function ensures that hashCodes that differ only by
constant multiples at each bit position have a bounded
number of collisions (approximately 8 at default load factor).
stale entries may be in use by a HashIterator
clear out ref queue. We don't need to expunge entries
since table is getting cleared.
Allocation of array may have caused GC, which may have caused
additional entries to go stale.  Removing these entries from the
reference queue will make them eligible for reclamation.
hold on to key in strong ref
current index, modified on advance/split
-1 until first use; then one past last index
for comodification checks
initialize fence and size on first use
Ignore the security exception, try the next provider
CatalogEntry.java - Represents Catalog entries
%REVIEW% Since this is (should be) always equal
to the length of m_extendedTypes, do we need this?
These are all the types prerotated, for caller convenience.
Calculate the hash code
Redefine the hashET object to represent the new expanded name.
Calculate the index into the HashEntry table.
Look up the expanded name in the hash table. Return the id if
the expanded name is already in the hash table.
Expand the internal HashEntry array if necessary.
Create a new ExtendedType object
Expand the m_extendedTypes array if necessary.
Create a new hash entry for the new ExtendedType and put it into
Increase array size by only 1 at a time.  Fix this
if it looks to be a problem.
For the moment, I'm going to first create a full UnionPathIterator, and
then see if I can reduce it to a UnionChildIterator.  It would obviously
be more effecient to just test for the conditions for a UnionChildIterator,
and then create that directly.
check for positional predicates or position function, which won't work.
I could strip the lpi down to a pure PredicatedNodeTest, but
I don't think it's worth it.  Note that the test can be used
as a static object... so it doesn't have to be cloned.
TODO: Handle unwrapped FilterExpr
Have to check for unwrapped functions, which the LocPathIterator
Loop through the iterators getting the current fetched
node, and get the earliest occuring in document order
Found a duplicate, so skip past it.
Could be smarter.
Yuck.  Need FilterExprIter.  Or make it so m_exprs can be just
By default, MBeanServerInterceptors are disabled.
Use com.sun.jmx.mbeanserver.MBeanServerBuilder to obtain
MBeanServers on which MBeanServerInterceptors are enabled.
Type-specific CORBA::Object operations
REVISIT - return type
End of file.
if an XNIException is thrown, just let it go.
REVISIT: is this OK? or should we try to wrap it into SAXException?
Internal constants used in the implementation
A more flexible implementation would consult a ResourceBundle
to find the appropriate orientation.  Until pluggable locales
are introduced however, the flexiblity isn't really needed.
So we choose efficiency instead.
-- This file was mechanically generated: Do not edit! --
Cached unsafe-access object
Cached array base offset
Cached unaligned-access capability
Base address, used in all indexing calculations
NOTE: moved up to Buffer.java for speed in JNI GetDirectBufferAddress
An object attached to this buffer. If this buffer is a view of another
buffer then we use this field to keep a reference to that buffer to
ensure that its memory isn't freed before we are done with it.
For duplicates and slices
non-private to simplify nested class access
non-private to simplify nested class access
Note: This restriction of at least one is not actually needed,
but continues for 1.5 compatibility
If c.toArray incorrectly doesn't return Object[], copy it.
Double size if small; else grow by 50%
Make a new array of a's runtime type, but my contents:
removed last element
loop while a non-leaf
assume left child is least
Write out element count, and any hidden stuff
Write out array length, for compatibility with 1.5 version
Write out all elements in the "proper order".
Read in size, and any hidden stuff
Read in (and discard) array length
Read in all elements.
Elements are guaranteed to be in "proper order", but the
spec has never explained what that might be.
current index, modified on advance/split
-1 until first use
initialized when fence set
initialize fence to size on first use
hoist accesses and checks from loop
must be CME
make Global NamespaceContextWrapper object,  fScanner.getNamespaceContext() is dynamic object and ita value changes
as per the state of the parser.
publicId, systemid, baseSystemId, inputStream, enocding
pass the input source to document scanner impl.
publicId, systemid, baseSystemId, inputStream, enocding
pass the input source to document scanner impl.
publicId, systemid, baseSystemId, inputStream, enocding
pass the input source to document scanner impl.
publicId, systemid, baseSystemId, inputStream, enocding
xxx: Using buffered reader
pass the input source to document scanner impl.
pass the input source to document scanner impl.
once setInputSource() is called this instance is busy parsing the inputsource supplied
this instances is free for reuse if parser has reached END_DOCUMENT state or application has
XMLStreamReader should be in defined state
Issue 56 XNIException not caught
set Stax internal properties -- Note that these instances are being created in XMLReaderImpl.
4. call reset()
when parsing begins, fReuse is set to false
fReuse is set to 'true' when application calls close()
reset entity manager
reset the scanner
REVISIT:this is too ugly -- we are getting XMLEntityManager and XMLEntityReader from
property manager, it should be only XMLEntityManager
default value for this property is true. However, this should be false when using XMLEventReader... Ugh..
because XMLEventReader should not have defined state.
xxx: Check what this function is intended to do.
xxx check whats the value of fCurrentElement
doesn't take care of Attribute as separte event
apply SAP's patch: the default version in the scanner was set to 1.0 because of DOM and SAX
so this patch is a workaround of the difference between StAX and DOM
SAPJVM: Return null if the XML version has not been declared (as specified in the JavaDoc).
the scanner returns -1 when it detects a broken stream
we can check in scanners if the scanner state is not set to
terminating, we still have more events.
if this error occured trying to resolve the external DTD subset
and IS_VALIDATING == false, then this is not an XML error
ignore the error, set scanner to known state
else real error
get the new scanner state to old scanner's previous state
xxx: recognize SAX properties namespace, namespace-prefix to get XML Namespace declarations
does length includes namespace declarations ?
State should be either START_ELEMENT or ATTRIBUTE
State should be either START_ELEMENT or ATTRIBUTE
State should be either START_ELEMENT or ATTRIBUTE
State should be either START_ELEMENT or ATTRIBUTE
State should be either START_ELEMENT or ATTRIBUTE
State should be either START_ELEMENT or ATTRIBUTE
create new object at runtime..
State should be either START_ELEMENT or ATTRIBUTE
State should be either START_ELEMENT or ATTRIBUTE
State should be either START_ELEMENT or ATTRIBUTE
sjsxp issue 70
namespaceContext is dynamic object.
REVISIT: check if it specifies all conditions mentioned in the javadoc
namespaceContext is dynamic object.
namespaceContext is dynamic object.
this requires creation of new string
fEventType == XMLEvent.ENTITY_REFERENCE
getTextStart() + sourceStart should not be greater than the lenght of number of characters
check that current state should be either START_ELEMENT or ATTRIBUTE
xxx: it requires if the standalone was set in the document ? This is different that if the document
xxx: prefix definition ?
first add the string to symbol table.. since internally identity comparisons are done.
xxx: this function is not being used.
REVISIT: we were supplying hashmap ealier
Need to add constant
The new table is used when generic types are about...
J5TODO: Needs some testing !
Table of local
<init>(MessageFormatter, Locale, String, String, Object[])
The references to the message formatter and locale
aren't needed anymore so null them.
These are only valid if hasBaseline is true and are indexed by
Internal helper methods
removing front item; just advance
an "interior" remove
slide over all others up through putIndex.
Lock only for visibility, not mutual exclusion
null when queue is empty
this doc comment is overridden to remove the reference to collections
greater in size than Integer.MAX_VALUE
this doc comment is a modified copy of the inherited doc comment,
without the reference to unlimited queues.
Restore invariants even if c.add() threw
to limit search to one full sweep
found a discarded/exhausted iterator
We've run out of iterators to track; retire
no more iterators to track
no more iterators to track
in this order
how far takeIndex has advanced since the previous
operation of this iterator
Check indices for invalidation
Switch to detached mode
try to unlink from itrs (but not too hard)
might update lastRet
might update lastRet or detach
else lastRet == REMOVED and the last returned element was
previously asynchronously removed via an operation other
than this.remove(), so nothing to do.
Don't set nextItem to null because we must continue to be
able to return it on next().
Caller will unlink from itrs when convenient.
All the elements that existed at the time of the last
operation are gone, so abandon further iteration.
/** Uncomment for debugging. */
return ("cursor=" + cursor + " " +
"nextIndex=" + nextIndex + " " +
"lastRet=" + lastRet + " " +
"nextItem=" + nextItem + " " +
"lastItem=" + lastItem + " " +
"prevCycles=" + prevCycles + " " +
"prevTakeIndex=" + prevTakeIndex + " " +
"size()=" + size() + " " +
table of all instances in this class, used by readResolve
Serialization compatibility with Java 2 platform v1.2.
1.2 will throw an InvalidObjectException if ever asked to
This shouldn't happen in real life.
For use with Font.
Adornments added to text.
Attributes use to control layout of text on a line.
For use by input method.
REMIND: Once 6277756 is fixed, we should do a bulk write of all 8
bytes here as we do in writeShort() and writeInt() for even better
performance.  For now, two bulk writes of 4 bytes each is still
faster than 8 individual write() calls (see 6347575 for details).
Fix 4430357 - if off + len < 0, overflow occurred
Fix 4430357 - if off + len < 0, overflow occurred
Fix 4430357 - if off + len < 0, overflow occurred
Fix 4430357 - if off + len < 0, overflow occurred
Fix 4430357 - if off + len < 0, overflow occurred
Fix 4430357 - if off + len < 0, overflow occurred
Prologue: deal with pre-existing bits
Bug 4499158, 4507868 - if we're at the beginning of the stream
and the bit offset is 0, there can't be any pre-existing bits
read() will reset bitOffset
Notch out the partial byte and drop in the new bits
Clear out old bits
Or in new ones
Signal that we are done
Fill out the partial byte and reduce numBits
Clear out bits
Note that bitOffset is already 0, so there is no risk
of this advancing to the next byte
Now write any whole bytes
Epilogue: write out remaining partial byte, if any
Note that we may be at EOF, in which case we pad with 0,
or not, in which case we must preserve the existing bits
If we are not at the end of the file, read the current byte
If we are at the end of the file, initialize our byte to 0.
Fix 4494976: writeBit(int) does not pad the remainder
of the current byte with 0s
bitOffset is always already 0 when we get here.
Sets bitOffset to 0
Fix 4465683: When bitOffset is set
to something non-zero beyond EOF,
we should set that whole byte to
zero and write it to stream.
controls the usage of the MenuItem.disabledAreNavigable UIDefaults
property in the setArmed() method
unarm and unpress, just in case
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
if (changeEvent == null)
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
if (changeEvent == null)
end of line
Check if the subject delegation permission allows the
authenticated subject to assume the identity of each
principal in the delegated subject
* Change the value that was most recently associated with the given key
* in a <code>push</code> operation not cancelled by a subsequent
* <code>restore</code>.  If there is no such association, nothing happens
* and the return value is null.
* @param key the key of interest.
* @param value the new value to associate with that key.
* @return the value that was previously associated with the key, or null
* if the key does not exist in the stack.
* @exception IllegalArgumentException if <code>key</code> is null.
public static Object set(String key, Object value)
if (context == null)
Can't use getMostRecentEventTimeForSource because source is always null during deserialization
throw the IllegalArgumentException to conform to EventObject spec
Will throw CCE when we try to sort if T is not Comparable
If the input is already naturally sorted and this operation
also naturally sorted then this is a no-op
If the input is already naturally sorted and this operation
naturally sorts then collect the output
Store away our index and pools in members
this is for Schema Mixed Content
Ok, so lets grind through the building of the DFA. This method
handles the high level logic of the algorithm, but it uses a
number of helper classes to do its thing.
In order to avoid having hundreds of references to the error and
string handlers around, this guy and all of his helper classes
just throw a simple exception and we then pass it along.
A DFA content model must *always* have at least 1 child
so a failure is given if no children present.
Defect 782: This is an incorrect statement because a DFA
content model is also used for constructions such as:
where a perfectly valid content would be NO CHILDREN.
Therefore, if there are no children, we must check to
see if the CMNODE_EOC marker is a valid start state! -Ac
if child count == 0
Lets loop through the children in the array and move our way
through the states. Note that we use the fElemMap array to map
an element index to a state index.
Get the current element index out
ignore mixed text
Look up this child in our element map
If we didn't find it, then obviously not valid
Look up the next state for this input symbol when in the
If its not a legal transition, then invalid
We transitioned all the way through the input list. However, that
does not mean that we ended in a final state. So check whether
our ending state is a final state.
The first step we need to take is to rewrite the content model
using our CMNode objects, and in the process get rid of any
repetition short cuts, converting them into '*' style repetitions
or getting rid of repetitions altogether.
The conversions done are:
x+ -> (x|x*)
x? -> (x|epsilon)
This is a relatively complex scenario. What is happening is that
we create a top level binary node of which the special EOC value
is set as the right side node. The the left side is set to the
rewritten syntax tree. The source is the original content model
info from the decl pool. The rewrite is done by buildSyntaxTree()
which recurses the decl pool's content of the element and builds
a new tree in the process.
Note that, during this operation, we set each non-epsilon leaf
node's DFA state position and count the number of such leafs, which
is left in the fLeafCount member.
The nodeTmp object is passed in just as a temp node to use during
the recursion. Otherwise, we'd have to create a new node on every
level of recursion, which would be piggy in Java (as is everything
for that matter.)
And handle specially the EOC node, which also must be numbered
and counted as a non-epsilon leaf node. It could not be handled
in the above tree build because it was created before all that
started. We save the EOC position since its used during the DFA
Ok, so now we have to iterate the new tree and do a little more
work now that we know the leaf count. One thing we need to do is
to calculate the first and last position sets of each node. This
is cached away in each of the nodes.
Along the way we also set the leaf count in each node as the
maximum state count. They must know this in order to create their
first/last pos sets.
We also need to build an array of references to the non-epsilon
leaf nodes. Since we iterate it in the same way as before, this
will put them in the array according to their position values.
And, moving onward... We now need to build the follow position
sets for all the nodes. So we allocate an array of state sets,
one for each leaf node (i.e. each DFA position.)
And finally the big push... Now we build the DFA using all the
states and the tree we've built up. First we set up the various
data structures we are going to use while we do this.
First of all we need an array of unique element names in our
content model. For each transition table entry, we need a set of
contiguous indices to represent the transitions for a particular
input element. So we need to a zero based range of indexes that
map to element types. This element map provides that mapping.
Get the current leaf's element index
See if the current leaf node's element index is in the list
If it was not in the list, then add it, if not the EOC node
set up the fLeafNameTypeVector object if there is one.
Next lets create some arrays, some that that hold transient
information during the DFA build and some that are permament.
These are kind of sticky since we cannot know how big they will
get, but we don't want to use any Java collections because of
Basically they will probably be about fLeafCount*2 on average,
but can be as large as 2^(fLeafCount*2), worst case. So we start
with fLeafCount*4 as a middle ground. This will be very unlikely
to ever have to expand, though it if does, the overhead will be
Ok we start with the initial set as the first pos set of the
head node (which is the seq node that holds the content model
and the EOC node.)
Init our two state flags. Basically the unmarked state counter
is always chasing the current state counter. When it catches up,
that means we made a pass through that did not add any new states
to the lists, at which time we are done. We could have used a
expanding array of flags which we used to mark off states as we
complete them, but this is easier though less readable maybe.
Init the first transition table entry, and put the initial state
into the states to do list, then bump the current state.
Ok, almost done with the algorithm... We now enter the
loop where we go until the states done counter catches up with
the states to do counter.
Get the first unmarked state out of the list of states to do.
And get the associated transition table entry.
Mark this one final if it contains the EOC state
Bump up the unmarked state count, marking this state done
Loop through each possible input symbol in the element map
Build up a set of states which is the union of all of
the follow sets of DFA positions that are in the current
state. If we gave away the new set last time through then
create a new one. Otherwise, zero out the existing one.
If this leaf index (DFA position) is in the current set...
If this leaf is the current input symbol, then we
want to add its follow list to the set of states to
transition to from the current state.
If this new set is not empty, then see if its in the list
of states to do. If not, then add it.
Search the 'states to do' list to see if this new
state set is already in there.
If we did not find it, then add it
Put this new state into the states to do and init
a new entry at the same index in the transition
We now have a new state to do so bump the count
Null out the new set to indicate we adopted it.
This will cause the creation of a new set on the
next time around the loop.
Now set this state in the transition table's entry
for this element (using its index), with the DFA
state we will move to from the current state when we
see this input element.
Expand the arrays if we're full
Yikes, we overflowed the initial array size, so
we've got to expand all of these arrays. So adjust
up the size by 50% and allocate new arrays.
Copy over all of the existing content
Store the new array size
Check to see if we can set the fEmptyContentIsValid flag.
And now we can say bye bye to the temp representation since we've
built the DFA.
Recurse as required
Now handle our level. We use our left child's last pos
set and our right child's first pos set, so go ahead and
get them ahead of time.
Now, for every position which is in our left child's last set
add all of the states in our right child's first set to the
follow set for that position.
Now handle our level. We use our own first and last position
sets, so get them up front.
For every position which is in our last position set, add all
of our first position states to the follow set for that
Set the maximum states on this node
Recurse as required
REVISIT: Don't waste these structures.
Put this node in the leaf list at the current index if its
a non-epsilon leaf.
-- This file was mechanically generated: Do not edit! --
-- This file was mechanically generated: Do not edit! --
Node name, followed by description
Node name + "/" + AttributeName, followed by description
construct an ENTITY datatype validator
Not that it matters, but there is some variation across
standard sources about value at msec precision.
The value used is the same as in java.util.GregorianCalendar
XREVISIT - is this used?
REVISIT - hashCode(org.omg.CORBA.Object self)
For use by "sticky manager" if one is registered.
Only do local.  The APP Server interceptors check
effectiveTarget.isLocal - which is determined via
the IOR - so if we added other addresses then
transactions and interceptors would not execute.
XREVISIT - See Base Line 62
XXX Note that this always uses the first IIOP profile to get the
scid.  What about multi-profile IORs?  This should perhaps be
tied to the current ContactInfo in some way, together with an
implementation of ClientDelegate that generally prefers co-located
ContactInfo.  This may in fact mean that we should do this at
the ContactInfo level, rather than the IOR/profile level.
End of file.
Overridden to ensure we don't paint icon over button borders.
focus painting is handled by the border
this method should never be called: XSSimpleTypeDecl is responsible for
calling the member types for the convertion
Patch attributed to Gary L Peskin <garyp@firstech.com>
Patch attributed to Gary L Peskin <garyp@firstech.com>
Annoyingly, AxisIterators do not currently implement DTMIterator, so
we can't just wap DTMNodeList around an Axis.CHILD iterator.
Instead, we've created a special-case operating mode for that object.
Attr's Next is defined at DTM level, but not at DOM level.
Note that this uses the DOM-compatable version of the call
More than one; ill-formed.
These are harmless; document is still wellformed
%OPT% This should do something smarter?
We really don't know which attributes might have come from the
source document versus from the DTD. Treat them all as having
been provided by the user.
%REVIEW% if/when we become aware of DTDs/schemae.
In XPath and DTM data models, unlike DOM, an Attr's parent is its
Could create a DTM... but why, when it'd have to be permanantly empty?
we don't have any alternate node, either this node does the job
or we don't have anything that does
RAMESH : Pending proper implementation of DOM Level 3
we don't have any alternate node, either this node does the job
or we don't have anything that does
in theory nodeName can't be null but better be careful
who knows what other implementations may be doing?...
REVISIT: is it possible that prefix is empty string?
looking for default namespace
non default namespace
at this point we are dealing with DOM Level 2 nodes only
non default namespace
type is unknown
REVISIT: When Namespaces 1.1 comes out this may not be true
Prefix can't be bound to null namespace
type is unknown
we do not use any wrapper so the answer is obvious
Old actions forward to an instance of this.
WARNING: Be careful with the bounds held by treeState. They are
always in terms of left-to-right. They get mapped to right-to-left
by the various methods of this class.
Following 4 ivars are only valid when editing.
Methods for configuring the behavior of the tree. None of them
push the value to the JTree instance. You should really only
call these methods on the JTree.
TreeState doesn't care about the x location, hence it isn't
Boilerplate install block
Data member initializations
Custom install code
Create, if necessary, the TreeState instance.
JTree's original row height is 16.  To correctly display the
contents on Linux we should have set it to 18, Windows 19 and
Solaris 20.  As these values vary so much it's too hard to
be backward compatable and try to update the row height, we're
therefor NOT going to adjust the row height based on font.  If the
developer changes the font, it's there responsibility to update
the row height.
default TransferHandler doesn't support drop
so we don't want drop handling
Should never happen if installed for a UI
Draw the lines, knobs, and rows
Find each parent and have them draw a line to their last child
Information for the node being rendered.
This will only happen if the model changes out
from under us (usually in another thread).
Swing isn't multithreaded, but I'll put this
check in anyway.
See if the vertical line to the parent has been drawn.
Empty out the renderer pane, allowing renderers to be gc'ed.
Don't paint the legs for the root'ish node if the
This shouldn't happen, but if the model is modified
in another thread it is possible for this to happen.
Swing isn't multithreaded, but I'll add this check in
Draw icons if not a leaf and either hasn't been loaded,
or the model child count is > 0.
Don't paint the renderer if editing this row.
Generic painting methods
Draws the icon centered at (x,y)
This method is slow -- revisit when Java2D is ready.
assumes x1 <= x2
Drawing only even coordinates helps join line segments so they
appear as one line.  This can be defeated by translating the
Graphics by an odd amount.
This method is slow -- revisit when Java2D is ready.
assumes y1 <= y2
Drawing only even coordinates helps join line segments so they
appear as one line.  This can be defeated by translating the
Graphics by an odd amount.
Various local methods
Only do this if necessary, may loss state if call with
same model as it currently has.
Create a listener to update preferred size when bounds
changes, if necessary.
The tree doesn't have a valid bounds yet. Calculate
based on visible row count.
we should consider a non-visible area above
cover method for startEditing that allows us to pass extra
information into that method via a class variable
Only allow odd heights if explicitly set.
Editor wants different width or height, invalidate
treeState and relayout.
To make sure x/y are updated correctly, fetch
the bounds again.
We really want similar behavior to getMouseEventTarget,
but it is package private.
Following are primarily for handling mouse events.
Should this event toggle the selection of this row?
Have to return something here...
The following selection methods (lead/anchor) are covers for the
methods in JTree.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
Try the horizontal scrollbar.
End of BasicTreeUI.ComponentHandler
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
End of BasicTreeUI.TreeModelHandler
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
End of BasicTreeUI.TreeSelectionHandler
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
Also note these fields aren't use anymore, nor does Handler have
the old functionality. This behavior worked around an old bug
in JComponent that has long since been fixed.
End of BasicTreeUI.KeyHandler
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
End of class BasicTreeUI.FocusHandler
This returns locations that don't include any Insets.
Return size of editing component, if editing and asking
for editing row.
Not editing, use renderer.
Only ever removed when UI changes, this is OK!
End of class BasicTreeUI.NodeDimensionsHandler
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
End of BasicTreeUI.MouseHandler
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
End of BasicTreeUI.PropertyChangeHandler
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
End of BasicTreeUI.SelectionModelPropertyChangeHandler
End of class BasicTreeUI.TreeIncrementAction
End of class BasicTreeUI.TreeHomeAction
End of class BasicTreeUI.TreeToggleAction
End of class BasicTreeUI.TreeCancelEditingAction
End of class BasicTreeUI.MouseInputHandler
remove the last newline
sort the paths to display order rather than selection order
handle first letter navigation
Subsequent same key presses move the keyboard focus to the next
object that starts with the same letter.
Whether or not the mouse press (which is being considered as part
of a drag sequence) also caused the selection change to be fully
Set to true when a drag gesture has been fully recognized and DnD
begins. Use this to ignore further mouse events which could be
delivered if DnD is cancelled (via ESCAPE for example)
The path over which the press occurred and the press event itself
Used to detect whether the press event causes a selection change.
If it does, we won't try to start editing on the release.
if we can't stop any ongoing editing, do nothing
if we have a valid path and this is a drag initiating event
do nothing for control - will be handled on release
or when drag starts
clicking on something that's already selected
and need to make it the lead now
could be a drag initiating event - don't grab focus
Preferably checkForClickInExpandControl could take
the Event to do this it self!
Perhaps they clicked the cell itself. If so,
Note: We don't give the tree a chance to start editing if the
mouse press caused a selection change. Otherwise the default
tree cell editor will start editing on EVERY press and
release. If it turns out that this affects some editors, we
can always parameterize this with a client property. ex:
if (pressedPath != null &&
(Boolean.TRUE == tree.getClientProperty("Tree.DnD.canEditOnValueChange") ||
!valueChangedOnPress) && ...
Make sure all the paths are visible, if necessary.
PENDING: This should be tweaked when isAdjusting is added
Indicates this path isn't valid anymore,
we shouldn't attempt to expand it then.
The root has changed
Changed nodes are visible
Find the minimum index, we only need paint from there
Forward to the treestate
Mark preferred size as bogus.
Nodes that changed aren't visible.  No need to paint
PENDING(sky): Need a method in TreeModelEvent
that can return the count, getChildIndices allocs
a new array!
add the lead item to the selection without changing lead or anchor
toggle the selected state of the lead item and move the anchor to it
extend the selection to the lead item
move the anchor to the lead and ensure only that item is selected
disable moving of lead unless in discontiguous mode
disable moving of lead unless in discontiguous mode
disable moving of lead unless in discontiguous mode
disable moving of lead unless in discontiguous mode
End of class BasicTreeUI
non-volatile, protected by state reads/writes
ensure visibility of callable
ensure visibility of callable
in case call to interrupt throws exception
runner must be non-null until state is settled to
prevent concurrent calls to run()
state must be re-read after nulling runner to prevent
don't set result
runner must be non-null until state is settled to
prevent concurrent calls to run()
state must be re-read after nulling runner to prevent
It is possible for our interrupter to stall before getting a
chance to interrupt us.  Let's spin-wait patiently.
wait out pending interrupt
We want to clear any interrupt we may have received from
cancel(true).  However, it is permissible to use interrupts
as an independent mechanism for a task to communicate with
its caller, and there is no way to clear only the
unlink to help gc
to reduce footprint
cannot time out yet
restart on removeWaiter race
check for race
Fixing this raw Class type correctly in 2.2 API. This shouldn't cause
any compatibility issues for applications.
This is the container object for the servant.
In the RMI-IIOP case, it is the RMI-IIOP Tie, and the servant is the
target of the Tie.
In all other cases, it is the same as the Servant.
These fields are to support standard OMG APIs.
These fields are to support the Object adapter implementation.
This is the copier to be used by javax.rmi.CORBA.Util.copyObject(s)
For the current request.
Copy constructor of sorts; used in local optimization path
Create CookieHolder on demand.  This is only called by a single
thread, so no synchronization is needed.
Implemented only for type checking.
the Indexed readMethod was explicitly set to null.
no "is" method, so look for a "get" method.
the indexed property type is set by the reader.
the Indexed writeMethod was explicitly set to null.
We need the indexed type to ensure that we get the correct method.
Cannot use the getIndexedPropertyType method since that could
result in an infinite loop.
Set iprop type to be the classic type
If the indexed property type has not been set, then set it.
Private methods which set get/set the Reference objects
Note: This would be identical to PropertyDescriptor but they don't
share the same fields.
Should not happen
Should not happen
Copyright (c) 1995-96 by Cisco Systems, Inc.
For security and performance reasons we don't call getHostName here
Use getDevName() explicitly when necessary.
to do later.
Suppresses default constructor, ensuring non-instantiability.
Approach for parallel implementation:
- Decompose as per usual
- run match on leaf chunks, call result "b"
- if b == matchKind.shortCircuitOn, complete early and return b
- else if we complete normally, return !shortCircuitOn
name of the complexType
target namespace of the complexType
base type of the complexType
derivation method of the complexType
final set of the complexType
block set (prohibited substitution) of the complexType
whether it's an anonymous tpye
the attribute group that holds the attribute uses and attribute wildcard
the content type of the complexType
if the content type is simple, then the corresponding simpleType
if the content type is element or mixed, the particle
if there is a particle, the content model corresponding to that particle
the content model that's sufficient for computing UPA
list of annotations affiliated with this type
The namespace schema information item corresponding to the target namespace
of the complex type definition, if it is globally declared; or null otherwise.
DOM Level 3 TypeInfo Derivation Method constants
do-nothing constructor for now.
flags for the misc flag
methods to get/set misc flag
for complex type with empty or simple content,
there is no content model validator
some utility methods:
return the attribute group for this complex type
ancestor is null, retur false
ancestor is anyType, return true
recursively get base, and compare it with ancestor
compare with ancestor
ancestor is null, retur false
ancestor is anyType, return true
recursively get base, and compare it with ancestor
compare with ancestor
ancestor is null, retur false
ancestor is anyType, return true
list or union
If the value of the parameter is 0 i.e. no bit (corresponding to
restriction, list, extension or union) is set to 1 for the
If the ancestor type is reached or is the same as this type.
Check if this type is derived from the base by restriction or
ancestor is anySimpleType, return false
if the name and namespace of this type is the same as the
ancestor return true
If the base type is a complexType with simpleContent
If the base type is a complex type
Every derivation step till the base type should be
restriction. If not return false
If ancestor is anySimpleType return false.
returns true if atleast one derivation step was extension
If the base type is a complexType with simpleContent
derivationMethod extension will always return false for a
we treat it like a restriction
If the base type is a complex type
At least one derivation step upto the ancestor type should be
reset attribute group
help out the garbage collector
This next three instanceofs are a little worrysome, since a NodeList
might also implement a Node!
This must come after org.w3c.dom.Node, since many Node implementations
also implement NodeList.
The point is colinear, classify based on which side of
the segment the point falls on.  We can calculate a
relative value using the projection of px,py onto the
segment - a negative value indicates the point projects
outside of the segment in the direction of the particular
endpoint used as the origin for the projection.
Reverse the projection to be relative to the original x2,y2
x2 and y2 are simply negated.
px and py need to have (x2 - x1) or (y2 - y1) subtracted
from them (based on the original values)
Since we really want to get a positive answer when the
point is "beyond (x2,y2)", then we want to calculate
the inverse anyway - thus we leave x2 & y2 negated.
Adjust vectors relative to x1,y1
x2,y2 becomes relative vector from x1,y1 to end of segment
px,py becomes relative vector from x1,y1 to test point
px,py is on the side of x1,y1 away from x2,y2
distance to segment is length of px,py vector
"length of its (clipped) projection" is now 0.0
switch to backwards vectors relative to x2,y2
x2,y2 are already the negative of x1,y1=>x2,y2
to get px,py to be the negative of px,py=>x2,y2
the dot product of two negated vectors is the same
as the dot product of the two normal vectors
px,py is on the side of x2,y2 away from x1,y1
distance to segment is length of (backwards) px,py vector
"length of its (clipped) projection" is now 0.0
px,py is between x1,y1 and x2,y2
dotprod is the length of the px,py vector
projected on the x2,y2=>x1,y1 vector times the
length of the x2,y2=>x1,y1 vector
Distance to line is now the length of the relative point
vector minus the length of its projection onto the line
(which is zero if the projection falls outside the range
of the line segment).
Adjust vectors relative to x1,y1
x2,y2 becomes relative vector from x1,y1 to end of segment
px,py becomes relative vector from x1,y1 to test point
dotprod is the length of the px,py vector
projected on the x1,y1=>x2,y2 vector times the
length of the x1,y1=>x2,y2 vector
Distance to line is now the length of the relative point
vector minus the length of its projection onto the line
this shouldn't happen, since we are Cloneable
add more if necessary.
Copyright (c) 1995-96 by Cisco Systems, Inc.
Returns the community string associated to the specified command.
private int               _retryPolicy ;   not implemented as yet.
should never be called
both methods have no args
Allocate state storage
Put fields into initial states
Reallocate state storage
If next search starts before region, start it at region
If next search starts beyond region then it fails
If no match, return error
Process substitution string to replace group references with groups
Skip past $
Throw IAE if this "$" is the last character in replacement
The first number is always a group
Capture the largest legal group string
not a number
Append the intervening text
Append the match substitution
wrap native call to allow instrumentation
Table of local
Fixed date of January 1, 1970 (Gregorian)
Useful millisecond constants.  Although ONE_DAY and ONE_WEEK can fit
into ints, they must be longs in order to prevent arithmetic overflow
when performing (bug 4173516).
Reference to the sun.util.calendar.LocalGregorianCalendar instance (singleton).
Gregorian calendar instance. This is required because era
transition dates are given in Gregorian dates.
The Era instance representing "before Meiji".
Imperial eras. The sun.util.calendar.LocalGregorianCalendar
doesn't have an Era representing before Meiji, which is
inconvenient for a Calendar. So, era[0] is a reference to
Fixed date of the first date of each era.
ZONE_OFFSET (UNIX compatibility)
ERA (initialized later)
YEAR (initialized later)
MONTH (Showa 64 ended in January.)
WEEK_OF_YEAR (Showa 1 has only 6 days which could be 0 weeks.)
DAY_OF_YEAR (initialized later)
DST_OFFSET (historical least maximum)
DST_OFFSET (double summer time)
Proclaim serialization compatibility with JDK 1.6
eras[BEFORE_MEIJI] and sinceFixedDate[BEFORE_MEIJI] are the
same as Gregorian.
Calculate the least maximum year and least day of Year
values. The following code assumes that there's at most one
era transition in a Gregorian year.
Unless the first year starts from January 1, the actual
max value could be one year short. For example, if it's
Showa 63 January 8, 63 is the actual max value since
Showa 64 January 8 doesn't exist.
Max year could be smaller than this value.
If amount == 0, do nothing even the given field is out of
range. This is tested by JCK.
Sync the time and calendar fields.
Handle the time fields here. Convert the given
amount to milliseconds and call setTimeInMillis.
hours to milliseconds
minutes to milliseconds
seconds to milliseconds
Handle week, day and AM_PM fields which involves
time zone offset change adjustment. Convert the
given amount to the number of days.
synonym of DATE
Convert the amount to the number of days (delta)
and +12 or -12 hours (timeOfDay).
The time fields don't require time zone offset change
The rest of the fields (week, day or AM_PM fields)
require time zone offset (both GMT and DST) change
Translate the current time to the fixed date and time
of the day.
fd is the expected fixed date after the calculation
If the time zone offset has changed, then adjust the difference.
If the adjustment has changed the date, then take
the previous one.
If amount == 0, do nothing even the given field is out of
range. This is tested by JCK.
Sync the time and calendar fields.
These fields are handled simply, since they have fixed
minima and maxima. Other fields are complicated, since
the range within they must roll varies depending on the
date, a time zone and the era transitions.
12 or 24 hours
The day might have changed, which could happen if
the daylight saving time transition brings it to
the next day, although it's very unlikely. But we
have to make sure not to change the larger fields.
Time zone offset and/or daylight saving might have changed.
Rolling the month involves both pinning the final value to [0, 11]
and adjusting the DAY_OF_MONTH if necessary.  We only adjust the
DAY_OF_MONTH if, after updating the MONTH field, it is illegal.
E.g., <jan31>.roll(MONTH, 1) -> <feb28> or <feb29>.
To avoid overflow, use an equivalent year.
Month may have changed by the normalization.
To avoid underflow, use an equivalent year.
Month may have changed by the normalization.
Keep the day of month in the range.  We
don't want to spill over into the next
month; e.g., we don't want jan31 + 1 mo ->
feb31 -> mar3.
The year has only one month. No need to
process further. (Showa Gan-nen (year 1)
and the last year have only one month.)
If the new value is in between min and max
(exclusive), then we can use the value.
Make sure that the min week has the current DAY_OF_WEEK
Make sure the same thing for the max week
Handle transition here.
Make sure that the min week has the current DAY_OF_WEEK
Make sure the same thing for the max week
value: the new WEEK_OF_YEAR which must be converted
to month and day of month.
dow: relative day of week from the first day of week
fixed date of the first day (usually 1) of the month
actual month length
the first day of week of the month.
if the week has enough days to form a week, the
week starts from the previous month.
value: the new WEEK_OF_MONTH value
nfd: fixed date of the rolled date
Unlike WEEK_OF_YEAR, we need to change day of week if the
nfd is out of the month.
TODO: Need to change the spec to be usable DAY_OF_MONTH rolling...
Transition handling. We can't change year and era
values here due to the Calendar roll spec!
It may not be a regular month. Convert the date and range to
the relative values, perform the roll, and
convert the result back to the rolled date.
Handle transition. We can't change year and era values
here due to the Calendar roll spec.
If the week of year is in the same year, we can
just change DAY_OF_WEEK.
We need to handle it in a different way around year
boundaries and in the transition year. Note that
changing era and year values violates the roll
rule: not changing larger calendar fields...
after having normalized, min should be 1.
Transition year handling.
"GanNen" is supported only in the LONG style.
If the ERA value is null, then
try to get its name or abbreviation from the Era instance.
If strings[] has fewer than eras[], get more names from eras[].
count unique era values
The value should depend on the time zone of this calendar.
Get a local date which includes time of day and time zone,
which are missing in jc.jdate.
Use the same year in jd to take care of leap
years. i.e., both jd and d must agree on leap
or common years.
Use an equvalent year of d.getYear() if
possible. Otherwise, ignore the leap year and
common year difference.
In Before Meiji and Meiji, January is the first month.
shift 400 years to avoid underflow
TODO: there may be multiple transitions in a year.
Handle transition year.
TODO: there may be multiple transitions in a year.
shift 400 years to avoid underflow
Get the day of week of January 1 of the year
Normalize the day of week with the firstDayOfWeek value
# of days in the first week
Use an equivalent year for the
getYearOffsetInMillis call to avoid overflow.
Use the same year as d.getYear() to be
consistent with leap and common years.
To share the zone by the CalendarDate
To share the zone by the CalendarDate
Determine which calendar fields need to be computed.
Specify all fields
After computing all the fields, set the field state to `COMPUTED'.
By computing time and zoneOffset separately, we can take
the wider range of time+zoneOffset than the previous
See if we can use jdate to avoid date calculation.
Always set the ERA and YEAR values.
Set the basic date fields.
Assume AM == 0
If it's a year of an era transition, we need to handle
irregular year boundaries.
The spec is to calculate WEEK_OF_YEAR in the
ISO8601-style. This creates problems, though.
If the date belongs to the last week of the
previous year, use the week number of "12/31" of
the "previous" year. Again, if the previous year is
a transition year, we need to take care of it.
Usually the previous day of the first day of a year
is December 31, which is not always true in the
Japanese imperial calendar system.
As of Heisei (since Meiji) there's no case
that there are multiple transitions in a
year.  Historically there was such
case. There might be such case again in the
The first days forms a week in which the date is included.
The first days forms a week in which the date is included.
We can always use `jcal' since Julian and Gregorian are the
same thing for this calculation.
In non-lenient mode, perform brief checking of calendar
fields which have been set externally. Through this
checking, the field values are stored in originalFields[]
to see if any of them are normalized later.
Quick validation for any out of range values
Let the super class determine which calendar fields to be
used to calculate the time.
Equivalent to 1970 (Gregorian)
Calculate the time of day. We rely on the convention that
an UNSET field has 0.
The default value of AM_PM is 0 which designates AM.
Convert the time of day to the number of days and the
millisecond offset from midnight.
Calculate the fixed date since January 1, 1 (Gregorian).
millis represents local wall-clock time in milliseconds.
Compute the time zone offset and DST offset.  There are two potential
ambiguities here.  We'll assume a 2:00 am (wall time) switchover time
for discussion purposes here.
1. The transition into DST.  Here, a designated time of 2:00 am - 2:59 am
can be in standard or in DST depending.  However, 2:00 am is an invalid
representation (the representation jumps from 1:59:59 am Std to 3:00:00 am DST).
We assume standard time.
2. The transition out of DST.  Here, a designated time of 1:00 am - 1:59 am
can be in standard or DST.  Both are valid representations (the rep
jumps from 1:59:59 DST to 1:00:00 Std).
Again, we assume standard time.
We use the TimeZone object, unless the user has explicitly set the ZONE_OFFSET
or DST_OFFSET fields; then we use those fields.
Adjust the time zone offset values to get the UTC time.
Set this calendar's time in milliseconds
Restore the original field values
No need to check if MONTH has been set (no isSet(MONTH)
call) since its unset value happens to be JANUARY (0).
If the month is out of range, adjust it into range.
Adjust the base date if year is the minimum value.
Get the fixed date since Jan 1, 1 (Gregorian). We are on
the first day of either `month' or January in 'year'.
We are on the "first day" of the month (which may
not be 1). Just add the offset if DAY_OF_MONTH is
set. If the isSet call returns false, that means
DAY_OF_MONTH has been selected just because of the
selected combination. We don't need to add any
since the default value is the "first day".
To avoid underflow with DAY_OF_MONTH-firstDayOfMonth, add
DAY_OF_MONTH, then subtract firstDayOfMonth.
If we have enough days in the first week, then
move to the previous week.
In lenient mode, we treat days of the previous
months as a part of the specified
WEEK_OF_MONTH. See 4633646.
We are basing this on the day-of-week-in-month.  The only
trickiness occurs if the day-of-week-in-month is
Go to the first day of the next week of
the specified week boundary.
Then, get the day of week date on or before the last date.
We are on the first day of the year.
Add the offset, then subtract 1. (Make sure to avoid underflow.)
If we have enough days in the first week, then move
to the previous week.
There might be multiple era transitions in a year.
If the given date is on or after the transition date, then
return the transition date.
Otherwise, we can use the 1st day of the month.
Create a clone and normalize the calendar fields
Use an equivalent year.
restore the year.
Don't normalize date here so as not to cause underflow.
PixelAspectRatio not in image
A null result means that the property was not set for
this action, so do not override the default value in this case.
6482575 - clear the appContext field so as not to leak it
We don't care about component.
So don't prevent class initialisation.
7020198 - set acc field to no permissions and no subject
Note, will have appContext set.
Opt: Only synchronize if trackerObj comes back null?
If null, synchronize, re-check for null, and put new tracker
Log wrapper class for standard exceptions
Generated by MC.java version 1.0, DO NOT EDIT BY HAND!
Generated from input file c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/corba/src/share/classes/com/sun/corba/se/spi/logging/data/OMG.mc on Fri Jul 21 21:58:44 PDT 2017
DOM2: support public ID.
DOM2: support system ID.
DOM2: support internal subset.
Doctype number.   Doc types which have no owner may be assigned
a number, on demand, for ordering purposes for compareDocumentPosition
NamedNodeMaps must be cloned explicitly, to avoid sharing them.
test if the following string attributes are equal: publicId,
test if NamedNodeMaps entities and notations are equal
If the doctype has a document owner, get the node number
relative to the owner doc
The doctype is disconnected and not associated with any document.
Assign the doctype a number relative to the implementation.
set read-only property
Convert the HashMap to Hashtable
Write serialized fields
We have to read serialized fields first.
convert the Hashtable back to HashMap
If this MutableBigInteger can't be fit into long, we need to
make a BigInteger object for the resultant BigDecimal object.
If this MutableBigInteger can not be fitted into long, we need to
make a BigInteger object for the resultant BigDecimal object.
Add Integer.MIN_VALUE to make the comparison act as unsigned integer
Add Integer.MIN_VALUE to make the comparison act as unsigned integer
Only 2 cases left:len == blen or len == blen - 1
len == blen - 1
compare values with right-shifted values of b,
carrying shifted-out bits across words
carray will be either 0x80000000 or 0
If shift can be done without moving words, do so
The array must grow
Use space on right
Must use space on left
Add common parts of both numbers
Add remainder of the longer number
Result must grow in length
Result one word longer from carry-out; copy low-order
bits into new result.
Add common parts of both numbers
Add remainder of the longer number
Result must grow in length
Result one word longer from carry-out; copy low-order
bits into new result.
copy from this if needed
zero the gap
Subtract common parts of both numbers
Subtract remainder of longer number
Subtract common parts of both numbers
Subtract remainder of longer number
Put z into an appropriate state to receive product
The first iteration is hoisted out of the loop to avoid extra add
Perform the multiplication word by word
Remove leading zeros from product
Perform the multiplication word by word
Special case of one word dividend
Normalize the divisor
Dividend is zero
Dividend less than divisor
Dividend equal to divisor
Special case one word divisor
Cancel common powers of two if we're above the KNUTH_POW2_* thresholds
Clear the quotient
Unlike Knuth division, we don't check for common powers of two here because
BZ already runs faster if both numbers contain powers of two and cancelling them has no
step 2a: j = ceil(s/m)
step 2b: block length in 32-bit units
block length in bits
step 4a: shift b so its length is a multiple of n
step 4b: shift a by the same amount
step 5: t is the number of blocks needed to accommodate a plus one additional bit
step 6: conceptually split a into blocks a[t-1], ..., a[0]
the most significant block of a
step 7: z[t-2] = [a[t-1], a[t-2]]
the second to most significant block
do schoolbook division on blocks, dividing 2-block numbers by 1-block numbers
step 8a: compute (qi,ri) such that z=b*qi+ri
step 8b: z = [ri, a[i-1]]
update q (part of step 9)
final iteration of step 8: do the loop one more time for i=0 but leave z unchanged
step 9: a and b were shifted, so shift back
step 1: base case
step 2: view this as [a1,a2,a3,a4] where each ai is n/2 ints or less
aUpper = [a1,a2,a3]
this = a4
step 3: q1=aUpper/b, r1=aUpper%b
step 4: quotient=[r1,this]/b, r2=[r1,this]%b
this = [r1,this]
step 5: let quotient=[q1,quotient] and return r2
half the length of b in ints
step 1: view this as [a1,a2,a3] where each ai is n ints or less; let a12=[a1,a2]
step 2: view b as [b1,b2] where each bi is n ints or less
step 3a: if a1<b1, let quotient=a12/b1 and r=a12%b1
step 4: d=quotient*b2
step 3b: if a1>=b1, let quotient=beta^n-1 and r=a12-b1*2^n+b1
step 4: d=quotient*b2=(b2 << 32*n) - b2
step 5: r = r*beta^n + a3 - d (paper says a4)
However, don't subtract d until after the while loop so r doesn't become negative
step 6: add b until r>=d
Dividend is zero
Special case on word divisor
assert div.intLen > 1
D1 normalize the divisor
Copy divisor value to protect divisor
Remainder starts as dividend with space for a leading zero
Set the quotient size
Must insert leading 0 in rem if its length did not change
D2 Initialize j
D3 Calculate qhat
D4 Multiply and subtract
D5 Test remainder
D6 Add back
Store the quotient digit
D7 loop on j
D3 Calculate qhat
D4 Multiply and subtract
D5 Test remainder
D6 Add back
Store the quotient digit
Remainder starts as dividend with space for a leading zero
D1 normalize the divisor
Must insert leading 0 in rem if its length did not change
D2 Initialize j
D3 Calculate qhat
D4 Multiply and subtract
D5 Test remainder
D6 Add back
Store the quotient digit
D7 loop on j
Approximate the quotient and remainder
Correct the approximation
n - q*dlong == r && 0 <= r <dLong, hence we're done.
Use Euclid's algorithm until the numbers are approximately the
same length, then use the binary GCD algorithm to find the GCD.
Algorithm B from Knuth section 4.5.2
steps B3 and B4
Special case one word numbers
Right shift a & b till their last bits equal to 1.
a > b as unsigned
Modulus is odd, use Schroeppel's algorithm
Base and modulus are even, throw exception
Get even part of modulus expressed as a power of 2
Construct odd part of modulus
Calculate 1/a mod oddMod
Calculate 1/a mod evenMod
Combine the results using Chinese Remainder Theorem
1 more Newton iter step
Copy the mod to protect original
Right shift f k times until odd, left shift d k times
The Almost Inverse Algorithm
If gcd(f, g) != 1, number is not invertible modulo mod
If f < g exchange f, g and c, d
If f == g (mod 4)
If f != g (mod 4)
Right shift f k times until odd, left shift d k times
Set r to the multiplicative inverse of p mod 2^32
V = R * c (mod 2^j)
c = c + (v * p)
c = c / 2^j
V = R * c (mod 2^j)
c = c + (v * p)
c = c / 2^j
In theory, c may be greater than p at this point (Very rare!)
swap b & r
Access to protected field members is restricted to receivers only
of the accessing class, or one of its subclasses, and the
accessing class must in turn be a subclass (or package sibling)
of the protected member's defining class.
If the updater refers to a protected field of a declaring class
outside the current package, the receiver argument will be
narrowed to the type of the accessing class.
This file was generated AUTOMATICALLY from a template file Fri Jul 21 22:00:53 PDT 2017
There is a titlecase equivalent.  Perform further checks:
The character does not have an uppercase equivalent, so it must
already be uppercase; so add 1 to get the titlecase form.
The character does not have a lowercase equivalent, so it must
already be lowercase; so subtract 1 to get the titlecase form.
The character has both an uppercase equivalent and a lowercase
equivalent, so it must itself be a titlecase form; return it.
This character has no titlecase equivalent but it does have an
uppercase equivalent, so use that (subtract the signed case offset).
Java supradecimal digit
The following tables and code generated using:
java GenerateCharacter -plane 2 -template c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/jdk/make/data/characterdata/CharacterData02.java.template -spec c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/jdk/make/data/unicodedata/UnicodeData.txt -specialcasing c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/jdk/make/data/unicodedata/SpecialCasing.txt -proplist c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/jdk/make/data/unicodedata/PropList.txt -o c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/build/windows-amd64/jdk/gensrc/java/lang/CharacterData02.java -string -usecharforbyte 11 4 1
The X table has 2048 entries for a total of 4096 bytes.
The Y table has 96 entries for a total of 192 bytes.
The A table has 8 entries for a total of 32 bytes.
The B table has 8 entries for a total of 16 bytes.
In all, the character property tables require 4320 bytes.
THIS CODE WAS AUTOMATICALLY CREATED BY GenerateCharacter:
override with covariant return type
override for return type
Check for overflow
Use just the limit if the number of elements
to skip is <= the known pipeline size
regardless of the value of n
Need to adjust the target size of splitting for the
SliceTask from say (size / k) to say min(size / k, 1 << 14)
This will limit the size of the buffers created at the leaf nodes
cancellation will be more aggressive cancelling later tasks
if the target slice size has been reached from a given task,
cancellation should also clear local results if any
Because the pipeline is SIZED the slice spliterator
can be created from the source, this requires matching
to shape of the source, and is potentially more efficient
than creating the slice spliterator from the pipeline
Collect using this pipeline, which is empty and therefore
can be used with the pipeline wrapping spliterator
Note that we cannot create a slice spliterator from
the source spliterator if the pipeline is not SIZED
Use just the limit if the number of elements
to skip is <= the known pipeline size
Because the pipeline is SIZED the slice spliterator
can be created from the source, this requires matching
to shape of the source, and is potentially more efficient
than creating the slice spliterator from the pipeline
Collect using this pipeline, which is empty and therefore
can be used with the pipeline wrapping spliterator
Note that we cannot create a slice spliterator from
the source spliterator if the pipeline is not SIZED
Use just the limit if the number of elements
to skip is <= the known pipeline size
Because the pipeline is SIZED the slice spliterator
can be created from the source, this requires matching
to shape of the source, and is potentially more efficient
than creating the slice spliterator from the pipeline
Collect using this pipeline, which is empty and therefore
can be used with the pipeline wrapping spliterator
Note that we cannot create a slice spliterator from
the source spliterator if the pipeline is not SIZED
Use just the limit if the number of elements
to skip is <= the known pipeline size
Because the pipeline is SIZED the slice spliterator
can be created from the source, this requires matching
to shape of the source, and is potentially more efficient
than creating the slice spliterator from the pipeline
Collect using this pipeline, which is empty and therefore
can be used with the pipeline wrapping spliterator
Note that we cannot create a slice spliterator from
the source spliterator if the pipeline is not SIZED
There is no need to truncate since the op performs the
skipping and limiting of elements
must be completed
javax.rmi.CORBA.Stub stub =
org.omg.CORBA.ORB orb =
This is currently never called.
set the current position to 0 if any has components, otherwise to -1.
set the current position to 0 if any has components, otherwise to -1.
DynAny interface methods
Spec: Returns a copy of the internal Any
If the other DynAny is a constructed one we don't want it to have
to create its Any representation just for this test.
The flag "true" indicates copying the Any value
Throw InvalidValue if this is a bounded string and the length is exceeded
Throw InvalidValue if this is a bounded string and the length is exceeded
_REVISIT_ Copy value here?
_REVISIT_ Copy value here?
The spec doesn't allow us to throw back this exception
incase the anys any if of type Principal, native or abstract interface.
Can never be greater that upTo, this avoids overflow if upper bound
All elements are traversed if from == upTo & last == 0
1 if the range is closed and the last element has not been traversed
Otherwise, 0 if the range is open, or is a closed range and all
elements have been traversed
Last element of closed range
Ensure ranges of size > Integer.MAX_VALUE report the correct size
Left split always has a half-open range
Cast to int is safe since:
2 <= size < 2^32
2 <= d <= 8
Can never be greater that upTo, this avoids overflow if upper bound
All elements are traversed if from == upTo & last == 0
1 if the range is closed and the last element has not been traversed
Otherwise, 0 if the range is open, or is a closed range and all
elements have been traversed
Last element of closed range
Left split always has a half-open range
2 <= size <= Long.MAX_VALUE
>= 0 when building, < 0 when built
-1 == no elements
-2 == one element, held by first
-3 == two or more elements, held by buffer
Spliterator implementation for 0 or 1 element
count == -1 for no elements
count == -2 for one element held by first
The first element in the stream
valid if count == 1
The first and subsequent elements in the stream
non-null if count == 2
Switch count to negative value signalling the builder is built
Use this spliterator if 0 or 1 elements, otherwise use
the spliterator of the spined buffer
Spliterator implementation for 0 or 1 element
count == -1 for no elements
count == -2 for one element held by first
The first element in the stream
valid if count == 1
The first and subsequent elements in the stream
non-null if count == 2
Switch count to negative value signalling the builder is built
Use this spliterator if 0 or 1 elements, otherwise use
the spliterator of the spined buffer
Spliterator implementation for 0 or 1 element
count == -1 for no elements
count == -2 for one element held by first
The first element in the stream
valid if count == 1
The first and subsequent elements in the stream
non-null if count == 2
Switch count to negative value signalling the builder is built
Use this spliterator if 0 or 1 elements, otherwise use
the spliterator of the spined buffer
Spliterator implementation for 0 or 1 element
count == -1 for no elements
count == -2 for one element held by first
The first element in the stream
valid if count == 1
The first and subsequent elements in the stream
non-null if count == 2
Switch count to negative value signalling the builder is built
Use this spliterator if 0 or 1 elements, otherwise use
the spliterator of the spined buffer
Spliterator implementation for 0 or 1 element
count == -1 for no elements
count == -2 for one element held by first
True when no split has occurred, otherwise false
Never read after splitting
The spliterator is known to be unsized before splitting if the
sum of the estimates overflows.
If one or both estimates are Long.MAX_VALUE then the sum
will either be Long.MAX_VALUE or overflow to a negative value
Concatenation loses DISTINCT and SORTED characteristics
read and discard the repository ID
write the repository ID
generated code, not worth fixing
A file can contain several acl definitions
This could change the preferred size of the Component.
REMIND: remove when filtering is done at lower level
skip value for unrecognized key
[[[PENDING:  WDW -- need to provide a localized string]]]
Simulate a button click
inner class AccessibleAWTButton
Control the selection behavior of the JComboBox when it is used
in the JTable DefaultCellEditor.
This list is for drawing the current item in the combo box.
Used to render the currently selected item in the combo box.
It doesn't have anything to do with the popup's rendering.
The implementation of ComboPopup that is used to show the popup.
The Component that the ComboBoxEditor uses for editing
The arrow button that invokes the popup.
Listeners that are attached to the JComboBox
Listeners that the ComboPopup produces.
This is used for knowing when to cache the minimum preferred size.
If the data in the list changes, the cached value get marked for recalc.
Added to the current JComboBox model
Flag for recalculating the minimum preferred size.
Cached minimum preferred size.
Flag for calculating the display size
Cached the size that the display needs to render the largest item
Key used for lookup of the DefaultListCellRenderer in the AppContext.
Used for calculating the default size.
begin UI Initialization
Is this combo box a cell editor?
Leave focus in JComboBox.
NOTE: this needs to default to true if not specified
end UI Initialization
begin Inner classes
This class used to implement behavior which is now redundant.
Syncronizes the ToolTip text for the components within the combo box to be the
same value as the combo box ToolTip text.
end Inner classes
begin Sub-Component Management
Just to be safe.
Switch focus to the editor component
Should be in the same state as the combobox
end Sub-Component Management
begin ComboBoxUI Implementation
end ComboBoxUI Implementation
begin ComponentUI Implementation
calculate the width and height of the button
adjust the size based on the button width
force sameBaseline to be updated.
Note, we're assuming the baseline is the same for all
cells, if not, this needs to loop through all.
Force sameBaseline to be updated.
Note, we're assuming the baseline is the same for all
cells, if not, this needs to loop through all.
This is currently hacky...
This is currently hacky...
0 = the popup
1 = the editor
end ComponentUI Implementation
begin Utility Methods
end Utility Methods
begin Painting Utility Methods
Fix for 4238829: should lay out the JPanel.
end Painting Utility Methods
begin Size Utility Methods
Calculates the height and width using the default text renderer
Calculates the dimension based on the prototype value
Calculate the dimension by iterating over all the elements in the combo
Calculates the maximum height and width based on the largest
calculate in the padding
Set the cached value
This has been refactored out in hopes that it may be investigated and
simplified for the next major release. adding/removing
the component to the currentValuePane and changing the font may be
end Size Utility Methods
begin Keyboard Action Management
Special case in which pressing the arrow keys will not
make the popup appear - except for editable combo boxes
and combo boxes inside a table.
Forces the selection of the list item if the
combo box is in a JTable.
Special case in which pressing the arrow keys will not
make the popup appear - except for editable combo boxes.
If ComboBox.noActionOnKeyNavigation is set,
forse selection of list item
Forces the selection of the list item
Use the selected value from popup
to set the selected item in combo box,
but ensure before that JComboBox.actionPerformed()
won't use editor's value to set the selected item
Hide combo box if it is a table cell editor
Call the default button binding.
This is a pretty messy way of passing an event through
to the root pane.
end Keyboard Action Management
Shared Handler, implements all listeners
If the border of the editor changes then this can effect
the size of the editor which can cause the combo's size to
become invalid so we need to clear size caches
This listener checks to see if the key event isn't a navigation
key.  If it finds a key event that wasn't a navigation key it
dispatches it to JComboBox.selectWithKeyChar() so that it can do
NOTE: The class is added to both the Editor and ComboBox.
The combo box listener hides the popup when the focus is lost.
It also repaints when focus is gained or lost.
This listener watches for changes in the ComboBoxModel
set the editor with the selected item since this
is the event handler for a selected item change.
This layout manager handles the 'standard' layout of combo boxes.
It puts the arrow button to the right and the editor to the left.
If there is no editor it still keeps the arrow button to the right.
Fix for 4515752: Forward the Enter pressed on the
editable combo box to the default button
Note: This could depend on event ordering. The first ActionEvent
from the editor may be handled by the JComboBox in which case, the
enterPressed action will always be invoked.
Subsequent same key presses move the keyboard focus to the next
object that starts with the same letter.
These message should be read from a locale-specific resource bundle
emulate XPath which only returns the first node in
contiguous text/cdata nodes
-- This file was mechanically generated: Do not edit! --
these declarations are here as documentation
--- Methods to support CharSequence ---
End of file.
This could change the preferred size of the Component.
REMIND: remove when filtering is done at lower level
skip value for unrecognized key
To be fully implemented in a future release
To be fully implemented in a future release
To be fully implemented in a future release
To be fully implemented in a future release
To be fully implemented in a future release
To be fully implemented in a future release
To be fully implemented in a future release
inner class AccessibleAWTCheckbox
no need to sync in the future
we don't want to generate any event for this so turn them off
set mutation events flag back to its original value
create all built-in types
add 2 duration types
For the enabled state, prefer the widget's colors
If getForeground returns a non-UIResource it means the
developer has explicitly set the foreground, use it over
that of TEXT_FOREGROUND as that is typically the expected
The following calculations are derived from gtkbutton.c
(GTK+ version 2.8.20), gtk_button_size_allocate() method.
Include the default border insets, but only for JButtons
that are default capable.  Note that
JButton.getDefaultCapable() returns true by default, but
GtkToolButtons are never default capable, so we skip this
step if the button is contained in a toolbar.
The following calculations are derived from gtkcheckbutton.c
(GTK+ version 2.8.20), gtk_check_button_size_allocate() method.
Note: GTKIconFactory.DelegateIcon will have already included the
"indicator-spacing" value in the size of the indicator icon,
which explains why we use zero as the left inset (or right inset
in the RTL case); see 6489585 for more details.
The following calculations are derived from gtkmenubar.c
(GTK+ version 2.8.20), gtk_menu_bar_size_allocate() method.
The following calculations are derived from gtkmenuitem.c
(GTK+ version 2.8.20), gtk_menu_item_size_allocate() method.
NOTE: this is called for ComboBox, and FormattedTextField also
This scrollbar is part of a scrollpane; use only the
"scrollbar-spacing" style property to determine the padding
between the scrollbar and its parent scrollpane.
This is a standalone scrollbar; leave enough room for the
focus line in addition to the trough border.
See if this is a class specific value.
Is it a specific value ?
Believe it or not, the size of a spinner arrow button is
dependent upon the size of the spinner's font.  These
calculations come from gtkspinbutton.c (version 2.8.20),
For all other kinds of arrow buttons (e.g. combobox arrow
buttons), we will simply fall back on the value of
ArrowButton.size as defined in the UIDefaults for
GTKLookAndFeel when we call UIManager.get() below...
The iconTextGap value needs to include "indicator-spacing"
and it also needs to leave enough space for the focus line,
which falls between the indicator icon and the text.
See getRadioInsets() and 6489585 for more details.
Is it a stock icon ?
Is it another kind of value ?
For backward compatibility we'll fallback to the UIManager.
We don't go to the UIManager for engine as the engine is GTK
Don't call super, we don't want to pick up defaults from
First try loading a theme-specific icon using the native
GTK libraries (native GTK handles the resizing for us).
In a failure case where native GTK (unexpectedly) returns a
null icon, we can try loading a default icon as a fallback.
In an extreme failure situation, just return null (callers are
already prepared to handle a null icon, so the worst that can
happen is that an icon won't be included in the button/dialog).
The chain is stale.
This must be a unique attribute.
Update table view.
This chain is active.
We need to check if any of the attributes has the same rawname.
Search the table.
This attribute is unique.
Select a new hash function and rehash the table view
if the collision threshold is exceeded.
The current attribute will be processed in the rehash.
Need to set its name first.
Update table view
Duplicate. We still need to find the index.
Make the discarded Attribute object available for re-use
by tucking it after the Attributes that are still in use
AttributeList and Attributes methods
If the list is small check for duplicates using pairwise comparison.
If the list is large check duplicates using a hash table.
We don't want this table view to be read if someone calls
addAttribute so we invalidate it up front.
The chain is stale.
This must be a unique attribute.
This chain is active.
We need to check if any of the attributes has the same name.
Search the table.
Select a new hash function and rehash the table view
if the collision threshold is exceeded.
The current attribute will be processed in the rehash.
Update table view
Overflow. We actually need to visit the chain state array.
Need to populate the hash table with the attributes we've processed so far.
Update table view
REVISIT: The empty string is not entered in the symbol table!
Need to populate the hash table with the attributes we've processed so far.
Update table view
Additional data for attribute table view
we have a submenu to open
Handle the case for Escape or Enter...
Invoke the menu action
submenus are handled in menuKeyTyped
we have a menu item
Select the menu item with the matching mnemonic. If
the same mnemonic has been invoked then select the next
menu item in the cycle.
Types of actions
Used for next/previous actions
Used for parent/child actions
check if we have an open submenu. A submenu item may or
may not be selected, so submenu popup can be either the
last or next to the last item.
we have a submenu, just close it
we have a submenu, open it
check if we have a toplevel menu selected.
If this is the case, we select another toplevel menu
menu is selected but its popup not shown
menu is selected and its popup is shown
a toplevel menu is selected, but its popup not shown.
Show the popup and select the first item
an enabled item found -- include it in newPath
menu has no enabled items -- still must show the popup
a menu (not necessarily toplevel) is open and its popup
shown. Select the appropriate menu item
all items in the popup are disabled.
We're going to find the parent popup menu and select
its next item. If there's no parent popup menu (i.e.
current menu is toplevel), do nothing
just select the next item, no path expansion needed
4234793: This action should call JPopupMenu.firePopupMenuCanceled but it's
a protected method. The real solution could be to make
firePopupMenuCanceled public and call it directly.
unselect MenuItem and its Popup by default
unselect the last visible popup only
unselect invisible popup and two visible elements
clear selection for the topLevelMenu
A grab needs to be added
The grab should be removed
Popup should be canceled in case of ungrab event
We are interested in MouseEvents only
Cancel popup only if this property was not set.
If this property is set to TRUE component wants
to deal with this event by himself.
Ask UIManager about should we consume event that closes
popup. This made to match native apps behaviour.
Consume the event so that normal processing stops.
Do not forward event to MSM, let component handle it
For the MOUSE_DRAGGED event the src is
the Component in which mouse button was pressed.
If the src is in popupMenu,
do not forward event to MSM, let component handle it.
We should ungrab window if a user code throws
an unexpected runtime exception. See 6495920.
4234793: This action should call firePopupMenuCanceled but it's
a protected method. The real solution could be to make
firePopupMenuCanceled public and call it directly.
Workarounr for 4810575.
If lastFocused is not in currently focused window
requestFocusInWindow will fail. In this case we must
request focus by requestFocus() if it was not
transferred from our popup.
Do nothing for non-focusable popups
a menu has been selected but not open
remember current focus owner
request focus on root pane and install keybindings
used for menu navigation
menu hidden -- return focus to where it had been before
and uninstall menu keybindings
Remember the last path selected
If our parent is not a Component, then this PopupMenu is
really just a plain, old Menu.
Use localParent for thread safety.
Fixed 6278745: Incorrect exception throwing in PopupMenu.show() method
Exception was not thrown if compParent was not equal to origin and
was not Container
No action for the moment.
No action for the moment.
No action for the moment.
Note that the namespace-aware call must be used to correctly
construct a Level 2 DOM, even for non-namespaced nodes.
First handle a possible ID attribute
DOM represents no-namespace as null
System.out.println("attrNS: "+attrNS+", localName: "+atts.getQName(i)
Crimson won't let us set an xmlns: attribute on the DOM.
In SAX, xmlns[:] attributes have an empty namespace, while in DOM they
should have the xmlns namespace
ALWAYS use the DOM Level 2 call!
Do nothing. This method is meant to be overiden.
avoid DOM006 Hierarchy request error
avoid DOM006 Hierarchy request error
Almost certainly the wrong behavior...
avoid DOM006 Hierarchy request error
avoid DOM006 Hierarchy request error
Do nothing for now.
Do nothing for now.
the key type is Object for supporting null key
lazily install the 2nd level valuesMap for the particular cacheKey
create subKey and retrieve the possible Supplier<V> stored by that
subKey from valuesMap
supplier might be a Factory or a CacheValue<V> instance
else no supplier in cache
or a supplier that returned null (could be a cleared CacheValue
or a Factory that wasn't successful in installing the CacheValue)
lazily construct a Factory
successfully installed Factory
else retry with winning supplier
cleared CacheEntry / unsuccessful Factory
with our Factory
retry with current supplier
something changed while we were waiting:
might be that we were replaced by a CacheValue
or were removed because of failure ->
return null to signal WeakCache.get() to retry
else still us (supplier == this)
create new value
remove us on failure
the only path to reach here is with non-null value
wrap value with CacheValue (WeakReference)
put into reverseMap
try replacing us with CacheValue (this should always succeed)
successfully replaced us with new CacheValue -> return the value
wrapped by it
compare by identity
compare by identity
compare by identity
cleared CacheValue is only equal to itself
compare by identity
a replacement for null keys
null key means we can't weakly reference it,
so we use a NULL_KEY singleton as cache key
non-null key requires wrapping with a WeakReference
compare by identity
cleared CacheKey is only equal to itself
compare key by identity
removing just by key is always safe here because after a CacheKey
is cleared and enqueue-ed it is only equal to itself
(see equals method)...
remove also from reverseMap if needed
These are currently the same in both RepositoryId and
RepositoryId_1_3, but provide the constants again here
to eliminate awkardness when using this interface.
Determine how many (if any) repository IDs follow the value
Accessors for precomputed value tags
These message should be read from a locale-specific resource bundle
Constructors and factory methods in this class *must* be package scoped or private.
Check for corner case: invokeinterface of Object method
else this.form is wrong
must override in subclasses
call preparedFieldLambdaForm instead
precompute the barrier-free version:
insert newly allocated obj
<init> returns void
look, shifted args!
got to move this one
This is a tricky bit of code.  Don't send it through the LF interpreter.
Help along bootstrapping...
No need to initialize the class on this kind of member.
These guys have lots of <clinit> DMH creation but we know
the MHs will not be used until the system is booted.
It is a system class.  It is probably in the process of
being initialized, but we will help it along just to be safe.
If the previous call didn't block, this can happen.
We are executing inside <clinit>.
The coast is clear.  Delete the <clinit> barrier.
the final state
Somebody may still be running defc.<clinit>.
If anybody is running defc.<clinit>, it is this thread.
Yes, we are running it; keep the barrier for now.
We are in a random thread.  Block.
put it into the final state
Note: We return a long because that is what Unsafe.getObject likes.
We store a plain int because it is more compact.
Note that the object's class has already been verified,
since the parameter type of the Accessor method handle
is either member.getDeclaringClass or a subclass.
This was verified in DirectMethodHandle.make.
Therefore, the only remaining check is for null.
Since this check is *not* guaranteed by Unsafe.getInt
and its siblings, we need to make an explicit one here.
maybe throw NPE
Caching machinery for field accessors:
Enumerate the different field kinds using Wrapper,
with an extra case added for checked references.
precompute the barrier-free version:
don't bother with a CAS
getObject, putIntVolatile, etc.
What is the external type of the lambda form?
erase short to int, etc.
if this is for non-static access, the base pointer is stored at this index:
if this is for write access, the value to be written is stored at this index:
static base if any
Either static offset or field offset.
either the call or the cast
significant only for debugging
Each nf must be statically invocable or we get tied up in our bootstraps.
REVIST name ForRequest?
REVISIT - not sure if the final fragment and DII stuff should
End of file.
Use the default classloader for this class to load the prompt strings.
Keys to retrieve the stored username and password
Used for the username token replacement
Supplied username and password
Unchecked warning from (Map<String, Object>)sharedState is safe
since javax.security.auth.login.LoginContext passes a raw HashMap.
Add any JNDI properties to the environment
initialize any configured options
return no attrs
set later, from the specified attribute
attempt the authentication
attempt the authentication by getting the
username and password from shared state
authentication failed -- try again below by prompting
attempt the authentication by getting the
username and password from shared state
attempt the authentication by prompting for the username and pwd
add Principals to the Subject
in any case, clean out state
Clean out state
overall authentication succeeded and commit succeeded,
but someone else's commit failed
clean out state
first get the username and password
Prepare to bind using user's username and password
Connect to the LDAP server (using simple bind)
Authentication has succeeded
Locate the user's distinguished name
Connect to the LDAP server (using anonymous bind)
Locate the user's distinguished name
Prepare to bind using user's distinguished name and password
Connect to the LDAP server (using simple bind)
Authentication has succeeded
Save input as shared state only if authentication succeeded
Create the user principals
Locate the user's LDAP entry
Extract the distinguished name of the user's entry
(Use the first entry if more than one is returned)
Extract a value from user's authorization identity attribute
use the password saved by the first module in the stack
prompt for a username and password
Disallow subsequent initCause
End of file.
Our field for storage
Determine how many keys have Serializable values, when
done all non-null values in keys identify the Serializable
Write ou the Serializable key/value pairs.
We are an array
We are a hashtable
Is key on the list?
If so,  remove it
Copy the list up to index
Copy from two past the index, up to
the end of tmp (which is two elements
shorter than the old list)
set the listener array to the new array or null
Since we implement Cloneable, this should never happen
okay because we never modify the contents of printerResolution
This will throw an IllegalArgumentException
This will throw an IllegalArgumentException
Return a copy because otherwise client code could circumvent the
the checks made in setPrinterResolution by modifying the
Store a copy because otherwise client code could circumvent the
the checks made above by holding a reference to the array and
modifying it after calling setPrinterResolution.
table of all instances in this class, used by readResolve
make sure the serial version doesn't change between compiler versions
All WireObjectKeyTemplates are the same, so they should
have the same hashCode.
We assume the setter is called BEFORE the getter has been invoked
for a particular AppContext.
Yes, this is hacky. A better solution is to get the UI
and cast, but JComponent doesn't expose a getter for the UI
(each of the UIs do), making that approach impractical.
Fill in the background, if necessary.
We should uninstall the StyleFactory here, but unfortunately
there are a handful of things that retain references to the
LookAndFeel and expect things to work
SynthTabbedPaneUI supports rollover on tabs, GTK does not
These need to be defined for JColorChooser to work.
These need to be defined for ImageView.
These are needed for PopupMenu.
enabled antialiasing depending on desktop settings
Only update on an ancestor change when getting a valid
parent and the LookAndFeel wants this.
De-register listener on old keyboard focus manager and
register it on the new one.
Get the current background color.
Get the last background color.
Reset the component state back to original.
Repaint the component if the backgrounds differed.
Verify that the Component is recursively enabled. Disabling a
heavyweight Container disables its children, whereas disabling
a lightweight Container does not.
Class name of server's main class.
class path used to run the server.
arguments passed to the server
arguments passed to the server's Java VM1
result will contain the attrs which have to be output
The prefix visibly utilized (in the attribute or in the name) in
Not a namespace definition.
The Element is output element, add the prefix (if used) to
Add to the result.
The default mapping for xml must not be output.
New definition check if it is relative.
result will contain the attrs which have to be output
The prefix visibly utilized (in the attribute or in the name) in
It's the output selected.
The Element is output element, add the prefix (if used)
Add to the result.
New definition check if it is relative
The element is visible, handle the xmlns definition
There is a definition but the xmlns is not selected by the
xpath. then xmlns=""
Read the list of names
Read the entities
Read the elements
We reverse the order of the linked list by doing this, but
that order isn't important.
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of MenuBarPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of MenuBarPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
We are in V3 architecture, ACM is in the picture.
set owner document
Need to break the association w/ original kids
invalidate cache for children NodeList
Then, if deep, clone the kids too.
last child is stored as the previous sibling of first child
store lastChild as previous sibling of first child
Tail-call; optimizer should be able to do good things with.
SLOW BUT SAFE: We could insert the whole subtree without
juggling so many next/previous pointers. (Wipe out the
parent's child-list, patch the parent pointers, set the
ends of the list.) But we know some subclasses have special-
case behavior they add to insertBefore(), so we don't risk it.
This approch also takes fewer bytecodes.
NOTE: If one of the children is not a legal child of this
node, throw HIERARCHY_REQUEST_ERR before _any_ of the children
have been transferred. (Alternative behaviors would be to
reparent up to the first failure point or reparent all those
which are acceptable to the target node, neither of which is
as robust. PR-DOM-0818 isn't entirely clear on which it
No need to check kids for right-document; if they weren't,
they wouldn't be kids of that DocFrag.
stupid case that must be handled as a no-op triggering events...
refChild must be a child of this node (or null)
Prevent cycles in the tree
newChild cannot be ancestor of this Node,
and actually cannot be this
Convert to internal type, to avoid repeated casting
Convert to internal type, to avoid repeated casting
Attach before and after
Note: firstChild.previousSibling == lastChild!!
this our first and only child
this is an append
this is an insert
at the head of the list
somewhere in the middle
update cached length if we have any
if we happen to insert just before the cached node, update
the cache to the new node to match the cached index
otherwise just invalidate the cache
Tail-call, should be optimizable
update cached length if we have any
if the removed node is the cached node
move the cache to its (soon former) previous sibling
otherwise just invalidate the cache
Patch linked list around oldChild
Note: lastChild == firstChild.previousSibling
removing first child
removing last child
removing some other child in the middle
Save previous sibling for normalization checking.
Remove oldInternal's references to tree
If Mutation Events are being generated, this operation might
throw aggregate events twice when modifying an Attr -- once
on insertion and once on removal. DOM Level 2 does not specify
this as either desirable or undesirable, but hints that
aggregations should be issued only once per user request.
internal method taking a StringBuffer in parameter
internal method returning whether to take the given node's text content
get rid of any existing children
create a Text node to hold the given content
get rid of trivial cases
otherwise request a cache object
is the cached length invalid ?
start from the cached node if we have one
get rid of trivial case
otherwise request a cache object
release cache if reaching last child or first child
we can keep using the cache until it is actually reused
fNodeListCache will be nulled by the pool (document) if that
otherwise update it
DOM2: methods, getters, setters
No need to normalize if already normalized.
there are many ways to do this test, and there isn't any way
better than another. Performance may vary greatly depending on
the implementations involved. This one should work fine for us.
Recursively set kids
By default just change the flag to avoid calling this method again
See if insertion caused this node to be unnormalized.
If an adjacent sibling of the new child is a text node,
flag this node as unnormalized.
If the new child is not normalized,
then this node is inherently not normalized.
See if removal caused this node to be unnormalized.
If the adjacent siblings of the removed child were both text nodes,
flag this node as unnormalized.
perform default deseralization
hardset synchildren - so we don't try to sync - it does not make any
sense to try to synchildren when we just deserialize object.
Just for tracing purposes
send to the real writer
from here on just for tracing purposes
send to the real writer
from here on just for tracing purposes
send to the real writer
---------- from here on just collect for tracing purposes
send to the real writer
from here on just collect for tracing purposes
send to the real writer
from here on just collect for tracing purposes
We multiply the length by three since this is the maximum length
of the characters that we can put into the buffer.  It is possible
for each Unicode character to expand to three bytes.
Note, this implementation is not very efficient.
Subclasses should override this method and calculate
the results more directly.
Note, this implementation is not very efficient.
Subclasses should override this method and avoid
the allocation overhead of getClipBounds().
generic array construction
add this message to fix bug 21478
Earlier (JDK 1.4 XALAN 2.2-D11) at key code '204' the key name was ER_PRIORITY_NOT_PARSABLE
In latest Xalan code base key name is  ER_VALUE_SHOULD_BE_NUMBER. This should also be taken care
in locale specific files like XSLTErrorResources_de.java, XSLTErrorResources_fr.java etc.
NOTE: Not only the key name but message has also been changed.
Note to translators:  The following message should not normally be displayed
to users.  It describes a situation in which the processor has detected
an internal consistency problem in itself, and it provides this message
for the developer to help diagnose the problem.  The name
'ElemTemplateElement' is the name of a class, and should not be
Note to translators:  The following message should not normally be displayed
to users.  It describes a situation in which the processor has detected
an internal consistency problem in itself, and it provides this message
for the developer to help diagnose the problem.  The substitution text
provides further information in order to diagnose the problem.  The name
'RedundentExprEliminator' is the name of a class, and should not be
This code is shared with warning codes.
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "QNAME" is the XML data-type of
The following codes are shared with the warning codes...
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "ENUM" is the XML data-type of
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "NMTOKEN" is the XML data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "NCNAME" is the XML data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "boolean" is the XSLT data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "number" is the XSLT data-type
End of shared codes...
Note to translators:  A "match pattern" is a special form of XPath expression
that is used for matching patterns.  The substitution text is the name of
a function.  The message indicates that when this function is referenced in
a match pattern, its argument must be a string literal (or constant.)
ER_ARG_LITERAL - new error message for bugzilla 5202
Note to translators:  The following message indicates that two definitions of
a variable.  A "global variable" is a variable that is accessible everywher
in the stylesheet.
ER_DUPLICATE_GLOBAL_VAR - new error message for bugzilla #790
Note to translators:  The following message indicates that two definitions of
a variable were encountered.
ER_DUPLICATE_VAR - new error message for bugzilla #790
Note to translators:  "xsl:template, "name" and "match" are XSLT keywords
which must not be translated.
ER_TEMPLATE_NAME_MATCH - new error message for bugzilla #789
Note to translators:  "exclude-result-prefixes" is an XSLT keyword which
should not be translated.  The message indicates that a namespace prefix
encountered as part of the value of the exclude-result-prefixes attribute
was in error.
ER_INVALID_PREFIX - new error message for bugzilla #788
Note to translators:  An "attribute set" is a set of attributes that can
be added to an element in the output document as a group.  The message
was never defined.
ER_NO_ATTRIB_SET - new error message for bugzilla #782
Note to translators:  This message indicates that there was a reference
Note to translators:  This message indicates that the XSLT instruction
instructions (content) or a "select" attribute.  The word "select" is
an XSLT keyword in this case and must not be translated.
Note to translators:  This message indicates that the value argument
of setParameter must be a valid Java Object.
Following are the new WARNING keys added in XALAN code base after Jdk 1.4 (Xalan 2.2-D11)
Note to translators:  "name" and "xsl:processing-instruction" are keywords
and must not be translated.
Note to translators:  "name" and "xsl:processing-instruction" are keywords
and must not be translated.  "NCName" is an XML data-type and must not be
Note to translators:  This message is reported if the stylesheet that is
being processed attempted to construct an XML document with an attribute in a
place other than on an element.  The substitution text specifies the name of
Check: WHY THERE IS A GAP B/W NUMBERS in the XSLTErrorResources properties file?
Other miscellaneous text used inside the code...
Note to translators:  The following messages provide usage information
for the Xalan Process command line.  "Process" is the name of a Java class,
and should not be translated.
Note to translators: The option name and the parameter name do not need to
be translated. Only translate the messages in parentheses.  Note also that
leading whitespace in the messages is used to indent the usage information
for each option in the English messages.
Do not translate the keywords: XSLTC, SAX, DOM and DTM.
Following are the new options added in XSLTErrorResources.properties files after Jdk 1.4 (Xalan 2.2-D11)
Added by sboag/scurcuru; experimental
AddITIONAL  STRINGS that need L10n
Note to translators:  The following message describes usage of a particular
command-line option that is used to enable the "template inlining"
optimization.  The optimization involves making a copy of the code
generated for a template in another template that refers to it.
================= INFRASTRUCTURE ======================
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of InternalFramePainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of InternalFramePainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
Create a panel to wrap the textfield so that the textfields
laf border shows through.
Default to preferred.
Default to preferred.
Following are for Borders that used for Unknown tags and comments.
End of class HiddenTagView.StartTagBorder
End of class HiddenTagView.EndTagBorder
End of HiddenTagView
Action to post popup
We shall not interfere with already opened menu
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of TableHeaderPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of TableHeaderPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
Message keys used by the serializer
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The localname is the portion after the optional colon; the message indicates
that there is a problem with that part of the QNAME.
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The prefix is the portion before the optional colon; the message indicates
that there is a problem with that part of the QNAME.
Copyright (c) 1995-96 by Cisco Systems, Inc.
These should be visible in all the nested classes
Remember that this is equivalent to defaultReadObject
We were treating readFields same as defaultReadObject. It is
incorrect if the state is readOptionalData. If this line
is uncommented, it will throw a stream corrupted exception.
_REVISIT_: The ideal fix would be to add a new state. In
writeObject user may do one of the following
1. Call defaultWriteObject()
2. Put out optional fields
3. Call writeFields
We have the state defined for (1) and (2) but not for (3), so
we should ideally introduce a new state for 3 and have the
beginDefaultReadObject do nothing.
The following is a State pattern implementation of what
should be done when the sender's Serializable has a
writeObject method.  This was especially necessary for
RMI-IIOP stream format version 2.  Please see the
state diagrams in the docs directory of the workspace.
On the reader's side, the main factors are whether or not
we have a readObject method and whether or not the
sender wrote default data
Description of possible actions
This will happen for Big Integer which uses
writeFields in it's writeObject. We should be past
start_value by now.
NOTE: If we don't log any exception here we should
be fine. If there is an error, it will be caught
while reading the optional data.
XXX I18N and logging needed.
REVISIT.  If a readObject exits here without reading
default data, we won't skip it.  This could be done automatically
as in line 1492 in IIOPInputStream.
XXX I18N and logging needed.
This should never happen.
In stream format version 2, we can skip over
the optional data this way.  In stream format version 1,
we will probably wind up with an error if we're
unmarshaling a superclass.
Read the fake valuetype header in stream format version 2
Fix Date interop bug. For older versions of the ORB don't do
anything for readData(). Before this used to throw
StreamCorruptedException for older versions of the ORB where
calledDefaultWriteObject always returns true.
XXX I18N and logging needed.
This should never happen.
XXX I18N and logging needed.
Code should read default fields before calling this
XXX print backtrace of cause
XXX print backtrace of cause
XXX print backtrace of cause
null weak references to not create too many objects
do nothing, everything is done in restoreFocus()
do nothing, everything is done in restoreFocus()
Check that the component awaiting focus belongs to
the current focused window. See 8015454.
we can not accept focus on such window, so reject it.
If there exists a current focused window, then notify it
that it has lost focus.
Failed to dispatch, clear by ourselfves
Because the native libraries do not post WINDOW_ACTIVATED
events, we need to synthesize one if the active Window
Activation change was rejected. Unlikely, but
Focus change was rejected. Will happen if
newFocusedWindow is not a focusable Window.
Restore focus to the Component which last held it. We do
this here so that client code can override our choice in
a WINDOW_GAINED_FOCUS handler.
Make sure that the focus change request doesn't change the
focused Window in case we are no longer the focused Window
when the request is handled.
Identify which Component should initially gain focus
in the Window.
WINDOW_GAINED_FOCUS message which was generated by a
the FOCUS_GAINED handler. Allow the Component to
which the FOCUS_GAINED message was targeted to
receive the focus.
We don't use Window.getMostRecentFocusOwner because
window is focused now and 'null' will be returned
Calculating of most recent focus owner and focus
request should be synchronized on KeyboardFocusManager.class
to prevent from thread race when user will request
focus between calculation and our request.
But if focus transfer is synchronous, this synchronization
may cause deadlock, thus we don't synchronize this block.
The component which last has the focus when this window was focused
should receive focus first
If there is a component which requested focus when this window
was inactive it expects to receive focus after activation.
If there exists a current active window, then notify it that
it has lost activation.
Failed to dispatch, clear by ourselfves
Activation change was rejected. Unlikely, but
Activation change was rejected. Unlikely, but
We can't just drop the event - there could be
type-ahead markers associated with it.
If there exists a current focus owner, then notify it that
it has lost focus.
Failed to dispatch, clear by ourselfves
Because the native windowing system has a different notion
of the current focus and activation states, it is possible
that a Component outside of the focused Window receives a
FOCUS_GAINED event. We synthesize a WINDOW_GAINED_FOCUS
event in that case.
Focus change was rejected. Will happen if
newFocusedWindow is not a focusable Window.
Need to recover type-ahead, but don't bother
restoring focus. That was done by the
Refuse focus on a disabled component if the focus event
isn't of UNKNOWN reason (i.e. not a result of a direct request
but traversal, activation or system generated).
we should not accept focus on such component, so reject it.
If FOCUS_GAINED is for a disposed component (however
it shouldn't happen) its toplevel parent is null. In this
case we have to try to restore focus in the current focused
window (for the details: 6607170).
Focus change was rejected. Will happen if
newFocusOwner is not focus traversable.
Focus change was rejected. Unlikely, but possible.
Ignore cases where a Component loses focus to itself.
If we make a mistake because of retargeting, then the
FOCUS_GAINED handler will correct it.
Focus change was rejected. Unlikely, but possible.
Focus change was rejected. Unlikely, but possible.
The event is lost in time.
Allow listeners to precess the event but do not
change any global states
Activation change was rejected. Unlikely, but possible.
Special case -- if the native windowing system posts an
event claiming that the active Window has lost focus to the
focused Window, then discard the event. This is an artifact
of the native windowing system not knowing which Window is
The focus owner should always receive a FOCUS_LOST event
before the Window is defocused.
Focus change was rejected. Unlikely, but possible.
Then we need to deactive the active Window as well.
No need to synthesize in other cases, because
WINDOW_ACTIVATED will handle it if necessary.
Activation change was rejected. Unlikely,
Allow the peer to process KeyEvent
if focus owner is lightweight then its native container
Fixed 5064013: may appears that the events have the same time
The fix is rolled out.
Clear any pending events here as well as in the FOCUS_GAINED
handler. We need this call here in case a marker was removed in
response to a call to dequeueKeyEvents.
Fixed 5064013: may appears that the events have the same time
The fix is rolled out.
KeyEvent was posted before focus change request
Search the marker list for the first marker tied to
the Component which just gained focus. Then remove
that marker, any markers which immediately follow
and are tied to the same component, and all markers
that preceed it. This handles the case where
multiple focus requests were made for the same
Component in a row and when we lost some of the
earlier requests. Since FOCUS_GAINED events will
not be generated for these additional requests, we
need to clear those markers too.
Exception condition - event without marker
Now, dispatch any pending KeyEvents which have been
released because of the FOCUS_GAINED event so that we don't
have to wait for another event to be posted to the queue.
Explicitly set the key event timestamp here (not in Component.dispatchEventImpl):
- A key event is anyway passed to this method which starts its actual dispatching.
- If a key event is put to the type ahead queue, its time stamp should not be registered
until its dispatching actually starts (by this method).
consume processed event if needed
KEY_TYPED events cannot be focus traversal keys
Fix for 6637607: consumeNextKeyTyped should be reset.
* must be called inside a synchronized block
* if 'start' is < 0, then this function does nothing
* if 'end' is < 0, then all KeyEvents from 'start' to the end of the
queue will be removed
End of file.
@@@ check for illegal combinations of data violating MUSTs in W3c spec
convert a String to Double form, we have to take care of cases specified in spec like INF, -INF and NaN
Can't call Double#compareTo method, because it's introduced in jdk 1.2
distinguishes between identity and equality for double datatype
0.0 is equal but not identical to -0.0
NOTE: we don't distinguish 0.0 from -0.0
This check is necessary because doubleToLongBits(+0) != doubleToLongBits(-0)
NOTE: 0.0 is equal but not identical to -0.0
this < other
this > other
this == other
NOTE: we don't distinguish 0.0 from -0.0
one of the 2 values or both is/are NaN(s)
this = NaN = other
this is NaN <> other
other is NaN <> this
NOTE: we don't distinguish 0.0 from -0.0
REVISIT: use the java algorithm for now, because we
don't know what to output for 1.1d (which is no
if it contains 'E', then it should be a valid schema
at most 3 longer: E, -, 9
expected decimal point position
for non-zero integer part
decimal point position
move the digits: ddd.d --> d.ddd
trim trailing zeros: d00.0 --> d.000 --> d.
add the last zero if necessary: d. --> d.0
append E: d.dd --> d.ddE
how far we shifted the decimal point
append the exponent --> d.ddEd
the exponent is at most 7
non-zero digit point
skip zeros: 0.003
put the first non-zero digit to the left of '.'
move other digits (non-zero) to the right of '.'
adjust the length
append 0 if nessary: 0.03 --> 3. --> 3.0
append E-: d.dd --> d.ddE-
how far we shifted the decimal point
append the exponent --> d.ddEd
the exponent is at most 3
"Z" is always in the cache
parse - +h, +hh, +hhmm, +hh:mm, +hhmmss, +hh:mm:ss
override for Javadoc
override for Javadoc and performance
compress to -72 to +72
Some places assume margins are non-null.
layout the text and icon
imports for javadoc
The EncryptedKey being built (part of a WRAP operation) or read
(part of an UNWRAP operation)
The EncryptedData being built (part of a WRAP operation) or read
(part of an UNWRAP operation)
Create a canonicalizer - used when serializing DOM to octets
prior to encryption (and for the reverse)
The default is to preserve the physical representation.
Now create the working cipher if none was created already
Now perform the encryption
The Spec mandates a 96-bit IV for GCM algorithms
Now build up to a properly XML Encryption encoded octet stream
Now create the working cipher
Now perform the encryption
Should internally generate an IV
todo - allow user to set an IV
Obtain the encrypted octets
Now create the working cipher
Check to see if an RSA OAEP MGF-1 with SHA-1 algorithm was requested
Some JDKs don't support RSA/ECB/OAEPPadding
The de-serialiser returns a node whose children we need to take on.
If this is a content decryption, this may have problems
Add an EncryptedKey resolver
Obtain the encrypted octets
Now create the working cipher
Calculate the IV length and copy out
For now, we only work with Block ciphers, so this will work.
This should probably be put into the JCE mapper.
You may be able to pass the entire piece in to IvParameterSpec
and it will only take the first x bytes, but no way to be certain
that this will work for every JCE provider, so lets copy the
necessary bytes into a dedicated array.
Find any Transforms
Need to get the last CipherData found, as earlier ones will
be for elements in the KeyInfo lists
BFL 16/7/03 - simple implementation
TODO: Work out how to handle relative URI
TODO: Make this mess work
<any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
TODO: Make this lot work...
TODO: Make this work...
<any namespace='##other' processContents='lax'/>
TODO: figure out the anyAttribyte stuff...
TODO: figure out the any stuff...
Over-ride the namespace
TODO: Need to martial referenceInformation
Figure out how to make this work..
<any namespace="##other" minOccurs="0" maxOccurs="unbounded"/>
BEGIN: Keys needed for exception messages of  JAXP 1.3 XPath API implementation
END: Keys needed for exception messages of  JAXP 1.3 XPath API implementation
Note to translators:  A relative location path is a form of XPath expression.
The message indicates that such an expression was expected following the
characters '/' or '', but was not found.
Note to translators:  A location path is a form of XPath expression.
The message indicates that syntactically such an expression was expected,but
the characters specified by the substitution text were encountered instead.
Note to translators:  A location path is a form of XPath expression.
The message indicates that syntactically such a subexpression was expected,
but no more characters were found in the expression.
Note to translators:  A location step is part of an XPath expression.
The message indicates that syntactically such an expression was expected
following the specified characters.
Note to translators:  A node test is part of an XPath expression that is
used to test for particular kinds of nodes.  In this case, a node test that
consists of an NCName followed by a colon and an asterisk or that consists
of a QName was expected, but was not found.
Note to translators:  A step pattern is part of an XPath expression.
The message indicates that syntactically such an expression was expected,
but the specified character was found in the expression instead.
Note to translators: A relative path pattern is part of an XPath expression.
The message indicates that syntactically such an expression was expected,
but was not found.
Note to translators:  The substitution text is the name of a data type.  The
message indicates that a value of a particular type could not be converted
to a value of type boolean.
Note to translators: Do not translate ANY_UNORDERED_NODE_TYPE and
Note to translators: Do not translate UNORDERED_NODE_SNAPSHOT_TYPE and
Note to translators: This message indicates that the document being operated
upon changed, so the iterator object that was being used to traverse the
document has now become invalid.
Note to translators:  The substitution text is the name of a data type.  The
message indicates that a value of a particular type could not be converted
to a value of type string.
Note to translators: Do not translate snapshotItem,
UNORDERED_NODE_SNAPSHOT_TYPE and ORDERED_NODE_SNAPSHOT_TYPE.
Note to translators:  XPathEvaluator is a Java interface name.  An
XPathEvaluator is created with respect to a particular XML document, and in
this case the expression represented by this object was being evaluated with
respect to a context node from a different document.
Note to translators:  The XPath expression cannot be evaluated with respect
to this type of node.
BEGIN:  Definitions of error keys used  in exception messages of  JAXP 1.3 XPath API implementation
END:  Definitions of error keys used  in exception messages of  JAXP 1.3 XPath API implementation
Other miscellaneous text used inside the code...
================= INFRASTRUCTURE ======================
Update icon layout if frame is already iconified
Force future UI to relayout icon
This will cause DefaultDesktopManager to layout the icon
Move aside to allow fresh layout of all icons
_x & _y are the mousePressed location in absolute coordinate system
__x & __y are the mousePressed location in source view's coordinate system
(STEVE) Yucky work around for bug ID 4106552
Make sure we stay in-bounds
this chains the collision list of table "map"
this chains the collision list of table "rmap"
size must be power of 2
now rehash the entries into the new table
these are the "supplemental hash function" copied from
java.util.HashMap, supposed to be "critical"
if we get here we are trying to put in the same key/val pair
this is a no-op, so we just return
this means the key is not present in our table
then it shouldnt be present in our reverse table either
The old code was optimized to try to guess which way to load classes
first.  The real stub class name could either be className or
"org.omg.stub." + className.  We will compute this as follows:
If stubName starts with a "forbidden" package, try the prefixed
version first, otherwise try the non-prefixed version first.
In any case, try both forms if necessary.
log only at FINE level
XXX Is this step necessary, or should the Util.loadClass
algorithm always produce a valid class if the setup is correct?
Does the OMG standard algorithm need to be changed to include
XXX make this a system exception
XXX log exceptions at FINE level
_REVISIT_ The spec does not specify a loadingContext parameter for
the following call.  Would it be useful to pass one?
The name of the variable.
The escaped qname of the variable.
The type of this variable.
True if the variable is local.
Reference to JVM variable
Instruction to load JVM variable
Instruction to load JVM variable
Reference to variable expression
Textual repr. of variable expr.
References to this variable (when local)
Used to make sure parameter field is not added twice
TODO: namespace ?
Get the 'name attribute
Check whether variable/param of the same name is already in scope
Children must be parsed first -> static scoping
Compile expression is 'select' attribute if present
Create a CachedNodeListIterator for select expressions
in a variable or parameter.
If not, compile result tree from parameter body if present.
If neither are present then store empty string in variable
We're using volatile here to avoid synchronizing getters, which
would prevent other threads from calling isLoggable()
while publish() is executing.
On the other hand, setters will be synchronized to exclude concurrent
execution with more complex methods, such as StreamHandler.publish().
We wouldn't want 'level' to be changed by another thread in the middle
of the execution of a 'publish' call.
Package private support for security checking.  When sealed
is true, we access check updates to the class.
Check for a null pointer:
Package-private support method for security checks.
If "sealed" is true, we check that the caller has
appropriate security privileges to update Handler
state and if not throw a SecurityException.
NOTE: MetalCheckBoxUI inherts from MetalRadioButtonUI instead
of BasicCheckBoxUI because we want to pick up all the
painting changes made in MetalRadioButtonUI.
start the content model: did not see any children
restore content model state:
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
read and discard the repository ID
write the repository ID
We shouldn't have to do this, but just in case.
This may happen if the caller tries to use
an encoding that wasn't registered in the
(java name)->(preferred mime name) mapping file.
In that case we attempt to load the charset for the
given encoding, and if that succeeds - we create a new
EncodingInfo instance - assuming the canonical name
of the charset can be used as the mime name.
is the character a lower case ASCII one?
a cheap and fast way to uppercase that is good enough
the uppercased String is different
A little optimization, don't call String.valueOf() if
the uppercased string is the same as the input string.
Get the default system character encoding.  This may be
incorrect if they passed in a writer, but right now there
seems to be no way to get the encoding from a writer.
Using an inner static class here prevent initialization races
where the hash maps could be used before they were populated.
These maps are final and not modified after initialization.
This map will be added to after initialization: make sure it's
thread-safe. This map should not be used frequently - only in cases
where the mapping requested was not declared in the Encodings.properties
Opens the file/resource containing java charset name -> preferred mime
name mapping and returns it as an InputStream.
Loads the Properties resource containing the mapping:
java charset name -> preferred mime name
and returns it.
Seems to be no real need to force failure here, let the
system do its best... The issue is not really very critical,
and the output will be in any case _correct_ though maybe not
always human-friendly... :)
But maybe report/log the resource problem?
Any standard ways to report/log errors (in static context)?
Parses the mime list associated to a java charset name.
The first mime name in the list is supposed to be the preferred
Maybe report/log this problem?
"Last printable character not defined for encoding " +
mimeName + " (" + val + ")" ...
This method here attempts to find the canonical charset name for the
the given name - which is supposed to be either a java name or a mime
For that, it attempts to load the charset using the given name, and
then returns the charset's canonical name.
If the charset could not be loaded from the given name,
the method returns null.
This method here attempts to find the canonical charset name for the
the set javaName+mimeNames - which are supposed to all refer to the
For that it attempts to load the charset using the javaName, and if
not found, attempts again using each of the mime names in turn.
If the charset could be loaded from the javaName, then the javaName
itself is returned as charset name. Otherwise, each of the mime names
is tried in turn, until a charset can be loaded from one of the names,
and the loaded charset's canonical name is returned.
If no charset can be loaded from either the javaName or one of the
mime names, then null is returned.
Note that the returned name is the 'java' name that will be used in
instances of EncodingInfo.
This is important because EncodingInfo uses that 'java name' later on
in calls to String.getBytes(javaName).
As it happens, sometimes only one element of the set mime names/javaName
is known by Charset: sometimes only one of the mime names is known,
sometime only the javaName is known, sometimes all are known.
By using this method here, we fix the problem where one of the mime
names is known but the javaName is unknown, by associating the charset
loaded from one of the mime names with the unrecognized javaName.
When none of the mime names or javaName are known - there's not much we can
do... It can mean that this encoding is not supported for this
OS. If such a charset is ever use it will result in having all characters
load (java name)->(preferred mime name) mapping.
create instances of EncodingInfo from the loaded mapping
canonicals will map the charset name to
the info containing the prefered mime name
(the preferred mime name is the first mime
name in the list).
None of the java or mime names on the line were
recognized => this charset is not supported?
Fix up the _encodingTableKeyJava so that the info mapped to
the java name contains the preferred mime name.
(a given java name can correspond to several mime name,
but we want the _encodingTableKeyJava to point to the
preferred mime name).
is specified to only occur when the engine is not initialized
this case should never occur as it is caught in Signature.java
Constructors and Factories
Field Accessor Methods
Version is bits masked by 0x000000000000F000 in MS long
This field is composed of a varying number of bits.
0    -    -    Reserved for NCS backward compatibility
1    0    -    The IETF aka Leach-Salz variant (used by this class)
1    1    0    Reserved, Microsoft backward compatibility
1    1    1    Reserved for future definition.
Object Inherited Methods
The ordering is intentionally set up so that the UUIDs
can simply be numerically compared as two numbers
no need to sync in the future
extract prefix and local part from QName
returns true iff the given prefix is bound to "" *and*
this is disallowed by the version of XML namespaces in use.
prefixBoundToNullURI(String, String):  boolean
Message keys used by the serializer
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The localname is the portion after the optional colon; the message indicates
that there is a problem with that part of the QNAME.
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The prefix is the portion before the optional colon; the message indicates
that there is a problem with that part of the QNAME.
add a named style, a class of attributes
PENDING(prinz) add cache behavior
haven't seen this one yet.
The Toolkit implementations cache, so we just forward
to the default toolkit.
--- AttributeContext methods --------------------
build a search key and find/create an immutable and unique
build a search key and find/create an immutable and unique
build a search key and find/create an immutable and unique
build a search key and find/create an immutable and unique
build a search key and find/create an immutable and unique
force WeakHashMap to expunge stale entries
if current thread is not event dispatching thread
do not bother with expunging stale entries.
--- local methods -----------------------------------------------
force WeakHashMap to expunge stale entries
PENDING(prinz) should consider finding a alternative to
generating extra garbage on search key.
--- serialization ---------------------------------------------
clean out unused sets before saving
--- variables ---------------------------------------------------
--- Object methods -------------------------
--- AttributeSet methods ----------------------------
--- variables -----------------------------------------
This is also stored in attributes
avoid searching the keys, they are already interned.
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
--- AttributeSet ----------------------------
delegated to the immutable field "attributes"
--- MutableAttributeSet ----------------------------------
should fetch a new immutable record for the field
--- serialization ---------------------------------------------
--- member variables -----------------------------------------------
initialize the static key registry with the StyleConstants keys
The direction of traversal (default to DOWN).
DOWN is for child and descendant. UP is for parent and ancestor.
Increase the node ID for down traversal. Also match the node type
if the type is given.
Decrease the node ID for up traversal.
Increase the node ID by 1 if self is not included.
END of SimpleIterator
END of SingletonIterator
empty iterator to be returned when there are no children
The root node id of the simple RTF
The Text node id of the simple RTF (simple RTF has only one Text node).
The number of nodes.
Document URI index, which increases by 1 at each getDocumentURI() call.
Constant for empty String
The String value of the Text node.
This is set at the endDocument() call.
The array of Text items, which is built by the characters() call.
The characters() interface can be called multiple times. Each character item
can have different escape settings.
Number of character items
The document ID
A BitArray, each bit holding the escape setting for a character item.
The current escape setting
Create a SimpleResultTreeImpl from a DTMManager and a document ID.
Return the document ID
Return the String value of the RTF
Return the axis iterator for a given axis.
The SimpleIterator is used for the child, descendant, parent and ancestor axes.
%REVISIT% Can this one ever get used?
%REVISIT% Can this one ever get used?
Return the expanded type id of a given node
%REVISIT% Can the makeNode() and makeNodeList() interfaces ever get used?
Set the String value when the document is built.
Resize the text array if necessary
If the escape setting is false, set the corresponding bit in
the _dontEscape BitArray.
The _dontEscape array is only created when needed.
Resize the _dontEscape array if necessary
An array to hold the argument for a method of Charset, CharsetEncoder or CharToByteConverter.
preferably a MIME name, but aliases are fine too.
The CharsetEncoder with which we test unusual characters.
The CharToByteConverter with which we test unusual characters.
Is the converter null because it can't be instantiated
for some reason (perhaps we're running with insufficient authority as
Is the charset encoder usable or available.
this should always be true!
use UTF-8 as preferred encoding
Attempt to get a CharsetEncoder for this encoding.
try and create the CharsetEncoder
This charset cannot be used for encoding, don't try it again...
don't try it again...
Attempt to use the CharsetEncoder to determine whether the character is printable.
obviously can't use this charset encoder; possibly a JDK bug
As a last resort try to use a sun.io.CharToByteConverter to
determine whether this character is printable. We will always
reach here on JDK 1.3 or below.
forget it; nothing we can do...
try and create the CharToByteConverter
don't try it again...
obviously can't use this converter; probably some kind of
is this an encoding name recognized by this JDK?
if not, will throw UnsupportedEncodingException
Flag indicating whether or not java.nio.charset.* is available.
Attempt to get methods for Charset and CharsetEncoder on class initialization.
ClassNotFoundException, NoSuchMethodException or SecurityException
Whatever the case, we cannot use java.nio.charset.*.
Flag indicating whether or not sun.io.CharToByteConverter is available.
Attempt to get methods for char to byte converter on class initialization.
ClassNotFoundException, NoSuchMethodException or SecurityException
Whatever the case, we cannot use sun.io.CharToByteConverter.
Use special constructor which takes over "buf".
I use the "invariant division by multiplication" trick to
accelerate Integer.toString.  In particular we want to
avoid division by 10.
The "trick" has roughly the same performance characteristics
as the "classic" Integer.toString code on a non-JIT VM.
The trick avoids .rem and .div calls but has a longer code
path and is thus dominated by dispatch overhead.  In the
JIT case the dispatch overhead doesn't exist and the
"trick" is considerably faster than the classic code.
TODO-FIXME: convert (x * 52429) into the equiv shift-add
RE:  Division by Invariant Integers using Multiplication
T Gralund, P Montgomery
ACM PLDI 1994
Generate two digits per iteration
Fall thru to fast mode for smaller numbers
r = i-(q*10) ...
Requires positive x
Possible leading "+" or "-"
Cannot have lone "+" or "-"
Accumulating negatively avoids surprises near MAX_VALUE
Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits
Integer.MAX_VALUE in base 10 is 10 digits
high value may be configured by property
Maximum array size is Integer.MAX_VALUE
If the property cannot be parsed into an int, ignore it.
range [-128, 127] must be interned (JLS7 5.1.7)
Handle sign, if present
Handle radix specifier, if present
If number is Integer.MIN_VALUE, we'll end up here. The next line
handles this case, and causes any genuine format error to be
In lieu of tricky code, for now just use long arithmetic.
In lieu of tricky code, for now just use long arithmetic.
HD, Figure 3-1
HD, Section 2-1
HD, Figure 5-6
HD, Figure 5-14
HD, Figure 5-2
HD, Figure 7-1
HD, Section 2-7
Find the appropriate constructor in cls
get the ID from the public static final int SERVICE_CONTEXT_ID
End of file.
made this class public so it can be accessed by
the XS content models from the schema package -neilg.
Store the required bit count and insure its legal
See if we need to allocate the byte array or whether we can live
within the 64 bit high performance scheme.
Init all the bits to zero
Public inherited methods
We know this won't happen but we have to catch it to avoid it
having to be in our 'throws' list.
Package final methods
the XS content models from the schema package -neilg.
Create the mask and byte values
And access the right bit and byte
the XS content models from the schema package -neilg.
Create the mask and byte values
And access the right bit and byte
the XS content models from the schema package -neilg.
They have to be the same size
had to make this method public so it could be accessed from
schema package - neilg.
Private data members
The count of bits that the outside world wants to support,
so its the max bit index plus one.
If the bit count is > 64, then we use the fByteArray member to
store the bits, and this indicates its size in bytes. Otherwise
its value is meaningless.
When the bit count is < 64 (very common), these hold the bits.
Otherwise, the fByteArray member holds htem.
set flag for GIF as NOT tiff
Check header magic
Check compression method
Skip MTIME, XFL, and OS fields
Skip optional extra field
Skip optional file name
Skip optional file comment
Check optional header CRC
Uses left-to-right evaluation order
rfc1952; ISIZE is the input size modulo 2^32
If there are more bytes available in "in" or
the leftover in the "inf" is > 26 bytes:
this.trailer(8) + next.header.min(10) + next.trailer(8)
try concatenated case
ignore any malformed, do nothing
This can only happen when the cache hits 16 terabytes of
We've already got enough data cached
we've filled the current buffer, so a new one will be
allocated next time around (and offset will be reset to 0)
Fix 4430357 - if off + len < 0, overflow occurred
Ensure there is space for the incoming data
Copy the data into the cache, block by block
Always after the first time
Ensure there is space for the incoming data
Insert the data.
Fix 4430357 - if off + len < 0, overflow occurred
Always after the first time
If uri is "" then ignore prefix
final int index =
(localName == null || uri == null) ?
the attribute doesn't exist yet, create it
do nothing (base behavior)
_cdataStack.push(new Integer(-1));  push dummy value
default behavior is to do nothing
loop through 2 at a time, as these are pairs of URI and localName
If this transformer object implements the SerializerTrace interface
then assign m_tracer to the transformer object so it can be used
to fire trace events.
protected void fireCharEvent(char[] chars, int start, int length)
if (m_tracer != null)
we do not need to handle this.
protected void fireEndElem(String name)
if (m_tracer != null)
if we do get called with startDocument(), handle it right away
don't set writer to null, so that it might be re-used
This method just provides a definition to satisfy the interface
A particular sub-class of SerializerBase provides the implementation (if desired)
This method just provides a definition to satisfy the interface
A particular sub-class of SerializerBase provides the implementation (if desired)
This method just provides a definition to satisfy the interface
A particular sub-class of SerializerBase provides the implementation (if desired)
If last is null, we're in the constructor. If we're in
the constructor we don't want to call to overridable methods.
Currently unsorted, use sort so that internal fields
are correctly set.
Key doesn't exist
It's the primary sorting key, toggle it
It's not the first, but was sorted on, remove old
entry, insert as first with ascending.
sort the data
Update the modelToView array
No filter & unsorted
sorted -> unsorted
unsorted -> unsorted
No need to do anything.
There is filter, reset mappings
Update the modelToView array
Update model -> view
Update view -> model
Returns the Comparator to use during sorting.  Where as
getComparator() may return null, this will never return null.
This should be ok as useToString(column) should have returned
true in this case.
When filtering this may differ from getModelWrapper().getRowCount()
Keys are already empty, to force a resort we have to
null filter, always include the row.
v1 != null && v2 != null
Treat nulls as < then non-null
If we get here, they're equal. Fallback to model order.
Not transformed, nothing to do.
We either weren't sorted, or to much changed, sort it all
Build the list of Rows to add into added
Adjust the model index of rows after the effected region
Insert newly added rows into viewToModel
Notify of change
Figure out how many visible rows are going to be effected.
Update the model index of rows after the effected region
Then patch up the viewToModel array
Update the modelToView mapping
And notify of change
Remove the effected rows
Sort the update rows
Build the intermediary array: the array of
viewToModel without the effected rows.
Build the new viewToModel
Sorting & filtering.
Remove the effected rows, adding them to updated and setting
modelToView to -2 for any rows that were not filtered out
This row was filtered out
No longer filtered
This row was visible, make sure it should still be
Sort the updated rows
Build the intermediary array: the array of
viewToModel without the updated rows.
Recreate viewToModel, if necessary
Rebuild the new viewToModel array
And finally fire a sort event.
NOTE: this class is static so that it can be placed in an array
why have these ?
cached values computed from GlyphSets and set info:
all are recomputed from scratch in buildCache()
This value is obtained from an attribute, and constrained to the
interval [0,1].  If 0, the layout cannot be justified.
If a layout is produced by justification, then that layout
cannot be justified.  To enforce this constraint the
justifyRatio of the justified layout is set to this value.
dx and dy specify the distance between the TextLayout's origin
and the origin of the leftmost GlyphSet (TextLayoutComponent,
actually).  They were used for hanging punctuation support,
which is no longer implemented.  Currently they are both always 0,
and TextLayout is not guaranteed to work with non-zero dx, dy
values right now.  They were left in as an aide and reminder to
anyone who implements hanging punctuation or other similar stuff.
They are static now so they don't take up space in TextLayout
default implementation just calls private method on layout
normalize to current baseline
set paragraph attributes
If there's an embedded graphic at the start of the
paragraph, look for the first non-graphic character
and use it and its font to initialize the paragraph.
If not, use the first graphic to initialize.
hmmm what to do here?  Just try to supply reasonable
values I guess.
naturalBounds, boundsRect will be generated on demand
hashCode will be regenerated on demand
make sure textLine is not null
default justification range to exclude trailing logical whitespace
this version provides extra info in the float array
the first two values are as above
the next four values are the endpoints of the caret, as computed
using the hit character's offset (baseline + ssoffset) and
natural ascent and descent.
these  values are trimmed to the bounds where required to fit,
but otherwise independent of it.
get old data first
then add our new data
!!! note: want non-shifted, baseline ascent and descent here!
TextLine should return appropriate line metrics object for these values
this is a graphic, no italics, use entire line height for caret
!!! top/bottom adjustment not implemented for vertical
At this point, the leading edge of the character
at offset is at the given caret.
at left end
at right end
values are there to make compiler happy
y0 <= y1, always
x0 <= x1, always
right now we're using the following rule for strong hits:
A hit on a character with a lower level
is stronger than one on a character with a higher level.
If this rule ties, the hit on the leading edge of a character wins.
If THIS rule ties, hit1 wins.  Both rules shouldn't tie, unless the
infos aren't counterparts of some sort.
hmm, allow indices at endpoints?  For now, yes.
more than one caret
then other is weak
A utility to return a path enclosing the given path
Path0 must be left or top of path1
Really, we want the path to be a convex hull around all of the
points in path0 and path1.  But we can get by with less than
that.  We do need to prevent the two segments which
join path0 to path1 from crossing each other.  So, if we
traverse path0 from top to bottom, we'll traverse path1 from
bottom to top (and vice versa).
A utility to convert a pair of carets into a bounding path
!!! probably want to optimize for all LTR text
dlf cast safe?
would this ever not handle all cases?
now create paths for pairs of carets
dlf cast safe?
distanceOffBaseline is negative if you're 'above' baseline
check boundary conditions
revised hit test
the original seems too complex and fails miserably with italic offsets
the natural tendency is to move towards the character you want to hit
so we'll just measure distance to the center of each character's visual
bounds, pick the closest one, then see which side of the character's
center line (italic) the point is on.
this tends to make it easier to hit narrow characters, which can be a
bit odd if you're visually over an adjacent wide character. this makes
a difference with bidi, so perhaps i need to revisit this yet again.
just work around baseline mess for now
proximity in x (along baseline) is two times as important as proximity in y
current implementation doesn't support multiple baselines
Andorra, Principality of
United Arab Emirates
Antigua and Barbuda
Albania, People's Socialist Republic of
Angola, Republic of
Antarctica (the territory South of 60 deg S)
Argentina, Argentine Republic
Austria, Republic of
Australia, Commonwealth of
Azerbaijan, Republic of
Bosnia and Herzegovina
Bangladesh, People's Republic of
Belgium, Kingdom of
Bulgaria, People's Republic of
Bahrain, Kingdom of
Burundi, Republic of
Benin, People's Republic of
Bolivia, Republic of
Bonaire, Sint Eustatius and Saba
Brazil, Federative Republic of
Bahamas, Commonwealth of the
Bhutan, Kingdom of
Bouvet Island (Bouvetoya)
Botswana, Republic of
Cocos (Keeling) Islands
Congo, Democratic Republic of
Central African Republic
Congo, People's Republic of
Switzerland, Swiss Confederation
Cote D'Ivoire, Ivory Coast, Republic of the
Chile, Republic of
Cameroon, United Republic of
China, People's Republic of
Colombia, Republic of
Costa Rica, Republic of
+ "CS" + "SCG"   Serbia and Montenegro
Cuba, Republic of
Cape Verde, Republic of
Cyprus, Republic of
Djibouti, Republic of
Denmark, Kingdom of
Dominica, Commonwealth of
Algeria, People's Democratic Republic of
Ecuador, Republic of
Egypt, Arab Republic of
Spain, Spanish State
Finland, Republic of
Fiji, Republic of the Fiji Islands
Falkland Islands (Malvinas)
Micronesia, Federated States of
France, French Republic
Gabon, Gabonese Republic
United Kingdom of Great Britain & N. Ireland
Ghana, Republic of
Gambia, Republic of the
Guinea, Revolutionary People's Rep'c of
Equatorial Guinea, Republic of
Greece, Hellenic Republic
South Georgia and the South Sandwich Islands
Guatemala, Republic of
Guinea-Bissau, Republic of
Guyana, Republic of
Hong Kong, Special Administrative Region of China
Heard and McDonald Islands
Honduras, Republic of
Haiti, Republic of
Hungary, Hungarian People's Republic
Indonesia, Republic of
Israel, State of
Isle of Man
India, Republic of
British Indian Ocean Territory (Chagos Archipelago)
Iraq, Republic of
Iran, Islamic Republic of
Iceland, Republic of
Italy, Italian Republic
Jordan, Hashemite Kingdom of
Kenya, Republic of
Cambodia, Kingdom of
Kiribati, Republic of
Comoros, Union of the
St. Kitts and Nevis
Korea, Democratic People's Republic of
Korea, Republic of
Kuwait, State of
Kazakhstan, Republic of
Lao People's Democratic Republic
Lebanon, Lebanese Republic
Liechtenstein, Principality of
Sri Lanka, Democratic Socialist Republic of
Liberia, Republic of
Lesotho, Kingdom of
Luxembourg, Grand Duchy of
Libyan Arab Jamahiriya
Morocco, Kingdom of
Monaco, Principality of
Moldova, Republic of
Montenegro, Republic of
Madagascar, Republic of
Macedonia, the former Yugoslav Republic of
Mali, Republic of
Mongolia, Mongolian People's Republic
Macao, Special Administrative Region of China
Northern Mariana Islands
Mauritania, Islamic Republic of
Malta, Republic of
Maldives, Republic of
Malawi, Republic of
Mexico, United Mexican States
Mozambique, People's Republic of
Niger, Republic of the
Nigeria, Federal Republic of
Nicaragua, Republic of
Netherlands, Kingdom of the
Norway, Kingdom of
Nepal, Kingdom of
Nauru, Republic of
Niue, Republic of
Oman, Sultanate of
Panama, Republic of
Peru, Republic of
Papua New Guinea
Philippines, Republic of the
Pakistan, Islamic Republic of
Poland, Republic of Poland
St. Pierre and Miquelon
Palestinian Territory, Occupied
Portugal, Portuguese Republic
Paraguay, Republic of
Qatar, State of
Romania, Socialist Republic of
Serbia, Republic of
Rwanda, Rwandese Republic
Saudi Arabia, Kingdom of
Seychelles, Republic of
Sudan, Democratic Republic of the
Sweden, Kingdom of
Singapore, Republic of
Svalbard & Jan Mayen Islands
Slovakia (Slovak Republic)
Sierra Leone, Republic of
San Marino, Republic of
Senegal, Republic of
Somalia, Somali Republic
Suriname, Republic of
Sao Tome and Principe, Democratic Republic of
El Salvador, Republic of
Sint Maarten (Dutch part)
Syrian Arab Republic
Swaziland, Kingdom of
Turks and Caicos Islands
Chad, Republic of
French Southern Territories
Togo, Togolese Republic
Thailand, Kingdom of
Tokelau (Tokelau Islands)
Timor-Leste, Democratic Republic of
Tunisia, Republic of
Tonga, Kingdom of
Turkey, Republic of
Trinidad and Tobago, Republic of
Taiwan, Province of China
Tanzania, United Republic of
Uganda, Republic of
United States Minor Outlying Islands
United States of America
Uruguay, Eastern Republic of
Holy See (Vatican City State)
St. Vincent and the Grenadines
Venezuela, Bolivarian Republic of
British Virgin Islands
US Virgin Islands
Viet Nam, Socialist Republic of
Wallis and Futuna Islands
Samoa, Independent State of
South Africa, Republic of
Zambia, Republic of
Flags that can be used to control getBeanInfo:
Static Caches to speed up introspection.
These should be removed.
Methods maps from Method names to MethodDescriptors
properties maps from String names to PropertyDescriptors
events maps from String names to EventSetDescriptors
Same parameters to take advantage of caching.
Old behaviour: Make an independent copy of the BeanInfo.
Private implementation methods
Check stopClass is a superClass of startClass.
the evaluation order here is import, as we evaluate the
event sets and locate PropertyChangeListeners before we
look for properties.
Check if the bean has its own BeanInfo that will provide
We have no explicit BeanInfo properties.  Check with our parent.
Add the explicit BeanInfo data to our results.
Apply some reflection to the current class.
First get an array of all the public methods at this level
Now analyze each method.
skip static methods.
Optimization. Don't bother with invalid propertyNames.
This happens if a PropertyDescriptor or IndexedPropertyDescriptor
constructor fins that the method violates details of the deisgn
pattern, e.g. by having an empty name, or a getter returning
void , or whatever.
If this class or one of its base classes is a PropertyChange
source, then we assume that any properties we discover are "bound".
Allocate and populate the result array.
Set the default index.
replace existing property descriptor
only if we have types to resolve
in the context of this.beanClass
First pass. Find the latest getter method. Merge properties
of previous getter methods.
Don't replace the existing read
method if it starts with "is"
Second pass. Find the latest setter method which
has the same type as the getter method.
At this stage we should have either PDs or IPDs for the
representative getters and setters. The order at which the
property descriptors are determined represent the
precedence of the property ordering.
Complete indexed properties set
Merge any classic property descriptors
Complete simple properties set
Merge any classic property descriptors
Merge any classic property descriptors
Very special case to ensure that an IndexedPropertyDescriptor
doesn't contain less information than the enclosed
PropertyDescriptor. If it does, then recreate as a
PropertyDescriptor. See 4168833
Find the first property descriptor
which does not have getter and setter methods.
See regression bug 4984912.
Cannot merge the pd because of type mismatch
Return the most specific pd
Try to add methods which may have been lost in the type change
no consequences for failure.
no consequences for failure.
Handle regular pd merge
Handle regular ipd merge
Check if the bean has its own BeanInfo that will provide
We have no explicit BeanInfo events.  Check with our parent.
Add the explicit explicitBeanInfo data to our results.
Apply some reflection to the current class.
Get an array of all the public beans methods at this level
Find all suitable "add", "remove" and "get" Listener methods
The name of the listener type is the key for these hashtables
skip static methods.
Optimization avoid getParameterTypes
Now look for matching addFooListener+removeFooListener pairs.
Bonus if there is a matching getFooListeners method as well.
Skip any "add" which doesn't have a matching "remove" or
a listener name that doesn't end with Listener
generate a list of Method objects for each of the target methods:
If the adder method throws the TooManyListenersException then it
is a Unicast event source.
if (adds != null ...
Allocate and populate the result array.
Set the default index.
Check if the bean has its own BeanInfo that will provide
We have no explicit BeanInfo methods.  Check with our parent.
Add the explicit explicitBeanInfo data to our results.
Apply some reflection to the current class.
First get an array of all the beans methods at this level
Now analyze each method.
Allocate and populate the result array.
We have to be careful here to distinguish method by both name
and argument lists.
This method gets called a *lot, so we try to be efficient.
This is the common case.
We have a collision on method names.  This is rare.
Check if old and md have the same type.
We have a collision on method names with different type signatures.
This is very rare.
Use explicit info, if available,
OK, fabricate a default BeanDescriptor.
Each customizer should inherit java.awt.Component and implement java.beans.Customizer
according to the section 9.3 of JavaBeans&trade; specification
ignore any exceptions
We assume that a method is an event handler if it has a single
argument, whose type inherit from java.util.Event.
Looking up Class.getDeclaredMethods is relatively expensive,
so we cache the results.
ignore methods declared elsewhere
ignore methods from superclasses
commented out because of 6976577
result[i] = null;  ignore inaccessible methods
Package private support methods.
For overriden methods we need to find the most derived version.
So we start with the given class and walk up the superclass chain.
make sure method signature matches.
Now check any inherited interfaces.  This is necessary both when
the argument class is itself an interface, and when the argument
class is an abstract class.
Note: The original implementation had both methods calling
the 3 arg method. This is preserved but perhaps it should
pass the args array instead of null.
We rely on the fact that for any given java class or
primtitive type there is a unqiue Class object, so
we can use object equivalence in the comparisons.
First check with sibling's classloader (if any).
end class Introspector
NOTE: Don't rely on this class staying in this location. It is likely
to move to a different package in the future.
Check if the current UI is WindowsLookAndfeel and flush the XP style map.
Note: Change the package test if this class is moved to a different package.
The only sure fire way to clear our references is to create a
Thread and wait for a reference to be added to the queue.
Because it is so rare that you will actually change the look
and feel, this stepped is forgoed and a middle ground of
flushing references from the constructor is instead done.
The implication is that once one DesktopProperty is created
there will most likely be n (number of DesktopProperties created
by the LookAndFeel) WeakPCLs around, but this number will not
grow past n.
The property was GC'ed, we're no longer interested in
PropertyChanges, remove the listener.
Default to System.out, autoflushing
Read our simplistic input args, if supplied
Use user-specified output writer if non-null
Setup a hash to store various environment information in
Check for ERROR keys in the hashtable, and print report
Note: many logMsg calls have # at the start to
fake a property-file like output
Setup a hash to store various environment information in
Call various worker methods to fill in the hash
These are explicitly separate for maintenance and so
advanced users could call them standalone
Fake the Properties-like output
Special processing for classes found..
..normal processing for all other entries
Note: we could just check for the ERROR key by itself,
since we now set that, but since we have to go
through the whole hash anyway, do it this way,
which is safer for maintenance
Serializer (shared between Xalan & Xerces)
Special processing for classes found..
..normal processing for all other entries
Note: we could just check for the ERROR key by itself,
since we now set that, but since we have to go
through the whole hash anyway, do it this way,
which is safer for maintenance
end of for...
Grab java version for later use
For applet context, etc.
Printout jar files on classpath(s) that may affect operation
Do this in order
This is present in all JVM's
Also check for JDK 1.2+ type classpaths
@todo NOTE: We don't actually search java.ext.dirs for
*.jar files therein! This should be updated
@todo also check other System properties' paths?
v2 = checkPathForJars(System.getProperty("sun.boot.library.path"), jarNames);    ?? may not be needed
v3 = checkPathForJars(System.getProperty("java.library.path"), jarNames);    ?? may not be needed
For applet context, etc.
Look at each classpath entry for each of our requested jarNames
If any requested jarName exists, report on
the details of that .jar file
Note "-" char is looked for in appendFoundJars
We won't bother reporting on the xalan.jar apparent version
since this requires knowing the jar size of the xalan.jar
before we build it.
For other jars, eg. xml-apis.jar and xercesImpl.jar, we
report the apparent version of the file we've found
Note "-" char is looked for in appendFoundJars
If we found a matching size and it's for our
jar, then return it's description
Lookup in static JARVERSIONS Map
For xalan.jar and xerces.jar/xercesImpl.jar, which we ship together:
The jar is not from a shipped copy of xalan-j, so
it's up to the user to ensure that it's compatible
Otherwise, it's just a jar we don't have the version info calculated for
If we succeeded, we have JAXP 1.4 available
Found Xalan-J 1.x, grab it's version fields
NOTE: This is the old Xalan 2.0, 2.1, 2.2 version class,
is being replaced by class below
Found Xalan-J 2.x, grab it's version fields
NOTE: This is the new Xalan 2.2+ version class
Found Xerces-J 1.x, grab it's version fields
Look for xerces1 and xerces2 parsers separately
Found Xerces-J 2.x, grab it's version fields
@todo determine specific crimson version
If we succeeded, we have loaded interfaces from a
level 3 DOM somewhere
If we succeeded, we have loaded interfaces from a
level 2 DOM somewhere
Check for the working draft version, which is
commonly found, but won't work anymore
Check for the final draft version as well
@todo load an actual DOM implmementation and query it as well
@todo load an actual DOM implmementation and check if
isNamespaceAware() == true, which is needed to parse
xsl stylesheet files into a DOM
Note this introduces a minor compile dependency on SAX...
see changes.html "Changes from SAX 2.0beta2 to SAX 2.0prerelease"
If we succeeded, we have loaded interfaces from a
real, final SAX version 2.0 somewhere
If we didn't find the SAX 2.0 class, look for a 2.0beta2
If we succeeded, we have loaded interfaces from a
SAX version 2.0beta2 or earlier; these might work but
you should really have the final SAX 2.0
If we didn't find the SAX 2.0beta2 class, look for a 1.0 one
If we succeeded, we have loaded interfaces from a
SAX version 1.0 somewhere; which won't work very
well for JAXP 1.1 or beyond!
If we didn't find the SAX 2.0 class, look for a 1.0 one
Note that either 1.0 or no SAX are both errors
Stop recording xalan.jar sizes as of Xalan Java 2.5.0
Stop recording xsltc.jar sizes as of Xalan Java 2.5.0
If the below were more common I would update it to report
errors better; but this is so old hardly anyone has it
Stop recording xalanservlet.jar sizes as of Xalan Java 2.5.0; now a .war file
For those who've downloaded JAXP from sun
jakarta-ant: since many people use ant these days
should be changed to private final, keeping original modifier to keep backwards compatibility
As this instance is immutable, these two values
need only be calculated once.
may throw an ArrayStoreException
may throw an ArrayStoreException
if obj is null, return false
if obj is not a OpenMBeanInfo, return false
Now, really test for equality between this OpenMBeanInfo
implementation and the other:
their MBean className should be equal
their infos on attributes should be equal (order not
significant => equality between sets, not arrays or lists)
their infos on constructors should be equal (order not
significant => equality between sets, not arrays or lists)
their infos on operations should be equal (order not
significant => equality between sets, not arrays or lists)
their infos on notifications should be equal (order not
significant => equality between sets, not arrays or lists)
All tests for equality were successful
Calculate the hash code value if it has not yet been done
(ie 1st call to hashCode())
return always the same hash code for this instance (immutable)
Calculate the string value if it has not yet been done (ie
1st call to toString())
return always the same string representation for this
The following diagram shows the data structure of the RBCollationTables object.
Suppose we have the rule, where 'o-umlaut' is the unicode char 0x00F6.
"a, A < b, B < c, C, ch, cH, Ch, CH < d, D ... < o, O; 'o-umlaut'/E, 'O-umlaut'/E ...".
What the rule says is, sorts 'ch'ligatures and 'c' only with tertiary difference and
sorts 'o-umlaut' as if it's always expanded with 'e'.
mapping table                     contracting list           expanding list
(contains all unicode char
entries)                   ___    ____________       _________________________
________                +>|_*_|->|'c' |v('c') |  +>|v('o')|v('umlaut')|v('e')|
|_\u0001_|-> v('\u0001') | |_:_|  |------------|  | |-------------------------|
|_\u0002_|-> v('\u0002') | |_:_|  |'ch'|v('ch')|  | |             :           |
|____:___|               | |_:_|  |------------|  | |-------------------------|
|____:___|               |        |'cH'|v('cH')|  | |             :           |
|__'a'___|-> v('a')      |        |------------|  | |-------------------------|
|__'b'___|-> v('b')      |        |'Ch'|v('Ch')|  | |             :           |
|____:___|               |        |------------|  | |-------------------------|
|____:___|               |        |'CH'|v('CH')|  | |             :           |
|___'c'__|----------------         ------------   | |-------------------------|
|____:___|                                        | |             :           |
Noted by Helena Shih on 6/23/97
this object is filled in through
the BuildAPI object
internal (for use by CollationElementIterator)
get contract values from contractTable by index
Right now this does a linear search through the entire
expansion table.  If a collator had a large number of expansions,
this could cause a performance problem, but in practise that
shemran/Note: this is used for secondary order value reverse, no
need to consider supplementary pair.
sherman/Todo: is the value big enough?????
Expand index follows
contract indexes follow
there are 27 types. 53 is the closest prime number to 27*2=54.
create all built-in types
base schema simple type names
first check whether the CoreDOMImplementation would do
if not try the DOMImplementation
first check whether the CoreDOMImplementation would do
Set to the ORB's transportDebugFlag value.  This value is
used if the ORB is null.
Repository ID cache
Current Class Stack (repository Ids of current class being read)
Length of current chunk, or a large positive number if not in a chunk
Read end flag (value nesting depth)
Beginning with the resolution to interop issue 3526 (4328?),
only enclosing chunked valuetypes are taken into account
when computing the nesting level.  However, we still need
the old computation around for interoperability with our
Flag used to determine whether blocksize was zero
In block flag
Indicates whether we are inside a value
Int used by read_value(Serializable) that is set by this class
before calling ValueFactory.read_value
Int set by readStringOrIndirection to communicate the actual
offset of the string length field back to the caller
Flag indicating whether we are unmarshalling a chunked value
Repository ID handlers
Code set converters (created when first needed)
RMI-IIOP stream format version 2 case in which we know
that there is no more optional data available.  If the
Serializable's readObject method tries to read anything,
we must throw a MARSHAL with the special minor code
so that the ValueHandler can give the correct exception
to readObject.  The state is cleared when the ValueHandler
calls end_value after the readObject method exits.
To ensure we keep bbwi.byteBuffer.limit in sync with bbwi.buflen.
See description in CDRInputStream
Called by Request and Reply message. Valid for GIOP versions >= 1.2 only.
Illegal for GIOP versions < 1.2.
Since chunks can end at arbitrary points (though not within
primitive CDR types, arrays of primitives, strings, wstrings,
we must check here for termination of the current chunk.
RMI-IIOP stream format version 2 case in which we know
that there is no more optional data available.  If the
Serializable's readObject method tries to read anything,
we must throw a MARSHAL exception with the special minor code
so that the ValueHandler can give the correct exception
to readObject.  The state is cleared when the ValueHandler
calls end_value after the readObject method exits.
Are we at the end of the current chunk?  If so,
try to interpret the next long as a chunk length.
(It has to be either a chunk length, end tag,
If it isn't a chunk length, blockLength will
remain set to maxBlockLength.
What's next is either a valuetag or
an end tag.  If it's a valuetag, we're
probably being called as part of the process
to read the valuetag.  If it's an end tag,
then there isn't enough data left in
this valuetype to read!
Are we already past the end of the current chunk?
This is always an error.
If what's next on the wire isn't a chunk length or
what we want to read (which can't be split across chunks)
won't fit in the current chunk, throw this exception.
This probably means that we're in an RMI-IIOP
Serializable's readObject method or a custom marshaled
IDL type is reading too much/in an incorrect order
REVISIT - We should look at using the built in advancement
of using ByteBuffer.get() rather than explicitly
advancing the ByteBuffer's position.
This is true for anywhere we are incrementing
the ByteBuffer's position.
It was an end tag, so there wasn't enough data
left in the valuetype's encoding on the wire
to read what we wanted
WARNING: Must compute real alignment after calling
checkBlockLength since it may move the position
This can be overridden....
No such type in java
Don't allow transmission of wchar/wstring data with
foreign ORBs since it's against the spec.
If we're talking to one of our legacy ORBs, do what
Check for indirection
Workaround for ORBs which send string lengths of
zero to mean empty string.
IMPORTANT: Do not replace 'new String("")' with "", it may result
in a Serialization bug (See serialization.zerolengthstring) and
bug id: 4728756 for details
Skip over the 1 byte null
Don't allow transmission of wchar/wstring data with
foreign ORBs since it's against the spec.
Workaround for ORBs which send string lengths of
zero to mean empty string.
IMPORTANT: Do not replace 'new String("")' with "", it may result
in a Serialization bug (See serialization.zerolengthstring) and
bug id: 4728756 for details
skip the two null terminator bytes
Must call alignAndCheck at least once to ensure
we aren't at the end of a chunk.  Of course, we
should only call it if we actually need to read
something, otherwise we might end up with an
exception at the end of the stream.
Microbenchmarks are showing a loop of ByteBuffer.get(int) being
faster than ByteBuffer.get(byte[], int, int).
read off the typecode
REVISIT We could avoid this try-catch if we could peek the typecode
kind off this stream and see if it is a tk_value.  Looking at the
code we know that for tk_value the Any.read_value() below
ignores the tc argument anyway (except for the kind field).
But still we would need to make sure that the whole typecode,
including encapsulations, is read off.
We can be sure that the whole typecode encapsulation has been
read off the value of the any
------------ RMI related methods --------------------------
IDL to Java ptc-00-01-08 1.21.4.1
The clz argument to read_Object can be either a stub
Class or the "Class object for the RMI/IDL interface type
that is statically expected."
This functions as follows:
1. If clz==null, just use the repository ID from the stub
2. If clz is a stub class, just use it as a static factory.
clz is a stub class iff StubAdapter.isStubClass( clz ).
In addition, clz is a IDL stub class iff
IDLEntity.class.isAssignableFrom( clz ).
3. If clz is an interface, use it to create the appropriate
In any case, we must first read the IOR.
Could not create stubFactory, so use null.
XXX stubFactory handling is still too complex:
Can we resolve the stubFactory question once in
a single place?
clz is an interface class
If we managed to load a stub, return it, otherwise we
Return the "default" stub...
In RMI-IIOP the ValueHandler will recognize this
exception and use the provided indirection value
to lookup a possible indirection to an object
currently on the deserialization stack.
Throw an exception if we have no repository ID info and
no expectedType to work with.  Otherwise, how would we
know what to unmarshal?
Read value tag
Is value null?
Is this an indirection to a previously
Save where this valuetype started so we
can put it in the indirection valueCache
Need to save this special marker variable
to restore its value during recursion
Read repository id(s)
If isChunked was determined to be true based
on the valuetag, this will read a chunk length
Remember that end_flag keeps track of all nested
valuetypes and is used for older ORBs
read in the class whether with the old ClassDesc or the
By this point, either the expectedType or repositoryIDString
is guaranteed to be non-null.
No point attempting to use value handler below, since the
class information is not available.
Must be some form of RMI-IIOP valuetype
Just rethrow any CORBA system exceptions
that come out of the ValueHandler
Skip any remaining chunks until we get to
an end tag or a valuetag.  If we see a valuetag,
that means there was another valuetype in the sender's
version of this class that we need to skip over.
Read and process the end tag if we're chunking.
Assumes that we're at the position of the end tag
(handleEndOfValue should assure this)
Cache the valuetype that we read
Allow for possible continuation chunk.
If we're a nested valuetype inside of a chunked
valuetype, and that enclosing valuetype has
more data to write, it will need to have this
new chunk begin after we wrote our end tag.
Read value tag
value is null
Read repository id
Compare rep. ids to see if we should use passed helper
Put into valueCache
allow for possible continuation chunk
This method is actually called indirectly by
Therefore, it is not a truly independent read call that handles
header information itself.
Put into valueCache using valueIndirection
Read value tag
value is null
Read repository id
Put into valueCache
allow for possible continuation chunk
Pre-Merlin/J2EE 1.3 ORBs wrote the repository ID
and codebase strings in the wrong order.
look for two-argument static read method
must be boxed value helper
found two-argument read method, so must be non-boxed value...
...create a blank instance
Value's constructor is protected or private
So, use the helper to read the value.
NOTE : This means that in this particular case a recursive ref.
add blank instance to cache table
if custom type, call unmarshal method
call two-argument read method using reflection
getDeclaredMethod requires RuntimePermission accessDeclaredMembers
if a different class loader is used (even though the javadoc says otherwise)
this gets caught below
Always try to find a ValueFactory first, as required by the spec.
There are some complications here in the IDL 3.0 mapping (see 1.13.8),
but basically we must always be able to override the DefaultFactory
or Helper mappings that are also used.  This appears to be the case
even in the boxed value cases.  The original code only did the lookup
in the case of class implementing either StreamableValue or CustomValue,
but abstract valuetypes only implement ValueBase, and really require
the use of the repId to find a factory (including the DefaultFactory).
use new-style OBV support (factory object)
XXX log marshal at one of the INFO levels
Could not get a factory, so try alternatives
use old-style OBV support (helper object)
must be a boxed IDLEntity, so make a reflective call to the
helper's static read method...
If there was no error in getting the factory, use it.
Read the end tag
End tags should always be negative, and the outermost
enclosing chunked valuetype should have a -1 end tag.
handleEndOfValue should have assured that we were
at the end tag position!
If the ORB is null, or if we're sure we're talking to
a foreign ORB, Merlin, or something more recent, we
use the updated end tag computation, and are more strenuous
about the values.
If the end tag we read was less than what we were expecting,
then the sender must think it's sent more enclosing
chunked valuetypes than we have.  Throw an exception.
If the end tag is bigger than what we expected, but
still negative, then the sender has done some end tag
compaction.  We back up the stream 4 bytes so that the
next time readEndTag is called, it will get down here
again.  Even with fragmentation, we'll always be able
to do this.
When talking to Kestrel or Ladybird, we use our old
end tag rules and are less strict.  If the end tag
isn't what we expected, we back up, assuming
This only keeps track of the enclosing chunked
This keeps track of all enclosing valuetypes
if called from alignAndCheck, need to reset blockLength
to avoid an infinite recursion loop on read_long() call
Must remember where we began the chunk to calculate how far
along we are.  See notes above about chunkBeginPos.
_REVISIT_ unsafe, should use a Java long
not a chunk length field
Makes sure that if we were reading a chunked value, we end up
at the right place in the stream, no matter how little the
unmarshalling code read.
After calling this method, if we are chunking, we should be
in position to read the end tag.
If we're not chunking, we don't have to worry about
skipping remaining chunks or finding end tags
Skip any remaining chunks
Now look for the end tag
This is a little wasteful since we're reading
this long up to 3 times in the worst cases (once
in start_block, once here, and once in readEndTag
Peek next long
We did find an end tag, so we're done.  readEndTag
should take care of making sure it's the correct
end tag, etc.  Remember that since end tags,
chunk lengths, and valuetags have non overlapping
ranges, we can tell by the value what the longs are.
A custom marshaled valuetype left extra data
on the wire, and that data had another
nested value inside of it.  We've just
read the value tag or null of that nested value.
In an attempt to get by it, we'll try to call
read_value() to get the nested value off of
the wire.  Afterwards, we must call handleEndOfValue
recursively to read any further chunks that the containing
valuetype might still have after the nested
This probably means that the code to skip chunks has
an error, and ended up setting blockLength to something
other than maxBlockLength even though we weren't
starting a new chunk.
if in a chunk, check for underflow or overflow
Chunk ended correctly
Skip over anything left by bad unmarshaling code (ex:
a buggy custom unmarshaler).  See handleEndOfValue.
------------ End RMI related methods --------------------------
CDRInputStream state management.
Read # of repository ids
read first array element and store it as an indirection to the whole array
read and ignore the subsequent array elements, but put them in the
indirection table in case there are later indirections back to them
digits isn't really needed here
This method is unable to yield the correct scale.
Each octet contains (up to) two decimal digits.
If the fixed type has an odd number of decimal digits, then the representation
begins with the first (most significant) digit.
Otherwise, this first half-octet is all zero, and the first digit
is in the second half-octet.
The sign configuration, in the last half-octet of the representation,
is 0xD for negative numbers and 0xC for positive and zero values.
positive number or zero
For every 16 bytes, there is one line
of output.  First, the hex output of
the 16 bytes with each byte separated
by a space.
Add any extra spaces to align the
text column in case we didn't end
Now output the ASCII equivalents.  Non-ASCII
characters are shown as periods.
Number of bytes to skip
Mark and reset -------------------------------------------------
These are the fields that may change after marking
the stream position, so we need to save them.
Provides a hook so subclasses of CDRInputStream can provide
a CodeBase.  This ultimately allows us to grab a Connection
instance in IIOPInputStream, the only subclass where this
is actually used.
First try to load the class locally, then use
the provided URL (if it isn't null)
class cannot be loaded remotely.
Get a URL from the remote CodeBase and retry
Don't bother trying to find it locally again if
we got a null URL
Failed to load the class
Always report a bad URL
First try to load the class locally
Try to load the class using the provided
codebase URL (falls out below)
Try to load the class using a URL from the
Don't bother if the codebaseURL is null
Will ultimately return null if all three
attempts fail, but don't do anything here.
If we get here, we have failed to load the class
Utility method used to get chars from bytes
REVISIT - Look at CodeSetConversion.BTCConverter to see
if it can work with an NIO ByteBuffer. We should
avoid getting the bytes into an array if possible.
To be honest, I doubt this saves much real time
If the entire string is in this buffer,
just convert directly from the bbwi rather than
allocating and copying.
Microbenchmarks are showing a loop of ByteBuffer.get(int)
being faster than ByteBuffer.get(byte[], int, int).
Stretches across buffers.  Unless we provide an
incremental conversion interface, allocate and
copy the bytes.
Read value tag
Stream needs to go into a state where it
throws standard exception until end_value
is called.  This means the sender didn't
send any custom data.  If the reader here
tries to read more, we need to throw an
exception before reading beyond where
we're supposed to
One should never indirect to a custom wrapper
REVISIT - Could verify repository ID even though
it isn't used elsewhere
Note: isChunked should be true here.  Should have
been set to true in the containing value's read_value
Note that isChunked should still be true here.
If the containing valuetype is the highest
chunked value, it will get set to false
at the end of read_value.
allow for possible continuation chunk
tell BufferManagerRead to release any ByteBuffers
It's possible bbwi.byteBuffer is shared between
this InputStream and an OutputStream. Thus, we check
if the Input/Output streams are using the same ByteBuffer.
If they sharing the same ByteBuffer we need to ensure only
one of those ByteBuffers are released to the ByteBufferPool.
Set OutputStream's ByteBuffer and bbwi to null
so its ByteBuffer cannot be released to the pool
release this stream's ByteBuffer to the pool
print address of ByteBuffer being released
Commit edited value.
Override the implementations of the superclass, forwarding all methods
from the CellEditor interface to our delegate.
Implementing the TreeCellEditor Interface
Implementing the CellEditor Interface
in order to avoid a "flashing" effect when clicking a checkbox
in a table, it is important for the editor to have as a border
the same border that the renderer has, and have as the background
the same color as the renderer has. This is primarily only
needed for JCheckBox since this editor doesn't fill all the
visual space of the table cell, unlike a text field.
Protected EditorDelegate class
End of class JCellEditor
Versioning numbers  for the compiler -v option output
This variable should be set to false to prevent any methods in this
class from calling System.exit(). As this is a command-line tool,
calling System.exit() is normally OK, but we also want to allow for
this class being used in other ways as well.
used to be 'false'
fall through to case h
Generate a vector containg URLs for all stylesheets specified
Compile the stylesheet and output class/jar file(s)
exits with code '-1'
after predecessor character
hash table to find  predecessor + char pairs
next code if adding new prestring + char
if used up all codes
return the code and inc for next code
Rob fixed used to sign extend
init with no prefix
just in case
DONE no more unpacked
how much data we are actually expanding
length of expanded code left
how much space left
only got this many to unpack
only > 0 if codeLen > bufSpace [left overs]
initialise to exclusive end address of buffer area
NOTE: data unpacks in reverse direction and we are placing the
unpacked data directly into the array in the correct location.
skip required of expanded data
to predecessor code
indicate what part of codeLen used
indicate length of dat unpacked
PENDING(prinz) this code should be in the html
paragraph, but we can't add api to enable it.
fall through to one column
PENDING(prinz) this code should be in the html
paragraph, but we can't add api to enable it.
fall through to one row
A change in any of the table cells usually effects the whole table,
so redraw it all!
determine which views are table rows and clear out
grid points marked filled.
advance to a free column
fill in the overflow entries for this cell
setup the column layout/requirements
allocate using the convenience method on SizeRequirements
make grid is properly represented
all of the row layouts are invalid, so mark them that way
calculate column spans
continue normal layout
calculate column requirements for each column
the requirements are the sum of the columns.
pass 1 - single column cells
advance to a free column
pass 2 - multi-column cells
advance to a free column
calculate the totals
check if the minimum size needs adjustment.
apply the adjustments
check if the preferred size needs adjustment.
apply the adjustments
it's in this view.
---- variables ----------------------------------------------------
advance to a free column
Because the table may be only partially formed, some
of the columns may not yet exist.  Therefore we check
advance to a free column
test bounds of each row because it may not exist
either because of error or because the table isn't
fully loaded yet.
it's in this view.
--- GridCell methods -------------------------------------
Exported operations inherited and implemented from interface Attribute.
Since this isn't synchronized, setLength must be
done before the instance is freed.
Fix attributed to Peter Speck <speck@ruc.dk>.
Computing the Gregorian day checks the valid ranges
TODO does the limited range of valid years cause years to
start/end part way through? that would affect range
not using checkValidIntValue so EPOCH_DAY and PROLEPTIC_MONTH work
TODO: validate value
Like resolvePreviousValid the day is constrained to stay in the same month
for javadoc and covariant return type
override for performance
override for performance
HijrahChronology is implicit in the Hijrah_DATE_TYPE
Since listPainter paints in the insets we have to check for the
case where the child is not painted because the paint region is
to the left of the child. This assumes the ListPainter paints in
the left margin.
Look for the filename
Was the initial port specified? If so, override
This property normally is applied for the client side
configuration of resolvers.  Here we are using it to
define the server port that the with which the resolvers
Create a file
Verify that if it exists, it is readable
Success: start up
Use the SERVER_PORT to create an Acceptor using the
old legacy code in ORBConfiguratorImpl.  When (if?)
the legacy support is removed, this code will need
to create an Acceptor directly.
This causes the acceptors to start listening.
computed using serialver tool
initialize the counter database
Returning Context from Cache
instead of cast to E, we should perhaps use elementType.cast()
to avoid injection of forged stream, but it will slow the implementation
readObject method for the serialization proxy pattern
See Effective Java, Second Ed., Item 78.
specified to return null if no network interfaces
don't have connect permission to any local address
should we cache this?
DOMCatalogReader.java - Read XML Catalog files
Return codes for validate() method
REMIND: Make sure this functionality is in line with the
spec.  In particular, we are returning the Source for a
static image (the snapshot), not a changing image (the
VolatileImage).  So if the user expects the Source to be
up-to-date with the current contents of the VolatileImage,
they will be disappointed...
REMIND: This assumes that getSnapshot() returns something
valid and not the default null object returned by this class
(so it assumes that the actual VolatileImage object is
subclassed off something that does the right thing
REMIND: if we want any decent performance for getScaledInstance(),
we should override the Image implementation of it...
Volatile management methods
ARGHH!!  JAXP Uses Xerces without setting the namespace processing to ON!
Set the content handler
Set the system ID, if it is given
A Serializer implements ContentHandler, but not NodeConsumer
so drop this reference to NodeConsumer which would otherwise
pull in all sorts of things
if (m_contentHandler instanceof NodeConsumer)
Make sure the namespace node
for the element itself is declared
to the ContentHandler
Make sure the namespace node of
each attribute is declared to the ContentHandler
Use "" instead of null, as Xerces likes "" for the
name of the default namespace.  Fix attributed
to "Steven Murray" <smurray@ebt.com>.
Don't bother with endPrefixMapping calls if the ContentHandler is a
SerializationHandler because SerializationHandler's ignore the
endPrefixMapping() calls anyways. . . .  This is an optimization.
do the endPrefixMapping calls in reverse order
of the startPrefixMapping calls
Use "" instead of null, as Xerces likes "" for the
name of the default namespace.  Fix attributed
to "Steven Murray" <smurray@ebt.com>.
override as super would return range from 0 to 1
A constant representing the empty String
Visibility guaranteed by final field guarantees
this shouldn't happen, since we are Cloneable
Note: this check to see if it is an instance of Serializable
is for backwards compatibiity
REVISIT: Should this be transient? -Ac
REVISIT: Should this be transient? -Ac
Currently implemented as a singleton, since it's hardcoded
Not DOM Level 2. Support DocumentTraversal methods.
stop firing events when there isn't any listener
turn mutation events on
EventTarget support (public and internal)
We can't dispatch to blank type-name, and of course we need
a listener to dispatch to
Each listener may be registered only once per type per phase.
Simplest way to code that is to zap the previous entry, if any.
Record active listener
If this couldn't be a valid listener registration, ignore request
Note that addListener has previously ensured that
each listener may be registered only once per type per phase.
count-down is OK for deletions!
Storage management: Discard empty listener lists
Remove active listener
Found it; no need to loop farther.
Can't use anyone else's implementation, since there's no public
API for setting the event's processing-state fields.
VALIDATE -- must have been initialized at least once, must have
a non-null non-blank name.
If nobody is listening for this event, discard immediately
INITIALIZE THE EVENT'S DISPATCH STATUS
that doesn't seem to be explicitly guaranteed in the DOM, but
I believe it is the intent.)
use pre-event-dispatch ancestors even if event handlers mutate
document and change the target's context.
Note that this is parents ONLY; events do not
cross the Attr/Element "blood/brain barrier".
DOMAttrModified. which looks like an exception,
is issued to the Element rather than the Attr
and causes a _second_ DOMSubtreeModified in the Element's
Ancestors are scanned, root to target, for
Someone set the flag. Phase ends.
Handle all capturing listeners on this node
call listeners in the order in which they got registered
All exceptions are ignored.
Both AT_TARGET and BUBBLE use non-capturing listeners.
AT_TARGET PHASE: Event is dispatched to NON-CAPTURING listeners
on the target node. Note that capturing listeners on the target
node are _not_ invoked, even during the capture phase.
call listeners in the order in which they got registered
All exceptions are ignored.
BUBBLING_PHASE: Ancestors are scanned, target to root, for
non-capturing listeners. If the event's preventBubbling flag
has been set before processing of a node commences, we
instead immediately advance to the default phase.
Note that not all events bubble.
Someone set the flag. Phase ends.
Handle all bubbling listeners on this node
call listeners in the order in which they got
All exceptions are ignored.
DEFAULT PHASE: Some DOMs have default behaviors bound to specific
nodes. If this DOM does, and if the event's preventDefault flag has
not been set, we now return to the target node and process its
default handler for this event, if any.
No specific phase value defined, since this is DOM-internal
and should be replaced in conjunction with optimization
We have to send DOMAttrModified.
DOMSubtreeModified gets sent to the lowest common root of a
set of changes.
"This event is dispatched after all other events caused by the
mutation have been fired."
If we're within an Attr, DStM gets sent to the Attr
and to its owningElement. Otherwise we dispatch it
dispatchAggregateEvents(NodeImpl, AttrImpl,String) :void
MUTATION PREPROCESSING AND PRE-EVENTS:
If we're within the scope of an Attr and DOMAttrModified
was requested, we need to preserve its previous value for
Any other parent means we're not in an Attr
Subroutine: Transmit DOMAttrModified and DOMSubtreeModified,
if required. (Common to most kinds of mutation)
End mutation postprocessing
now that we have finished replacing data, we need to perform the same actions
that are required after a character data node has been modified
send the value of false for replace parameter so that mutation
events if appropriate will be initiated
"Local" events (non-aggregated)
New child is told it was inserted, and where
If within the Document, tell the subtree it's been added
to the Doc.
Might have been orphan Attr
Last non-null ancestor
In this context, ancestry includes
walking back from Attr to Element
Subroutine: Transmit DOMAttrModified and DOMSubtreeModified
(Common to most kinds of mutation)
notify the range of insertions
MUTATION PREPROCESSING AND PRE-EVENTS:
If we're within the scope of an Attr and DOMAttrModified
was requested, we need to preserve its previous value for
Child is told that it is about to be removed
If within Document, child's subtree is informed that it's
losing that status
Might have been orphan Attr
Last non-null ancestor
End mutation preprocessing
Subroutine: Transmit DOMAttrModified and DOMSubtreeModified,
if required. (Common to most kinds of mutation)
End mutation postprocessing
We can't use the standard dispatchAggregate, since it assumes
that the Attr is still attached to an owner. This code is
similar but dispatches to the previous owner, "element".
If we have to send DOMAttrModified (determined earlier),
We can hand off to process DOMSubtreeModified, though.
Note that only the Element needs to be informed; the
Attr's subtree has not been changed by this operation.
REVISIT: To be implemented!!!
REVISIT: To be implemented!!!
Convert Maps to Hashtables, Lists to Vectors
Write serialized fields
We have to read serialized fields first.
convert Hashtables back to HashMaps and Vectors to Lists
Status byte defines
Default meta message data: just the META status byte value
can throw InvalidMidiDataException
$$fb 2001-10-06: need to calculate dataLength. Fix for bug #4511796
status value for MetaMessages (meta events)
write the length as a variable int
number of bitwise left-shifts of mask
first screen out leading zeros
then write actual values
do not instantiate
count of number of nodes created
No. of nodes allowed.
stores defaults for different security holes (maxOccurLimit in current context) if it has
been set on the configuration.
we are setting the limit of number of nodes to 3times the maxOccur value..
similarly to entity manager behaviour, take into accont
behaviour if continue-after-fatal-error is set.
reset the node count
check for preceding '-' sign
validate and normalize
save unnormalized values
just make a copy of the base if spec is empty
check for scheme
two slashes means generic URI syntax, so we get the authority
get authority - everything up to path, query or fragment
if we found authority, parse it out, otherwise we set the
host to empty string
Resolve relative URI to base URI - see RFC 2396 Section 5.2
In some cases, it might make more sense to throw an exception
(when scheme is specified is the string spec and the base URI
is also specified, for example), but we're just following the
check to see if this is the current doc - RFC 2396 5.2 #2
note that this is slightly different from the RFC spec in that
we don't include the check for query string being null
- this handles cases where the urispec is just a query
string or a fragment (e.g. "?y" or "#s") -
see <http:www.ics.uci.edu/~fielding/url/test1.html> which
identified this as a bug in the RFC
check for scheme - RFC 2396 5.2 #3
if we found a scheme, it means absolute URI, so we're done
check for authority - RFC 2396 5.2 #4
if we found a host, then we've got a network path, so we're done
check for absolute path - RFC 2396 5.2 #5
if we get to this point, we need to resolve relative path
RFC 2396 5.2 #6
6a - get all but the last segment of the base URI path
6b - append the relative URI path
6c - remove all "./" where "." is a complete path segment
6d - remove "." if path ends with "." as a complete path segment
6e - remove all "<segment>/../" where "<segment>" is a complete
path segment not equal to ".."
6f - remove ending "<segment>/.." where "<segment>" is a
complete path segment
userinfo is everything up @
host is everything up to ':'
path - everything up to query string or fragment
check for valid escape sequence
"Path contains invalid character: "
query - starts with ? and up to fragment or end
fragment - starts with #
userinfo can contain alphanumerics, mark characters, escaped
presence of the host (whether valid or empty) means
double-slashes which means generic uri
rightmost domain label starting with digit indicates IP address
since top level domain label can only start with an alpha
see RFC 2396 Section 3.2.2
make sure that 1) we see only digits and dot separators, 2) that
any dot separator is preceded and followed by a digit and
3) that we find 3 dots
domain labels can contain alphanumerics and '-"
but must start and end with an alphanumeric
convert file to appropriate URI, f.toURI().toASCIIString()
converts the URI to string as per rule specified in
convert file to appropriate URI, f.toURI().toASCIIString()
converts the URI to string as per rule specified in
-- This file was mechanically generated: Do not edit! --
Cached unsafe-access object
Cached array base offset
Cached unaligned-access capability
Base address, used in all indexing calculations
NOTE: moved up to Buffer.java for speed in JNI GetDirectBufferAddress
An object attached to this buffer. If this buffer is a view of another
buffer then we use this field to keep a reference to that buffer to
ensure that its memory isn't freed before we are done with it.
For duplicates and slices
hash for forwarding nodes
hash for roots of trees
hash for transient reservations
usable bits of normal node hash
type arg is c
for cast to Comparable
Use at least as many bins
as estimated threads
Original (since JDK1.2) Map methods
ignore transient negative values
no lock when adding to empty bin
negative number of deletions
For serialization compatibility
Emulate segment calculation from previous version of this class
force exclusion for table construction
Overrides of JDK8+ Map extension method defaults
Hashtable legacy methods
ignore transient negative values
loop to avoid arbitrarily deep recursion on forwarding nodes
lost initialization race; just spin
try to cope with OOME
to ensure sweep before committing nextTab
recheck before commit
See LongAdder version for explanation
True if last slot nonempty
Try to attach new Cell
Recheck under lock
Slot is now non-empty
CAS already known to fail
Continue after rehash
At max size or stale
Expand table unless stale
Retry with expanded table
Fall back on using base
red-black tree links
needed to unlink next upon deletion
values for lockState
set while holding write lock
set when waiting for write lock
increment value for setting read lock
offload to separate method
unlink traversal pointers
p was s's direct parent
Red-black tree methods, all adapted from CLR
current table; updated if resized
the next entry to use
to save/restore on ForwardingNodes
index of bin to use next
current index of initial table
index bound for initial table
initial table size
must use locals in checks
visit upper slots if present
reuse if possible
save for reuse
To export MapEntry
Parallel bulk operations
slack of 4
implementations below rely on concrete classes supplying these
same as Traverser
save for reuse
largest numerical value
These would not be used for EN. Only used for traditional numbering
These only used for mutiplicative-additive numbering
Default is left
If the delimiter is an empty string, create one token Element for
every single character.
Cache of singletons for the predefined color spaces.
NOTE: This method may be called by privileged threads.
DO NOT INVOKE CLIENT CODE ON THIS THREAD!
Synchronizing "this" to prevent this key from getting canceled
multiple times by different threads, which might cause race
condition between selector's select() and channel's close().
Common UI methods
low-level behavior, or null if not yet prepared
Either a LambdaForm cache (managed by LambdaFormEditor) or a link to uncustomized version (for customized LF)
all reference types
all primitive types
not valid in all contexts
all subword types are represented as ints
Cannot use LF interpreter on very high arity expressions.
Make a blank lambda form, which returns a constant zero or null.
It is used as a template for managing the invocation of similar forms that are non-empty.
Called only from getPreparedForm.
might still be void
If shared LambdaForm has been compiled, compile customized version as well.
LambdaFormEditor should always use uncustomized form.
Customized LambdaForm should always has a link to uncustomized version.
If customized LambdaForm has been compiled, compile uncustomized version as well.
Do all names possess an index consistent with their local definition order?
Also, do all local name references
ref must come after def!
NYI: fit this into the fast path?
must be of the form *_*
must be [LIJFD]
already prepared (e.g., a primitive DMH invoker form)
TO DO: Maybe add invokeGeneric, invokeWithArguments
already compiled somehow
Find all predefined invokers and associate them with canonical empty lambda forms.
Set this false to disable use of the interpret_L methods defined in this file.
The following are predefined exact invokers.  The system must build
a separate invoker for each distinct signature.
The next few routines are called only from assert expressions
They verify that the built-in invokers process the correct raw data types.
The following line is needed because (...)void method handles can use non-void invokers
can drop any kind of value
allow anything here; will be dropped
Replace vmentry with a bytecode version of this LF.
also check that the leading (receiver) argument is somehow bound to this LF:
note:  argument #0 could also be an interface wrapper, in the future
names array has MH in slot 0; skip it.
Note:  The LF constructor will rename names2[argpos...].
Make space for new arguments (shift temporaries).
Note:  When inArg = reorder[outArg], outArg is fed by a copy of inArg.
The types are the types of the new (incoming) arguments.
skip trivial first part of reordering:
copy the body:
return the corresponding inArg
rework names in the body:
replace names[skip+j] by names2[skip+i]
some names are unused, but must be filled in
replace names2[i] by names[j]
The following assert is almost always correct, but will fail for corner cases, such as PrivateInvokeTest.
necessary to pass BigArityTest
The next 3 constructors are used to break circular dependencies on MH.invokeStatic, etc.
Any LambdaForm containing such a member is not interpretable.
This is OK, since all such LFs are prepared with special primitive vmentry points.
And even without the resolvedHandle, the name can still be compiled and optimized.
Put the predefined NamedFunction invokers into the table.
The following are predefined NamedFunction invokers.  The system must build
a separate invoker for each distinct signature.
normalize to basic type
this could take a while
If we have a cached invoker, call it right away.
NOTE: The invoker always returns a reference value.
Get an invoker and cache it.
If the dest. type is a primitive we keep the
only for certain internal LFs during bootstrapping
Called only from assert.
Hack to make signatures more readable when they show up in method names.
shift in the next char:
shift in the next count:
end of a  character run
found three or more in a row
additional type information, if not null
only params have constraints
FIXME: use replaceNames uniformly
harmless check to see if the thing is already in newNames:
n might not have the correct index: n != oldNames[n.index].
each parameter is a unique atom
this != that
this.index == that.index &&
live all the way beyond the end
Look up some symbolic names.  It might not be necessary to have these,
but if we need to emit direct references to bytecodes, it helps.
Zero is built from a call to an identity function with a constant zero input.
Do this in a separate pass, so that SimpleMethodHandle.make can see the tables.
Avoid appealing to ValueConversions at bootstrap time:
same as zeroV, but that's OK
Put this last, so that previous static inits can run before.
The following hack is necessary in order to suppress TRACE_INTERPRETER
during execution of the static initializes of this class.
Turning on TRACE_INTERPRETER too early will cause
stack overflows and other misbehavior during attempts to trace events
that occur during LambdaForm.<clinit>.
Therefore, do not move this line higher in this file, and do not remove.
XXX log this fallback at a low level
TODO: Maybe change this to force Graphics2D, since many things will
break with plain Graphics nowadays.
TODO: Maybe make that return a BufferedImage, because some stuff will
break if a different kind of image is returned.
TODO: Include capabilities here and fix Component#createVolatileImage
public static synchronized void
Get the builder. Creates a new one if necessary.
Returned value cannot be null.  NullPointerException if violated.
Try with context class loader
No context class loader? Try with Class.forName()
Check whether a new builder needs to be created
no need to create a new builder...
Create a new builder
*  Set the root node of the TreeWalker.
* @param root The context node of this step.
public void setRoot(int root)
A negative predicate index seems to occur with
Count 'em all
Count 'em all
NODE FOR THIS CACHE
End of file.
defaultOption is an index into the options array
defaultOption is an option value
convert standard transitions
convert savings transitions to locals
convert savings transitions to instants
convert savings transitions to locals
check if using last rules
using historic rules
switch negative insert position to start of matched range
should probably be optimized
check if using last rules
using historic rules
before first transition
switch negative insert position to start of matched range
handle overlap immediately following gap
gap or overlap
normal (neither gap or overlap)
should use Year class, but this saves a class load
switch negative insert position to start of matched range
check if using last rules
search year the instant is in
use first from following year
using historic rules
switched value is the next transition
exact match, so need to add one to get the next
allow rest of method to only use seconds
check if using last rules
search year the instant is in
use last from preceding year
using historic rules
inline for performance
define shared variables for date/time
define constants to be used in assigning default values for
all date/time excluding duration
distinguishes between identity and equality for date/time values
ie: two values representing the same "moment in time" but with different
remembered timezones are now equal but not identical.
original timezones must be the same in addition to date/time values
the parameters are in compiled form (from getActualValue)
compare date1<=date1<=(date2 with time zone -14)
clones date1 value to global temporary storage: fTempDate
compare date1>=(date2 with time zone +14)
clones date1 value to global temporary storage: tempDate
compare (date1 with time zone -14)<=date2
clones date1 value to global temporary storage: tempDate
compare (date1 with time zone +14)<=date2
clones date1 value to global temporary storage: tempDate
get hours (hh)
get minutes (mm)
get seconds (ss)
find UTC sign if any
get seconds (ms)
parse UTC time zone (hh:mm)
REVISIT: date starts with preceding '-' sign
do we have to do anything with it?
fStart points right after the MONTH
fStart points right after the date
REVISIT: should we throw an exception for not valid dates
or reporting an error message should be sufficient?
REVISIT: more testing on this parsing needs to be done.
parse Year differently to support negative value.
REVISIT: we have common code in addDuration() for durations
should consider reorganizing it.
add minutes (from time zone)
REVISIT: should we take care about Julian calendar?
help function described in W3C PR Schema [E Adding durations to dateTimes]
modulo(a, b) = a - fQuotient(a,b)*b
help function described in W3C PR Schema [E Adding durations to dateTimes]
fQuotient(a, b) = the greatest integer less than or equal to a/b
help function described in W3C PR Schema [E Adding durations to dateTimes]
modulo(a - low, high - low) + low
help function described in W3C PR Schema [E Adding durations to dateTimes]
fQuotient(a - low, high - low)
Need to convert from scientific notation of the form
n.nnn...E-N (N >= 4) to a normal decimal value.
This should never happen.
It's only possible if String.valueOf(double) is broken.
Remove trailing zeros.
Now append the digits to the end. Skip over the decimal point.
Need to convert from scientific notation of the form
n.nnn...EN (N >= 7) to a normal decimal value.
This should never happen.
It's only possible if String.valueOf(double) is broken.
Append trailing zeroes if necessary.
Private help functions
used for comparisons - to decide the 'interesting' portions of
a date/time based data type.
a pointer to the type that was used go generate this data
note that this is not the actual simple type, but one of the
statically created XXXDV objects, so this won't cause any GC problem.
If two DateTimeData are equals - then they should have the same
hashcode. This means we need to convert the date to UTC before
we return its hashcode.
The DateTimeData is unfortunately mutable - so we cannot
cache the result of the conversion...
address of jzfile data
zip file name
total number of entries
if zip file starts with LOCSIG (usually true)
A system prpperty to disable mmap use to avoid vm crash when
in-use zip file is accidently overwritten by others.
see getEntry() for details
If no entry is found for the specified 'name' and
the 'name' does not end with a forward slash '/',
the implementation tries to find the entry with a
slash '/' appended to the end of the 'name', before
returning null. When such entry is found, the name
that actually is found (with a slash '/' attached)
(disabled if jdk.util.zip.ensureTrailingSlash=false)
freeEntry releases the C jzentry struct.
the outstanding inputstreams that need to be closed,
mapped to the inflater objects they use.
MORE: Compute good size for inflater stream:
Inflater likes a bit of slack
Override fill() method to provide an extra "dummy" byte
at the end of the input stream. This is required when
using the "nowrap" Inflater option.
List of available Inflater objects for decompression
get the flag first
length 0 empty name
Close streams, release their inflaters
Release cached inflaters
Close the zip file
address of jzentry data
current position within entry data
number of remaining bytes within entry
uncompressed size of this entry
Check if ZipFile open
access to the native zentry object
End of file.
jmx RI import
Note: the thread will be started by the subclass.
Notify the server we are now active
Call protocol specific sequence
Now notify the adaptor server that the handler is terminating.
This is important because the server may be blocked waiting for
a handler to terminate.
The protocol-dependent part of the request
Low order bits of sum
Used to compute right sum for non-finite inputs
Little wolf of rounding error
Better error bounds to add both terms as the final sum
If the compensated sum is spuriously NaN from
accumulating one or more same-signed infinite values,
return the correctly-signed infinity stored in
XXX: uwe: abuse old field for now
will need to take care of serialization
On some platforms, changing the resizable state affects
the insets of the Frame. If we could, we'd call invalidate()
from the peer, but we need to guarantee that we're not holding
the Frame lock when we call invalidate().
peer.setState must be called outside of object lock
synchronization block to avoid possible deadlock
get the latest Frame state before disposing
HeadlessException is thrown by Window's readObject
pre-1.4 instances will not have this optional data.
1.6 and later instances serialize icons in the Window class
e.eof will be true to indicate that there is no more
data available for this object.
If e.eof is not true, throw the exception as it
might have been caused by unrelated reasons.
Ensure 1.1 serialized Frames can read & hook-up
owned windows properly
inner class AccessibleAWTFrame
attribute value is always empty string
REVISIT: what should happen in this case?
reinstantiate Signature object to work around bug in JDK
this shouldn't occur, but if it does, restore previous
stuff a variable into the client property of this renderer indicating the sort order,
so that different rendering can be done for the header based on sorted state.
REVISIT: current implementations wraps error several times:
XMLErrorReport.reportError creates XMLParserException (by wrapping all info)
and goes via switch to send errors.
DOMErrorHandlerWrapper catches calls, copies info from XMLParserException and
sends one call back to the application
I think we can avoid this indirection if we modify XMLErrorReporter. --el
It keeps the reference of DOMErrorHandler of application
some components may set error node
Default constructor /
REVISIT: May need to lookup from DOMErrorTypeMap in the future.
REVISIT: May need to lookup from DOMErrorTypeMap in the future.
REVISIT: Abort processing if fatal error, do we need to??
initialize error type table: internal error codes (represented by domain and key) need to be mapped to a DOM error type.
REVISIT: do well-formedness issues involving XML declaration <?xml ... ?> need to be added to hash table (no XML declaration node in DOM, but Document includes xmlEncoding, xmlStandalone, xmlVersion, etc.
e.g. in Processing Instruction
InvalidCharInXMLDecl omitted because XML declaration is not a DOM Node
considered error in name of node (which follows !DOCTYPE)
considered error in name of node (which follows !ENTITY)
considered error in name of node (which follows !ENTITY %)
considered error in name of node (which follows !ENTITY %)
considered error in name of node (which follows !ENTITY)
considered error in name of node
considered error in name of node, which follows !NOTATION
considered error in name of node, which follows !NOTATION
considered error in name of node, which follows !NOTATION
REVISIT: do EntityNotDeclared, RecursiveReference, RecursiveGeneralReference, RecursivePEReference belong here?
Check to see whether the Resolver is allowed
first check the individual Resolvers
paint using image to not Graphics2D to support
Java 1.1 printing API
Import general CORBA classes
Import org.omg.CosNaming classes
register object with activator.
if obj extends Activatable, set its ref.
make sure Map only contains correct types
Write out the non-transient fields
(revocationDate, reason, authority)
Write out the size (number of mappings) of the extensions map
For each extension in the map, the following are emitted (in order):
the OID String (Object), the criticality flag (boolean), the length
of the encoded extension value byte array (int), and the encoded
extension value byte array. The extensions themselves are emitted
in no particular order.
Read in the non-transient fields
(revocationDate, reason, authority)
Defensively copy the revocation date
Read in the size (number of mappings) of the extensions map
and create the extensions map
Read in the extensions and put the mappings in the extensions map
ResolvingXMLFilter.java - An XMLFilter that performs catalog resolution
Ideally this method would not attempt to open the
InputStream, but there is a bug (in Xerces, at least)
that causes the parser to mistakenly open the wrong
system identifier if the returned InputSource does
not have a byteStream.
It could be argued that we still shouldn't do this here,
but since the purpose of calling the entityResolver is
almost certainly to open the input stream, it seems to
do little harm.
Package private methods for recreating the weak/soft referent
Constants from SplittableRandom
1.0  / (1L << 53)
1.0f / (1 << 24)
false during super() call
only allow call from super() constructor
read and update per-thread seed
We must define this, but never use it.
power of two
reject over-represented candidates
range not representable as long
correct for rounding
power of two
reject over-represented candidates
power of two
reject over-represented candidates
correct for rounding
Use nextLocalGaussian instead of nextGaussian field
between -1 and 1
between -1 and 1
stream methods, coded in a way intended to better isolate for
maintenance purposes the small differences across forms.
Compute the typecode for easy switching
the name of the field
type first byte of the type signature
iff object, typename
the type of this field, if has been resolved
the next 3 things are RMI-IIOP specific, it can be easily
removed, if we can figure out all place where there are dependencies
to this.  Signature is esentially equal to typestring. Then
essentially we can use the java.io.ObjectStreamField as such.
the signature of the field
read and discard the repository ID
write the repository ID
amount of progress to draw
Do not paint the standard stripes from the skin, because they obscure
See if we can squeeze in an extra chunk without spacing after
get the full repaint area and add it the
previous one so we can erase it
an apparently hard coded value in Windows
this code adjusts the chunk size to properly account for the
size and gap specified in the XP style. It also does it's own
box placement for the chunk animation. This is required because
the inherited algorithm from BasicProgressBarUI goes back and
forth whereas XP only goes in one direction. XP also has ghosted
trailing chunks to create the illusion of speed. This code
adjusts the pixel length of the animation to account for the
add 2x for the trails
add 2x for the trails
Paint the bouncing box.
create a new graphics to keep drawing surface state
calculate the chunk offsets
Calculate the area of the chunks combined
save this box for the next time
this is the entire progress bar minus the track and borders
only paint where the chunks overlap with the progress bar drawing area
adjust the cliprect to chop the chunks when they go off the end
get the skin
do the drawing
get rid of our clip and composite changes
override with covariant return type
override with covariant return type
override with covariant return type
override with covariant return type
override with covariant return type
override with covariant return type
override with covariant return type
override with covariant return type
override with covariant return type
override with covariant return type
override with covariant return type
override for performance
override for better proleptic algorithm
override for enhanced behaviour
do not invent era if strict, but do cross-check with year
reinstate the field removed earlier, no cross-check issues
override for performance
override with covariant return type
Constants for whatToShow.  These are used to set the node type that will
be traversed. These values may be ORed together before being passed to
Backup for specifying the version, this isn't currently documented.
If you pass in anything but 2.2 you got the 2.0 colors/look.
NOTE: We're currently hard coding to use 2.2.
If we want to support both GTK 2.0 and 2.2, we'll
need to get the major/minor/micro version from the .so.
Refer to bug 4912613 for details.
If the button is SELECTED and is PRELIGHT we need to
make the state MOUSE_OVER otherwise we don't paint the
These Regions treat FOREGROUND as TEXT.
We need to call super for basic's properties file.
SynthTabbedPaneUI supports rollover on tabs, GTK does not
Prevents Synth from setting text AA by itself
For compatibility with apps expecting certain defaults we'll
populate the table with the values from basic.
For compatibility with apps expecting certain defaults we'll
populate the table with the values from basic.
The following progress bar size calculations come from
gtkprogressbar.c (version 2.8.20), see MIN_* constants and
the gtk_progress_bar_size_request() method.
These bindings are only enabled when there is a default
button set on the rootpane.
colors specific only for GTK
It is impossible to create a simple GtkWidget without specifying the
type. So for GtkWidget we can use any appropriate concrete type of
wigdet. LABEL in this case.
The property was GC'ed, we're no longer interested in
PropertyChanges, remove the listener.
We are using invokeLater here because we are getting called
on the AWT-Motif thread which can cause a deadlock.
Subclassed to pass in false to the superclass, we don't want to try
and load the system colors.
If we are in initialize initializations will be
called later, don't do it now.
Desktop property appears to have preference over rc font.
Indent group members 12 pixels to denote hierarchy and
Fall through to related
As a basic rule of thumb, leave space between user
interface components in increments of 6 pixels, going up as
the relationship between related elements becomes more
distant. For example, between icon labels and associated
graphics within an icon, 6 pixels are adequate. Between
labels and associated components, leave 12 horizontal
pixels. For vertical spacing between groups of components,
18 pixels is adequate.
The first part of this is handled automatically by Icon (which
won't give you 6 pixels).
A general padding of 12 pixels is
recommended between the contents of a dialog window and the
-- This file was mechanically generated: Do not edit! --
These fields are declared here rather than in Heap-X-Buffer in order to
reduce the number of virtual method invocations needed to access these
values, which is especially costly when coding small buffers.
Non-null only for heap buffers
Valid only for heap buffers
Creates a new buffer with the given mark, position, limit, capacity,
backing array, and array offset
Creates a new buffer with the given mark, position, limit, and capacity
-- Singleton get/put methods --
-- Bulk get operations --
-- Bulk put operations --
-- Other stuff --
-- Other char stuff --
-- Other byte stuff: Access to binary data --
While we must in general read state before owner,
we don't need to do so to check if current thread is owner
Methods relayed from outer class
reset to unlocked state
Get the pattern for the default locale.
Always applyPattern after the symbols are set
Always applyPattern after the symbols are set
Always applyPattern after the symbols are set
If fieldPosition is a DontCareFieldPosition instance we can
try to go to fast-path code.
if fast-path could not work, we fallback to standard code.
at this point we are guaranteed a nonnegative finite number.
In general, long values always represent real finite numbers, so
we don't have to check for +/- Infinity or NaN.  However, there
is one case we have to be careful of:  The multiplier can push
a number near MIN_VALUE or MAX_VALUE outside the legal range.  We
check for this before multiplying, and if it happens we use
This can only happen if number == Long.MIN_VALUE.
==== Begin fast-path formating logic for double =========================
The fast-path algorithm is semi-hardcoded against
minimumIntegerDigits and maximumIntegerDigits.
The fast-path algorithm is hardcoded against
minimumFractionDigits and maximumFractionDigits.
Since some instance properties may have changed while still falling
in the fast-path case, we need to reinitialize fastPathData anyway.
We need to instantiate fastPathData if not already done.
Sets up the locale specific constants used when formatting.
'0' is our default representation of zero.
Sets up fractional constants related to currency/decimal pattern.
Records the need for adding prefix or suffix
Creates a cached char container for result, with max possible size.
Sets up prefix and suffix char arrays constants.
Sets up fixed index positions for integral and fractional digits.
Sets up decimal point in cached result container.
Previous state was fast-path and is no more.
Resets cached array constants.
Will always be positive.
Will always be negative.
Scale is 100 = 128 - 32 + 4.
Multiply by 2**n is a shift. No roundoff. No error.
Scale is 1000 = 1024 - 16 - 8.
Multiply by 2**n is a shift. No roundoff. No error.
Shewchuk/Dekker's FastTwoSum(approxMedium, approxMin).
Now we have got the roundoff for the scaled fractional
---- TwoProduct(fractionalPart, scale (i.e. 1000.0d or 100.0d)) end.
---- Taking the rounding decision end
Generates 3 digits per iteration.
-1024 +16 +8 = 1000.
Collects last 3 or less digits.
Currency case. Always collects fractional digits.
Decimal case. Hundreds will always be collected
Ending zeros won't be collected.
This is decimal pattern and fractional part is zero.
We must remove decimal point from result.
We add affixes only if needed (affix length > 0).
If prefix to prepend is only 1 char long, just assigns this char.
If prefix is less or equal 4, we use a dedicated algorithm that
has shown to run faster than System.arraycopy.
If more than 4, we use System.arraycopy.
If suffix to append is only 1 char long, just assigns this char.
If suffix is less or equal 4, we use a dedicated algorithm that
has shown to run faster than System.arraycopy.
If more than 4, we use System.arraycopy.
We will localize only the digits, using the groupingSize,
and taking into account fractional part.
First take into account fractional part.
The case when there is no fractional digits.
Only the digits remains to localize.
This is a digit char, we must localize it.
Decimal separator or grouping char. Reinit counter only.
Exact integral part of d.
Exact fractional part of d (since we subtract it's integral part).
Approximated scaled fractional part of d (due to multiplication).
Exact integral part of scaled fractional above.
Exact fractional part of scaled fractional above.
Only when scaledFractional is exactly 0.5d do we have to do exact
calculations and take fine-grained rounding decision, since
approximated results above may lead to incorrect decision.
Otherwise comparing against 0.5d (strictly greater or less) is ok.
Rounding need fine-grained decision.
Rounds up both fractional part (and also integral if needed).
Propagates rounding to integral part since "all nines" case.
Adding prefix and suffix.
(Re-)Evaluates fast-path status if needed.
DecimalFormat instance is not in a fast-path state.
Should not use fast-path for Infinity and NaN.
Extracts and records sign of double value, possibly changing it
to a positive one, before calling fastDoubleFormat().
Filters out values that are outside expected fast-path range
Returns a new string from updated fastPathContainer.
======== End fast-path formating logic for double =========================
NOTE: This isn't required anymore because DigitList takes care of this.
The negative of the exponent represents the number of leading
zeros between the decimal and the first non-zero digit, for
a value < 0.1 (e.g., for 0.00123, -fExponent == 2).  If this
is more than the maximum fraction digits, then we have an underflow
for the printed representation.  We recognize this here and set
the DigitList representation to zero in this situation.
if (-digitList.decimalAt >= getMaximumFractionDigits())
'0' is the DigitList representation of zero
Minimum integer digits are handled in exponential format by
adjusting the exponent.  For example, 0.01234 with 3 minimum
integer digits is "123.4E-4".
Maximum integer digits are interpreted as indicating the
repeating range.  This is useful for engineering notation, in
which the exponent is restricted to a multiple of 3.  For
example, 0.01234 with 3 maximum integer digits is "12.34e-3".
If maximum integer digits are > 1 and are larger than
minimum integer digits, then minimum integer digits are
A repeating range is defined; adjust to it as follows.
-3,-4,-5=>-6, etc. This takes into account that the
it is for the format 0.MMMMMx10^n.
integer division rounds towards 0
No repeating range is defined; use minimum integer digits.
We now output a minimum number of digits, and more if there
are more digits, up to the maximum number of digits.  We
place the decimal point after the "integer" digits, which
are the first (decimalAt - exponent) digits.
The number of integer digits is handled specially if the number
is zero, since then there may be no digits.
Record field information for caller.
Record field information for caller.
Record field information for caller.
Record field information for caller.
Record field information
The exponent is output using the pattern-specified minimum
exponent digits.  There is no maximum limit to the exponent
digits, since truncating the exponent would result in an
For zero values, we force the exponent to zero.  We
must do this here, and not earlier, because the value
is used to determine integer digit count above.
Output the integer portion.  Here 'count' is the total
number of integer digits we will display, including both
leading zeros required to satisfy getMinimumIntegerDigits,
and actual digits present in the number.
Index into digitList.fDigits[]
Handle the case where getMaximumIntegerDigits() is smaller
than the real number of integer digits.  If this is so, we
output the least significant max integer digits.  For example,
the value 1997 printed with 2 max integer digits is just "97".
Output a real digit
Output a leading zero
Output grouping separator if necessary.  Don't output a
grouping separator if i==0 though; that's at the end of
the integer part.
Determine whether or not there are any printable fractional
digits.  If we've used up the digits we know there aren't.
If there is no fraction present, and we haven't printed any
integer digits, then print a zero.  Otherwise we won't print
_any_ digits, and we won't be able to parse this string.
Output the decimal separator if we always do so.
Here is where we escape from the loop.  We escape if we've
output the maximum fraction digits (specified in the for
We also stop when we've output the minimum digits and either:
we have an integer, so there is no fractional stuff to
display, or we're out of significant digits.
Output leading fractional zeros. These are zeros that come
after the decimal but before any significant digits. These
are only output if abs(number being formatted) < 1.0.
Output a digit, if we have any precision left, or a
zero if we don't.  We don't want to output noise digits.
Record field information for caller.
special case NaN
special case INFINITY
non-terminating decimal expansion
Finally, have DigitList parse the digits into a value.
Divide by multiplier. We have to be careful here not to do
unneeded conversions between double and long.
Avoid converting to double if we can
At this point, if we divided the result by the multiplier, the
result may fit into a long.  We check for this case and return
a long if possible.
We must do this AFTER applying the negative (if appropriate)
in order to handle the case of LONG_MIN; otherwise, if we do
this with a positive value -LONG_MIN, the double is > 0, but
the long is < 0. We also must retain a double in the case of
-0.0, which will compare as == to a long 0 cast to a double
check for positivePrefix; take longest
process digits or Inf, find decimal position
We now have a string of digits, possibly with grouping symbols,
and decimal points.  We want to process these into a DigitList.
We don't want to put a bunch of leading zeros into the DigitList
though, so we keep track of the location of the decimal point,
put only significant digits into the DigitList, and adjust the
exponent as needed.
Set to the exponent value, if any
We have to track digitCount ourselves, because digits.count will
pin when the maximum allowable digits is reached.
Cancel out backup setting (see grouping handler below)
Do this BEFORE continue statement below!!!
Handle leading zeros
Ignore leading zeros in integer part of number.
If we have seen the decimal, but no significant
digits yet, then we account for leading zeros by
decrementing the digits.decimalAt into negative
[sic] digit==0 handled above
Cancel out backup setting (see grouping handler below)
If we're only parsing integers, or if we ALREADY saw the
decimal, then don't parse this one.
Ignore grouping characters, if we are using them, but
require that they be followed by a digit.  Otherwise
we backup and reprocess them.
Process the exponent by recursively calling this method.
Advance past the exponent
Whether we fail or succeed, we exit this loop
If there was no decimal point we have an integer
Adjust for exponent, if any
If none of the text string was recognized.  For example, parse
"x" with pattern "#0.00" (return index and error index both 0)
parse "$" with pattern "$#0.00". (return index 0 and error
check for suffix
if both match, take longest
fail if neither or both
don't allow multiple references
should never happen
don't allow multiple references
should never happen
Fast-path is almost stateless algorithm. The only logical state is the
isFastPath flag. In addition fastPathCheckNeeded is a sentinel flag
that forces recalculation of all fast-path fields when set to true.
There is thus no need to clone all the fast-path fields.
We just only need to set fastPathCheckNeeded to true when cloning,
and init fastPathData to null as if it were a truly new instance.
Every fast-path field will be recalculated (only once) at next usage of
super does class check
just enough fields for a reasonable distribution
Reuse one StringBuffer for better performance
Fall through and append another QUOTE below
Fall through and append another CURRENCY_SIGN below
n == p == null
n == p == null
Two variables are used to record the subrange of the pattern
occupied by phase 1.  This is used during the processing of the
second pattern (the one representing negative numbers) to ensure
that no deviation exists in phase 1 between the two patterns.
The phase ranges from 0 to 2.  Phase 0 is the prefix.  Phase 1 is
the section of the pattern with digits, decimal separator,
grouping characters.  Phase 2 is the suffix.  In phases 0 and 2,
percent, per mille, and currency symbols are recognized and
translated.  The separation of the characters into phases is
strictly enforced; if phase 1 characters are to appear in the
suffix, for example, they must be quoted.
The affix is either the prefix or the suffix.
Process the prefix / suffix characters
A quote within quotes indicates either the closing
quote or two quotes, which is a quote literal. That
is, we have the second quote in 'do' or 'don''t'.
Process unquoted characters seen in prefix or suffix
Reprocess this character
Use lookahead to determine if the currency sign
is doubled or not.
Skip over the doubled character
A quote outside quotes indicates either the
opening quote or two quotes, which is a quote
literal. That is, we have the first quote in 'do'
Don't allow separators before we see digit
characters of phase 1, and don't allow separators
in the second pattern (j == 0).
Next handle characters which are appended directly.
Note that if we are within quotes, or if this is an
unquoted, non-special character, then we usually fall
through to here.
Phase one must be identical in the two sub-patterns. We
enforce this by doing a direct comparison. While
processing the first sub-pattern, we just record its
length. While processing the second, we compare
Process the digits, decimal, and grouping characters. We
record five pieces of information. We expect the digits
to occur in the pattern ####0000.####, and we record the
number of left digits, zero (central) digits, and right
digits. The position of the last grouping character is
recorded (should be somewhere within the first two blocks
of characters), as is the position of the decimal point,
if any (should be in the zero digits). If there is no
decimal point, then there should be no right digits.
Use lookahead to parse out the exponential part
of the pattern, then jump into phase 2.
Transition to phase 2
Handle patterns with no '0' pattern character. These patterns
are legal, but must be interpreted.  "##.###" -> "#0.###".
".###" -> ".0##".
Handle "###.###" and "###." and ".###"
Do syntax checking on the digits.
assume these for now
If there was no negative pattern, or if the negative pattern is
identical to the positive pattern, then prepend the minus sign to
the positive pattern to form the negative pattern.
We force complete fast-path reinitialization when the instance is
deserialized. See clone() comment on fastPathCheckNeeded.
We only need to check the maximum counts because NumberFormat
.readObject has already ensured that the maximum is greater than the
Didn't have exponential fields
invariant, > 0 if useThousands
Newly persistent in the Java 2 platform v.1.2
Newly persistent in the Java 2 platform v.1.2
------ DecimalFormat fields for fast-path for double algorithm  ------
--- Temporary fields used in fast-path, shared by several methods.
--- State fields related to fast-path status. Changes due to a
property change only. Set by checkAndSetFastPathStatus() only.
------ Fast-Path for double Constants ------
initialize on demand holder class idiom for arrays of digits
------ Fast-Path for double Constants end ------
Constants for characters used in programmatic (unlocalized) patterns.
Upper limit on integer and fraction digits for a Java double
Upper limit on integer and fraction digits for BigDecimal and BigInteger
Proclaim JDK 1.1 serial compatibility.
List of all child Monitored Objects
All the Attributes of this Monitored Object instance
First call clearState on all the local attributes
next call clearState on all the children MonitoredObjects
I'll let them go if they gave us 'extra' symbols...
convert the owner's mode to something the Normalizer understands
if buffer contains any decomposed char values
return their strength orders before continuing in
the Normalizer's CharacterIterator.
are we at the end of Normalizer's text?
convert the owner's mode to something the Normalizer understands
getBeginIndex, getEndIndex and setIndex are deprecated
if the desired character isn't used in a contracting character
sequence, bypass all the backing-up logic-- we're sitting on
the right character already
walk backwards through the string until we see a character
that DOESN'T participate in a contracting character sequence
now walk forward using this object's next() method until
we pass the starting point and set our current position
to the beginning of the last "character" before or at
our starting position
we don't need this, since last is the last index
that is the starting of the contraction which encompass
First get the ordering of this single character,
which is always the first element in the list
find out the length of the longest contracting character sequence in the list.
There's logic in the builder code to make sure the longest sequence is always
(the Normalizer is cloned here so that the seeking we do in the next loop
won't affect our real position in the text)
extract the next maxLength characters in the string (we have to do this using the
Normalizer to ensure that our offsets correspond to those the rest of the
iterator is using) and store it in "fragment".
now that we have that fragment, iterate through this list looking for the
longest sequence that matches the characters in the actual text.  (maxLength
is used here to keep track of the length of the longest sequence)
Upon exit from this loop, maxLength will contain the length of the matching
sequence and order will contain the collation-element value corresponding
to this sequence
seek our current iteration position to the end of the matching sequence
and return the appropriate collation-element value (if there was no matching
sequence, we're already seeked to the right position and order already contains
the correct collation-element value for the single character)
This function is identical to nextContractChar(), except that we've
switched things so that the next() and previous() calls on the Normalizer
are switched and so that we skip entry pairs with the fwd flag turned on
rather than off.  Notice that we still use append() and startsWith() when
working on the fragment.  This is because the entry pairs that are used
in reverse iteration have their names reversed already.
-- This file was mechanically generated: Do not edit! --
XREVISIT - is this used?
End of file.
This member is an instance of a signature-polymorphic method, which cannot be reflected
A method handle invoker can come in either of two forms:
A generic placeholder (present in the source code, and varargs)
and a signature-polymorphic instance (synthetic and not varargs).
Suppresses default constructor, ensuring non-instantiability.
Insertion sort on smallest arrays
Recursively sort halves of dest into src
If list is already sorted, just copy from src to dest.  This is an
optimization that results in faster sorts for nearly ordered lists.
Merge sorted halves (now in src) into dest
Insertion sort on smallest arrays
Recursively sort halves of dest into src
If list is already sorted, just copy from src to dest.  This is an
optimization that results in faster sorts for nearly ordered lists.
Merge sorted halves (now in src) into dest
Like public version, but without range checks.
key not found.
Like public version, but without range checks.
key not found.
Like public version, but without range checks.
key not found.
Like public version, but without range checks.
key not found.
Like public version, but without range checks.
key not found.
Like public version, but without range checks.
Neither val is NaN, thisVal is smaller
Neither val is NaN, thisVal is larger
Values are equal
(-0.0, 0.0) or (!NaN, NaN)
(0.0, -0.0) or (NaN, !NaN)
key not found.
Like public version, but without range checks.
Neither val is NaN, thisVal is smaller
Neither val is NaN, thisVal is larger
Values are equal
(-0.0, 0.0) or (!NaN, NaN)
(0.0, -0.0) or (NaN, !NaN)
key not found.
Like public version, but without range checks.
key not found.
Like public version, but without range checks.
key not found.
Figure out whether the two elements are equal
element is an array of object references
element is non-null and not an array
-- This file was mechanically generated: Do not edit! --
Get all methods, including super-interface methods.
Removed because of bug 4989053
Must be a checked exception, not including RemoteException or
Some final checks that apply to all properties.
Look for a valid corresponding Read property
ignore. this means we didn't find a corresponding get property.
Look for a valid corresponding Is property
ignore. this means we didn't find a corresponding Is property.
Look for a valid corresponding Read property
ignore. this means we didn't find a corresponding read property.
don't set the first letter to lower-case if the
first two are upper-case
Section 1.2.3, #2
Section 1.2.3, #4
See also bug 4972402
For all exceptions E in exceptions,
(isCheckedException(E) => (isValue(E) || RemoteException.isAssignableFrom( E ) )
Comparison is based on method names only.  First collect
all methods from current interface, eliminating duplicate
Now check each method against list of all unique method
names processed so far.
0 in CORBA 2.3.1 13.6.3
* Visit a variable reference.
* @param owner The owner of the expression, to which the expression can
*              be reset if rewriting takes place.
* @param var The variable reference object.
* @return true if the sub expressions should be traversed.
public boolean visitVariableRef(ExpressionOwner owner, Variable var)
Don't go have the caller go any further down the subtree.
Make a copy of the set in order to avoid
concurrent modification (the is.close()
will in turn call removeFromQueue())
is this faster than call s.toCharArray first and compare the
two arrays directly, which will possibly involve creating a
new char array object.
The provider that created this selector
-- Interruption machinery --
Set other instance variables to default values.
Modifying and Querying attributes
Renderers and Editors
Property Change Support
End of class TableColumn
unregister server definition
get server definition
Return whether the server has been installed
if the server is currently marked as installed.
if the server is currently marked as uninstalled.
list registered servers
Find the ServerID associated with the given application name.
Type-specific CORBA::Object operations
TODO: When DOM Level 3 goes to REC replace method calls using
reflection for: getXmlEncoding, getInputEncoding and getXmlEncoding
with regular static calls on the Document object.
XML 1.1 serializer
set default features
false does not have any effect
true is not supported
namespace-declaration has effect only if namespaces is true
false is not supported
both values supported
true is not supported
false is not supported
Add DOM recognized parameters
REVISIT: Would have been nice to have a list of
Add recognized xerces features and properties
determine which serializer to use:
this should run under JDK 1.1.8...
no way to test the version...
ignore the exception
copy setting from "main" serializer to XML 1.1 serializer
stopped at user request
REVISIT: A generic IOException doesn't provide enough information
to determine that the serialized document is too large to fit
into a string. This could have thrown for some other reason. -- mrglavas
this initializes a newly-created serializer
copies all settings that could have been modified
by calls to LSSerializer methods from one serializer to another.
IMPORTANT:  if new methods are implemented or more settings of
the serializer are made alterable, this must be
reflected in this method!
this should run under JDK 1.1.8...
no way to test the version...
ignore the exception
determine which serializer to use:
copy setting from "main" serializer to XML 1.1 serializer
ignore the exception
ignore the exception
URI was specified. Handle relative URIs.
Use FileOutputStream if this URI is for a local file.
Try to write to some other kind of URI. Some protocols
won't support this, though HTTP should work.
The DOM L3 LS CR says if we are writing to an HTTP URI
it is to be done with an HTTP PUT.
byte stream was specified
character stream is specified
stopped at user request
this should run under JDK 1.1.8...
no way to test the version...
ignore the exception
copy setting from "main" serializer to XML 1.1 serializer
ignore the exception
ignore the exception
URI was specified. Handle relative URIs.
Use FileOutputStream if this URI is for a local file.
Try to write to some other kind of URI. Some protocols
won't support this, though HTTP should work.
The DOM L3 LS CR says if we are writing to an HTTP URI
it is to be done with an HTTP PUT.
stopped at user request
REVISIT: this is inefficient implementation of well-formness. Instead, we should check
well-formness as we serialize the tree
no way to test the version...
ignore the exception
Move down to first child
No child nodes, so walk tree
Move to sibling if possible.
only verify well-formness if comments included in the tree
only if entity is preserved in the tree
the ]]> string will be checked during serialization
Locate the escape characters
Decode the 2 digit hexadecimal number following % in '%nn'
constants describing whether a match was made,
and if so how.
matched any way
matched on the attribute axis
matched on the descendant-or-self axixs
matched some previous (ancestor) node on the descendant-or-self-axis, but not this node
xpath has been matched if any one of the members of the union have matched.
a place-holder method; to be overridden by subclasses
that care about matching element content.
matched(String content, XSSimpleType val)
try next xpath, if not matching
consume self::node() steps
now if the current step is a descendant step, we let the next
step do its thing; if it fails, we reset ourselves
to look at this step for next time we're called.
so first consume all descendants:
match child::... step, if haven't consumed any self::node()
match attribute::... step
go back a step
don't do anything, if not matching
signal match, if appropriate
only certain kinds of matchers actually
match element content.  This permits
them a way to override this to do nothing
and hopefully save a few operations.
NOTE: The main of this class is here for debugging purposes.
However, javac (JDK 1.1.8) has an internal compiler
error when compiling. Jikes has no problem, though.
If you want to use this main, use Jikes to compile but
*never* check in this code to CVS without commenting it
These message should be read from a locale-specific resource bundle
This can only be set at object construction time (no sync necessary).
what kind of exception to throw
delegate not set therefore it is null and will return default
Same code as in PortableRemoteObject. Can not be shared because they
are in different packages and the visibility needs to be package for
security reasons. If you know a better solution how to share this code
then remove it from PortableRemoteObject. Also in Util.java
ignore, then try RMIClassLoader
BEGIN: Keys needed for exception messages of  JAXP 1.3 XPath API implementation
END: Keys needed for exception messages of  JAXP 1.3 XPath API implementation
Note to translators:  A relative location path is a form of XPath expression.
The message indicates that such an expression was expected following the
characters '/' or '', but was not found.
Note to translators:  A location path is a form of XPath expression.
The message indicates that syntactically such an expression was expected,but
the characters specified by the substitution text were encountered instead.
Note to translators:  A location path is a form of XPath expression.
The message indicates that syntactically such a subexpression was expected,
but no more characters were found in the expression.
Note to translators:  A location step is part of an XPath expression.
The message indicates that syntactically such an expression was expected
following the specified characters.
Note to translators:  A node test is part of an XPath expression that is
used to test for particular kinds of nodes.  In this case, a node test that
consists of an NCName followed by a colon and an asterisk or that consists
of a QName was expected, but was not found.
Note to translators:  A step pattern is part of an XPath expression.
The message indicates that syntactically such an expression was expected,
but the specified character was found in the expression instead.
Note to translators: A relative path pattern is part of an XPath expression.
The message indicates that syntactically such an expression was expected,
but was not found.
Note to translators:  The substitution text is the name of a data type.  The
message indicates that a value of a particular type could not be converted
to a value of type boolean.
Note to translators: Do not translate ANY_UNORDERED_NODE_TYPE and
Note to translators: Do not translate UNORDERED_NODE_SNAPSHOT_TYPE and
Note to translators: This message indicates that the document being operated
upon changed, so the iterator object that was being used to traverse the
document has now become invalid.
Note to translators:  The substitution text is the name of a data type.  The
message indicates that a value of a particular type could not be converted
to a value of type string.
Note to translators: Do not translate snapshotItem,
UNORDERED_NODE_SNAPSHOT_TYPE and ORDERED_NODE_SNAPSHOT_TYPE.
Note to translators:  XPathEvaluator is a Java interface name.  An
XPathEvaluator is created with respect to a particular XML document, and in
this case the expression represented by this object was being evaluated with
respect to a context node from a different document.
Note to translators:  The XPath expression cannot be evaluated with respect
to this type of node.
BEGIN:  Definitions of error keys used  in exception messages of  JAXP 1.3 XPath API implementation
END:  Definitions of error keys used  in exception messages of  JAXP 1.3 XPath API implementation
Other miscellaneous text used inside the code...
================= INFRASTRUCTURE ======================
Type-specific CORBA::Object operations
this usually means the entry is no longer in the map.
v changed or k is gone
k is no longer in the map.
something to remove
removed the old value as expected
some other value replaced old value. try again.
nothing to do. Leave things as they were.
add or replace old mapping
replaced as expected.
some other value replaced old value. try again.
add (replace if oldValue was null)
some other value replaced old value. try again.
NOTE: This is a SUN PROPRIETARY EXTENSION
Add the poolToUse to the upper 6 bits of byte 6 of the GIOP header.
this.flags represents byte 6 here.
IMPORTANT: Bitwise operations will promote
byte types to int before performing
bitwise operations. And, Java
types are signed.
Patch the size field in the header.
check for message type validity
This should do nothing even if it is called. The Message Header is read
off a java.io.InputStream (not a CDRInputStream) by IIOPConnection
in order to choose the correct CDR Version , msg_type, and msg_size.
So, we would never need to read the Message Header off a CDRInputStream.
XREVISIT - Currently a java.lang.Object during
the rip-int-generic transition.  Should eventually
become a GIOPOutputObject.
ComponentUI Interface Implementation methods
We replace the
we use JPopup in our TitlePane so need escape support
BasicInternalFrameUI creates an action with the same name, we override
it as MotifInternalFrameTitlePane has a titlePane ivar that shadows the
titlePane ivar in BasicInternalFrameUI, making supers action throw
an NPE for us.
Set up the bindings for the DesktopIcon, it is odd that
we install them, and not the desktop icon.
create a vector to hold all the components in use
create table for features and properties
add default recognized features
set state for default features
add default recognized properties
don't add a component more than once
register component's recognized features
register component's recognized properties
set default values
REVISIT: Should this be a property?
REVISIT: Should this be a property?
REVISIT: Should this be a property?
REVISIT: Should this be a property?
forward to every component
save state if noone "objects"
forward to every component
store value if noone "objects"
reset every component
Value type: String
Get the literal string of characters associated with the
current event.  If the parser recognises and supports this
property but is not currently parsing text, it should return
null (this is a good way to check for availability before the
REVISIT - we should probably ask xml-dev for a precise
definition of what this is actually supposed to return, and
in exactly which circumstances.
special performance feature: no one by component manager is allowed to set it
General Attribute Checking
create identity constraint
return this array back to pool
return this array back to pool
if ret == null, we've already reported an error in getGlobalDecl
we report an error only when ret != null, and the return type keyref
If errors occurred in traversing the identity constraint, then don't
add it to the schema, to avoid errors when processing the instance.
Schema Component Constraint: Identity-constraint Definition Properties Correct
add key reference to element decl
and stuff this in the grammar
also add it to extended map
and put back attributes
Status byte defines
Default sysex message data: SOX followed by EOX
non-private to simplify nested class access
Find the best power of two to hold elements.
Tests "<=" because arrays aren't kept full.
Too many elements, must back off
Good luck allocating 2 ^ 30 elements
number of elements to the right of p
The main insertion and extraction methods are addFirst,
addLast, pollFirst, pollLast. The other methods are defined in
terms of these.
Element is null if deque empty
Must null out slot
elements[head] is null if deque empty
Invariant: head <= i < tail mod circularity
Optimize for least element motion
Copy the null tail as well
This check doesn't catch all possible comodifications,
but does catch the ones that corrupt traversal
if left-shifted, undo increment in next()
clear all cells
Write out size
Write out elements in order.
Read in size and allocate array
Read in all elements in the proper order.
-1 until first use
current index, modified on traverse/split
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of TreeCellEditorPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of TreeCellEditorPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
if we remove current component we should show next one
correct currentCard if this is necessary
--- View methods ---------------------------------------------
try to build a component
components associated with the View tree are added
to the hosting container with the View as a constraint.
remove the component from its hosting container
--- member variables ------------------------------------------------
NOTE: When we remove this class we are going to have to some
how enforce setting of the focus traversal keys on the children
so that they don't inherit them from the JEditorPane. We need
to do this as JEditorPane has abnormal bindings (it is a focus cycle
root) and the children typically don't want these bindings as well.
Endpoint types known in advance.
If you change the value of this constant then update
activation.idl accordingly.  It has a duplicate definition
to avoid a compilation dependency.
Required SERVICE_CONTEXT_ID and getId definitions
Check order first
Go through both list of values
order is not relevant; check for existence
For finding first element that has a null in JDK1.1 Vector.
object references are equal
obj2 was not false
For the Java 2 platform, can just use "return removeElement(attrval);"
Need to do the following to handle null case
---- ordering methods
---- serialization methods
write out the attrID
read in the attrID
number of values
Note that the declaring class in method is the interface
in which the method was defined, not the proxy class.
handler should never be null here.
This array maps Unicode characters to their collation ordering
Normalize the build rules.  Find occurances of all decomposed characters
and normalize the rules before feeding into the builder.  By "normalize",
we mean that all precomposed Unicode characters must be converted into
a base character and one or more combining characters (such as accents).
When there are multiple combining characters attached to a base character,
the combining characters must be in their canonical order
(1)decmp will be NO_DECOMPOSITION only in ko locale to prevent decompose
hangual syllables to jamos, so we can actually just call decompose with
normalizer's IGNORE_HANGUL option turned on
(2)just call the "special version" in NormalizerImpl directly
Build the merged collation entries
Since rules can be specified in any order in the string
(e.g. "c , C < d , D < e , E .... C < CH")
this splits all of the rules in the string out into separate
objects and then sorts them.  In the above example, it merges the
"C < CH" rule in just before the "C < D" rule.
Now walk though each entry and add it to my own tables
Iterate through all of the pre-composed characters in Unicode
We don't already have an ordering for this pre-composed character.
First, see if the decomposed string is already in our
tables as a single contracting-string ordering.
If so, just map the precomposed character to that order.
TODO: What we should really be doing here is trying to find the
longest initial substring of the decomposition that is present
in the tables as a contracting character sequence, and find its
ordering.  Then do this recursively with the remaining chars
so that we build a list of orderings, and add that list to
the expansion table.
That would be more correct but also significantly slower, so
I'm not totally sure it's worth doing.
sherman/Note: if this is 1 character decomposed string, the
only thing need to do is to check if this decomposed character
has an entry in our order table, this order is not necessary
to be a contraction order, if it does have one, add an entry
for the precomposed character by using the same order, the
previous impl unnecessarily adds a single character expansion
We don't have a contracting ordering for the entire string
that results from the decomposition, but if we have orders
for each individual character, we can add an expanding
table entry for the pre-composed character
found a expanding character that isn't filled in yet
Get the real values for the non-filled entry
The real value is still unmapped, maybe it's ignorable
just fill in the value
increment priamry order  and mask off secondary and tertiary difference
increment secondary order and mask off tertiary difference
record max # of ignorable chars with secondary difference
increment tertiary order
record max # of ignorable chars with tertiary difference
See if the char already has an order in the mapping table
There's already an entry for this character that points to a contracting
character table.  Instead of adding the character directly to the mapping
table, we must add it to the contract table instead.
add the entry to the mapping table,
the same later entry replaces the previous one
See if the initial character of the string already has a contract table.
We need to create a new table of contract entries for this base char
Add the initial character's current ordering first. then
update its mapping to point to this contract table
Now add (or replace) this string in the table
NOTE:  This little bit of logic is here to speed CollationElementIterator
.nextContractChar().  This code ensures that the longest sequence in
this list is always the _last_ one in the list.  This keeps
nextContractChar() from having to search the entire list for the longest
If this was a forward mapping for a contracting string, also add a
reverse mapping for it, so that CollationElementIterator.previous
can work right
Create an expansion table entry
And add its index into the main mapping table
only add into table when it is a legal surrogate
If anOrder is valid, we want to add it at the beginning of the list
ether we are missing the low surrogate or the next char
is not a legal low surrogate, so stop loop
can't find it in the table, will be filled in by commit().
we had at least one supplementary character, the size of valueList
is bigger than it really needs...
Add the expanding char list into the expansion table.
need look up in .commit()
variables used by the build process
"shadow" copies of the instance variables in RBCollationTables
(the values in these variables are copied back into RBCollationTables
at the end of the build process)
unregister server definition
get server definition
Return whether the server has been installed
if the server is currently marked as installed.
if the server is currently marked as uninstalled.
list registered servers
Find the ServerID associated with the given application name.
Type-specific CORBA::Object operations
the actions mask
does path indicate a directory? (wildcard or recursive)
is it a recursive directory specification?
Left null as long as possible, then
created and re-used in the getAction function.
canonicalized dir path. In the case of
directories, it is the name "/blah/*" or "/blah/-" without
the last character (the "*" or "-").
static Strings used by init(int mask)
store only the canonical cpath if possible
call getCanonicalPath with a path with wildcard character
replaced to avoid calling it with paths that are
intended to match all entries in a directory
overkill since they are initialized to false, but
commented out here to remind us...
XXX: at this point the path should be absolute. die if it isn't?
package private for use by the FilePermissionCollection add method
we get the effective mask. i.e., the "and" of this and that.
They must be equal to that.mask for implies to return true.
make sure that.path is longer then path so
something like /foo/- does not imply /foo
if the permission passed in is a directory
specification, make sure that a non-recursive
permission (i.e., this object) can't imply a recursive
Use regionMatches to avoid creating new string
if this is NOT recursive/wildcarded,
do not let it imply a recursive/wildcarded permission
Null action valid?
Use object identity comparison against known-interned strings for
performance benefit (these values are used heavily within the JDK).
check for the known strings
make sure we didn't just match the tail of a word
like "ackbarfaccept".  Also, skip to the comma.
point i at the location of the comma minus one (or -1).
Write out the actions. The superclass takes care of the name
call getActions to make sure actions field is initialized
Read in the actions, then restore everything else by calling init.
Not serialized; see serialization section at end of class
Convert Iterator into Enumeration
Need to maintain serialization interoperability with earlier releases,
which had the serializable field:
Don't call out.defaultWriteObject()
Write out Vector
Don't call defaultReadObject()
Read in serialized fields
Get the one we want
isPrivileged and isAuthorized are referenced by the VM - do not remove
or change their names
Note: This field is directly used by the virtual machine
native codes. Don't touch it.
limited privilege scope
is constrained by limited privilege scope?
we do not need to run the combine method on the
provided ACC.  it was already "combined" when the
context was originally retrieved.
at this point in time, we simply throw away the old
combiner and use the newly provided one.
used in checkPermission2()
If "codebase" is not specified, we dump the info by default.
If "codebase" is specified, only dump if the specified code
value is in the stack.
Want to make sure this is always displayed for failure,
but do not want to display again if already displayed
allow if all of them allowed access
the assigned (privileged or inherited) context
in that case, ignore the stack context
in that case, ignore the assigned context
if there is no enclosing limited privilege scope on the stack or
inherited from a parent thread
let the assigned acc's combiner do its thing
No need to clone current and assigned.context
combine() will not update them
optimization: if there is a single stack domain and
that domain is already in the assigned context; no
need to combine
Reuse existing ACC
in that case, ignore the stack context
in that case, ignore the assigned context
optimization: if there is no assigned context and the stack length
is less then or equal to two; there is no reason to compress the
stack context, it already is
now we combine both of them, and create a new context
first copy in the assigned context domains, no need to compress
now add the stack context domains, discarding nulls and duplicates
if length isn't equal, we need to shorten the array
optimization: if we didn't really combine anything
ProtectionDomains within an ACC currently cannot be null
and this is enforced by the constructor and the various
optimize methods. However, historically this logic made attempts
to support the notion of a null PD and therefore this logic continues
to support that notion.
Class check required to avoid PD exposure (4285406)
Instantiate XSLTC and get reference to parser object
A _uriResolver must be set if this method is called
-- ContentHandler --------------------------------------------------
create the templates
Set the translet class name if not already set
Get java-legal class name from XSLTC module
Compile the translet - this is where the work is done!
Create a Stylesheet element from the root node
Set a document loader (for xsl:include/import) if defined
Set it as top-level in the XSLTC object
Create AST under the Stylesheet element
Generate the bytecodes and output the translet class(es)
Class synchronization is needed for BCEL
Check that the transformation went well before returning
Set URIResolver on templates object
PENDING(jeff) - the thumb's location and size is currently hard coded.
It should be dynamic.
Two methods are exposed so that MotifMouseHandler can see the
superclass protected ivars
Constrain the mouse pressed to the thumb.
Check the state info first
Painter specified with no method
Painter specified for this method
Smooth over an anomily in the opcode map...
if((OpCodes.OP_FUNCTION == stepType) && (m_expr instanceof com.sun.org.apache.xalan.internal.templates.FuncKey))
if(m_expr instanceof WalkingIterator)
if(wi.getFirstWalker() instanceof FilterExprWalker)
if(null == fw.getNextWalker())
Define system property "jaxp.debug" to get output
Use try/catch block to support applets, which throws
SecurityException out of this code.
Allow simply setting the prop to turn on debug
Use current class loader - should always be bootstrap CL
make sure we have access to restricted packages
Extra check to avoid computing cl strings
Retain maximum compatibility if no security manager.
Do not call the method if it's not public static.
Only call the method if it's declared to return an instance of
This should not happen, as
declared to return TransformerFactory.
Use the system property first
try to read from $java.home/lib/jaxp.properties
Try Jar Service Provider Mechanism
It is not possible to wrap an error directly in
FactoryConfigurationError - so we need to wrap the
ServiceConfigurationError in a RuntimeException.
The alternative would be to modify the logic in
FactoryConfigurationError to allow setting a
Throwable as the cause, but that could cause
compatibility issues down the road.
no need to sync in the future
4th phisical button (this is not a wheel!)
(this is not a wheel!)
the constant below MUST be updated if any extra modifier
bits are to be added!
in fact, it is undesirable to add modifier bits
to the same field as this may break applications
see bug# 5066958
state serialization compatibility with JDK 1.1
remove trailing '+'
true if not known to be in heap order
true if must screen for nulls
If c.toArray incorrectly doesn't return Object[], copy it.
must release and then re-acquire main lock
grow faster if small
back off if another thread is allocating
loop while a non-leaf
assume left child is least
never need to block
never need to block
removed last element
In this order, in case add() throws.
Make a new array of a's runtime type, but my contents:
Array of all elements
index of next element to return
index of last element, or -1 if no such
avoid zero capacity argument
Similar to Collections.ArraySnapshotSpliterator but avoids
commitment to toArray until needed
hoist accesses and checks from loop
ThreadPool and WorkQueue monitoring constants
End of file.
don't complain serialVersionUID not constant
Inner classes <========================================
Private fields ---------------------------------------->
Serialization compatibility stuff -------------------->
Two serial forms are supported in this class. The selected form depends
on system property "jmx.serial.form":
- "1.0" for JMX 1.0
- any other value for JMX 1.1 and higher
Serial version for old serial form
Serial version for new serial form
Serializable fields in old serial form
Serializable fields in new serial form
Actual serial version and serial form
OK: exception means no compat with 1.0, too bad
Serialization compatibility stuff <==============================
Class private fields ----------------------------------->
Class private fields <==============================
Instance private fields ----------------------------------->
Instance private fields <=======================================
Private fields <========================================
Private methods ---------------------------------------->
Category : Instance construction ------------------------->
The name cannot be null
Test if the name is empty
this is equivalent to the whole word query object name.
initialize parsing of the string
canonical form will
be same length at most
parses domain part
":" omission check.
Although "=" is a valid character in the domain part
it is true that it is rarely used in the real world.
So check straight away if the ":" has been omitted
from the ObjectName. This allows us to provide a more
accurate exception message.
check for non-empty properties
we have got the domain part, begins building of _canonicalName
parses property list
case of pattern properties
empty properties case
correct pattern spec in props, continue
standard property case, key part
'=' considered to introduce value part
in_index pointing after '=' char
found end of key
standard property case, value part
the case of quoted value part
the case of an escaped character
the case of standard value part
',' considered to be the value separator
Parsed property, checks the end of name
we got the key and value part, prepare a property for this
computes and set canonical name
The domain cannot be null
The key property list cannot be null
The key property list cannot be empty
checks domain validity
allocates the property array
initialize canonical name and data structure
Category : Instance construction <==============================
Category : Internal utilities ------------------------------>
if no more space for property arrays, have to increase it
Sort the list of found properties
now assigns _ca_array to the sorted list of keys
(there cannot be two identical keys in an objectname.
now we build the canonical name and set begin indexes of
properties to reflect canonical form
length of prop including '=' char
terminate canonicalname with '*' in case of pattern
we now build the canonicalname string
we got the key.
We have an escaped quote. If this escaped
quote is the last character, it does not
qualify as a valid termination quote.
Check that last character is a termination quote.
We have already handled the case were the last
character is an escaped quote earlier.
Non quoted value.
Category : Internal utilities <==============================
Category : Internal accessors ------------------------------>
Category : Internal accessors <==============================
Category : Serialization ----------------------------------->
Read an object serialized in the old serial form
6616825: take care of property patterns
Read an object serialized in the new serial form
Serializes this instance in the old serial form
Read CR 6441274 before making any changes to this code
Serializes this instance in the new serial form
Category : Serialization <===================================
Private methods <========================================
Public methods ---------------------------------------->
Category : ObjectName Construction ------------------------------>
If key or value are null a NullPointerException
will be thrown by the put method in Hashtable.
Category : ObjectName Construction <==============================
Category : Getter methods ------------------------------>
build (lazy eval) the property list from the canonical
CR 6441274 depends on the modification property defined above
BEWARE : we rebuild the propertyliststring at each call !!
the size of the string is the canonical one minus domain
part and pattern part
the size of the string is the canonical one
copy "domain:" into dest_chars
Add property list string
Add ",*" if necessary
Property list string is empty.
Property list string is not empty.
Category : Getter methods <===================================
Category : Utilities ---------------------------------------->
same object case
object is not an object name case
equality when canonical names are the same
(because usage of intern())
Because we are sharing canonical form between object names,
we have finished the comparison at this stage ==> unequal
Category : Utilities <===================================
Category : QueryExp Interface ---------------------------------------->
This ObjectName is the pattern
The other ObjectName is the string.
If key property value pattern but not key property list
pattern, then the number of key properties must be equal
If key property value pattern or key property list pattern,
then every property inside pattern should exist in name
Find value in given object name for key at current
index in receiver
Did we find a value for this key ?
If this property is ok (same key, same value), go to next
wildmatch key property values
p is the property pattern, v is the string
If no pattern, then canonical names must be equal
Category : QueryExp Interface <=========================
Category : Comparable Interface ---------------------------------------->
(1) Compare domains
(2) Compare "type=" keys
Within a given domain, all names with missing or empty "type="
come before all names with non-empty type.
When both types are missing or empty, canonical-name ordering
applies which is a total order.
(3) Compare canonical names
Category : Comparable Interface <=========================
Public methods <========================================
Implements the method defined in SnmpMibAgent. See SnmpMibAgent
Builds the request tree: creation is not allowed, operation
is not atomic.
For each sub-request stored in the request-tree, invoke the
Gets the Meta node. It can be either a Group Meta or a
Gets the depth of the Meta node in the OID tree
Invoke the get() operation.
Implements the method defined in SnmpMibAgent. See SnmpMibAgent
Optimization: we're going to get the whole SnmpRequestTree
built in the "check" method, so that we don't have to rebuild
Optimization didn't work: we have to rebuild the tree.
Builds the request tree: creation is not allowed, operation
For each sub-request stored in the request-tree, invoke the
Gets the Meta node. It can be either a Group Meta or a
Gets the depth of the Meta node in the OID tree
Invoke the set() operation
Implements the method defined in SnmpMibAgent. See SnmpMibAgent
Builds the request tree: creation is allowed, operation
For each sub-request stored in the request-tree, invoke the
Gets the Meta node. It can be either a Group Meta or a
Gets the depth of the Meta node in the OID tree
Invoke the check() operation
Optimization: we're going to pass the whole SnmpRequestTree
to the "set" method, so that we don't have to rebuild it there.
Implements the method defined in SnmpMibAgent. See SnmpMibAgent
Build the request tree for the operation
The subrequest stored in the request tree are valid GET requests
Now invoke get() for each subrequest of the request tree.
Gets the Meta node. It can be either a Group Meta or a
Gets the depth of the Meta node in the OID tree
Invoke the get() operation
Implements the method defined in SnmpMibAgent. See SnmpMibAgent
Ask the tree to do the job !
Now format the result
Build an empty request tree
For each varbind in the list finds its handling node.
Find the handling node for this varbind.
If the operation is atomic (Check/Set) or the version
is V1 we must generate an exception.
The index in the exception must correspond to the
SNMP index ...
Should never come here...
Creates an empty request tree, no entry creation is allowed (false)
Sets the getNext flag: if version=V2, status exception are
transformed in  endOfMibView
For each varbind, finds the handling node.
This function has the side effect of transforming a GET-NEXT
request into a valid GET request, replacing the OIDs in the
original GET-NEXT request with the OID of the first leaf that
Find the node handling the OID that follows the varbind
OID. `result' contains this next leaf OID.
We replace the varbind original OID with the OID of the
leaf object we have to return.
"Couldn't find a handling node for "
The index in the exception must correspond to the
SNMP index ...
combining class definitions
Special case mapping entries
# Conditional mappings
# GREEK CAPITAL LETTER SIGMA
# LATIN CAPITAL LETTER I WITH DOT ABOVE
# Locale-sensitive mappings
# COMBINING DOT ABOVE
# LATIN CAPITAL LETTER I
# LATIN CAPITAL LETTER J
# LATIN CAPITAL LETTER I WITH OGONEK
# LATIN CAPITAL LETTER I WITH GRAVE
# LATIN CAPITAL LETTER I WITH ACUTE
# LATIN CAPITAL LETTER I WITH TILDE
# Turkish and Azeri
# LATIN CAPITAL LETTER I WITH DOT ABOVE
# LATIN CAPITAL LETTER I WITH DOT ABOVE
# COMBINING DOT ABOVE
# COMBINING DOT ABOVE
# LATIN CAPITAL LETTER I
# LATIN CAPITAL LETTER I
# LATIN SMALL LETTER I
# LATIN SMALL LETTER I
A hash table that contains the above entries
create hashtable from the entry
default to Character class' one
default to Character class' one
Look for a preceding 'cased' letter
Check that there is no 'cased' letter after the index
Look for the last preceding base character
Look for the last preceding character
Look for a following ABOVE combining class character
Look for a following COMBINING DOT ABOVE
Check for Other_Lowercase and Other_Uppercase
MODIFIER LETTER SMALL H..MODIFIER LETTER SMALL Y
MODIFIER LETTER GLOTTAL STOP..MODIFIER LETTER REVERSED GLOTTAL STOP
MODIFIER LETTER SMALL GAMMA..MODIFIER LETTER SMALL REVERSED GLOTTAL STOP
COMBINING GREEK YPOGEGRAMMENI
MODIFIER LETTER CAPITAL A..MODIFIER LETTER SMALL CHI
ROMAN NUMERAL ONE..ROMAN NUMERAL ONE THOUSAND
SMALL ROMAN NUMERAL ONE..SMALL ROMAN NUMERAL ONE THOUSAND
CIRCLED LATIN CAPITAL LETTER A..CIRCLED LATIN CAPITAL LETTER Z
CIRCLED LATIN SMALL LETTER A..CIRCLED LATIN SMALL LETTER Z
Soft_Dotted # L&       LATIN SMALL LETTER I
Soft_Dotted # L&       LATIN SMALL LETTER J
Soft_Dotted # L&       LATIN SMALL LETTER I WITH OGONEK
Soft_Dotted # L&       LATIN SMALL LETTER I WITH STROKE
Soft_Dotted # L&       CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I
Soft_Dotted # L&       CYRILLIC SMALL LETTER JE
Soft_Dotted # L&       LATIN SUBSCRIPT SMALL LETTER I
Soft_Dotted # L&       LATIN SMALL LETTER I WITH TILDE BELOW
Soft_Dotted # L&       LATIN SMALL LETTER I WITH DOT BELOW
Soft_Dotted # L&       SUPERSCRIPT LATIN SMALL LETTER I
This does not override getSecondary1 (102,102,102)
Either iconify the frame or deiconify and activate it.
We have a read-only access.
We have a read-write access.
XXX print backtrace of cause
XXX print backtrace of cause
XXX print backtrace of cause
Fix For 6185151: Menu shortcuts of all menuitems within a menu
should be disabled when the menu itself is disabled
Fix For 6185151: Menu shortcuts of all menuitems within a menu
should be disabled when the menu itself is disabled
MenuShortcut match -- issue an event on keydown.
silently eat key release.
This is final so it can be called on the Toolkit thread.
REMIND: remove when filtering is done at lower level
HeadlessException will be thrown from MenuComponent's readObject
skip value for unrecognized key
[[[PENDING:  WDW -- need to provide a localized string]]]
Simulate a button click
don't render if the width/height are too small
no caching so paint directly
9 Square caching
can not give a right answer as painter sould not be used outside
of nimbus laf but do the best we can
handle some special cases for performance
don't do anything, it just didn't work, that's all.
This could be a normal occurance if you use a property
name referring to a key in clientProperties instead of
a real property
we return the defaultColor if the color found is null, or if
it is a UIResource. This is done because the color for the
ENABLED state is set on the component, but you don't want to use
that color for the over state. So we only respect the color
specified for the property if it was set by the user, as opposed
to set by us.
canvasSize.width - insets.right
only used if inverted == true
only used if inverted == true
only used if inverted == true
only used if inverted == true
---------------------- private methods
initializes the class to prepare it for being able to decode points
if no PaintContext has been specified, reset the values and bail
also bail if the canvasSize was not set (since decoding will not work)
calculate the scaling factor, and the sizes for the various 9-square sections
check if we can scale to the requested size
get image at canvas size
calculate dst inserts
todo: destination inserts need to take into acount scale factor for high dpi. Note: You can use f for this, I think
paint 9 square scaled
render cached image
get the buffer for this component
to avoid any potential, though unlikely, infinite loop
validate the buffer so we can check for surface loss
If the buffer status is incompatible or restored, then we need to re-render to the volatile image
if the buffer is null (hasn't been created), or isn't the right size, or has lost its contents,
then recreate the buffer
clear any resources related to the old back buffer
recreate the buffer
put in cache for future
create the graphics context with which to paint to the buffer
clear the background before configuring the graphics
paint the painter into buffer
close buffer graphics
check if we failed
convenience method which creates a temporary graphics object by creating a
clone of the passed in one, configuring it, drawing with it, disposing it.
These steps have to be taken to ensure that any hints set on the graphics
are removed subsequent to painting.
Handle the 'name' attribute
Ignore the element if the QName is invalid
Get namespace attribute
Optimize compilation when name is known at compile time
Ignore the element if the QName is invalid
Ignore the element if prefix is undeclared
Prepend prefix to local name
Optimize translation if element name is a literal
if the qname is an AVT, then the qname has to be checked at runtime if it is a valid qname
store the name into a variable first so _name.translate only needs to be called once
call checkQName if the name is an AVT
Push handler for call to endElement()
load name value again
Push additional arguments
Do this to keep format from crying.
This is better than making a bunch of conditional
code all over the place.
NOTE: MetalCheckBoxUI inherts from MetalRadioButtonUI instead
of BasicCheckBoxUI because we want to pick up all the
painting changes made in MetalRadioButtonUI.
no-op for now.
only if top level?
Yech, shouldn't have to do this.  -sb
Tell if this is being called from within a predicate.
And get how many total predicates are part of this step.
If we have already calculated the length, and the current predicate
is the first predicate, then return the length.  We don't cache
the anything but the length of the list to the first predicate.
I'm a bit worried about this one, since it doesn't have the
checks found above.  I suspect it's fine.  -sb
Create a clone, and count from the current position to the end
of the list, not taking into account the current predicate and
predicates after the current one.
We want to clip off the last predicate, but only if we are a sub
context node list, NOT if we are a context list.  See pos68 test,
also test against bug4638.
Don't call setPredicateCount, because it clones and is slower.
The line above used to be:
...which looks like a dumb bug to me. -sb
sb: allow reusing of cached nodes when possible?
m_prefixResolver = null;  sb: Why would this ever want to be null?
* Get a cloned LocPathIterator that holds the same
* position as this iterator.
* @return A clone of this iterator that holds the same node position.
* @throws CloneNotSupportedException
public Object clone() throws CloneNotSupportedException
* Set the current context node for this iterator.
* @param n Must be a non-null reference to the node context.
public void setRoot(int n)
* Get the analysis pattern built by the WalkerFactory.
* @return The analysis pattern built by the WalkerFactory.
* Set the analysis pattern built by the WalkerFactory.
* @param a The analysis pattern built by the WalkerFactory.
void setAnalysis(int a)
============= State Data =============
* The analysis pattern built by the WalkerFactory.
* TODO: Move to LocPathIterator.
* @see com.sun.org.apache.xpath.internal.axes.WalkerFactory
Always call the superclass detach last!
These three statements need to be combined into one operation.
Yuck.  Just to shut up the compiler!
These two statements need to be combined into one operation.
TODO: Fix this.
A zero status value corresponds to "NEW", it can't change to
not-NEW because we hold the lock.
Wake up thread if it was suspended; no-op otherwise
The VM can handle all thread states
Just to set the interrupt flag
check for getStackTrace permission
optimization so we do not call into the vm for threads that
have not yet started or have terminated
a thread that was alive during the previous isAlive call may have
since terminated, therefore not having a stacktrace.
Don't need JVM help for current thread
check for getStackTrace permission
Get a snapshot of the list of all threads
else terminated so we don't put it in the map
get current thread state
Added in JSR-166
null unless explicitly set
null unless explicitly set
The following three initially uninitialized fields are exclusively
managed by class java.util.concurrent.ThreadLocalRandom. These
fields are used to build the high-performance PRNGs in the
concurrent code, and we can not risk accidental false sharing.
Hence, the fields are isolated with @Contended.
Type-specific CORBA::Object operations
Ken and Simon will ask about editorial changes
needed in IDL to Java mapping to the following
_get_interface_def() replaces the _get_interface() method
First try to call the delegate implementation class's
"Object get_interface_def(..)" method (will work for ORBs
whose delegates implement this method).
Else call the delegate implementation class's
"InterfaceDef get_interface(..)" method using reflection
(will work for ORBs that were built using an older version
of the Delegate interface with a get_interface method
but not a get_interface_def method).
If the ORB's delegate class does not implement
"Object get_interface_def(..)", this will throw
Call "InterfaceDef get_interface(..)" method using reflection.
methods for which the user must provide an
check out Reference children
At least one Reference must be present. Bad.
the this.doc is handed implicitly by the this.getOwnerDocument()
add Reference object to our cache vector
add the Element of the Reference object to the Manifest/SignedInfo
update the cached Reference object, the Element content is automatically updated
not yet constructed, so _we_ have to
if only one item does not verify, the whole verification fails
was verification successful till now and do we want to verify the Manifest?
Hm, seems not to be a ds:Manifest
The Reference stated that it points to a ds:Manifest
but we did not find a ds:Manifest in the signed area
SplashScreen class is now a singleton
check for available data
no data available... well, let's try reading one byte
we'll see what happens then
check for enough room in buffer, realloc if needed
the buffer always grows in size 2x minimum
now read the data
get unscaled splash image size
Note that we steal the data array here, but just for reading
so we do not need to mark the DataBuffer dirty...
pointer to native Splash structure
Copyright (c) 1995-96 by Cisco Systems, Inc.
optimization. keep track of whether unresolved permissions need to be
optimization. keep track of the AllPermission collection
- package private for ProtectionDomain optimization
No sync; staleness -> optimizations delayed, which is OK
No sync; staleness -> skip optimization, which is OK
AllPermission has already been added
go through each Permissions in the hash table
and call their elements() function.
Check for unresolved permissions
if still null, create a new collection
still no PermissionCollection?
We'll give them a PermissionsHash.
Called from within synchronized method so permsMap doesn't need lock
we have no unresolved permissions if uc is null
we have no unresolved permissions of this type if unresolvedPerms is null
Need to maintain serialization interoperability with earlier releases,
which had the serializable field:
Don't call out.defaultWriteObject()
Copy perms into a Hashtable
no sync; estimate
Write out serializable fields
no sync; staleness OK
Don't call defaultReadObject()
Read in serialized fields
writeObject writes a Hashtable<Class<?>, PermissionCollection> for
the perms key, so this cast is safe, unless the data is corrupt.
all the perms
the current set
No need to synchronize; caller should sync on object as required
if we enter with permissionimpl null, we know
there are no more left.
try to see if there are any left in the current one
get the next one that has something in it...
if it is null, we are done!
No need to synchronize; caller should sync on object as required
hasMoreElements will update permset to the next permset
with something in it...
attempt a fast lookup and implies. If that fails
then enumerate through all the permissions.
If permission is found, then p.equals(permission)
Convert Iterator of Map values into an Enumeration
Need to maintain serialization interoperability with earlier releases,
which had the serializable field:
Don't call out.defaultWriteObject()
Copy perms into a Hashtable
Write out serializable fields
Don't call defaultReadObject()
Read in serialized fields
writeObject writes a Hashtable<Class<?>, PermissionCollection> for
the perms key, so this cast is safe, unless the data is corrupt.
XML Schema 1.1 type
notation use the same one as qname
XML Schema 1.1 type
XML Schema 1.1 type
XML Schema 1.1 type
Base64BinaryDV(),   Base64 know how to deal with spaces
PrecisionDecimalDV() (Schema 1.1)
YearMonthDurationDV() (Schema 1.1)
DayTimeDurationDV() (Schema 1.1)
AnyAtomicDV() (Schema 1.1)
XML Schema 1.1 type constants
DOM Level 3 TypeInfo Derivation Method constants
this will be true if this is a static XSSimpleTypeDecl
and hence must remain immutable (i.e., applyFacets
may not be permitted to have any effect).
The most specific built-in type kind.
for constraining facets
used in case fenumerationType value is LIST or LISTOFUNION
annotations for constraining facets
facets as objects
enumeration and pattern facets
for fundamental facets
The namespace schema information item corresponding to the target namespace
of the simple type definition, if it is globally declared; or null otherwise.
Create a new built-in primitive types (and id/idref/entity/integer/yearMonthDuration)
To simplify the code for anySimpleType, we treat it as an atomic type
Specify the build in kind for this primitive type
Create a new simple type for restriction for built-in types
Specify the build in kind for this built-in type
Create a new simple type for restriction.
always inherit facets from the base.
in case a type is created, but applyFacets is not called
always inherit facet annotations in case applyFacets is not called.
we also set fundamental facets information in case applyFacets is not called.
Inherit from the base type
Create a new simple type for list.
setting fundamental facets
Values of this type are lists
Create a new simple type for union.
even for union, we set whitespace to something
this will never be used, but we can use fFacetsDefined to check
whether applyFacets() is allwwed: it's not allowed
if fFacetsDefined != 0
setting fundamental facets
none of the schema-defined types are unions, so just set
fIsImmutable to false.
No value can be of this type, so it's unavailable.
set values for restriction.
decline to do anything if the object is immutable.
always inherit facets from the base.
in case a type is created, but applyFacets is not called
we also set fundamental facets information in case applyFacets is not called.
Inherit from the base type
set values for list.
decline to do anything if the object is immutable.
setting fundamental facets
Values of this type are lists
set values for union.
decline to do anything if the object is immutable.
even for union, we set whitespace to something
this will never be used, but we can use fFacetsDefined to check
whether applyFacets() is allwwed: it's not allowed
if fFacetsDefined != 0
setting fundamental facets
No value can be of this type, so it's unavailable.
for anySimpleType, return absent variaty
REVISIT: error situation. runtime exception?
recursively get base, until we reach anySimpleType
REVISIT: error situation. runtime exception?
REVISIT: error situation. runtime exception?
should never gets here, internel error
we've now applied facets; so lock this object:
should never gets here, internel error
we've now applied facets; so lock this object:
if the object is immutable, should not apply facets...
clear facets. because we always inherit facets in the constructor
REVISIT: in fact, we don't need to clear them.
we can convert 5 string values (4 bounds + 1 enum) to actual values,
store them somewhere, then do facet checking at once, instead of
going through the following steps. (lots of checking are redundant:
for example, ((presentFacet & FACET_XXX) != 0))
step 1: parse present facets
check 4.3.5.c0 must: enumeration values from the value space of base
check against fixed value in base
maxInclusive from base
check against fixed value in base
maxExclusive from base
If maxExclusive == base.maxExclusive, then we only need to check
maxExclusive <= base.maxInclusive
check against fixed value in base
minExclusive from base
If minExclusive == base.minExclusive, then we only need to check
minExclusive >= base.minInclusive
check against fixed value in base
minInclusive from base
token type: internal use, so do less checking
step 2: check facets against each other: length, bounds
check 4.3.2.c1 must: minLength <= maxLength
check 4.3.8.c1 error: maxInclusive + maxExclusive
check 4.3.9.c1 error: minInclusive + minExclusive
check 4.3.7.c1 must: minInclusive <= maxInclusive
check 4.3.8.c2 must: minExclusive <= maxExclusive ??? minExclusive < maxExclusive
check 4.3.9.c2 must: minExclusive < maxInclusive
check 4.3.10.c1 must: minInclusive < maxExclusive
check 4.3.12.c1 must: fractionDigits <= totalDigits
step 3: check facets against base
check 4.3.1.c1 error: length & (fBase.maxLength | fBase.minLength)
length, fBase.minLength and fBase.maxLength defined
length and fBase.maxLength defined
check 4.3.1.c2 error: length != fBase.length
check 4.3.1.c1 error: fBase.length & (maxLength | minLength)
fBase.length, minLength and maxLength defined
fBase.length, minLength and maxLength defined
check 4.3.2.c1 must: minLength <= fBase.maxLength
check 4.3.2.c2 error: minLength < fBase.minLength
check 4.3.2.c1 must: maxLength < fBase.minLength
check 4.3.3.c1 error: maxLength > fBase.maxLength
check 4.3.11.c1 error: totalDigits > fBase.totalDigits
check 4.3.12.c1 must: fractionDigits <= base.totalDigits
check 4.3.12.c2 error: fractionDigits > fBase.fractionDigits
check fixed value for fractionDigits
check 4.3.6.c1 error:
(whiteSpace = preserve || whiteSpace = replace) && fBase.whiteSpace = collapese or
whiteSpace = preserve && fBase.whiteSpace = replace
fFacetsDefined != null
step 4: inherit other facets from base (including fTokeyType)
step 5: mark fixed values
step 6: setting fundamental facets
first normalize string value, and convert it to actual value
first normalize string value, and convert it to actual value
first normalize string value, and convert it to actual value
then validate the actual value against the facets
now check extra rules: for ID/IDREF/ENTITY
For QName and NOTATION types, we don't check length facets
(fVariety == VARIETY_ATOMIC)
(fVariety == VARIETY_UNION)
we can still return object for internal use.
validate special kinds of token, in place of old pattern matching
we can't call fItemType.validate(), otherwise checkExtraRules()
will be called twice: once in fItemType.validate, once in
validate method of this type.
so we take two steps to get the actual value:
(fVariety == VARIETY_UNION)
we can't call fMemberType[i].validate(), otherwise checkExtraRules()
will be called twice: once in fMemberType[i].validate, once in
validate method of this type.
so we take two steps to get the actual value:
determine whether the two values are identical
normalize the string according to the whiteSpace facet
when it's replace, just replace #x9, #xa, #xd by #x20
when it's collapse
append real characters, so we passed leading ws
for whitespaces, we skip all following ws
if it's not a leading or tailing ws, then append a space
normalize the string according to the whiteSpace facet
If pattern is not defined, we can skip some of the normalization.
Otherwise we have to normalize the data for correct result of
when it's replace, just replace #x9, #xa, #xd by #x20
when it's collapse
append real characters, so we passed leading ws
for whitespaces, we skip all following ws
if it's not a leading or tailing ws, then append a space
REVISIT: is the length possible to be 0?
we need to process the first member type before entering the loop
for the other member types, check whether the value is false
and whether they have the same ancestor as the first one
REVISIT: all member types should have the same ordered value
just use the first one. Can we assume this?
REVISIT: implement according to derivation
ancestor is null, return false
extract the actual XSTypeDefinition if the given ancestor is a delegate.
ancestor is anyType, return true
anyType is the only type whose base type is itself
recursively get base, and compare it with ancestor
compare with ancestor
REVISIT: implement according to derivation
ancestor is null, retur false
ancestor is anyType, return true
recursively get base, and compare it with ancestor
compare with ancestor
ancestor is null, return false
ancestor is anyType, return true
If the value of the parameter is 0 i.e. no bit (corresponding to
restriction, list, extension or union) is set to 1 for the
for each base, item or member type
If the ancestor type is reached or is the same as this type.
check if derived by restriction or list or union
get the base, item or member type depending on the variety
If the variety is union
T2 is derived from the other type definition by DERIVATION_RESTRICTION
If the variety is union
get member types
T2 is derived from the other type definition by DERIVATION_RESTRICTION
schema validation is predicated upon namespaces
if it's immutable, can't be reset:
for constraining facets
REVISIT: reset for fundamental facets
or perhaps not registered at all
DirectExecutor using caller thread
Drop the POA lock during the incarnate call and
re-acquire it afterwards.  The entry state machine
prevents more than one thread from executing the
incarnate method at a time within the same POA.
servant == null means incarnate threw an exception,
while servant instanceof NullServant means incarnate returned a
null servant.  Either case is an incarnate failure to the
entry state machine.
XXX Does the AOM leak in this case? Yes,
but the problem is hard to fix.  There may be
a number of threads waiting for the state to change
from INCARN to something else, which is VALID or
INVALID, depending on the incarnate result.
The activeObjectMap.get() call above creates an
ActiveObjectMap.Entry if one does not already exist,
and stores it in the keyToEntry map in the AOM.
here check for unique_id policy, and if the servant
is already registered for a different ID, then throw
OBJ_ADAPTER exception, else activate it. Section 11.3.5.1
check if the servant already is associated with some id
Copy the elements in the set to an array to avoid
changes in the set due to concurrent modification
Here we etherealize in the thread that called this
method, rather than etherealizing in a new thread
as in the deactivate case.  We still inform the
entry state machine so that only one thread at a
time can call the etherealize method.
ignore all exceptions
ignore all exceptions
largest numerical value
These would not be used for EN. Only used for traditional numbering
These only used for mutiplicative-additive numbering
Note that we are using longs and that the last two
multipliers are not supported. This is a known limitation.
read and discard the repository ID
write the repository ID
name of current class
name of package
reference to constant pool
file to write to
String to return for cp[i]
The constants in the cp
Loop through constants, constants[0] is reserved
The header is always the same
Get class_index and name_and_type_index, depending on type
Get method name and its class
Partially compacted class name, i.e., / -> .
I.e., remove java.lang.
I.e., remove java.lang.
Remove class package prefix
Get method signature
Get array of strings containing the argument types
Get return type string
Method is local to class
Get class_index and name_and_type_index
Get method name and its class (compacted)
I.e., remove java.lang.
Remove class package prefix
Field is local to class
/ -> .
I.e., remove java.lang.
Remove class package prefix
-- This file was mechanically generated: Do not edit! --
Forward the event to the top of EventQueue stack
The event was not coalesced or has non-Component source.
Insert it at the end of the appropriate Queue.
Give Component.coalesceEvents a chance
The worst case
Return -1 for SunDropTargetEvent since they are usually synchronous
and we don't want to skip them by coalescing with MouseEvent or other drag events
In case fwDispatcher is installed and we're already on the
dispatch thread (e.g. performing DefaultKeyboardFocusManager.sendMessage),
dispatch the event straight away.
This could become the sole method of dispatching in time.
Transfer all events forward to new EventQueue.
Use getNextEventPrivate() as it doesn't call flushPendingEvents()
Wake up EDT waiting in getNextEvent(), so it can
pick up a new EventQueue. Post the waking event before
topQueue.nextQueue is assigned, otherwise the event would
Transfer all events back to previous EventQueue.
Wake up EDT waiting in getNextEvent(), so it can
pick up a new EventQueue
Forward the request to the top of EventQueue stack
This series of 'instanceof' checks should be replaced with a
polymorphic type (for example, an interface which declares a
getWhen() method). However, this would require us to make such
a type public, or to place it in sun.awt. Both of these approaches
have been frowned upon. So for now, we hack.
In tiger, we will probably give timestamps to all events, so this
will no longer be an issue.
Forward call to the top of EventQueue stack.
The method is used by AWTAccessor for javafx/AWT single threaded mode.
Return the dispatch-only TOA, which can dispatch
request for objects created by any TOA.
The dispatch-only TOA is not used for creating
objrefs, so its codebase can be null (and must
be, since we do not have a servant at this point)
override for Javadoc
override for Javadoc and performance
NOTE: methods to convert year-of-era/proleptic-year cannot be here as they may depend on month/day (Japanese)
read and discard the repository ID
write the repository ID
read and discard the repository ID
write the repository ID
Declare serialVersionUID to be compatible with JDK1.1
$Id: JAXPVariableStack.java,v 1.1.2.1 2005/08/01 01:30:17 jeffsuttor Exp $
JAXP 1.3 spec says that if variable name is null then
we need to through IllegalArgumentException
strings that's not added to the schema symbol table, because they
are not symbols in the schema document.
the validator can choose to add them by itself.
the following strings (xsi:, xsd) will be added into the
symbol table that comes with the parser
xsi attributes: in validator
all possible schema element names
all possible schema attribute names (and xml:lang defined on <schema> and <documentation>)
all possible schema attribute values
maxOccurs = "unbounded"
length of a binary type is the number of bytes
This file was generated AUTOMATICALLY from a template file Fri Jul 21 22:00:53 PDT 2017
There is a titlecase equivalent.  Perform further checks:
The character does not have an uppercase equivalent, so it must
already be uppercase; so add 1 to get the titlecase form.
The character does not have a lowercase equivalent, so it must
already be lowercase; so subtract 1 to get the titlecase form.
The character has both an uppercase equivalent and a lowercase
equivalent, so it must itself be a titlecase form; return it.
This character has no titlecase equivalent but it does have an
uppercase equivalent, so use that (subtract the signed case offset).
Java supradecimal digit
The following tables and code generated using:
java GenerateCharacter -plane 14 -template c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/jdk/make/data/characterdata/CharacterData0E.java.template -spec c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/jdk/make/data/unicodedata/UnicodeData.txt -specialcasing c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/jdk/make/data/unicodedata/SpecialCasing.txt -proplist c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/jdk/make/data/unicodedata/PropList.txt -o c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/build/windows-amd64/jdk/gensrc/java/lang/CharacterData0E.java -string -usecharforbyte 11 4 1
The X table has 2048 entries for a total of 4096 bytes.
The Y table has 80 entries for a total of 160 bytes.
The A table has 8 entries for a total of 32 bytes.
The B table has 8 entries for a total of 16 bytes.
In all, the character property tables require 4288 bytes.
THIS CODE WAS AUTOMATICALLY CREATED BY GenerateCharacter:
Chain the exception.
SAXNotSupportedException.java - unsupported feature or value.
Written by David Megginson
NO WARRANTY!  This class is in the Public Domain.
$Id: SAXNotSupportedException.java,v 1.4 2004/11/03 22:55:32 jsuttor Exp $
Added serialVersionUID to preserve binary compatibility
end of SAXNotSupportedException.java
Make the object key template
REVISIT - POA specific
REVISIT - absorb codebase into a policy
Methods required for dispatching requests
This is expected to result in an RMI-IIOP NoSuchObjectException.
See bug 4973160.
XXX For now, this does nothing.
This will need fixing once we support ORB and thread level policies,
but for now, there is no way to associate policies with the TOA, so
getEffectivePolicy must always return null.
Methods unique to the TOA
Store the objref and get a userkey allocated by the transient
Find out the repository ID for this objref.
Create the new objref
Copy the delegate from the new objref to the argument
XXX handle the case of an attempt to connect a local object.
Get the delegate, then ior, then transientKey, then delete servant
4370316. To position components in the center we should:
1. get an amount of extra space within Container
2. incorporate half of that value to the left/top position
Note that we use trancating division for widthOnComponent
The reminder goes to extraWidthAvailable
Imports for Logging
Import general CORBA classes
Import org.omg.CosNaming classes
The grammer for Parsing and Building Interoperable Stringified Names
are implemented in this class
doBind implements all four flavors of binding
isLoggable call to make sure that we save some precious
processor cycles, if there is no need to log.
doBind implements all four flavors of binding
isLoggable call to make sure that we save some precious
processor cycles, if there is no need to log.
doBind implements all four flavors of binding
This should not happen
isLoggable call to make sure that we save some precious
processor cycles, if there is no need to log.
doBind implements all four flavors of binding
This should not happen
isLoggable call to make sure that we save some precious
processor cycles, if there is no need to log.
doResolve actually resolves
doUnbind actually unbinds
isLoggable call to make sure that we save some precious
processor cycles, if there is no need to log.
List actually generates the list
isLoggable call to make sure that we save some precious
processor cycles, if there is no need to log.
Create actually creates a new naming context
If naming context is null, then that must be a serious
The obvious solution:
isLoggable call to make sure that we save some precious
processor cycles, if there is no need to log.
The context is empty so it can be destroyed
This context is not empty!
Not a fatal error, warning should do.
At bottom level?
The identifier must be set
Ensure synchronization of backend
Yes: bind object in this context under the name
Refer Naming Service Doc:00-11-01 section 2.2.3.4
If there is an object already bound with the name
and the binding type is not ncontext a NotFound
Exception with a reason of not a context has to be
Fix for bug Id: 4384628
Previously a Context was bound and now trying to
bind Object. It is invalid.
"Resistence is futile." [Borg pickup line]
Now there are no other bindings under this name
No: bind in a different context
How should we propagate the bind
Bind as object
Narrow to a naming context using Java casts. It must
Bind as context
This should not happen
Length must be greater than 0
The identifier must be set
Resolve first level in this context
Object was not found
n.length > 1
Compute restOfName = name[1..length]
Resolve rest of name in context
First try to resolve using the local call, this should work
most of the time unless there are federated naming contexts.
The identifier must be set
Yes: unbind in this context
It was not bound
No: unbind in a different context
Resolve first  - must be resolveable
Propagate unbind to this context
Resolve first  - must be resolveable
It was not bound
Was it bound as a context?
It was not a context
Narrow to a naming context
It was not a context
Hmm. must be ok
If there is a name component whose id and kind null or
zero length string, then an invalid name exception needs to be
Extra check to see that corba name url created is valid as per
INS spec grammer.
Used to map StyleConstants to CSS.
remove the old html view client property if one
existed, and install a new one if the text installed
into the JLabel is html source.
relies on fact that double 0 must have same rep as long
Common UI methods
Must always call init.  See bug 4488137.  This code was
incorrectly changed to return immediately on a non-null
cache result.  That allowed threads to gain access to
History: Note, the following init() call was originally within
the synchronization block, as it currently is now. Later, the
init() call was moved outside the synchronization block, and
the init() method used a private member variable lock, to
avoid performance problems. See bug 4165204. But that lead to
a deadlock situation, see bug 5104239. Hence, the init() method
has now been moved back into the synchronization block. The
right approach to solving these problems would be to rewrite
this class, based on the latest java.io.ObjectStreamClass.
Return a copy so the caller can't change the fields.
Ignore this; all we want to do is return false
Note that ValueUtility.getSignature can throw checked exceptions.
proxy classes are never externalizable
See description at definition of initialized.
For each declared persistent field, look for an actual
reflected Field. If there is one, make sure it's the correct
type and cache it in the ObjectStreamClass for that field.
Nothing to do
Lookup special Serializable members using reflection.
proxy classes always have serialVersionUID of 0L
SerialBug 5:  static final SUID should be read
SerialBug 2: should be computed after writeObject
SerialBug 2: should be computed after writeObject
SerialBug 2: should be computed after writeObject
This call depends on a lot of information computed above!
If we have a write object method, precompute the
RMI-IIOP stream format version 2 optional data
This must be done last.
Specific to RMI-IIOP
XXX I18N, logging needed
XXX I18N, logging needed
XXX I18N, logging needed
The next check is more generic, since it covers the
Proxy case, the JDK 1.3 serialization code has
if ((serializable && localClassDesc.externalizable) ||
(externalizable && localClassDesc.serializable))
throw new InvalidClassException(localCl.getName(),
XXX I18N, logging needed
XXX I18N, logging needed
go on to the next source field
should not occur, as access checks have been suppressed
Mask out any post-1.4 attributes
Mask out any post-1.4 bits
TBD: what modifiers does it have
mask out post-1.4 modifiers
mask out post-1.4 modifiers
Get SUID of parent
SerialBug 1; acc. to spec the one for
should be computed and put
&& (parent != java.lang.Object.class))
CORBA formal 00-11-03 10.6.2:  For each field of the
class that is mapped to IDL, sorted lexicographically
by Java field name, in increasing order...
...Java field name in UTF encoding, field
descriptor, as defined by the JVM spec...
SerialBug 3: SHA computation is wrong; for loop reversed
for (int i = minimum; i > 0; i--)
This entry has been cleared,  unlink it
Make sure not already present
XXX I18N, logging needed
XXX I18N, logging needed
cached parameter signature
is a Method.
These message should be read from a locale-specific resource bundle
Returns TRUE if this object represents a null valuetype
Changes the representation to a null valuetype.
If this object represents a null valuetype then this operation
replaces it with a newly constructed value with its components
initialized to default values as in DynAnyFactory::create_dyn_any_from_type_code.
If this object represents a non-null valuetype, then this operation has no effect.
the rest is done lazily
else: there is nothing to do
Methods differing from DynStruct
Required to raise InvalidValue if this is a null value type.
Required to raise InvalidValue if this is a null value type.
Overridden to change to non-null status.
If we didn't get an exception then this must be a valid non-null value
Overridden to change to non-null status.
If we didn't get an exception then this must be a valid non-null value
Hidden data members.
Exported operations inherited and overridden from class Object.
ABSTRACT METHOD IMPLEMENTATIONS: CONTROL
REVISIT - this needs alot more from previous ListenerThread
End of file.
Log wrapper class for Sun private system exceptions in group ACTIVATION
Generated by MC.java version 1.0, DO NOT EDIT BY HAND!
Generated from input file c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/corba/src/share/classes/com/sun/corba/se/spi/logging/data/Activation.mc on Fri Jul 21 21:58:44 PDT 2017
Fields from Image Descriptor
Fields from Graphic Control Extension
Fields from Plain Text Extension
Fields from ApplicationExtension
Fields from CommentExtension
List of byte[]
XXX The "text" attribute of the PlainTextExtension element
is not defined in the GIF image metadata format but it is
present in the GIFImageMetadata class. Consequently it is
used here but not required and with a default of "". See
REVISIT - impl/poa specific:
REVISIT: Would like to be able to configure
the connection cache type used.
REVISIT: Would like to be able to configure
the connection cache type used.
REVISIT - need to filter based on arguments.
REVISIT - initialization will be moved to OA.
Lazy initialization of acceptors.
REVISIT - POA specific policies
End of file.
Constants used internally; unit is milliseconds
Proclaim serialization compatibility with JDK 1.1
throws an NPE if null
Need to initialize the default time zone.
Don't clone here.
get the time zone ID from the system properties
if the time zone ID is not set (yet), perform the
platform to Java time zone ID mapping.
Get the time zone for zoneID. But not fall back to
If the given zone ID is unknown in Java, try to
get the GMT-offset-based time zone ID,
a.k.a. custom time zone ID (e.g., "GMT-08:00").
a static TimeZone we can reference if no AppContext is in place
Error if the length of id isn't long enough or id doesn't
start with "GMT".
First, we try to find it in the cache with the given
id. Even the id is not normalized, the returned ZoneInfo
should have its normalized id.
Always treat the cell as selected, will be adjusted appropriately
First pass, draw the rows
Draw the connecting lines and controls.
Find each parent and have them draw a line to their last child
See if the vertical line to the parent has been drawn.
Empty out the renderer pane, allowing renderers to be gc'ed.
Don't paint the renderer if editing this row.
modify the paintContext's state to match the state for the row
this is a hack in that it requires knowledge of the subsequent
method calls. The point is, the context used in drawCentered
should reflect the state of the row, not of the tree.
One click to edit.
BasicTreeUI directly uses expandIcon outside of the Synth methods.
To get the correct context we return an instance of this that fetches
the SynthContext as needed.
-- This file was mechanically generated: Do not edit! --
enforce limit == capacity
overridden so that this class has access to the same
grammarBucket as the corresponding DTDProcessor
will try and use...
now overwrite some entries in parent:
should never happen
An element in the cache
doPrivileged here because there are multiple
things in initialize that might require privs.
(the FileInputStream call and the File.exists call,
the securityPropFile call, etc)
first load the system properties file
to determine the value of security.overridePropertiesFile
now load the user-specified file so its values
will win if they conflict with the earlier values
maybe check for a system property which will specify where to
Is there a match if we do a case-insensitive property name
comparison? Let's try ...
Is there a match if we do a case-insensitive property name
comparison? Let's try ...
Get all installed providers first.
Then only return those providers who satisfy the selection criteria.
Returns all installed providers
if the selection criteria is null.
For each selection criterion, remove providers
which don't satisfy the criterion from the candidate set.
For each provider in the candidates set, if it
isn't in the newCandidate set, we should remove
it from the candidate set.
Map containing cached Spi Class objects of the specified type
could be a class name with trailing ws
throw first exception, but add second to suppressed
The first component is the service name.
The second is the algorithm name.
If the third isn't null, that is the attrinute name.
Check whether the provider has a property
whose key is the same as the given key.
Check whether we have an alias instead
of a standard name in the key.
The provider doesn't have the given
key in its property list.
If the key is in the format of:
there is no need to check the value.
If we get here, the key must be in the
format of <crypto_service>.<algorithm_or_provider> <attribute_name>.
For now, we just have two standard attributes:
KeySize and ImplementedIn.
For KeySize, prop is the max key size the
provider supports for a specific <crypto_service>.<algorithm>.
For Type, prop is the type of the implementation
for a specific <crypto service>.<algorithm>.
There must be a dot in the filter, and the dot
shouldn't be at the beginning of this string.
The filterValue is an empty string. So the filterKey
should be in the format of <crypto_service>.<algorithm_or_type>.
There must be a algorithm or type name.
The filterValue is a non-empty string. So the filterKey must be
in the format of
There is no attribute name in the filter.
There is no attribute name in the filter.
There must be an algorithm name in the filter.
Check the keys for each provider.
We should skip the currentKey if it contains a
whitespace. The reason is: such an entry in the
provider property contains attributes for the
implementation of an algorithm. We are only interested
in entries which lead to the implementation
Load the translet (for call to displayMessage() function)
Push current output handler onto the stack
Replace the current output handler by a ToXMLStream
Push a reference to a StringWriter
Inline translation of contents
Call toString() on StringWriter
Restore old output handler
Send the resulting string to the message handling method
If 'terminate' attribute is set to 'yes': Instanciate a
RunTimeException, but it on the stack and throw an exception
Create a new instance of RunTimeException
Return no grammars. This allows the garbage collector to sift
out grammars which are not in use when memory demand is high.
It also allows the pool to return the "right" schema grammar
based on schema locations.
retrieveInitialGrammarSet (String): Grammar[]
create a new entry
The JAXP 1.3 spec says that the implementation can assume that
if two schema location hints are the same they always resolve
to the same document. In the default grammar pool implementation
we only look at the target namespaces. Here we also compare
clear this entry; useful to promote garbage collection
since reduces reference count of objects to be destroyed
Reference to the AST parser
AST navigation pointers
Stylesheet ancestor node
Template ancestor node
Element description data
The element QName
Source file line number
Attributes of this element
Sentinel - used to denote unrecognised syntaxt tree nodes.
These two are used for indenting nodes in the AST (debug output)
Initialise the output (default is 'null' for undefined)
First look up the prefix/uri mapping in our own map...
... but if we can't find it there we ask our parent for the mapping
... and then we return whatever URI we've got.
Initialise the output (default is 'null' for undefined)
First look up the prefix/uri mapping in our own map...
... but if we can't find it there we ask our parent for the mapping
only create when needed
if variable or parameter, add it to scope
after the last element, remove any locals from scope
Call translate() on all child nodes
After translation, unmap any registers for any variables/parameters
that were declared in this scope. Performing this unmapping in the
same AST scope as the declaration deals with the problems of
references falling out-of-scope inside the for-each element.
(the cause of which being 'lazy' register allocation for references)
Save the current handler base on the stack
Create new instance of DOM class (with RTF_INITIAL_SIZE nodes)
Overwrite old handler with DOM handler
Call startDocument on the new handler
Instantiate result tree fragment
Call endDocument on the new handler
Check if we need to wrap the DOMImpl object in a DOMAdapter object.
DOMAdapter is not needed if the RTF is a simple RTF and the nodeset()
function is not used.
Push name arrays on the stack
Initialized DOM adapter
Add DOM adapter to MultiDOM class by calling addDOMAdapter()
ignore mask returned by addDOMAdapter
Restore old handler base from stack
create table for features and properties
add default recognized features
set state for default features
add default recognized properties
set default values for normalization features
add message formatters
REVISIT: try to include XML Schema formatter.
This is a hack to allow DTD configuration to be build.
REVISIT: What is the right thing to do? -Ac
save state if noone "objects"
store value if noone "objects"
REVISIT: Recognizes DOM L3 default features only.
Does not yet recognize Xerces features.
Setting to false has no effect.
true is not supported
false is not supported
REVISIT: turning augmentation of PSVI is not support,
because in this case we won't be able to retrieve element
false is not supported
REVISIT: type mismatch
REVISIT: type mismatch
map DOM schema-location to JAXP schemaSource property
REVISIT: type mismatch
REVISIT: when add support to DTD validation
Added support for revalidation against DTDs
Xerces Symbol Table
REVISIT: type mismatch
REVISIT: type mismatch
REVISIT: check if this is a boolean parameter -- type mismatch should be thrown.
parameter is not recognized
REVISIT: Recognizes DOM L3 default features only.
Does not yet recognize Xerces features.
REVISIT: datatype-normalization only takes effect if validation is on
if null, the returned value is true.
REVISIT: I dont like this --- even for unrecognized parameter it would
return 'true'. I think it should return false in that case.
Application will be surprised to find that setParameter throws not
recognized exception when canSetParameter returns 'true' Then what is the use
of having canSetParameter ??? - nb.
features whose parameter value can be set either 'true' or 'false'
or they accept any boolean value -- so we just need to check that
its a boolean value..
features whose parameter value can not be set to 'true'
features whose parameter value can not be set to 'false'
if name is not among the above listed above -- its not recognized. return false
REVISIT: should null value be supported?
as of now we are only supporting W3C XML Schema
Xerces Symbol Table
false if the parameter is not recognized or the requested value is not supported.
Add DOM recognized parameters
REVISIT: Would have been nice to have a list of
Add recognized xerces features and properties
Value type: String
Get the literal string of characters associated with the
current event.  If the parser recognises and supports this
property but is not currently parsing text, it should return
null (this is a good way to check for availability before the
REVISIT - we should probably ask xml-dev for a precise
definition of what this is actually supposed to return, and
in exactly which circumstances.
don't add a component more than once
register component's recognized features
register component's recognized properties
serialVersionUID not constant
Serialization compatibility stuff:
Two serial forms are supported in this class. The selected form depends
on system property "jmx.serial.form":
- "1.0" for JMX 1.0
- any other value for JMX 1.1 and higher
Serial version for old serial form
Serial version for new serial form
Serializable fields in old serial form
Serializable fields in new serial form
Actual serial version and serial form
OK : Too bad, no compat with 1.0
END Serialization compatibility stuff
Can throw IllegalArgumentException
Read an object serialized in the old serial form
Read an object serialized in the new serial form
Serializes this instance in the old serial form
Serializes this instance in the new serial form
Suppresses default constructor, ensuring non-instantiability.
Iterators from Spliterators
current index, modified on advance/split
one past last index
hoist accesses and checks from loop
current index, modified on advance/split
one past last index
hoist accesses and checks from loop
current index, modified on advance/split
one past last index
hoist accesses and checks from loop
current index, modified on advance/split
one past last index
hoist accesses and checks from loop
batch array size increment
batch size for splits
batch size for splits
batch size for splits
batch size for splits
batch array size increment
batch size for splits
batch size for splits
batch size for splits
batch size for splits
use long representation
REVISIT - impl/poa specific:
End of file.
inner class AccessibleCellRendererPane
no chance of subclasses, so no problems with runtime helper lookup
the indirection TCKind, needed for recursive typecodes.
typecode encodings have three different categories that determine
how the encoding should be done.
complex parameters. need to
use CDR encapsulation for
a table storing the encoding category for the various typecodes.
Maps TCKind values to names
This is also used in AnyImpl.
the typecode kind
data members for representing the various kinds of typecodes.
the typecode repository id
the typecode name
names of members
types of members
values of union labels
union discriminator type
union default index
_REVISIT_ We might want to keep references to the ValueMember classes
passed in at initialization instead of copying the relevant data.
Is the data immutable? What about StructMember, UnionMember etc.?
concrete base type
visibility of ValueMember
recursive sequence support
the enclosing type code
the level of enclosure
recursive type code support
caches the byte buffer written in write_value for quick remarshaling...
... but only if caching is enabled
the ORB instance: may be instanceof ORBSingleton or ORB
initialized to tk_null
to handle conversion of "remote" typecodes into "native" style.
also see the 'convertToNative(ORB orb, TypeCode tc)' function
This is a protection against misuse of this constructor.
Should only be used if tc is not an instance of this class!
Otherwise we run into problems with recursive/indirect type codes.
_REVISIT_ We should make this constructor private
set up kind
set up parameters
concrete base may be null
Need to reconstruct _memberAccess using member_count() and member_visibility()
set up member types
set up member names
set up member count
set up stuff for unions
set up length
set up content type
dont have to worry about these since code ensures we dont step
out of bounds.
for primitive types
private API. dont bother checking that
(creationKind < 0 || creationKind > typeTable.length)
do initialization for special cases
this is being used to create typecode for CORBA::Object
for structs and exceptions
else initializes to null
check whether this is the default branch.
else initializes to null
for value types
else initializes to null
else initializes to null
for aliases and value boxes
else initializes to null
else initializes to null
else initializes to null
for sequences and arrays
else initializes to null
for recursive sequences
else initializes to null
for recursive type codes
This is the type code of the type we stand in for, not our own.
Try to resolve it now. May return null in which case
we try again later (see indirectType()).
if (digits < 1 || digits > 31)
else initializes to null
Other creation functions...
If we checked for and returned constant primitive typecodes
here we could reduce object creation and also enable more
efficient typecode comparisons for primitive typecodes.
if (debug) System.out.println("Created TypeCodeOutputStream " + tcos +
Support for indirect/recursive type codes
Nothing we can do about that.
Assert that _kind == tk_indirect
check whether return value != this which would indicate that the
repository id isn't unique.
This is an unresolved recursive sequence tc.
Try to resolve it now if the hierarchy is complete.
Create a recursive type code object as the content type.
This is when the recursive sequence typecode morphes
into a sequence typecode containing a recursive typecode.
Other private functions
Note: Indirect types are handled in kind() method
_REVISIT_ for all optional names/ids, we might want to check that
they are equal in case both are non-nil.
make sure kinds are identical.
no parameters to check.
check for bound.
check for logical id.
check for logical id.
ignore name since its optional.
check for member count
check for repository id
check for member types.
ignore id and names since those are optional.
check for member count
check for repository id
check for default index
check for discriminator type
check for label types and values
check for branch types
ignore id and names since those are optional.
check for repository id
check member count
ignore names since those are optional.
check content type
ignore id and name since those are optional.
check for member count
check for repository id
check for member types.
concrete_base may be null
ignore id and names since those are optional.
check for repository id
check for equality with the true type
dont have to worry about these since the code ensures these dont
If the result of the kind operation on either TypeCode is tk_alias, recursively
replace the TypeCode with the result of calling content_type, until the kind
is no longer tk_alias.
Note: Always resolve indirect types first!
If results of the kind operation on each typecode differ,
equivalent returns false.
At this point the id operation is valid for both TypeCodes.
Return true if the results of id for both TypeCodes are non-empty strings
and both strings are equal.
If both ids are non-empty but are not equal, then equivalent returns FALSE.
id operation is not valid for either or both TypeCodes
If either or both id is an empty string, or the TypeCode kind does not support
the id operation, perform a structural comparison of the TypeCodes.
impossible if we checked correctly above
impossible if we checked correctly above
Structural comparison succeeded!
_REVISIT_ It isn't clear whether this method should operate on this or a copy.
For now just return this unmodified because the name and member_name fields
aren't used for comparison anyways.
Recursive is the only form of indirect type codes right now.
Indirection can also be used for repeated type codes.
return indirectType().id();  same as _id
exception and objref typecodes must have a repository id.
structs, unions, enums, and aliases may or may not.
all other typecodes throw the BadKind exception.
_REVISIT_ Why create a new Any for this?
hardly possible unless caller knows our "private" stream classes.
if (debug) System.out.println("Created WrapperInputStream " + wrapper +
don't wrap a CDRInputStream reading "inner" TypeCodes.
Bug fix 5034649: allow for padding that precedes the typecode kind.
check validity of kind
Don't do any work if this is native
We have to remember the stream and position for EVERY type code
in case some recursive or indirect type code references it.
The encoding used for indirection is the same as that used for recursive ,
TypeCodes i.e., a 0xffffffff indirection marker followed by a long offset
(in units of octets) from the beginning of the long offset.
substract 4 to get back to the beginning of the long offset.
Now we have to find the referenced type
by its indirectTypePosition within topStream.
if (debug) System.out.println(
"TypeCodeImpl looking up indirection at position topPos " +
unmarshal the kind
check validity of kind
Don't do any work if this is native
start unmarshaling the rest of the typecode, based on the
encoding (empty, simple or complex).
nothing to unmarshal
get the repository id
get the name
get the repository id
get the name
get the number of members
create arrays for the label values, names and types of members
read off label values, names and types
for the default case, read off the zero octet
_REVISIT_ figure out long double mapping
get the repository id
get the name
get the number of members
create arrays for the identifier names
read off identifier names
get the type of the sequence
get the bound on the length of the sequence
get the type of the array
get the length of the array
get the repository id
get the name
get the type aliased
get the repository id
get the name
get the number of members
create arrays for the names and types of members
read off member names and types
if (debug) System.out.println("TypeCode " + _name +
get the repository id
get the name
get the type modifier
get the type aliased
get the number of members
create arrays for the names, types and visibility of members
read off value member visibilities
if (debug) System.out.println("TypeCode " + _name +
Wrap OutputStream into TypeCodeOutputStream.
This test shouldn't be necessary according to the Java language spec.
Cache the buffer for repeated writes
if (outBuffer != null)
System.out.println("Caching outBuffer with length = " +
System.out.println("Using cached outBuffer: length = " + outBuffer.length +
Write the first 4 bytes first to trigger alignment.
We know that it is the kind.
Don't do any work if this is native
The encoding used for indirection is the same as that used for recursive ,
TypeCodes i.e., a 0xffffffff indirection marker followed by a long offset
(in units of octets) from the beginning of the long offset.
if (debug) System.out.println("TypeCodeImpl " + tcos +
" writing indirection " + _id +
All that gets written is _kind and offset.
The original approach changed for 5034649
marshal the kind
We have to remember the stream and position for EVERY type code
in case some recursive or indirect type code references it.
Bug fix 5034649:
Do this AFTER the write of the _kind in case the alignment
for the long changes the position.
nothing more to marshal
marshal the bound on string length
unknown typecode kind
create an encapsulation
put the repository id
put the name
put the repository id
put the name
put the number of members
marshal label values, names and types
for the default case, marshal the zero octet
_REVISIT_ figure out long double mapping
put the repository id
put the name
put the number of members
marshal identifier names
put the type of the sequence
put the bound on the length of the sequence
put the type of the array
put the length of the array
put the repository id
put the name
put the type aliased
put the repository id
put the name
put the number of members
marshal member names and types
if (debug) System.out.println("TypeCode " + _name +
put the repository id
put the name
put the type modifier
put the type aliased
put the number of members
marshal member names and types
if (debug) System.out.println("TypeCode " + _name +
marshal the encapsulation
make sure length bound in typecode is not violated
make sure length bound in typecode is not violated
Fall into ...
_REVISIT_ what about the inherited members of this values concrete base type?
copy each element, using the corresponding member type
_REVISIT_ figure out long double mapping
using the value of the tag, find out the type of the value
use equality over anys
check if label has not been found
must be of the default branch type
get the length of the sequence
check for sequence bound violated
write the length of the sequence
copy each element of the seq using content type
make sure it's resolved
copy each element of the array using content type
follow the alias
need to follow offset, get unmarshal typecode from that
offset, and use that to do the copy
Don't need to read type code before using it to do the copy.
It should be fully usable.
Only for union type. Returns the index of the union member
corresponding to the discriminator. If not found returns the
default index or -1 if there is no default index.
memberName might differ from the name of the member.
used to construct from native
the background color to use for cells for alternate cells
TableCellRenderer installed on the JTable at the time we're installed,
cached so that we can reinstall them at uninstallUI time.
The installation/uninstall procedures and support
Paint methods and support
account for the fact that the graphics has already been translated
into the table's bounds
this check prevents us from painting the entire table
when the clip doesn't intersect our bounds at all
This should never happen (as long as our bounds intersect the clip,
which is why we bail above if that is the case).
If the table does not have enough rows to fill the view we'll get -1.
(We could also get -1 if our bounds don't intersect the clip,
which is why we bail above if that is the case).
Replace this with the index of the last row.
This should never happen.
If the table does not have enough columns to fill the view we'll get -1.
Replace this with the index of the last column.
Paint the cells.
Paint the grid.
it is important to paint the grid after the cells, otherwise the grid will be overpainted
because in Synth cell renderers are likely to be opaque
Paint the dragged column if we are dragging.
Remove any renderers that may be left in the rendererPane.
Paint a gray well in place of the moving column.
Move to the where the cell has been dragged.
Fill the background.
Paint the vertical grid lines if necessary.
Render the cell value
Paint the (lower) horizontal grid line if necessary.
Super will have set value.
use the supplied JAAS login configuration
use the default JAAS login configuration (file-based)
Verify that credentials is of type String[].
Special case for null so we get a more informative message
Verify that the array contains two elements.
Verify that username exists and the associated
password matches the one supplied by the client.
The JAAS configuration for file-based authentication
The classname of the login module for file-based authentication
The option that identifies the password file to use
the configuration is fixed
SAX input source.
No warranty; no copyright -- use this as you will.
$Id: InputSource.java,v 1.2 2004/11/03 22:55:32 jsuttor Exp $
end of InputSource.java
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of SplitPanePainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of SplitPanePainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
so RMI-IIOP Util.isLocal can call ClientRequestDispatcher.useLocalInvocation.
Remember chosen subcontract for invoke and releaseReply.
NOTE: This is necessary since a stream is not available in
releaseReply if there is a client marshaling error or an
error in _invoke.
NOTE: InputStream may be null (e.g., exception request from PI).
instantiate the stub
check if returned object is of correct type
This cannot happen.
dest is the typeId of the interface to compare against.
repositoryIds is the list of typeIds that the stub knows about.
First we look for an answer using local information.
But repositoryIds may not be complete, so it may be necessary to
go to server.
This cannot happen.
This cannot happen.
DO NOT clear out internal variables to release memory
This delegate may be pointed-to by other objrefs.
obj._get_delegate() == this due to the argument passing conventions in
portable.ObjectImpl, so we just ignore obj here.
If ref is a local object, it is not a Stub!
Optimize the x.is_equivalent( x ) case
If delegate was created by a different ORB, return false
Come here if other is not implemented by our ORB.
XXX this need to check isNextCallValid
XXX Should this be public?
End of file.
End of file.
First Clean the URL Escapes if there are any
Append corbaloc: for Grammar check, Get the string between
corbaname: and # which forms the corbaloc string
Build a corbaloc string to check the grammar.
10 is the length of corbaname:
If the string doesnot end with a / then add one to end the
Check the corbaloc grammar and set the returned corbaloc
object to the CorbaName Object
String after '#' is the Stringified name used to resolve
the Object reference from the rootnaming context. If
the String is null then the Root Naming context is passed
this shouldn't happen, since we are Cloneable
REVISIT - type
End of file.
Program Counter (PC) corresponds to line
number in source file
The _loadedExternalExtensionFunctions will be empty when the
SecurityManager is not set and the FSP is turned off
We have to read serialized fields first.
throw with the same message as when Hashtable was used for compatibility.
Write serialized fields
Check if this is the main class
The translet needs to keep a reference to all its auxiliary
class to prevent the GC from collecting them
Property to override our maximum stream format version
The ValueHandler's maximum stream format version to advertise,
set in a static initializer.
Looks for the FORMAT_VERSION_PROPERTY system property
to allow the user to override our default stream format
version.  Note that this still only allows them to pick
a supported version (1 through MAX_STREAM_FORMAT_VERSION).
The property wasn't set
REVISIT.  Just set to MAX_SUPPORTED_FORMAT_VERSION
or really let the system shutdown with this Error?
XXX I18N, logging needed.
REVISIT.  Swallow this or really let
the system shutdown with this Error?
Must use narrow rather than a direct cast to a com.sun
class.  Fix for bug 4379539.
backward compatability 4365188
Indirections are resolved immediately since
the change to the active recursion manager,
so this will never happen.
backward compatability 4365188
clazz == null indicates an FVD situation for a nonexistant class
backward compatability 4365188
set the valueHandler so that correct/incorrect RepositoryID
calculations can be done based on the ORB version
methods supported for backward compatability so that the appropriate
Rep-id calculations take place based on the ORB version
XXX I18N, logging needed.
RMI Object reference...
IDL Object reference...
IDL Abstract Object reference...
Read length of coming array
XXX I18N, logging needed.
Store this object and its beginning position
since there might be indirections to it while
it's been unmarshalled.
The CDR stream had never seen the given offset
before, so check the recursion manager (it will
throw an IOException if it doesn't have a
Translate to a MARSHAL exception since
ValueHandlers aren't allowed to throw
Store this object and its beginning position
since there might be indirections to it while
it's been unmarshalled.
Decide what method call to make based on the componentType.
If it is a componentType for which we need to load a stub,
convert the componentType to the correct stub type.
RMI Object reference...
for better performance, load the stub class once
instead of for each element of the array
IDL Object reference...
IDL Abstract Object reference...
RMI Abstract Object reference...
The CDR stream had never seen the given offset before,
so check the recursion manager (it will throw an
IOException if it doesn't have a reference, either).
Translate to a MARSHAL exception since
ValueHandlers aren't allowed to throw
We've completed deserializing this object.  Any
future indirections will be handled correctly at the
CDR level.  The ActiveRecursionManager only deals with
objects currently being deserialized.
Throw exception under the carpet.
Throw exception under the carpet.
Note: We use the thread context or system ClassLoader here
since we want to load classes outside of the
core JDK when running J2EE Pure ORB and
talking to Kestrel.
Since the ClassLoader should cache the class, this isn't
as expensive as it looks.
Check the parameter.
Get the data type.
Check the data type
Return null for other types.
The return variable.
Get the sample size.
Create a Component ColorModel.
Get the number of bands.
Determine the color space.
Load the colormap with a ramp.
bitOffset != 0
bitOffset % 8 != 0
Optimal case: simply return.
bitOffset != 0
bitOffset % 8 != 0
when all the bits in this BYTE will be set
into the data buffer.
All the "leftShift" high bits will be set
into the data buffer.  But not all the
"rightShift" low bits will be set.
Less than "leftShift" high bits will be set.
This BYTE is set into one SHORT
Mask the bits to be set.
This BYTE will be set into two SHORTs
But not all the low bits will be set into SHORT
Only some of the high bits will be set into
This BYTE is set into one INT
Mask the bits to be set.
All the bits of this BYTE will be set into two INTs
But not all the low bits will be set into INT
Only some of the high bits will be set into INT
dataType == DataBuffer.TYPE_SHORT ||
Ensure image rows samples are stored contiguously
in a single bank.
Otherwise true if and only if it's a bilevel image with
a MultiPixelPackedSampleModel, 1 bit per pixel, and 1 bit
class in which the method is defined
may be null if not yet materialized
may be null if not yet materialized
modifier bits; see reflect.Modifier
if null, this guy is resolved
Get a snapshot of type which doesn't get changed by racing threads.
type is not a MethodType yet.  Convert it thread-safely.
Make sure type is a MethodType for racing threads.
Get a snapshot of type which doesn't get changed by racing threads.
type is not a Class yet.  Convert it thread-safely.
Make sure type is a Class for racing threads.
Looking up an interface method, can get (e.g.) Object.hashCode
Looked up a virtual, can get (e.g.) final String.hashCode.
else don't call
let the rest (native, volatile, transient, etc.) be tested via Modifier.isFoo
unofficial modifier flags, used by HotSpot:
modifiers exported by the JVM:
private flags, not part of RECOGNIZED_MODIFIERS:
method (not constructor)
defining class is allowed to be null (for a naked name/type pair)
name.toString();   null check
type.equals(type);   null check
fill in fields:
nobody should have touched this yet
assert(referenceKindIsConsistent());   do this after resolution
Capturing information from the Core Reflection API:
fill in vmtarget, vmindex while we have m in hand:
The JVM did not reify this signature-polymorphic instance.
Need a special case here.
See comments on MethodHandleNatives.linkMethod.
invokeSpecial on a default method
fill in vmtarget, vmindex while we have ctor in hand:
fill in vmtarget, vmindex while we have fld in hand:
it's not resolved, but add these modifiers anyway
bare-bones constructor; the JVM will fill it in
locally useful cloner
Construction from symbolic parts, for queries:
not initialized yet!
else it is a field, method, or constructor
JVM returned to us with an intentional overflow!
Signature matching is not the same as type matching, since
one signature might correspond to several types.
So if matchType is a Class or MethodType, refilter the results.
JVM will side-effect the ref
There are 4 entities in play here:
* LC: lookupClass
* PTYPES: parameter types (MN.type)
What we care about when resolving a MemberName is consistency between DEFC and PTYPES.
We do type alias (TA) checks on DEFC to ensure that. DEFC is not known until the JVM
finishes the resolution, so do TA checks right after MHN.resolve() is over.
All parameters passed by a caller are checked against MH type (PTYPES) on every invocation,
so it is safe to call a MH from any context.
REFC view on PTYPES doesn't matter, since it is used only as a starting point for resolution and doesn't
participate in method selection.
JVM reports that the "bytecode behavior" would get an error
fill the buffer with dummy structs for the JVM to fill in
This function always returns an empty string for namespace nodes.
We check for those here.  Fix inspired by Davanum Srinivas.
This should actually be the CORBA::ORBid type once that is available
NOTE: This may be different from same named one in CorbaContactInfoList.
Note: not all derived classes will use a connection cache.
These are convenience methods that may not be used.
Called when client making an invocation.
REVISIT: Would like version, ior, requestid, etc., decisions
to be in client subcontract.  Cannot pass these to this
factory method because it breaks generic abstraction.
Maybe set methods on mediator called from subcontract
Called when connection handling a read event.
read giop header only
read entire giop message
Called when connection reading message body
read giop body only
REVISIT: Duplicate of acceptor code.
REVISIT - remove this.
End of file.
initialize the system scope
Security.error("unable to establish a system scope from " +
We almost never put a newline after the XML
header because this XML could be used as
an extenal general parsed entity
and we don't know the context into which it
will be used in the future.  Only when
standalone, or a doctype system or public is
specified are we free to insert a new line
after the header.  Is it even worth bothering
in these rare cases?
Not sure this is really what we want.  -sb
Not sure this is really what we want.  -sb
See XSLT spec on error recovery of "?>" in PIs.
add space between.
"flags" has indicated that the characters
'>'  '<'   '&'  and '"' are not in the value and
m_htmlcharInfo has recorded that there are no other
entities in the range 32 to 127 so we write out the
use a different raw name, with the prefix used in the
generated namespace declaration
Generate a warning of the ignored attributes
Create the warning message
Prepare to issue the warning message
Issue the warning message
hack for XSLTC with finding URI for default namespace
the elements URI is not known yet, and it
doesn't have a prefix, and we are currently
setting the uri for prefix "", so we have
the uri for the element... lets remember it
Prepare to issue the warning message
Issue the warning message
XML Schema Components
Built-in types: primitive and derived
All images can have these
If it is an element in the app0jfif subtree, just check
that the image type is JFIF compliant.
font name might be broken across multiple calls
read and discard the repository ID
write the repository ID
Relation identifier (expected to be unique in the Relation Service where
the RelationSupport object will be added)
ObjectName of the Relation Service where the relation will be added
REQUIRED if the RelationSupport is created by the user to be registered as
a MBean, as it will have to access the Relation Service via the MBean
Server to perform the check regarding the relation type.
Is null if current object is directly created by the Relation Service,
as the object will directly access it.
Reference to the MBean Server where the Relation Service is
REQUIRED if the RelationSupport is created by the user to be registered as
a MBean, as it will have to access the Relation Service via the MBean
Server to perform the check regarding the relation type.
If the Relationbase object is created by the Relation Service (use of
createRelation() method), this is null as not needed, direct access to
the Relation Service.
If the Relationbase object is created by the user and registered as a
MBean, this is set by the preRegister() method below.
Relation type name (must be known in the Relation Service where the
relation will be added)
Role map, mapping <role-name> -> <Role>
Initialized by role list in the constructor, then updated:
- if the relation is a MBean, via setRole() and setRoles() methods, or
via Relation Service setRole() and setRoles() methods
- if the relation is internal to the Relation Service, via
setRoleInt() and setRolesInt() methods.
Flag to indicate if the object has been added in the Relation Service
Can throw InvalidRoleValueException and IllegalArgumentException
Can throw InvalidRoleValueException and
Can throw RoleNotFoundException and
Can throw RelationServiceNotRegisteredException
OK : Invalid parameters, ignore...
Try to retrieve the role
No null Role is allowed, so direct use of get()
Will throw a RoleNotFoundException
Will not throw InvalidRoleValueException, so catch it for the
OK : Do not throw InvalidRoleValueException as
a RoleNotFoundException will be thrown.
Will return null :)
Can throw RoleNotFoundException, InvalidRoleValueException,
Retrieves ObjectNames of MBeans referenced in current role
Sees if current MBean has been already referenced in
roles already seen
Pre-registration: retrieves the MBean Server (useful to access to the
This is the way to retrieve the MBean Server when the relation object is
a MBean created by the user outside of the Relation Service.
No exception thrown.
Post-registration: does nothing
Pre-unregistration: does nothing
Post-unregistration: does nothing
Gets the role with given name
Checks if the role exists and is readable according to the relation
This method is called in getRole() above.
It is also called in the Relation Service getRole() method.
It is also called in getRolesInt() below (used for getRoles() above
and for Relation Service getRoles() method).
Depending on parameters reflecting its use (either in the scope of
getting a single role or of getting several roles), will return:
- in case of success:
- for single role retrieval, the ArrayList of ObjectNames being the
- for multi-role retrieval, the Role object itself
- in case of failure (except critical exceptions):
- for single role retrieval, if role does not exist or is not
readable, an RoleNotFoundException exception is raised
- for multi-role retrieval, a RoleUnresolved object
-param roleName  name of role to be retrieved
-param relationServCallFlg  true if call from the Relation Service; this
will happen if the current RelationSupport object has been created by
the Relation Service (via createRelation()) method, so direct access is
-param relationServ  reference to Relation Service object, if object
created by Relation Service.
-param multiRoleFlg  true if getting the role in the scope of a
- for single role retrieval (multiRoleFlg false):
- ArrayList of ObjectName objects, value of role with given name, if
the role can be retrieved
- raise a RoleNotFoundException exception else
- for multi-role retrieval (multiRoleFlg true):
- the Role object for given role name if role can be retrieved
- a RoleUnresolved object with problem.
-exception IllegalArgumentException  if null parameter
-exception RoleNotFoundException  if multiRoleFlg is false and:
- there is no role with given name
- the role is not readable.
-exception RelationServiceNotRegisteredException  if the Relation
Service is not registered in the MBean Server
No null Role is allowed, so direct use of get()
Checks if the role is readable
Call from the Relation Service, so direct access to it,
avoiding MBean Server
Shall not throw a RelationTypeNotFoundException
Call from getRole() method above
So we have a MBean. We must access the Relation Service
via the MBean Server.
Can throw InstanceNotFoundException if the Relation
Service is not registered (to be catched in any case and
transformed into RelationServiceNotRegisteredException).
Shall not throw a MBeanException, or a ReflectionException
or an InstanceNotFoundException
Role can be retrieved
Single role retrieved: returns its value
Note: no need to test if role value (list) not null before
cloning, null value not allowed, empty list if
Role retrieved during multi-role retrieval: returns the
Role not retrieved
Problem when retrieving a simple role: either role not
found or not readable, so raises a RoleNotFoundException.
To keep compiler happy :)
Problem when retrieving a role in a multi-role retrieval:
returns a RoleUnresolved object
Gets the given roles
For each role, verifies if the role exists and is readable according to
the relation type.
This method is called in getRoles() above and in Relation Service
-param roleNameArray  array of names of roles to be retrieved
-param relationServCallFlg  true if call from the Relation Service; this
will happen if the current RelationSupport object has been created by
the Relation Service (via createRelation()) method, so direct access is
-param relationServ  reference to Relation Service object, if object
created by Relation Service.
-return a RoleResult object
-exception IllegalArgumentException  if null parameter
-exception RelationServiceNotRegisteredException  if the Relation
Service is not registered in the MBean Server
Can throw RelationServiceNotRegisteredException
RoleNotFoundException: not possible but catch it for compiler :)
Can throw IllegalArgumentException if role is null
(normally should not happen :(
Can throw IllegalArgumentException if role is null
(normally should not happen :(
Returns all roles present in the relation
-return a RoleResult object, including a RoleList (for roles
successfully retrieved) and a RoleUnresolvedList (for roles not
-exception IllegalArgumentException if null parameter
-exception RelationServiceNotRegisteredException  if the Relation
Service is not registered in the MBean Server
Sets the role with given value
This method is called in setRole() above.
It is also called by the Relation Service setRole() method.
It is also called in setRolesInt() method below (used in setRoles()
above and in RelationService setRoles() method).
Will check the role according to its corresponding role definition
provided in relation's relation type
Will send a notification (RelationNotification with type
RELATION_BASIC_UPDATE or RELATION_MBEAN_UPDATE, depending if the
relation is a MBean or not) if not initialization of role.
-param aRole  role to be set (name and new value)
-param relationServCallFlg  true if call from the Relation Service; this
will happen if the current RelationSupport object has been created by
the Relation Service (via createRelation()) method, so direct access is
-param relationServ  reference to Relation Service object, if internal
-param multiRoleFlg  true if getting the role in the scope of a
-return (except other "critical" exceptions):
- for single role retrieval (multiRoleFlg false):
- null if the role has been set
- raise an InvalidRoleValueException
- for multi-role retrieval (multiRoleFlg true):
- the Role object for given role name if role has been set
- a RoleUnresolved object with problem else.
-exception IllegalArgumentException if null parameter
-exception RoleNotFoundException  if multiRoleFlg is false and:
- internal relation and the role does not exist
- existing role (i.e. not initializing it) and the role is not
-exception InvalidRoleValueException  ifmultiRoleFlg is false and
value provided for:
- the number of referenced MBeans in given value is less than
expected minimum degree
- the number of referenced MBeans in provided value exceeds expected
- one referenced MBean in the value is not an Object of the MBean
class expected for that role
- a MBean provided for that role does not exist
-exception RelationServiceNotRegisteredException  if the Relation
Service is not registered in the MBean Server
-exception RelationTypeNotFoundException  if relation type unknown
-exception RelationNotFoundException  if a relation MBean has not been
added in the Relation Service
Checks if role exists in the relation
No error if the role does not exist in the relation, to be able to
handle initialization of role when creating the relation
(roles provided in the RoleList parameter are directly set but
roles automatically initialized are set using setRole())
Checks if the role can be set: is writable (except if
initialization) and correct value
Call from the Relation Service, so direct access to it,
avoiding MBean Server
Shall not raise a RelationTypeNotFoundException
Call from setRole() method above
So we have a MBean. We must access the Relation Service
via the MBean Server.
Can throw InstanceNotFoundException if the Relation Service
is not registered (to be transformed into
RelationServiceNotRegisteredException in any case).
Can throw a MBeanException wrapping a
throw wrapped exception.
Shall not throw a ReflectionException
Retrieves underlying exception
Role can be set
Not initializing the role
If role being initialized:
- do not send an update notification
- do not try to update internal map of Relation Service
listing referenced MBeans, as role is initialized to an
Sends a notification (RelationNotification)
Can throw a RelationNotFoundException
Updates the role map of the Relation Service
Can throw RelationNotFoundException
Sets the role
Single role set: returns null: nothing to set in result
Multi-roles retrieval: returns the role
Role not set
Problem when setting a simple role: either role not
found, not writable, or incorrect value:
raises appropriate exception, RoleNotFoundException or
To keep compiler happy :)
Problem when retrieving a role in a multi-role retrieval:
returns a RoleUnresolved object
Requires the Relation Service to send a notification
RelationNotification, with type being either:
- RelationNotification.RELATION_BASIC_UPDATE if the updated relation is
a relation internal to the Relation Service
- RelationNotification.RELATION_MBEAN_UPDATE if the updated relation is
a relation MBean.
-param newRole  new role
-param oldRoleValue  old role value (ArrayList of ObjectNames)
-param relationServCallFlg  true if call from the Relation Service; this
will happen if the current RelationSupport object has been created by
the Relation Service (via createRelation()) method, so direct access is
-param relationServ  reference to Relation Service object, if object
created by Relation Service.
-exception IllegalArgumentException  if null parameter provided
-exception RelationServiceNotRegisteredException  if the Relation
Service is not registered in the MBean Server
-exception RelationNotFoundException if:
- relation MBean
- it has not been added into the Relation Service
Direct call to the Relation Service
Shall not throw a RelationNotFoundException for an internal
Can throw InstanceNotFoundException if the Relation Service
is not registered (to be transformed).
Can throw a MBeanException wrapping a
RelationNotFoundException (to be raised in any case): wrapped
exception to be thrown
Shall not throw a ReflectionException
Requires the Relation Service to update its internal map handling
MBeans referenced in relations.
The Relation Service will also update its recording as a listener to
be informed about unregistration of new referenced MBeans, and no longer
informed of MBeans no longer referenced.
-param newRole  new role
-param oldRoleValue  old role value (ArrayList of ObjectNames)
-param relationServCallFlg  true if call from the Relation Service; this
will happen if the current RelationSupport object has been created by
the Relation Service (via createRelation()) method, so direct access is
-param relationServ  reference to Relation Service object, if object
created by Relation Service.
-exception IllegalArgumentException  if null parameter
-exception RelationServiceNotRegisteredException  if the Relation
Service is not registered in the MBean Server
-exception RelationNotFoundException if:
- relation MBean
- the relation is not added in the Relation Service
Direct call to the Relation Service
Shall not throw a RelationNotFoundException
Can throw InstanceNotFoundException if the Relation Service
is not registered (to be transformed).
Can throw a MBeanException wrapping a RelationNotFoundException:
wrapped exception to be thrown
Shall not throw a ReflectionException
Sets the given roles
For each role:
- will check the role according to its corresponding role definition
provided in relation's relation type
- will send a notification (RelationNotification with type
RELATION_BASIC_UPDATE or RELATION_MBEAN_UPDATE, depending if the
relation is a MBean or not) for each updated role.
This method is called in setRoles() above and in Relation Service
-param list  list of roles to be set
-param relationServCallFlg  true if call from the Relation Service; this
will happen if the current RelationSupport object has been created by
the Relation Service (via createRelation()) method, so direct access is
-param relationServ  reference to Relation Service object, if object
created by Relation Service.
-return a RoleResult object
-exception IllegalArgumentException  if null parameter
-exception RelationServiceNotRegisteredException  if the Relation
Service is not registered in the MBean Server
-exception RelationTypeNotFoundException if:
- relation MBean
- unknown relation type
-exception RelationNotFoundException if:
- relation MBean
- not added in the RS
Will not throw, due to parameters, RoleNotFoundException or
InvalidRoleValueException, but catch them to keep compiler
OK : Do not throw a RoleNotFoundException.
OK : Do not throw an InvalidRoleValueException.
Can throw IllegalArgumentException if role is null
(normally should not happen :(
Can throw IllegalArgumentException if role is null
(normally should not happen :(
Initializes all members
-param relationId  relation identifier, to identify the relation in the
Expected to be unique in the given Relation Service.
-param relationServiceName  ObjectName of the Relation Service where
the relation will be registered.
It is required as this is the Relation Service that is aware of the
definition of the relation type of given relation, so that will be able
to check update operations (set). Direct access via the Relation
Service (RelationService.setRole()) do not need this information but
as any user relation is a MBean, setRole() is part of its management
interface and can be called directly on the user relation MBean. So the
user relation MBean must be aware of the Relation Service where it will
-param relationTypeName  Name of relation type.
Expected to have been created in given Relation Service.
-param list  list of roles (Role objects) to initialized the
relation. Can be null.
Expected to conform to relation info in associated relation type.
-exception InvalidRoleValueException  if the same name is used for two
-exception IllegalArgumentException  if a required value (Relation
Service Object Name, etc.) is not provided as parameter.
Can throw InvalidRoleValueException
Initialize the internal role map from given RoleList parameter
-param list  role list. Can be null.
As it is a RoleList object, it cannot include null (rejected).
-exception InvalidRoleValueException  if the same role name is used for
No need to check if role is null, it is not allowed to store
a null role in a RoleList :)
Role already provided in current list
Callback used by the Relation Service when a MBean referenced in a role
The Relation Service will call this method to let the relation
take action to reflect the impact of such unregistration.
Current implementation is to set the role with its current value
(list of ObjectNames of referenced MBeans) without the unregistered
-param objectName  ObjectName of unregistered MBean
-param roleName  name of role where the MBean is referenced
-param relationServCallFlg  true if call from the Relation Service; this
will happen if the current RelationSupport object has been created by
the Relation Service (via createRelation()) method, so direct access is
-param relationServ  reference to Relation Service object, if internal
-exception IllegalArgumentException if null parameter
-exception RoleNotFoundException  if:
- the role does not exist
- role not writable.
-exception InvalidRoleValueException  if value provided for:
- the number of referenced MBeans in given value is less than
expected minimum degree
- the number of referenced MBeans in provided value exceeds expected
- one referenced MBean in the value is not an Object of the MBean
class expected for that role
- a MBean provided for that role does not exist
-exception RelationServiceNotRegisteredException  if the Relation
Service is not registered in the MBean Server
-exception RelationTypeNotFoundException if unknown relation type
-exception RelationNotFoundException if current relation has not been
added in the RS
Retrieves current role value
Note: no need to test if list not null before cloning, null value
not allowed for role value.
Can throw InvalidRoleValueException,
(RoleNotFoundException already detected)
The available constants for startingPointCall
The available constants for intermediatePointCall.  The default (0)
is receive_request, but can be set to none on demand.
The available constants for endingPointCall
Set to true if the server ending point raised ForwardRequest at some
point in the ending point.
Sources of server request information:
Information cached from calls to oktemp
key = Integer, value = IOP.ServiceContext.
key = Integer, value = IOP.ServiceContext.
Please keep these in the same order as declared above.
reset cached attributes:
Method IDs for all methods in ServerRequestInfo.  This allows for a
convenient O(1) lookup for checkAccess().
ServerRequestInfo validity table (see ptc/00-08-06 table 21-2).
Note: These must be in the same order as specified in contants.
r_rsc = receive_request_service_contexts
r_req = receive_request
s_rep = send_reply
s_exc = send_exception
s_oth = send_other
A true value indicates call is valid at specified point.
A false value indicates the call is invalid.
NOTE: If the order or number of columns change, update
sending_exception should not be callable if both dsiException
and exception are null.
For some reason, we never set object id.  This could be
because a servant locator caused a location forward or
raised an exception.  As per ptc/00-08-06, section 21.3.14,
we throw NO_RESOURCES
Good citizen: In the interest of efficiency, we will assume
interceptors will not change the resulting byte[] array.
Otherwise, we would need to make a clone of this array.
For some reason, we never set the ObjectKeyTemplate
because a servant locator caused a location forward or
raised an exception.  As per ptc/00-08-06, section 21.3.14,
we throw NO_RESOURCES
Good citizen: In the interest of efficiency, we will assume
interceptors will not change the resulting byte[] array.
Otherwise, we would need to make a clone of this array.
access is currently valid for all states:
_REVISIT_ RTF Issue: get_server_policy spec not in sync with
access is currently valid for all states:
access is currently valid for all states:
May be null.  If this is null, create a new one in its place.
This is during and ending point, so we now have enough
information to add the reply service context.
We enqueue all adds for the following reasons:
If we are not in the ending point then we do not yet have a
pointer to the ServiceContexts object so we cannot access the
service contexts until we get to the ending point.
So we enqueue this add reply service context request.
It is added when we do have a handle on the service contexts object.
If we are in the ending point and we just add directly to the
SC container but then an interceptor raises a SystemException
then that add will be lost since a new container is created
for the SystemException response.
Therefore we always enqueue and never dequeue (per request) so
that all adds will be completed.
REVISIT: this does not add to the cache.
NOTE: When adding a method, be sure to:
1. Add a MID_* constant for that method
2. Call checkAccess at the start of the method
3. Define entries in the validCall[][] table for interception points.
access is currently valid for all states:
access is currently valid for all states:
If it is a DSI request then get the arguments from the DSI req
and convert that into parameters.
Good citizen: In the interest of efficiency, we assume
interceptors will be "good citizens" in that they will not
modify the contents of the Parameter[] array.  We also assume
they will not change the values of the containing Anys.
_REVISIT_ PI RTF Issue: No exception list on server side.
We do not support this because our ORB does not send contexts.
We do not support this because our ORB does not send
Good citizen: In the interest of efficiency, we assume that
interceptors will not modify the contents of the result Any.
Otherwise, we would need to create a deep copy of the Any.
access is currently valid for all states:
Check to make sure we are in LOCATION_FORWARD
state as per ptc/00-08-06, table 21-2
A command encapsulating a request to add a reply service context.
These commands are enqueued until we have a handle on the actual
reply service context, at which point they are executed.
Adds the given add reply service context command to the queue of
such commands.  If a command is detected to have the same id as
the service context in this command, and replace is false,
BAD_INV_ORDER is thrown.  If replace is true, the original command
in the queue is replaced by this command.
If we are transitioning to ending point, we will now have a pointer
to the reply service contexts, so we can execute all queued
add reply service context requests.
_REVISIT_  The only way this can happen is if during
rrsc or rr, the interceptor tried to add with
replace=false to a service context that is present in
the reply message.  At that time there was no way for
us to check for this, so the best we can do is ignore
the original request.
We specifically do not empty the SC queue so that if
the interceptor raises an exception the queued service contexts
will be put in the exception response.
Clear cached exception value:
Make sure DSIException is null because this is the more recent one.
Clear cached exception value:
Make sure currentPoint matches the appropriate index in the
Check the validCall table:
Namespaces.java - Analyze namespace nodes in a DOM tree
/ Draw the proper Border
Using the background color set above
inner 3D border
inner 3D border
black drop shadow  __|
If there's no room to draw arrow, bail
Draw the arrow
Reset the Graphics back to it's original settings
textDecl(String, String, Augmentations)
comment (XMLString, Augmentations)
processingInstruction(String, XMLString, Augmentations)
attributeDecl(String,String,String,String[],String,XMLString, XMLString, Augmentations)
unparsedEntityDecl(String,XMLResourceIdentifier, String, Augmentations)
set the source of this handler
return the source from which this handler derives its events
set content model source
get content model source
A vector to contain the new characters.  We'll use it to construct
the result string.
Didn't find the character in the second string, so it
is not translated.
OK, there's a corresponding character in the
third string, so do the translation...
There's no corresponding character in the
third string, since it's shorter than the
second string.  In this case, the character
is removed from the output string, so don't
XCatalogReader.java - Read XML Catalog files
Implement the SAX DocumentHandler interface
nop, start of catalog
This is equivalent to an invalid catalog entry type
Ensures that we've used the connection's IOR to create
a valid CodeBase delegate.  If this returns false, then
it is not valid to access the delegate.
The delegate was null, so see if the connection's
IOR was set.  If so, then we just need to connect
it.  Otherwise, there is no hope of checking the
remote code base.  That could be bug if the
service context processing didn't occur, or it
could be that we're talking to a foreign ORB which
doesn't include this optional service context.
REVISIT.  Use Merlin logging service to report that
codebase functionality was requested but unavailable.
Recheck the condition to make sure another
thread didn't already do this while we waited
Do we have a reference initialized by another connection?
Connect the delegate and update the cache
Save it for the benefit of other connections
It's now safe to use the delegate
End of file.
event type cannot be consumed
suppress modifier keys in old event model.
no mask for button1 existed in old Event - strip it out
no mask for button1 existed in old Event - strip it out
Copy canAccessSystemClipboard value from this into that.
Use the converter
No converter, use getValueAt followed by toString
The following method is called by the private method
<code>updateSystemColors</code> in <code>SystemColor</code>.
Get accessibility properties
Try loading the per-user accessibility properties file.
Inputstream has been buffered in Properties class
Per-user accessibility properties file does not exist
Try loading the system-wide accessibility properties
file only if a per-user accessibility properties
file does not exist or is empty.
Inputstream has been buffered in Properties class
System-wide accessibility properties file does
Get whether a screen magnifier is present.  First check
the system property and then check the properties file.
Get the names of any assistive technolgies to load.  First
check the system property and then check the properties
Load any assistive technologies
Override to add printing support with new job/page control classes
Override to implement custom cursor support.
Override to implement custom cursor support.
Override to implement custom cursor support.
others are not guaranteed
called by platform toolkit
No resource file; defaults will be used.
ensure that the proper libraries are loaded
first try platform specific bundle
then shared one
This is a workaround for headless toolkits.  It would be
better to override this method but it is declared final.
"this instanceof" syntax defeats polymorphism.
This property should never be cached
This is a workaround for headless toolkits.  It would be
better to override this method but it is declared final.
"this instanceof" syntax defeats polymorphism.
Don't fire change event if old and new values are null.
It helps to avoid recursive resending of WM_THEMECHANGED
8014718: logging has been removed from SunToolkit
if user passed in a AWTEventListenerProxy object, extract
Create a new selectiveListener.
OR the eventMask into the selectiveListener's event mask.
If no bits are set, break out of loop.
Always test bit 0.
Right shift, fill with zeros on left.
assert tempL is not an AWTEventListenerProxy - we should
have weeded them all out
don't want to wrap a proxy inside a proxy
This is a workaround for headless toolkits.  It would be
better to override this method but it is declared package private.
"this instanceof" syntax defeats polymorphism.
Implementation cloned from AWTEventMulticaster.
#4178589: must overload remove(EventListener) to call our add()
instead of the static addInternal() so we allocate a
ToolkitEventMulticaster instead of an AWTEventMulticaster.
Note: this method is called by AWTEventListener.removeInternal(),
so its method signature must match AWTEventListener.remove().
it's not here
This array contains the number of times to call the eventlistener
for each event type.
For each event bit set in mask, increment its call count.
If no bits are set, break out of loop.
Always test bit 0.
Right shift, fill with zeros on left.
Used to save the bit of the event type.
Get the index of the call count for this event type.
Instead of using Math.log(...) we will calculate it with
bit shifts. That's what previous implementation looked like:
Call the listener as many times as it was added for this
End of file.
Moved this to the creation of the ORB that is passed into this
This is required for creating Persistent Servants under this ORB
Right now the Persistent NameService and ORBD are launched together
Find out a better way of doing this, Since ORBD is an important
process which should not be killed because of some external process
get and activate the root naming POA
create a new POA for persistent Naming Contexts
With Non-Retain policy, So that every time Servant Manager
will be contacted when the reference is made for the context
The id assignment is made by the NameServer, The Naming Context
id's will be in the format NC<Index>
create and set the servant manager
The RootObject key will be NC0
initialize the root Naming Context
Get the new Naming Context Key from
Create the new Naming context and create the Persistent
If the context is read from the File, The following three entries
will be null. So a fresh setup may be required.
Check if the authority is of form ':<port>'
Convert the authority to 'localhost:<port>' form
Make sure it now parses to a valid server based
convert file to appropriate URI, f.toURI().toASCIIString()
converts the URI to string as per rule specified in
convert file to appropriate URI, f.toURI().toASCIIString()
converts the URI to string as per rule specified in
Unwrap the actual exception so that it can be wrapped by an
UnknownException or thrown if it is a system exception.
This is expected in the server dispatcher code.
Initialize final field for classLoader.  The initialization value of non-null
prevents future JIT optimizations from assuming this final field is null.
Class modifiers are a superset of interface modifiers
Note: all annotation types are interfaces
Reflective call to get caller class is only needed if a security manager
is present.  Avoid the overhead of making this call otherwise.
NOTE: the following code may not be strictly correct under
the current Java memory model.
Disable accessibility checks on the constructor
since we have to do the security check here anyway
(the stack depth is wrong for the Constructor's
security check to work)
Security check (same as in java.lang.reflect.Constructor)
cache the name to reduce the number of calls into the VM
Package-private to allow ClassLoader access
Initialized in JVM not by private constructor
This field is filtered from reflection access, i.e. getDeclaredField
will throw NoSuchFieldException
Generic signature marks interfaces with superclass = Object
but this API returns null for interfaces
no cloning required
defensively copy before handing over to user code
Convert Types to Classes; returned types *should*
be class objects since the methodDescriptor's used
don't have generics information
Perform access check
finally, check return type
The array is expected to have three elements:
the immediately enclosing class
the immediately enclosing method or constructor's
name (can be null).
the immediately enclosing method or constructor's
descriptor (null iff name is).
Convert Types to Classes; returned types *should*
be class objects since the methodDescriptor's used
don't have generics information
Perform access check
There are five kinds of classes (or interfaces):
a) Top level classes
b) Nested classes (static member classes)
c) Inner classes (non-static member classes)
d) Local classes (named classes declared within a method)
e) Anonymous classes
JVM Spec 4.8.6: A class must have an EnclosingMethod
attribute if and only if it is a local class or an
This is a top level or a nested class or an inner class (a, b, or c)
This is a local class or an anonymous class (d or e)
top level class
strip the package name
According to JLS3 "Binary Compatibility" (13.1) the binary
name of non-package classes (not top level) is the binary
name of the immediately enclosing class followed by a '$' followed by:
(for nested and inner classes): the simple name.
(for local classes): 1 or more digits followed by the simple name.
(for anonymous classes): 1 or more digits.
Since getSimpleBinaryName() will strip the binary name of
the immediatly enclosing class, we are now looking at a
string that matches the regular expression "\$[0-9]*"
followed by a simple name (considering the simple of an
anonymous class to be the empty string).
Remove leading "\$[0-9]*" from the name
Eventually, this is the empty string iff this is an anonymous class
top level class
top level class
Otherwise, strip the enclosing class' name
JVM Spec 4.8.6: A class must have an EnclosingMethod
attribute if and only if it is a local class or an
Privileged so this implementation can look at DECLARED classes,
something the caller might not have privilege to do.  The code here
is allowed to look at DECLARED classes because (1) it does not hand
out anything other than public members and (2) public member access
has already been ok'd by the SecurityManager.
A system class.
A system class.
skip the package access check on a proxy class in default proxy package
check package access on the proxy interfaces
initialize Unsafe machinery here, since we need to call Class.class instance method
and have to avoid calling it in the static initializer of the Class class...
offset of Class.reflectionData instance field
offset of Class.annotationType instance field
offset of Class.annotationData instance field
Caches for certain reflective results
reflection data that might get invalidated when JVM TI RedefineClasses() is called
Intermediate results for getFields and getMethods
Value of classRedefinedCount when we created this ReflectionData instance
Incremented by the VM on each call to JVM TI RedefineClasses()
that redefines this class or a superclass.
Lazily create and cache ReflectionData
else no SoftReference or cleared SoftReference or stale ReflectionData
-> create and replace new instance
try to CAS it...
Generic signature handling
Generic info repository; lazily initialized
accessor for factory
create scope and factory
generic info is lazily initialized
Returns an array of "root" fields. These Field objects must NOT
be propagated to the outside world, but must instead be copied
No cached value available; request value from VM
Returns an array of "root" fields. These Field objects must NOT
be propagated to the outside world, but must instead be copied
No cached value available; compute value recursively.
Traverse in correct order for getField().
Direct superinterfaces, recursively
Direct superclass, recursively
Returns an array of "root" constructors. These Constructor
objects must NOT be propagated to the outside world, but must
instead be copied via ReflectionFactory.copyConstructor.
No cached value available; request value from VM
Returns an array of "root" methods. These Method objects must NOT
be propagated to the outside world, but must instead be copied
No cached value available; request value from VM
Don't add or remove methods except by add() or remove() calls.
name is guaranteed to be interned
Get rid of null slots
Returns true if m1 is more specific than m2
Returns an array of "root" methods. These Method objects must NOT
be propagated to the outside world, but must instead be copied
No cached value available; compute value recursively.
Start by fetching public declared methods
Now recur over superclass and direct superinterfaces.
Go over superinterfaces first so we can more easily filter
out concrete implementations inherited from superclasses at
Filter out concrete implementations of any
Insert superclass's inherited methods before
superinterfaces' to satisfy getMethod's search
Filter out all local methods from inherited ones
Helpers for fetchers of one field, method, or constructor
Note: the intent is that the search algorithm this routine
uses be equivalent to the ordering imposed by
privateGetPublicFields(). It fetches only the declared
public fields for each class, however, to reduce the number
of Field objects which have to be created for the common
case where the field being requested is declared in the
class which is being queried.
Search declared public fields
Direct superinterfaces, recursively
Direct superclass, recursively
Not found on class or superclass directly
may be null
Note: the intent is that the search algorithm this routine
uses be equivalent to the ordering imposed by
privateGetPublicMethods(). It fetches only the declared
public methods for each class, however, to reduce the
number of Method objects which have to be created for the
common case where the method being requested is declared in
the class which is being queried.
Due to default methods, unless a method is found on a superclass,
methods declared in any superinterface needs to be considered.
a superclass is found.
Must _not_ return root methods
Search declared public methods
Search superclass's methods
Search superinterfaces' methods
Other helpers and base implementation
If the loader is null this is a system class, so ask the VM
If the classloader has been initialized with the assertion
directives, ask it. Otherwise, ask the VM.
Retrieves the desired assertion status of this class from the VM
An enum must both directly extend java.lang.Enum and have
the ENUM bit set; classes for specialized enum constants
don't do the former.
Fetches the factory for reflective objects
To be able to query system properties as soon as they're available
Tests to ensure the system properties table is fully
initialized. This is needed because reflection code is
called very early in the initialization process (before
command-line arguments have been parsed and therefore
these user-settable properties installed.) We assume that
if System.out is non-null then the System class has been
fully initialized and that the bulk of the startup code
has been run.
java.lang.System not yet fully initialized
Doesn't use Boolean.getBoolean to avoid class init.
These can happen when users concoct enum-like classes
that don't comply with the enum spec.
annotation data that might get invalidated when JVM TI RedefineClasses() is called
Value of classRedefinedCount when we created this AnnotationData instance
null or stale annotationData -> optimistically create new instance
try to install it
successfully installed new AnnotationData
no inherited annotations -> share the Map with declaredAnnotations
at least one inherited annotation -> declared may override inherited
Annotation types cache their internal (AnnotationType) form
Retrieve the class loader from the repository
Start handling primitive types (int. boolean and so
Ok we do not have a primitive type ! We need to build
the signature of the method
We need to load the class through the class
loader of the target object.
Load through the default class loader
Instantiate the new object
Wrap the exception.
Instantiate the new object
Build the signature of the method
Build the signature of the method
Exception IllegalArgumentException raised in Jdk1.1.8
Query the metadata service to get the right constructor
Wrap the exception.
Check parameter validity
Check parameter validity
Load the class using the agent class loader
Get the class loader MBean
Start handling primitive types (int. boolean and so
Ok we do not have a primitive type ! We need to build
the signature of the method
We need to load the class through the class
loader of the target object.
Restrict to getClassLoader permission only
Copyright (c) 1995-96 by Cisco Systems, Inc.
Retreive the PDU factory of the SNMP adaptor to decode the received inform response.
REVISIT: should update the decl pool to cache XSCM objects too
It never changes, so a static member is good enough
needed for DFA construction
needed for UPA
Factory to create Bin, Uni, Leaf nodes
for complex type with empty or simple content,
there is no content model validator
if the content is element only or mixed, but no particle
is defined, return the empty content model
if the content model contains "all" model group,
we create an "all" content model, otherwise a DFA content model
now we are throught building content model and have passed sucessfully of the nodecount check
if set by the application
if the validator returned is null, it means there is nothing in
the content model, so we return the empty content model.
get the model group, and add all children of it to the content model
create an all content model. the parameter indicates whether
the <all> itself is optional
add the element decl to the all content model
convert particle tree to CM tree
build DFA content model from the CM tree
1. convert particle tree to CM tree:
3. convert model groups (a, b, c, ...) or (a | b | c | ...) to
binary tree: (((a,b),c),...) or (((a|b)|c)|...)
4. make sure each leaf node (XSCMLeaf) has a distinct position
(task 1) element and wildcard particles should be converted to
REVISIT: Make a clone of the leaf particle, so that if there
are two references to the same group, we have two different
leaf particles for the same element or wildcard decl.
This is useful for checking UPA.
(task 2) expand occurrence values
(task 1,3) convert model groups to binary trees
when the model group is a choice of more than one particles, but
only one of the particle is not empty, (for example
) we can't not return that one particle ("e"). instead, we should
treat such particle as optional ("e?").
the following boolean variable is true when there are at least
2 non-empty children.
first convert each child to a CM tree
then combine them using binary operation
record the fact that there are at least 2 children
(task 2) expand occurrence values
when the group is "choice", there is only one non-empty
child, and the group had more than one children, we need
to create a zero-or-one (optional) node for the non-empty
4. make sure each leaf node (XSCMLeaf) has a distinct position
zero or one
zero or more
one or more
or e+ and, once the DFA reaches a final state, check if the actual number
of elements is between minOccurs and maxOccurs. This new algorithm runs
in constant space.
TODO: What is the impact of this optimization on the PSVI?
create a+ node first, then put minOccurs-1 a's in front of it
for the first time "node" is used, we don't need to make a copy
and for other references to node, we make copies
(task 4) we need to call copyNode here, so that we append
an entire new copy of the node (a subtree). this is to ensure
all leaf nodes have distinct position
we know that minOccurs > 1
first n a's, then m-n a?'s.
copyNode is called, for the same reason as above
4. make sure each leaf node (XSCMLeaf) has a distinct position
for choice or sequence, copy the two subtrees, and combine them
for ?+*, copy the subtree, and put it in a new ?+* node
for element/wildcard (leaf), make a new leaf node,
with a distinct position
A special version of buildSyntaxTree() which builds a compact syntax tree
containing compound leaf nodes which carry occurence information. This method
for building the syntax tree is chosen over buildSyntaxTree() when
useRepeatingLeafNodes() returns true.
when the model group is a choice of more than one particles, but
only one of the particle is not empty, (for example
) we can't not return that one particle ("e"). instead, we should
treat such particle as optional ("e?").
the following int variable keeps track of the number of non-empty children
first convert each child to a CM tree
then combine them using binary operation
when the group is "choice" and the group has one or more empty children,
we need to create a zero-or-one (optional) node for the non-empty particles.
Convert element and wildcard particles to leaf nodes. Wrap repeating particles in a CMUniOpNode.
zero or one
zero or more
one or more
occurence information and wrap it in the appropriate CMUniOpNode.
This method checks if this particle can be transformed into a compact syntax
tree containing compound leaf nodes which carry occurence information. Currently
it returns true if each model group has minOccurs/maxOccurs == 1 or
contains only one element/wildcard particle with minOccurs/maxOccurs == 1.
trigger NPE on first null
Helper for computeUpdatedPixels method
We need to satisfy the congruences:
dst = destinationOffset + (src - sourceOffset)/sourceSubsampling
src - passStart == 0 (mod passPeriod)
src - sourceOffset == 0 (mod sourceSubsampling)
subject to the inequalities:
src >= passStart
src < passStart + passExtent
src >= sourceOffset
src < sourceOffset + sourceExtent
dst >= dstMin
dst <= dstmax
dst = destinationOffset + (src - sourceOffset)/sourceSubsampling
For now we use a brute-force approach although we could
attempt to analyze the congruences.  If passPeriod and
sourceSubsamling are relatively prime, the period will be
their product.  If they share a common factor, either the
period will be equal to the larger value, or the sequences
will be completely disjoint, depending on the relationship
between passStart and sourceOffset.  Since we only have to do this
twice per image (once each for X and Y), it seems cheap enough
to do it the straightforward way.
Record smallest valid pixel
Record second smallest valid pixel
Record largest valid pixel
If we never saw a valid pixel, set width to 0
The period is given by the difference of any two adjacent pixels
Paint the radio button
Use selected icon
Draw the Text
Note: This orb could be an instanceof ORBSingleton or ORB
Note: This orb could be an instanceof ORBSingleton or ORB
no case-order specified
Is there difference more significant than case-order?
more than SECONDARY
Difference more significant than case-order
No difference more significant than case-order.
Find case difference
No case differences. Less significant difference could exist
not to ignore case
No case differences
not case diffference
not case diff
Return a mask for the part of the order we're interested in
get collation element with given strength
from the element with max strength
lazy evaluate one
if there's a Vector there then add to it.
only add if this keystroke isn't registered for this component
if a JComponent is there then remove it and replace it with a vector
Then add the old compoennt and the new compoent to the vector
then insert the vector in the table
this means this is already registered for this component, no need to dup
Check for EmbeddedFrame case, they know how to process accelerators even
when focus is not in Java
component may have already been removed from the hierarchy, we
need to look up the container using the componentKeyStrokeMap.
never heard of this pairing, so bail
this should never happen, but I'm being safe
this should never happen, but I'm being safe
remove the KeyStroke from the Map
this means there is more than one component reg for this key
remove the KeyStroke from the Map
if no more bindings in this table
remove table to enable GC
Check for EmbeddedFrame case, they know how to process accelerators even
when focus is not in Java
in this case a keystroke made of an extended key code has a priority.
this container isn't registered, so bail
extended code has priority
don't do anything
only give it out if enabled and visible
more than one comp registered for this
There is no well defined order for WHEN_IN_FOCUSED_WINDOW
bindings, but we give precedence to those bindings just
added. This is done so that JMenus WHEN_IN_FOCUSED_WINDOW
bindings are accessed before those of the JRootPane (they
both have a WHEN_IN_FOCUSED_WINDOW binding for enter).
don't want to give these out
This means that tmp wasn't null, a JComponent, or a Vector.  What is it?
if no one else handled it, then give the menus a crack
The're handled differently.  The key is to let any JMenuBars
process the event
don't want to give these out
lazy evaluate one
use the menubar class as the key
if we don't have a list of menubars,
then make one.
remove table to enable GC
Range in the code the exception handler is
active. start_pc is inclusive, end_pc exclusive
Sprite buffer for the arrow image of the left button
Initialize the color array
Fill the background first ...
... then draw the arrow.
Adjust color mapping for pressed button state
Draw the image for a vertical split
Draw the image for a horizontal split
by simply swaping the i and j axis.
Except the drawLine() call this code is
identical to the code block above. This was done
in order to remove the additional orientation
check for each pixel.
to be drawn
Set the color from the
Draw a pixel
Don't want the button to participate in focus traversable.
Sprite buffer for the arrow image of the right button
Initialize the color array
Fill the background first ...
... then draw the arrow.
Adjust color mapping for pressed button state
Draw the image for a vertical split
Draw the image for a horizontal split
by simply swaping the i and j axis.
Except the drawLine() call this code is
identical to the code block above. This was done
in order to remove the additional orientation
check for each pixel.
to be drawn
Set the color from the
Draw a pixel
Don't want the button to participate in focus traversable.
NOTE NOTE NOTE NOTE NOTE
This class is no longer used, the functionality has
been rolled into BasicSplitPaneDivider.DividerLayout as a
This layout differs from the one used in BasicSplitPaneDivider.
It does not center justify the oneTouchExpadable buttons.
This was necessary in order to meet the spec of the Metal
We can move this out somewhere later.  For now, it serves its purpose
to create a concrete CDR delegate based on the GIOP version.
REVISIT - what is appropriate?  INTERNAL exceptions
are really hard to track later.
REVISIT - These two constructors should be re-factored to better hide
the fact that someone extending this class 'can' construct a CDROutputStream
that does not use pooled ByteBuffers. Right now, only EncapsOutputStream
does _not_ use pooled ByteBuffers, see EncapsOutputStream.
NOTE: When a stream is constructed for non-channel-backed sockets
it notifies the constructor not to use pooled (i.e, direct)
Provided by IIOPOutputStream and EncapsOutputStream
Used in indirections. Overridden by TypeCodeOutputStream.
XREVISIT - return to final if possible
REVISIT - was protected - need access from msgtypes test.
REVISIT: was protected - but need to access from xgiop.
Use Latin-1 for GIOP 1.0 or when code set negotiation was not
Subclasses must decide what to do here.  It's inconvenient to
make the class and this method abstract because of dup().
Needed by request and reply messages for GIOP versions >= 1.2 only.
read and discard the repository ID
write the repository ID
Pass output properties to the translet
Pass output properties to handler if identity
Get output method using get() to ignore defaults
Get encoding using getProperty() to use defaults
Set indentation number in the factory
Return the content handler for this Result object
Result object could be SAXResult, DOMResult, or StreamResult
StreamResult may have been created with a java.io.File,
java.io.Writer, java.io.OutputStream or just a String
try to get a Writer from Result object
or try to get an OutputStream from Result object
or try to get just a systemId string from Result object
System Id may be in one of several forms, (1) a uri
that starts with 'file:', (2) uri that starts with 'http:'
or (3) just a filename on the local system.
if StreamResult(File) or setSystemID(File) was used,
the systemId will be URI encoded as a result of File.toURI(),
it must be decoded for use by URL
if host (URI authority) then file: + host + path
else just path (may be absolute or relative)
URI exception which means nothing can be done so OK to ignore
system id is just a filename
If we cannot write to the location specified by the SystemId
If we cannot create the file specified by the SystemId
use only once, so reset to 'null'
Give the translet the opportunity to make a prepass of
the document, in case it can extract useful information early
Get systemId from source
Hook up reader and output handler
Create input source from source
Start pushing SAX events
Create a reader if not set by user
Hook up reader and output handler
Start pushing SAX events
Copy system ID from original, empty Source to new
If we create an output stream for the Result, we need to close it after the transformation.
Register a message handler to report xsl:messages
ignored - transformation cannot be continued
ignored - transformation cannot be continued
Ignore lower layer properties
Return right now if no properties are set
Get a list of all the defined properties
Note the use of get() instead of getProperty()
Ignore default properties
Pass property value to translet - override previous setting
clear previous setting
Return right now if no properties are set
Get a list of all the defined properties
Note the use of get() instead of getProperty()
Ignore default properties
Pass property value to translet - override previous setting
look for the last colon, as the String may be
something like "http:abc.com:local"
no colon at all, lets hope this is the
local name itself then
add the uri/localName as a pair, in that order
Call setDoctype() if needed
Copy propeties set in stylesheet to base
Update defaults based on output method
End of file.
Split the string into date and time components
Parse the date
Parse the time
Convert the date
Convert the time; default missing nanos
Add leading zeros
Add leading zeros
Truncate trailing zeros
do a string buffer here instead.
When Timestamp instance compare it with a Timestamp
Note typecasting is safe because o is instance of Timestamp
When Date doing a o.compareTo(this)
will give wrong results.
A collection of DOMImplementations
read and discard the repository ID
write the repository ID
should only clear this if the last document contained unparsed entities
The algorithm associated with this key factory
The provider implementation (delegate)
lock for mutex during provider selection
remaining services to try in provider selection
null once provider is selected
fetch and instantiate initial spi
disable further failover after this call
somebody else did a failover concurrently
try that spi now
invoked again as the mask should now be valid.
Convert to the value class if the Value returned from the
Format does not match.
This will work if the currently edited value is valid.
Backspace, adjust to actually delete next non-literal.
insert (or insert and remove)
Update the literal mask
Need to reset the complete string as Format's result can
be completely different.
Should never happen, otherwise canReplace would have
This will work if the currently edited value is valid.
If the XPathEvaluator was determined by "casting" the document
Check that the context node is owned by the same document
Check that the context node is an acceptable node type
If the type is not a supported type, throw an exception and be
done with it!
Cache xpath context?
if m_document is not null, build the DTM from the document
What should we do here?
Create a new XPathResult object
Reuse result object passed in?
The constructor will check the compatibility of type and xobj and
throw an exception if they are not compatible.
These states are system-wide, rather than AppContext wide.
If rectangles don't intersect, return zero'd intersection.
You can't assume that a string's width is the sum of its
characters' widths in Java2D -- it may be smaller due to
Translate LEADING/TRAILING values in horizontalAlignment
to LEFT/RIGHT values depending on the components orientation
Translate LEADING/TRAILING values in horizontalTextPosition
to LEFT/RIGHT values depending on the components orientation
If lsb is negative, add it to the width and later
adjust the x location. This gives more space than is
This is done like this for two reasons:
1. If we set the width to the actual bounds all
callers would have to account for negative lsb
(pref size calculations ONLY look at width of
2. You can do a drawString at the returned location
and the text won't be clipped.
(verticalTextPosition == BOTTOM)
(horizontalTextPosition == RIGHT)
WARNING: DefaultTreeCellEditor uses a shortened version of
this algorithm to position it's Icon. If you change how this
is calculated, be sure and update DefaultTreeCellEditor too.
(verticalAlignment == BOTTOM)
(horizontalAlignment == CENTER)
lsb is negative. Shift the x location so that the text is
visually drawn at the right location.
verify focusOwner is a descendant of c
Find the first JComponent in the ancestor hierarchy, and
invoke processKeyBindings on it
No JComponents, if Window or Applet parent, process
Get the command object.
ActionStandin is used for historical reasons to support
registerKeyboardAction with a null value.
Convert it to a string.
Do null for undefined chars, or if registerKeyboardAction
was called with a null.
Don't use String, as it's not guaranteed to be unique in a Hashtable.
This frame can never be shown
untrusted code not allowed to dispose
REMIND(aim): phase out use of 4 methods below since they
are just private covers for AWT methods (?)
this order reflects the overriding order
read system properties or jaxp.properties
if it's explicitly set, it's treated as yes no matter the value
if it's explicitly set, it's treated as yes no matter the value
only update if it shall override
internally, ordinal is used as index
special property to return entity count info
if system property is not found, try the older form if any
Array list to store printed warnings for each SAX parser used
one or many? Up to language spec; currently only one, but this API
allows for generalization.
the actions mask
Left null as long as possible, then
created and re-used in the getAction function.
Note: servicePrincipal can be "@REALM" which means any principal in
this realm implies it. action can be "-" which means any
action implies it.
check for the known strings
make sure we didn't just match the tail of a word
like "ackbarfaccept".  Also, skip to the comma.
point i at the location of the comma minus one (or -1).
Write out the actions. The superclass takes care of the name
call getActions to make sure actions field is initialized
Read in the action, then initialize the rest
Not serialized; see serialization section at end of class
need to deal with the case where the needed permission has
more than one action and the collection has individual permissions
that sum up to the needed.
Convert Iterator into Enumeration
Need to maintain serialization interoperability with earlier releases,
which had the serializable field:
Don't call out.defaultWriteObject()
Write out Vector
Don't call defaultReadObject()
Read in serialized fields
Get the one we want
Common UI methods
Instance method -> `this' is local var 0
Names for variables provided?
Give them dummy names
May happen, because end_pc is exclusive
Make it inclusive
Repair malformed handles
Repair malformed handles
Overwrite if necessary
Overwrite if necessary
Every entry takes 8 bytes
Remove any stale code attribute
prologue byte code
Add `Exceptions' if there are "throws" clauses
Undo effects of adding attributes
choose the next instruction based on whether current is a branch.
explore all of the select's targets. the default target is handled below.
nothing to fall through to.
if an instruction that comes back to following PC,
push next instruction, with stack depth reduced by 1.
for all branches, the target of the branch is pushed on the branch stack.
conditional branches have a fall through case, selects don't, and
jsr/jsr_w return to the next instruction.
check for instructions that terminate the method.
normal case, go to the next instruction.
if we have no more instructions, see if there are any deferred branches to explore.
These message should be read from a locale-specific resource bundle
The following shouldn't create a runtime dependence on ldap package.
WeakHashMap<Class | ClassLoader, Hashtable>
if clazz is null then applet cannot be an Applet.
There should be no instances of this class.
---------- Public methods ----------
Merge property values from env param, applet params, and system
properties.  The first value wins:  there's no concatenation of
Read system properties by first trying System.getProperties(),
and then trying System.getProperty() if that fails.  The former
is more efficient due to fewer permission checks.
Read system property.
Return without merging if application resource files lookup
Merge the above with the values read from all application
resource files.  Colon-separated lists are concatenated.
no classes specified; return null
Cache is based on context class loader and property val
Populate list with classes named in facProp; skipping
those that we cannot load
ignore ClassNotFoundException, IllegalArgumentException
Merge property with provider property and supplied default
Cache factory based on context class loader, class name, and
check if weak ref has been cleared
Not cached; find first factory and cache
ignore ClassNotFoundException, IllegalArgumentException,
---------- Private methods ----------
Merge in properties from file in <java.home>/lib.
Create a retrieval method over the given element
a raw certificate, direct parsing is done!
Check to make sure that the reference is not to another RetrievalMethod
which points to this element
Check to make sure that the reference is not to another RetrievalMethod
which points to this element
An element has been provided
An element has been provided
Retrieved resource is a nodeSet
Retrieved resource is an inputStream
otherwise, we parse the resource, create an Element and delegate
if the resource stores a raw certificate, we have to handle it
Apply the transforms
Obtain all the parents of the elemnt
Visit them in reverse order.
General Attribute Checking
Only elements are allowed in <all>
General Attribute Checking
A content type of all can only appear
as the content type of a complex type definition.
don't insert the "all" particle, otherwise we won't be
able to create DFA from this content model
Determines whether a content spec tree represents an "all" content model
If the content is not empty, is the top node ALL?
the inner class: used to store particles for model groups
to avoid creating a new Vector in each model group, or when traversing
each model group, we use this one big array to store all particles
for model groups. when the traversal finishes, this class returns an
XSParticleDecl[] containing all particles for the current model group.
it's possible that we need to traverse another model group while
traversing one (one inside another one; referring to a global group,
etc.), so we have push/pos context methods to save the same of the
current traversal before starting the traversal of another model group.
big array to contain all particles
the ending position of particles in the array for each context
index 0 is reserved, with value 0. index 1 is used for the fist
context. so that the number of particles for context 'i' can be
computed simply by fPos[i] - fPos[i-1].
number of contexts
start a new context (start traversing a new model group)
resize position array if necessary
the initial ending position of the current context is the
ending position of the previsous context. which means there is
no particle for the current context yet.
get the number of particles of this context (model group)
add a particle to the current context
resize the particle array if necessary
end the current context, and return an array of particles
clear the particle array, to release memory
the big particle array to hold all particles in model groups
protected for test: genericRPCMSGFramework.IIOPConnection constructor.
The socket used for this connection.
Start at some value other than zero since this is a magic
value in some protocols.
Server request map: used on the server side of Connection
Maps request ID to IIOPInputStream.
This is a flag associated per connection telling us if the
initial set of sending contexts were sent to the receiver
Remote reference to CodeBase server (supplies
FullValueDescription, among other things)
CodeBase cache for this connection.  This will cache remote operations,
handle connecting, and ensure we don't do any remote operations until
transport read timeout values
A message mediator used when shouldReadGiopHeaderOnly is
true to maintain request message state across execution in a
SelectorThread and WorkerThread.
Used in genericRPCMSGFramework test.
Both client and servers.
IMPORTANT: non-channel-backed sockets must use
dedicated reader threads.
Null can happen when client closes stream
REVISIT - use common factory base class.
REVISIT - make sure reader thread is killed.
Notify anyone waiting.
REVISIT - if this is called after purgeCalls then
the state of the socket is ABORT so the writeLock
in close throws an exception.  It is ignored but
causes IBM (screen scraping) tests to fail.
REVISIT - use common factory base class.
REVISIT - make sure reader thread is killed.
Notify anyone waiting.
REVISIT - if this is called after purgeCalls then
the state of the socket is ABORT so the writeLock
in close throws an exception.  It is ignored but
causes IBM (screen scraping) tests to fail.
This call is the transition from the tranport block
to the protocol block.
print address of ByteBuffer gotten from pool
print address of ByteBuffer being released
The reading of data incorporates a strategy to detect a
rogue client. The strategy is implemented as follows. As
long as data is being read, at least 1 byte or more, we
assume we have a well behaved client. If no data is read,
then we sleep for a time to wait, re-calculate a new time to
wait which is lengthier than the previous time spent waiting.
Then, if the total time spent waiting does not exceed a
maximum time we are willing to wait, we attempt another
read. If the maximum amount of time we are willing to
spend waiting for more data is exceeded, we throw an
NOTE: Reading of GIOP headers are treated with a smaller
maximum time to wait threshold. Based on extensive
performance testing, all GIOP headers are being
read in 1 read access.
failed to read entire message
To support non-channel connections.
The reading of data incorporates a strategy to detect a
rogue client. The strategy is implemented as follows. As
long as data is being read, at least 1 byte or more, we
assume we have a well behaved client. If no data is read,
then we sleep for a time to wait, re-calculate a new time to
wait which is lengthier than the previous time spent waiting.
Then, if the total time spent waiting does not exceed a
maximum time we are willing to wait, we attempt another
read. If the maximum amount of time we are willing to
spend waiting for more data is exceeded, we throw an
NOTE: Reading of GIOP headers are treated with a smaller
maximum time to wait threshold. Based on extensive
performance testing, all GIOP headers are being
read in 1 read access.
failed to read entire message
IMPORTANT: For non-blocking SocketChannels, there's no guarantee
all bytes are written on first write attempt.
TimeStamp connection to indicate it has been used
Note granularity of connection usage is assumed for
now to be that of a IIOP packet.
REVISIT It will be good to have a read lock on the reader thread
before we proceed further, to avoid the reader thread (server side)
from processing requests. This avoids the risk that a new request
will be accepted by ReaderThread while the ListenerThread is
attempting to close this connection.
we are busy!
stop the reader without causing it to do purgeCalls
This does writeUnlock().
REVISIT - remove this method from Connection and all it subclasses.
This is used by the GIOPOutputObject in order to
throw the correct error when handling code sets.
Can we determine if we are on the server side by
other means?  XREVISIT
Keep looping till we can set the writeLock.
somebody has changed 'state' so be careful
do not stay here too long if state != ESTABLISHED
Need to distinguish between client and server roles
the connection has been closed or closing
==> throw rebind exception
wake up one guy waiting to write
Assumes the caller handles writeLock and writeUnlock
Don't we need to check for CloseConnection
XREVISIT - Shouldn't the MessageMediator
be the one to handle writing the data here?
Write the fragment/message
REVISIT - no flush?
Since IIOPOutputStream's msgheader is set only once, and not
altered during sending multiple fragments, the original
msgheader will always have the requestId.
REVISIT This could be optimized to send a CancelRequest only
if any fragments had been sent already.
REVISIT When a send failure happens, purgeCalls() need to be
called to ensure that the connection is properly removed from
further usage (ie., cancelling pending requests with COMM_FAILURE
with an appropriate minor_code CompletionStatus.MAY_BE).
Relying on the IIOPOutputStream (as noted below) is not
sufficient as it handles COMM_FAILURE only for the final
fragment (during invoke processing). Note that COMM_FAILURE could
happen while sending the initial fragments.
Also the IIOPOutputStream does not properly close the connection.
It simply removes the connection from the table. An orderly
closure is needed (ie., cancel pending requests on the connection
COMM_FAILURE as well.
IIOPOutputStream will cleanup the connection info when it
sees this exception.
REVISIT - Reading of a GIOP header only is information
that should be passed into the constructor
from the SocketOrChannelConnection factory.
REVISIT: need to close connection.
public Acceptor getAcceptor() - already defined above.
IMPORTANT: Sanity checks on SelectionKeys such as
SelectorKey.isValid() should not be done
get the partialMessageMediator
created by SelectorThread
read remaining info needed in a MessageMediator
Null can happen when client closes stream
IMPORTANT: Reader Threads must NOT read Giop header only.
REVISIT - inteface defines isServer but already defined in
REVISIT: this is also defined in:
Negotiated code sets for char and wchar data
Needs to be synchronized for the following case when the client
doesn't send the code set context twice, and we have two threads
in ServerRequestDispatcher processCodeSetContext.
Thread A checks to see if there is a context, there is none, so
it calls setCodeSetContext, getting the synch lock.
Thread B checks to see if there is a context.  If we didn't synch,
it might decide to outlaw wchar/wstring.
Double check whether or not we need to do this
If the client says it's negotiated a code set that
isn't a fallback and we never said we support, then
it has a bug.
Map request ID to an InputObject.
This is so the client thread can start unmarshaling
the reply and remove it from the out_calls map while the
ReaderThread can still obtain the input stream to give
new fragments.  Only the ReaderThread touches the clientReplyMap,
so it doesn't incur synchronization overhead.
Can never be unset...
If this invocation is a result of ThreadDeath caused
by a previous execution of this routine, just exit.
Grab the writeLock (freeze the calls)
Mark the state of the connection
and determine the request status
Signal all threads with outstanding requests on this
REVISIT: Stop the reader thread
Signal all the waiters of the writeLock.
There are 4 types of writeLock waiters:
1. Send waiters:
2. SendReply waiters:
3. cleanUp waiters:
4. purge_call waiters:
REVISIT: See comments in CDROutputObject constructor.
Begin Code Base methods ---------------------------------------
Set this connection's code base IOR.  The IOR comes from the
SendingContext.  This is an optional service context, but all
JavaSoft ORBs send it.
The set and get methods don't need to be synchronized since the
first possible get would occur during reading a valuetype, and
that would be after the set.
Sets this connection's code base IOR.  This is done after
getting the IOR out of the SendingContext service context.
Our ORBs always send this, but it's optional in CORBA.
Get a CodeBase stub to use in unmarshaling.  The CachedCodeBase
won't connect to the remote codebase unless it's necessary.
End Code Base methods -----------------------------------------
set transport read thresholds
Must be public - used in encoding.
End of file.
XREVISIT - Should be in orbutil or package private
Adds the given ByteBufferWithInfo to the front
of the queue.
Local implementation class names and keys from Properties
file, translate names into Class objects using Class.forName
and store mappings
check if user is supplying his Synchronisation Provider
Implementation if not using Oracle's implementation.
The rowset.properties needs to be in jdk/jre/lib when
integrated with jdk.
else it should be picked from -D option from command line.
-Drowset.properties will add to standard properties. Similar
keys will over-write
Load user's implementation of SyncProvider
removed else, has properties should sum together
no property index has been set.
property index has been set.
check JNDI context for any additional bindings
Requested SyncProvider is unavailable. Return default provider.
Attempt to invoke classname from registered SyncProvider list
return a collection of classnames
of type SyncProvider
only one logger per session
touch JNDI namespace once.
Hunt one level below context for available SyncProvider objects
move to parameters ?
Re-entrant call into method
Actually, this is no longer supported by xpath...
must clone these because addCertStore, et al. modify them
other class fields are immutable to public, don't bother
to clone the read-only fields.
construct a NMTOKEN datatype validator
c.toArray might (incorrectly) not return Object[] (see 6260652)
this shouldn't happen, since we are Cloneable
Positional Access Operations
Not quite a no-op; ensures volatile write semantics
Optimize for lost race to another addXXX operation
temp array holds those elements we know we want to keep
temp array holds those elements we know we want to keep
uniquify and compact elements in cs
Write out array length
Write out all elements in the proper order.
bind to new lock
Read in array length and allocate array
Read in all elements in the proper order.
only call this holding l's lock
only call this holding l's lock
only call this holding l's lock
Support for resetting lock while deserializing
Catalog.java - Represents OASIS Open Catalog files.
Have to copy the readers in the right order...convert hash to arr
Pad the mapArr out to the right length
This is a little odd. The parseCatalog() method expects
a filename, but it adds that name to the end of the
catalogFiles vector, and then processes that vector.
This allows the system to handle CATALOG entries
In this init case, we take the last element off the
catalogFiles vector and pass it to parseCatalog. This
will "do the right thing" in the init case, and allow
parseCatalog() to do the right thing in the non-init
Put the file into the list of catalogs to process...
In all cases except the case when initCatalog() is the
caller, this will be the only catalog initially in the list...
Now process all the pending catalogs...
Now process all the pending catalogs...
No catalog; give up!
Move all the localCatalogFiles into the front of
the catalogFiles queue
Put the rest of the catalogs on the end of the new list
Suppose there are no catalog files to process, but the
single catalog already parsed included some delegate
entries? Make sure they don't get lost.
Now process all the files on the catalogFiles vector. This
vector can grow during processing if CATALOG entries are
encountered in the catalog
We haven't parsed any catalogs yet, let this
catalog be the first...
This is a subordinate catalog. We save its name,
but don't bother to load it unless it's necessary.
Move all the localCatalogFiles into the front of
the catalogFiles queue
Put the rest of the catalogs on the end of the new list
We've parsed them all, reinit the vector...
The base-base is the cwd. If the catalog file is specified
with a relative path, this assures that it gets resolved
tack on a basename because URLs point to files not dirs
The initial base URI is the location of the catalog file
No catalog; give up!
meaningless in XML
meaningless in XML
meaningless in XML
Parse all the subordinate catalogs
Parse all the DELEGATE catalogs
If there's a SYSTEM entry in this catalog, use it
If there's a PUBLIC entry in this catalog, use it
If there's a DOCTYPE entry in this catalog, use it
Otherwise, look in the subordinate catalogs
If there's a DOCUMENT entry, return it
If there's a SYSTEM entry in this catalog, use it
If there's a PUBLIC entry in this catalog, use it
If there's a ENTITY entry in this catalog, use it
Otherwise, look in the subordinate catalogs
If there's a SYSTEM entry in this catalog, use it
If there's a PUBLIC entry in this catalog, use it
If there's a NOTATION entry in this catalog, use it
Otherwise, look in the subordinate catalogs
If there's a SYSTEM entry in this catalog, use it
If there's a PUBLIC entry in this catalog, use it
Otherwise, look in the subordinate catalogs
Always normalize the public identifier before attempting a match
If there's a SYSTEM entry in this catalog, use it
If there's a PUBLIC entry in this catalog, use it
If there's a DELEGATE_PUBLIC entry in this catalog, use it
delegate this match to the other catalog
If there's a SYSTEM entry in this catalog, use it
Otherwise, look in the subordinate catalogs
If there's a REWRITE_SYSTEM entry in this catalog, use it
Is this the longest prefix?
return the systemId with the new prefix
If there's a SYSTEM_SUFFIX entry in this catalog, use it
Is this the longest prefix?
return the systemId for the suffix
If there's a DELEGATE_SYSTEM entry in this catalog, use it
delegate this match to the other catalog
If there's a URI entry in this catalog, use it
Otherwise, look in the subordinate catalogs
If there's a REWRITE_URI entry in this catalog, use it
Is this the longest prefix?
return the uri with the new prefix
If there's a URI_SUFFIX entry in this catalog, use it
Is this the longest prefix?
return the uri for the suffix
If there's a DELEGATE_URI entry in this catalog, use it
delegate this match to the other catalog
Ok, now what are we supposed to call here?
this can't happen
we already have this prefix
now insert partial into the vector at [pos]
Taken from DOM L3 Node interface.
typically the parent but not always!
as long as we do not have any owner, ownerNode is our ownerDocument
overridden in some subclasses
Default behavior is to do nothing, overridden in some subclasses
if we get here we have an error in our program we may as well
be vocal about it, so that people can take appropriate action.
Need to break the association w/ original kids
By default we make all clones readwrite,
this is overriden in readonly subclasses
if we have an owner simply forward the request
otherwise ownerNode is our ownerDocument
if we have an owner simply forward the request
otherwise ownerNode is our ownerDocument
if we have an owner we rely on it to have it right
otherwise ownerNode is our ownerDocument
overriden by ChildNode
default behavior, overriden in ChildNode
default behavior, overriden in ChildNode
default behavior, overriden in ChildNode
overridden in ElementImpl
overridden in ElementImpl
DOM2: methods, getters, setters
simply forward to Document
simply forward to Document
simply forward to Document
Public DOM Level 3 methods
Questions of clarification for this method - to be answered by the
DOM WG.   Current assumptions listed - LM
1. How do ENTITY nodes compare?
Current assumption: TREE_POSITION_DISCONNECTED, as ENTITY nodes
aren't really 'in the tree'
2. How do NOTATION nodes compare?
Current assumption: TREE_POSITION_DISCONNECTED, as NOTATION nodes
aren't really 'in the tree'
3. Are TREE_POSITION_ANCESTOR and TREE_POSITION_DESCENDANT
only relevant for nodes that are "part of the document tree"?
Is the element node "outer" considered an ancestor of "myattr"?
Current assumption: No.
4. How do children of ATTRIBUTE nodes compare (with eachother, or
with children of other attribute nodes with the same element)
Current assumption: Children of ATTRIBUTE nodes are treated as if
they they are the attribute node itself, unless the 2 nodes
are both children of the same attribute.
5. How does an ENTITY_REFERENCE node compare with it's children?
Given the DOM, it should precede its children as an ancestor.
Given "document order",  does it represent the same position?
Current assumption: An ENTITY_REFERENCE node is an ancestor of its
6. How do children of a DocumentFragment compare?
Current assumption: If both nodes are part of the same document
fragment, there are compared as if they were part of a document.
If the nodes are the same...
If either node is of type ENTITY or NOTATION, compare as disconnected
If either node is of type ENTITY or NOTATION, compare as disconnected
Find the ancestor of each node, and the distance each node is from
During this traversal, look for ancestor/descendent relationships
between the 2 nodes in question.
We do this now, so that we get this info correct for attribute nodes
and their children.
The other node is an ancestor of this one.
The other node is a descendent of the reference node.
if the ancestor is an attribute, get owning element.
we are now interested in the owner to determine position.
Before proceeding, we should check if both ancestor nodes turned
out to be attributes for the same element
Now, find the ancestor of the owning element, if the original
ancestor was an attribute
Note:  the following 2 loops are quite close to the ones above.
May want to common them up.  LM.
The other node is an ancestor of the owning element
Now, find the ancestor of the owning element, if the original
ancestor was an attribute
The other node is a descendent of the reference
thisAncestor and otherAncestor must be the same at this point,
otherwise, we are not in the same tree or document fragment
Go up the parent chain of the deeper node, until we find a node
with the same depth as the shallower node
Check if the node we have reached is in fact "otherNode". This can
happen in the case of attributes.  In this case, otherNode
Check if the node we have reached is in fact "thisNode".  This can
happen in the case of attributes.  In this case, otherNode
We now have nodes at the same depth in the tree.  Find a common
At this point, thisNode and otherNode are direct children of
the common ancestor.
See whether thisNode or otherNode is the leftmost
REVISIT:  shouldn't get here.   Should probably throw an
If the nodes are the same, no flags should be set
check if other is from a different implementation
other comes from a different implementation
get the respective Document owners.
If from different documents, we know they are disconnected.
and have an implementation dependent order
Find the ancestor of each node, and the distance each node is from
During this traversal, look for ancestor/descendent relationships
between the 2 nodes in question.
We do this now, so that we get this info correct for attribute nodes
and their children.
The other node is an ancestor of this one.
The other node is a descendent of the reference node.
Special casing for ENTITY, NOTATION, DOCTYPE and ATTRIBUTES
LM:  should rewrite this.
the nodes are of different types
the nodes are of the same type.  Find order.
Now, find the ancestor of the element
The other node is an ancestor of the owning element
The other node is a descendent of the reference
thisAncestor and otherAncestor must be the same at this point,
otherwise, the original nodes are disconnected
Go up the parent chain of the deeper node, until we find a node
with the same depth as the shallower node
Check if the node we have reached is in fact "otherNode". This can
happen in the case of attributes.  In this case, otherNode
Check if the node we have reached is in fact "thisNode".  This can
happen in the case of attributes.  In this case, otherNode
We now have nodes at the same depth in the tree.  Find a common
At this point, thisNode and otherNode are direct children of
the common ancestor.
See whether thisNode or otherNode is the leftmost
REVISIT:  shouldn't get here.   Should probably throw an
overriden in some subclasses
internal method taking a StringBuffer in parameter
we do not use any wrapper so the answer is obvious
REVISIT: remove casts when DOM L3 becomes REC.
REVISIT: is it possible that prefix is empty string?
type is unknown
REVISIT: When Namespaces 1.1 comes out this may not be true
Prefix can't be bound to null namespace
to flip out children
type is unknown
REVISIT: is it possible that prefix is empty string?
looking for default namespace
non default namespace
at this point we are dealing with DOM Level 2 nodes only
non default namespace
type is unknown
REVISIT: if no prefix is available is it null or empty string, or
could be both?
DOM Level 2 nodes
in theory nodeName can't be null but better be careful
who knows what other implementations may be doing?...
we don't have any alternate node, either this node does the job
or we don't have anything that does
we do not actually store this information on every node, we only
have a global indicator on the Document. Doing otherwise cost us too
much for little gain.
we do not actually store this information on every node, we only
have a global indicator on the Document. Doing otherwise cost us too
much for little gain.
By default just change the flag to avoid calling this method again
inconsistent name to avoid clash with public method on TextImpl
See if flag should propagate to parent.
Compute the typecode for easy switching
the name of the field
type first byte of the type signature
iff object, typename
the type of this field, if has been resolved
the next 2 things are RMI-IIOP specific, it can be easily
removed, if we can figure out all place where there are dependencies
to this.  Signature is esentially equal to typestring. Then
essentially we can use the java.io.ObjectStreamField as such.
the signature of the field
BEGIN: Keys needed for exception messages of  JAXP 1.3 XPath API implementation
END: Keys needed for exception messages of  JAXP 1.3 XPath API implementation
Note to translators:  A relative location path is a form of XPath expression.
The message indicates that such an expression was expected following the
characters '/' or '', but was not found.
Note to translators:  A location path is a form of XPath expression.
The message indicates that syntactically such an expression was expected,but
the characters specified by the substitution text were encountered instead.
Note to translators:  A location path is a form of XPath expression.
The message indicates that syntactically such a subexpression was expected,
but no more characters were found in the expression.
Note to translators:  A location step is part of an XPath expression.
The message indicates that syntactically such an expression was expected
following the specified characters.
Note to translators:  A node test is part of an XPath expression that is
used to test for particular kinds of nodes.  In this case, a node test that
consists of an NCName followed by a colon and an asterisk or that consists
of a QName was expected, but was not found.
Note to translators:  A step pattern is part of an XPath expression.
The message indicates that syntactically such an expression was expected,
but the specified character was found in the expression instead.
Note to translators: A relative path pattern is part of an XPath expression.
The message indicates that syntactically such an expression was expected,
but was not found.
Note to translators:  The substitution text is the name of a data type.  The
message indicates that a value of a particular type could not be converted
to a value of type boolean.
Note to translators: Do not translate ANY_UNORDERED_NODE_TYPE and
Note to translators: Do not translate UNORDERED_NODE_SNAPSHOT_TYPE and
Note to translators: This message indicates that the document being operated
upon changed, so the iterator object that was being used to traverse the
document has now become invalid.
Note to translators:  The substitution text is the name of a data type.  The
message indicates that a value of a particular type could not be converted
to a value of type string.
Note to translators: Do not translate snapshotItem,
UNORDERED_NODE_SNAPSHOT_TYPE and ORDERED_NODE_SNAPSHOT_TYPE.
Note to translators:  XPathEvaluator is a Java interface name.  An
XPathEvaluator is created with respect to a particular XML document, and in
this case the expression represented by this object was being evaluated with
respect to a context node from a different document.
Note to translators:  The XPath expression cannot be evaluated with respect
to this type of node.
BEGIN:  Definitions of error keys used  in exception messages of  JAXP 1.3 XPath API implementation
END:  Definitions of error keys used  in exception messages of  JAXP 1.3 XPath API implementation
Other miscellaneous text used inside the code...
================= INFRASTRUCTURE ======================
System.out.println("Getting tc " + (TypeCode)typeMap.get(new Integer(position)) +
The enclosed stream has to consider if the enclosing stream
had to read the enclosed stream completely when creating it.
This is why the size of the enclosed stream needs to be substracted.
Substract getBufferLength from the parents pos because it read this stream
from its own when creating it
System.out.println("TypeCodeInputStream.getTopLevelPosition using getTopLevelPosition " + topPos +
(isEncapsulation ? " - encaps length 4" : "") +
" - getBufferLength() " + getBufferLength() +
System.out.println("TypeCodeInputStream.getTopLevelPosition returning getPosition() = " +
_REVISIT_ Would be nice if we didn't have to copy the buffer!
read off part of the buffer corresponding to the encapsulation
create an encapsulation using the marshal buffer
first entry in an encapsulation is the endianess
PENDING(jeff) - the thumb should be dithered when disabled
This is a little bit backwards: By rights MappedByteBuffer should be a
subclass of DirectByteBuffer, but to keep the spec clear and simple, and
for optimization purposes, it's easier to do it the other way around.
This works because DirectByteBuffer is a package-private class.
For mapped buffers, a FileDescriptor that may be used for mapping
operations if valid; null if the buffer is not mapped.
This should only be invoked by the DirectByteBuffer constructors
Can only happen if a luser explicitly casts a direct byte buffer
Returns the distance (in bytes) of the buffer from the page aligned address
of the mapping. Computed each time to avoid storing in every direct buffer.
not used, but a potential target for a store, see load() for details.
Read a byte from each page to bring it into memory. A checksum
is computed as we go along to prevent the compiler from otherwise
considering the loop as dead code.
so that string compares can be done.
SNMP Runtime imports
A SnmpMibTree object is a tree of TreeNode
In this case, the node does not have any children. So no point to
continue the search ...
In this case, the oid does not have any more element. So the search
If the returned node got a null agent, we have to replace it by
the current one (in case it is not null)
That's it !
Create a child and register it !
We have to set the agent attribute
end of class TreeNode
implementation of ValidationContext methods
whether to do extra id/idref/entity checking
whether to validate against facets
if there is no symbol table, we return java-internalized string,
because symbol table strings are also java-internalzied.
this guarantees that the returned string from this method can be
compared by reference with other symbol table string. -SG
some fields are accessed using package scope from DateTimeParseContext
only copy fields used in parsing stage
not a complete date/time
inline TemporalAccessor.super.query(query) as an optimization
non-JDK classes are not permitted to make this optimization
if any other fields, handle them
any lenient date resolution should return epoch-day
have to restart to avoid concurrent modification
have to restart to avoid concurrent modification
have to restart to avoid concurrent modification
have to restart to avoid concurrent modification
catch infinite loops
if something changed then have to redo ChronoField resolve
resolve parsed instant seconds to date and time if zone available
lenient allows anything, smart allows 0-24, strict allows 1-24
lenient allows anything, smart allows 0-12, strict allows 1-12
STRICT or SMART
combine partial second fields strictly, leaving lenient expansion to later
convert to time if all four fields available (optimization)
leniently create a time from incomplete information
done after everything else as it creates information from nothing
which would break updateCheckConflict(field)
NANO_OF_SECOND merged with MILLI/MICRO above
merge milli-of-second and micro-of-second for better error message
convert milli-of-second to nano-of-second
convert micro-of-second to nano-of-second
merge hour/minute/second/nano leniently
check for invalid combinations that cannot be defaulted
default as necessary and build time
safe int cast
STRICT or SMART
handle 24:00 end of day
add whole days if we have both date and time
ensure fractional seconds available as ChronoField requires
resolveTimeLenient() will have merged MICRO_OF_SECOND/MILLI_OF_SECOND to NANO_OF_SECOND
add instant seconds if we have date, time and zone
only cross-check date, time and date-time
avoid object creation if possible
Xerces security manager
Implementation limits: API properties
Implementation limits: corresponding System Properties of the above
legacy System Properties
System Properties corresponding to ACCESS_EXTERNAL_* properties
all access keyword
write out a CDATA section closing "]]>"
Remember that we have done so.
Not a great thing if the writer was created
by this class, but don't have a choice.
Do not inline external DTD
Do not inline external DTD
if we are tracing events we need to trace what
characters are written to the output writer.
if standalone was explicitly specified
Access this only from the Hashtable level... we don't want to
get default properties.
if not already set then get it from the properties
if (output instanceof java.io.BufferedOutputStream)
else if (output instanceof java.io.FileOutputStream)
Not sure what to do in this case.  I'm going to be conservative
and not buffer.
if we are tracing events we need to trace what
characters are written to the output writer.
Should have been warned in init, I guess...
Do not inline external DTD
TODO Auto-generated catch block
This is the old/fast code here, but is this
correct for all encodings?
If we make it to here we have a valid high, low surrogate pair
If the character formed by the surrogate pair
is in the encoding, so just write it out
Don't know what to do with this char, it is
not in the encoding and not a high char in
a surrogate pair, so write out as an entity ref
not in the encoding, so write out a character reference
non-zero only if character reference was written out.
if this is text node character and a special one of those,
or if this is a character from attribute value and a special one of those
if (i != 0)
This needs to go into a function...
process two input characters
if ((i != 0) && (i < (end - 1)))
if (!m_cdataTagOpen && (i < (end - 1)))
This needs to go into a function...
process two input characters
time to fire off CDATA event
It does not make sense to continue with rest of the method if the number of
characters to read from array is 0.
Section 7.6.1 of XSLT 1.0 (http:www.w3.org/TR/xslt#value-of) suggest no text node
is created if string is empty.
the check with _escaping is a bit of a hack for XLSTC
time to fire off characters generation event
skip any leading whitspace
don't go off the end and use a hand inlined version
last character that needed processing
int lengthClean;     number of clean characters in a row
we've skipped the leading whitespace, now deal with the rest
A tight loop to skip over common clean chars
This tight loop makes it easier for the JIT
a character needing no special processing
we've reached the end. Any clean characters at the
end of the array than need to be written out?
For indentation purposes, mark that we've just writen text out
time to fire off characters generation event
if we have some clean characters accumulated
process them before the dirty one.
process the "dirty" character
Return the index of the last character that we just processed
which is a dirty character.
Should be the UTF-16 low surrogate of the hig/low pair.
Unicode code point formed from the high/low pair.
"Invalid UTF-16 surrogate detected: "
"Invalid UTF-16 surrogate detected: "
count the two characters that went into writing out this entity
count the single character that was processed
process the attributes now, because after this SAX call they might be gone
at one point this code seemed right,
but not anymore - Brian M.
elementAt is JDK 1.1.8
I guess the parser doesn't normalize cr/lf in attributes. -sb
if ((CharInfo.S_CARRIAGERETURN == ch)
&& ((i + 1) < len)
&& (CharInfo.S_LINEFEED == stringChars[i + 1]))
namespaces declared at the current depth are no longer valid
so get rid of them
clear attributes object for re-use with next element
fire off the end element event
the "true" causes the flush of any open tags
the prefix mapping applies to the child element (one deeper)
the prefix mapping applies to the current element
hack for XSLTC attribset16 test
that maps ns1 prefix to "" URI
Detect occurrences of two consecutive dashes, handle as necessary.
if we have some chars in the comment
Output the remaining characters (if any)
Protect comment end from a single trailing dash
time to generate comment event
Don't output doctype declaration until startDocumentInternal
has been called. Otherwise, it can appear before XML decl.
TODO: Should handle
clear attributes object for re-use with next element
Vector of URI/LocalName pairs
parse through string, breaking on whitespaces.  I do this instead
of a tokenizer so I can track whitespace inside of curly brackets,
which theoretically shouldn't happen if they contain legal URLs.
call the official, public method to set the collected names
add null URI and the local name
add URI, then local name
extract the prefix in front of the raw name
we have a prefix, lets see if it maps to a namespace
the prefix in the raw name is already maps to the given namespace uri
so we don't need to do anything
The uri does not map to the prefix in the raw name,
so lets make the mapping.
we don't have a prefix in the raw name.
Does the URI map to a prefix already?
uri is not associated with a prefix,
so lets generate a new prefix to use
Bugzilla1133: Generate attribute as well as namespace event.
SAX does expect both.
this method is really only useful in the ToSAXHandler classes but it is
in the interface.  If the method defined here is ever called
we are probably in trouble.
if (uri == null || localName == null || uri.length() == 0)
Don't use 'localName' as it gives incorrect value, rely only on 'rawName'
the attribute doesn't exist yet, create it
In the example above, is there a prefix like foo ?
TODO Auto-generated catch block
flush out the "<elemName" if not already flushed
make a StringBuffer to write the name="value" pairs to.
make a writer that internally appends to the same
Don't clear the attributes!
We only want to see what would be written out
at this point, we don't want to loose them.
the potential > after the attributes.
convert the StringBuffer to a char array and
emit the trace event that these characters "might"
this.m_charInfo = null;  don't set to null
Leave m_format alone for now - Brian M.
?? used anywhere ??
DON'T SET THE WRITER TO NULL, IT MAY BE REUSED !!
If we have changed the setting of the
We tried to get an EncodingInfo for Object for the given
encoding, but it came back with an internall null name
so the encoding is not supported by the JDK, issue a message.
Prepare to issue the warning message
Issue the warning message
TODO Auto-generated catch block
TODO Auto-generated catch block
use serialVersionUID from JDK 1.2.2 for interoperability
true if any all permissions have been added
No sync; staleness OK
No sync; staleness OK
End of file.
Feck the this pointer on the stack...
...then the entity name...
...to get the URI from the DOM object.
MAX_SKIP_BUFFER_SIZE is used to determine the maximum buffer size to
use when skipping.
1 (sign) + 19 (max # sig digits) + 1 ('.') + 1 ('e') + 1 (sign)
+ 3 (max # exp digits) + 4 (error) = 30
UnsupportedEncodingException should be thrown
index of last argument referenced
last ordinary index
fixed string, "%n", or "%%"
Anything between the start of the string and the beginning
of the format specifier is either fixed text or contains
an invalid format string.
Make sure we didn't miss any invalid format specifiers
Assume previous characters were fixed text
No more valid format specifiers.  Check for possible invalid
The rest of the string is fixed text
Any '%' found in the region starts an invalid format specifier.
remove the '.'
Instead of Calendar.setLenient(true), perhaps we should
wrap the IllegalArgumentException that might be thrown?
Note that the following method uses an instance of the
default time zone (TimeZone.getDefaultRef().
Note that the following method uses an instance of the
default time zone (TimeZone.getDefaultRef().
Use the provided locale so that invocations of
localizedMagnitude() use optimizations for null.
Flags.UPPERCASE is set internally for legal conversions.
'-' requires a width
'-' requires a width
'-' requires a width
'-' and '0' require a width
'-' requires a width
leading sign indicator
trailing sign indicator
apply ALTERNATE (radix indicator for octal) before ZERO_PAD
apply ALTERNATE (radix indicator for hex) before ZERO_PAD
justify based on width
neg := val < 0
neg := val < 0
leading sign indicator
apply ALTERNATE (radix indicator for octal) before ZERO_PAD
apply ALTERNATE (radix indicator for hex) before ZERO_PAD
trailing sign indicator
justify based on width
leading sign indicator
trailing sign indicator
justify based on width
!Double.isInfinite(value) && !Double.isNaN(value)
Create a new FormattedFloatingDecimal with the desired
If the precision is zero and the '#' flag is set, add the
requested decimal point.
Create a new FormattedFloatingDecimal with the desired
If the precision is zero and the '#' flag is set, add the
requested decimal point.
If the precision is zero and the '#' flag is set, add the
requested decimal point.
assume that we want all of the digits
don't localize hex
Add zeros to the requested precision.
Look for the dot.  If we don't find one, the we'll need to add
it before we add the zeros.
Determine existing precision.
Create new array with existing contents.
Add dot if previously determined to be necessary.
Method assumes that d > 0.
Let Double.toHexString handle simple cases
If this is subnormal input so normalize (could be faster to
do as integer operation).
Calculate the exponent.  This is not just exponent + 54
since the former is not the normalized exponent.
Deterime the number of bits to keep.
Bits to round away.
To decide how to round, look at the low-order bit of the
working significand, the highest order discarded bit (the
round bit) and whether any of the lower order discarded bits
are nonzero (the sticky bit).
Infinite result generated by rounding
Create a normalized subnormal string.
No 'p' character in hex string.
Get exponent and append at the end.
leading sign indicator
trailing sign indicator
justify based on width
value > 0
Create a new BigDecimal with the desired precision.
Add a decimal point if necessary.  The mantissa may not
contain a decimal point if the scale is zero (the internal
representation has no fractional part) or the original
precision is one. Append a decimal point if '#' is set or if
we require zero padding to get to the requested precision.
Add trailing zeros in the case precision is greater than
the number of available digits after the decimal separator.
Create a new BigDecimal with the desired precision.
more "scale" digits than the requested "precision"
case of 0.xxxxxx
Add a decimal point if necessary.  The mantissa may not
contain a decimal point if the scale is zero (the internal
representation has no fractional part).  Append a decimal
point if '#' is set or we require zero padding to get to the
Add trailing zeros if the precision is greater than the
number of available digits after the decimal separator.
g precision (# sig digits) = #x + #y
f precision = #y
exponent = #x - 1
=> f precision = g precision - exponent - 1
g precision (# sig digits) = #z
f precision = #0 (after '.') + #z
exponent = - #0 (after '.') - 1
=> f precision = g precision - exponent - 1
This conversion isn't supported.  The error should be
char[] with canonical string representation
The exponent will be formatted as a sign ('+' or '-') followed
by the exponent zero-padded to include at least two digits.
Construct a buffer, with sufficient capacity for all cases.
If E-notation is needed, length will be: +1 if negative, +1
if '.' needed, +2 for "E+", + up to 10 for adjusted
exponent.  Otherwise it could have +1 if negative, plus
count of padding zeros
Add a '.' to th mantissa if required
Add trailing zeros in the case precision is greater than the number
of available digits after the decimal separator.
justify based on width
'H' (00 - 23)
'I' (01 - 12)
'k' (0 - 23) -- like H
'l' (1 - 12) -- like I
'M' (00 - 59)
'N' (000000000 - 999999999)
'L' (000 - 999)
'Q' (0 - 99...?)
'p' (am or pm)
Calendar.AM = 0, Calendar.PM = 1, LocaleElements defines upper
's' (0 - 99...?)
'S' (00 - 60 - leap second)
combine minute and hour into a single integer
'h' -- same b
'C' (00 - 99)
'y' (00 - 99)
'Y' (0000 - 9999)
'd' (01 - 31)
'e' (1 - 31) -- like d
'j' (001 - 366)
'm' (01 - 12)
'T' (24 hour hh:mm:ss - %tH:%tM:%tS)
'R' (hh:mm same as %H:%M)
'r' (hh:mm:ss [AP]M)
this may be in wrong place for some locales
'c' (Sat Nov 04 12:02:33 EST 1999)
justify based on width
'H' (00 - 23)
'k' (0 - 23) -- like H
'I' (01 - 12)
'l' (1 - 12) -- like I
'M' (00 - 59)
'N' (000000000 - 999999999)
'L' (000 - 999)
'Q' (0 - 99...?)
'p' (am or pm)
Calendar.AM = 0, Calendar.PM = 1, LocaleElements defines upper
's' (0 - 99...?)
'S' (00 - 60 - leap second)
combine minute and hour into a single integer
'h' -- same b
'C' (00 - 99)
'y' (00 - 99)
'Y' (0000 - 9999)
'd' (01 - 31)
'e' (1 - 31) -- like d
'j' (001 - 366)
'm' (01 - 12)
'T' (24 hour hh:mm:ss - %tH:%tM:%tS)
'R' (hh:mm same as %H:%M)
'r' (hh:mm:ss [AP]M)
this may be in wrong place for some locales
'c' (Sat Nov 04 12:02:33 EST 1999)
-- Methods to support throwing exceptions --
determine localized grouping separator and size
localize the digits inserting group separators as necessary
no more group separators after the decimal separator
apply zero padding
duplicate declarations from Formattable.java
parse those flags which may be provided by users
Byte, Short, Integer, Long, BigInteger
(and associated primitives due to autoboxing)
Float, Double, BigDecimal
(and associated primitives due to autoboxing)
Character, Byte, Short, Integer
(and associated primitives due to autoboxing)
java.util.Date, java.util.Calendar, long
if (arg.TYPE != boolean) return boolean
if (arg instanceof Formattable) arg.formatTo()
Returns true iff the Conversion is applicable to all objects.
Returns true iff the Conversion is applicable to character.
Returns true iff the Conversion is an integer type.
Returns true iff the Conversion is a floating-point type.
Returns true iff the Conversion does not require an argument
(00 - 23)
(01 - 12)
(0 - 23) -- like H
(1 - 12) -- like I
(00 - 59)
(000000000 - 999999999)
jdk, not in gnu (000 - 999)
(0 - 99...?)
(am or pm)
(0 - 99...?)
(00 - 60 - leap second)
(24 hour hh:mm:ss)
(-1200 - +1200) - ls minus?
(00 - 99)
(01 - 31)
(1 - 31) -- like d
-- same b
(001 - 366)
(01 - 12)
(00 - 99)
(0000 - 9999)
(hh:mm same as %H:%M)
(Sat Nov 04 12:02:33 EST 1999)
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of SliderThumbPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of SliderThumbPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
Added in GIOP 1.1
Accessor methods (RequestMessage interface)
this will raise a MARSHAL exception upon errors.
Remove the empty SoftReference if any
make the world safe
FIXME: These three constants should be removed.
XXX: things to do: use SnmpOid rather than `instance' for future
XXX: Maybe use hashlists rather than vectors for entries?
=> in that case, the key should be SnmpOid.toString()
tree. It holds the original varbind vector passed
by the SnmpSubRequestHandler to this MIB. This
varbind vector is used to retrieve the "real"
position of a varbind in the vector. There is no other easy
way to do this - since as a result of the segmentation the
original positions will be lost.
allows for entry creation (ie: it is a SET request).
Now take care of V2 errorCodes that can be stored
in the varbind itself:
noSuchObject => notWritable
noSuchInstance => notWritable
Now take care of V2 errorCodes that can be stored
in the varbind itself:
noSuchObject => noSuchObject
noSuchInstance => noSuchInstance
Now we're going to try to transform every other
global code in either noSuchInstance or noSuchObject,
so that the get can return a partial result.
Only noSuchInstance or noSuchObject can be stored
in the varbind itself.
According to RFC 1905: noAccess is emitted when the
the access is denied because it is not in the MIB view...
noAccess => noSuchInstance
According to RFC 1905: (my interpretation because it is not
really clear) The specified variable name exists - but the
variable does not exists and cannot be created under the
present circumstances (probably because the request specifies
another variable/value which is incompatible, or because the
value of some other variable in the MIB prevents the creation)
Note that this error should never be raised in a GET context
but who knows?
inconsistentName => noSuchInstance
All the errors comprised between snmpRspWrongType and
snmpRspInconsistentValue concern values: so we're going
to assume the OID was correct, and reply with noSuchInstance.
Note that this error should never be raised in a GET context
but who knows?
We're going to assume the OID was correct, and reply
For all other errors but genErr, we're going to reply with
Only genErr will abort the GET and be returned as global
This class is a package implementation of the enumeration of
SnmSubRequest associated with an Handler node.
This class is a package implementation of the SnmpMibSubRequest
interface. It can only be instantiated by SnmpRequestTree.
Implements the method defined in SnmpMibRequest interface.
See SnmpMibRequest for the java doc.
Implements the method defined in SnmpMibRequest interface.
See SnmpMibRequest for the java doc.
Implements the method defined in SnmpMibRequest interface.
See SnmpMibRequest for the java doc.
Implements the method defined in SnmpMibRequest interface.
See SnmpMibRequest for the java doc.
XXX not sure we must also add the varbind in the global
request? or whether we should raise an exception:
in principle, this method should not be called!
Implements the method defined in SnmpMibSubRequest interface.
See SnmpMibSubRequest for the java doc.
Implements the method defined in SnmpMibSubRequest interface.
See SnmpMibSubRequest for the java doc.
Implements the method defined in SnmpMibRequest interface.
See SnmpMibRequest for the java doc.
Implements the method defined in SnmpMibRequest interface.
See SnmpMibRequest for the java doc.
Implements the method defined in SnmpMibSubRequest interface.
See SnmpMibSubRequest for the java doc.
The index in the exception must correspond to
the SNMP index ...
If we're doing a getnext ==> endOfMibView
Now take care of V2 errorCodes that can be stored
in the varbind itself:
noSuchObject => noSuchObject
noSuchInstance => noSuchInstance
Implements the method defined in SnmpMibSubRequest interface.
See SnmpMibSubRequest for the java doc.
The index in the exception must correspond to
the SNMP index ...
Although the first pass of check() did not fail,
the set() phase could not be carried out correctly.
Since we don't know how to make an "undo", and some
assignation may already have been performed, we're going
to throw an snmpRspUndoFailed.
Implements the method defined in SnmpMibSubRequest interface.
See SnmpMibSubRequest for the java doc.
The index in the exception must correspond to
the SNMP index ...
We throw the exception in order to abort the SET operation
in an atomic way.
Implements the method defined in SnmpMibRequest interface.
See SnmpMibRequest for the java doc.
This class implements a node in the SnmpRequestTree.
o The SnmpMibNode involved (key)
o The sublist of varbind directly handled by this node
o A vector of sublists concerning the entries (existing or not)
of the SnmpMIbNode (when it is a table).
The meta  which handles the sublist.
The depth of the meta node.
The sublist of varbinds to be handled.
List        entryoids;   Sorted array of entry oids
List        entrylists;  Sorted array of entry lists
List        isentrynew;  Sorted array of booleans
Sorted array of entry oids
Sorted array of entry lists
Sorted array of booleans
RowStatus varbind, if any
request PDU type as defined in SnmpDefinitions
We need this because of new Vector[n] instead of
new Vector<SnmpVarBind>[n], which is illegal.
Vectors are null: Allocate new vectors
Vectors must be enlarged
Save old vectors
Allocate larger vectors
Check pos validity
Copy original vectors up to `pos'
Copy original vectors from `pos' to end, leaving
an empty room at `pos' in the new vectors.
Vectors are large enough to accommodate one additional
Shift vectors, making an empty room at `pos'
Fill the gap at `pos'
We do not include the status variable in the varbind,
because we're going to set it separately...
Returns the contextual object containing user-data allocated
through the SnmpUserDataFactory for this request.
Tells whether creation of new entries is allowed with respect
to the operation involved (GET=>false/SET=>true)
Tells whether we are currently processing a SET request (check/set)
Returns the protocol version in which the original request is
Returns the actual protocol version of the request PDU.
Returns the SnmpMibNode associated with the given handler
Indicates the depth of the arc in the OID that identifies the
SnmpMibNode associated with the given handler
returns an enumeration of the SnmpMibSubRequest's to be invoked on
the SnmpMibNode associated with a given Handler node.
If this node is a group, there will be a single subrequest.
If it is a table, there will be one subrequest per entry involved.
returns an enumeration of the Handlers stored in the Hashtable.
adds a varbind to a handler node sublist
adds an entry varbind to a handler node sublist
adds an entry varbind to a handler node sublist - specifying the
varbind which holds the row status
Type of the request (see SnmpDefinitions)
We deal with a GET-NEXT request
Tell whether creation is allowed.
Returns the subrequest handled by the SnmpMibNode itself
(in principle, only for Groups)
Returns the subrequest associated with the entry identified by
the given entry (only for tables)
Returns the subrequest associated with the entry identified by
the given entry (only for tables). The `entry' parameter is an
index relative to the position of the entry in the handler sublist.
stores a handler node in the Hashtable
finds a handler node in the Hashtable
Search for the given oid in `oids'. If none is found, returns -1
otherwise, returns the index at which the oid is located.
never know ...we might find something ...
Return the index at which the given oid should be inserted in the
never know ...we might find something ...
In the calling method we will have to check for this case...
if (comp == 0)
Returning curr instead of -1 avoids having to call
findOid() first and getInsertionPoint() afterwards.
We can simply call getInsertionPoint() and then checks whether
there's an OID at the returned position which equals the
adds a varbind in a handler node sublist
retrieve the handler node associated with the given meta,
If no handler node was found for that meta, create one.
debug("registerNode", "adding node for " +
debug("registerNode","found node for " +
Adds the varbind in the handler node's sublist.
Hashtable of Handler objects
The original list of varbinds
The protocol version
Does the operation allow
creation of entries
Does the operation allow
creation of entries
Request PDU type as defined
True if we're processing a
SET request (check/set).
First copy any remaining bytes down to the beginning
Now fill the rest of the buffer
First see what's left in the buffer.
Some there, but not enough
Now read the rest directly from the stream
First see what's left in the buffer.
Some there, but not enough
Now read the rest directly from the stream
out of inner while
Reload the buffer and keep going
Skip any remaining pad bytes
Only if it still is 0xff
send out a warning, but treat it as EOI
eliminate loops in case of the boot
ClassLoader returning itself as a parent
handled by ELEMENT_NODE
These node types are ignored!!!
should be handled!!!
Generate SAX event to start element
Process all namespace attributes first
Is this a namespace declaration?
Process all non-namespace attributes next
Is this a regular attribute?
Uri may be implicitly declared
Fix for bug 26319
For attributes not given an prefix explictly
but having a namespace uri we need
to explicitly generate the prefix
Now element namespace and children
Uri may be implicitly declared
Fix for bug 26319
If an element foo is created using
then the  element should be serialized
<foo xmlns=" "/>
Traverse all child nodes of the element (if any)
Generate SAX event to close element
General Attribute Checking for elmNode
for <any>, need to create a new particle to reflect the min/max values
General Attribute Checking for elmNode
get all attributes
resize prefix array
this saves us from having a copy of each of these in fNamespace for each scope
find uri in current context
uri not found
this saves us from having a copy of each of these in fNamespace for each scope
find prefix in current context
prefix not found
0.00 -> 0.30
0.30 -> 0.75
0.75 -> 1.00
Length of corbaloc:
Length of corbaname:
override for covariant return type
inline TemporalAccessor.super.query(query) as an optimization
non-JDK classes are not permitted to make this optimization
not specified => getDefault
called from C code
Snapshot sub-group data so we don't hold this lock
while our children are computing.
This is done last so it doesn't matter in case the
thread is killed
Zap dangling reference to the dead group so that
the garbage collector will collect it.
This is done last so it doesn't matter in case the
thread is killed
The thread is now a fully fledged member of the group, even
though it may, or may not, have been started yet. It will prevent
the group from being destroyed so the unstarted Threads count is
Zap dangling reference to the dead thread so that
the garbage collector will collect it.
set to true if invocation handler allows finalize method (legacy behavior)
-- Begin Closure interface --------------------
way up in the tree
Only one reference per variable
Add variable to parent closure as well
-- End Closure interface ----------------------
We need explicit type information for reference types - no good!
A result tree fragment should not be cast directly to a number type,
but rather to a boolean value, and then to a numer (0 or 1).
Ref. section 11.2 of the XSLT 1.0 spec
Numerical types will be converted to a position filter
Cast any numerical types to an integer
Nth position optimization. Expression must not depend on context
_nthDescendant optimization - only if _nthPositionFilter is on
Reset optimization flags
Otherwise, expand [e] to [position() = e]
All other types will be handled as boolean values
Add a new instance variable for each var in closure
Store the dom in a local variable
Store the dom index in the test generator
Returned cached value if called more than once
Nothing to do if _exp is null
Ignore if not equality expression
Unwrap and set _step if appropriate
Unwrap and set _step if appropriate
Returned cached value if called more than once
Nothing to to do if _exp is null
Ignore if not an equality expression
Return if left is literal string
Return if left is a variable reference of type string
Return if right is literal string
Return if left is a variable reference whose type is string
Compile auxiliary class for filter
Create new instance of filter
Initialize closure variables
Find nearest closure implemented as an inner class
Use getfield if in an inner class
Use a load of instruction if in translet class
Store variable in new closure
Memorize BranchInstructions that need an update
blocks until user brings dialog down...
inner class AccessibleJColorChooser
The following few lines are used to register esc to close the dialog
end esc handling
Aug 21, 2000:
Fixed bug in isElement and made HTMLdtd public.
Contributed by Eric SCHAEFFER" <eschaeffer@posterconseil.com>
Several elements are defined as closing the HEAD
P closes iteself
DT closes DD, DD closes DT
LI and OPTION close themselves
Each of these table sections closes all the others
TD closes TH and TH closes TD
Make sure not to initialize twice.
End of file.
Shared UI object
anchor is null after deserialization
fill 'predefined' array for backwards compatibility.
Lookup localized name.
The value stores both Stringified Object Reference and
Non-Stringified Object Reference. This is done to avoid
calling orb.string_to_object( ) everytime. Instead it
will be set once and then the result will be used everytime.
Objectreference or Context
BEGIN: Keys needed for exception messages of  JAXP 1.3 XPath API implementation
END: Keys needed for exception messages of  JAXP 1.3 XPath API implementation
Note to translators:  A relative location path is a form of XPath expression.
The message indicates that such an expression was expected following the
characters '/' or '', but was not found.
Note to translators:  A location path is a form of XPath expression.
The message indicates that syntactically such an expression was expected,but
the characters specified by the substitution text were encountered instead.
Note to translators:  A location path is a form of XPath expression.
The message indicates that syntactically such a subexpression was expected,
but no more characters were found in the expression.
Note to translators:  A location step is part of an XPath expression.
The message indicates that syntactically such an expression was expected
following the specified characters.
Note to translators:  A node test is part of an XPath expression that is
used to test for particular kinds of nodes.  In this case, a node test that
consists of an NCName followed by a colon and an asterisk or that consists
of a QName was expected, but was not found.
Note to translators:  A step pattern is part of an XPath expression.
The message indicates that syntactically such an expression was expected,
but the specified character was found in the expression instead.
Note to translators: A relative path pattern is part of an XPath expression.
The message indicates that syntactically such an expression was expected,
but was not found.
Note to translators:  The substitution text is the name of a data type.  The
message indicates that a value of a particular type could not be converted
to a value of type boolean.
Note to translators: Do not translate ANY_UNORDERED_NODE_TYPE and
Note to translators: Do not translate UNORDERED_NODE_SNAPSHOT_TYPE and
Note to translators: This message indicates that the document being operated
upon changed, so the iterator object that was being used to traverse the
document has now become invalid.
Note to translators:  The substitution text is the name of a data type.  The
message indicates that a value of a particular type could not be converted
to a value of type string.
Note to translators: Do not translate snapshotItem,
UNORDERED_NODE_SNAPSHOT_TYPE and ORDERED_NODE_SNAPSHOT_TYPE.
Note to translators:  XPathEvaluator is a Java interface name.  An
XPathEvaluator is created with respect to a particular XML document, and in
this case the expression represented by this object was being evaluated with
respect to a context node from a different document.
Note to translators:  The XPath expression cannot be evaluated with respect
to this type of node.
BEGIN:  Definitions of error keys used  in exception messages of  JAXP 1.3 XPath API implementation
END:  Definitions of error keys used  in exception messages of  JAXP 1.3 XPath API implementation
Other miscellaneous text used inside the code...
================= INFRASTRUCTURE ======================
As this instance is immutable, these two values
need only be calculated once.
indexes refering to columns in the PRIMITIVE_ARRAY_TYPES table.
Check and construct state defined by parent.
We can't use the package-private OpenType constructor because
we don't know if the elementType parameter is sane.
Check and construct state specific to ArrayType
Check and construct state defined by parent.
We can call the package-private OpenType constructor because the
set of SimpleTypes is fixed and SimpleType can't be subclassed.
Check and construct state specific to ArrayType
Add N (= dimension) additional '[' characters to the existing array
Ideally we should throw an IllegalArgumentException here,
but for compatibility reasons we throw an OpenDataException.
(used to be thrown by OpenType() constructor).
Convert from wrapper type to primitive type
Ideally we should throw an IllegalArgumentException here,
but for compatibility reasons we throw an OpenDataException.
(used to be thrown by OpenType() constructor).
if obj is null, return false
if obj is not an array, return false
Test if obj's class name is the same as for the array values that this instance describes
(this is fine if elements are of simple types, which are final classes)
In case this ArrayType instance describes an array of classes implementing the TabularData or CompositeData interface,
we first check for the assignability of obj to such an array of TabularData or CompositeData,
which ensures that:
. obj is of the the same dimension as this ArrayType instance,
. it is declared as an array of elements which are either all TabularData or all CompositeData.
If the assignment check is positive,
then we have to check that each element in obj is of the same TabularType or CompositeType
as the one described by this ArrayType instance.
[About assignment check, note that the call below returns true: ]
assignment check: return false if negative
check that all elements in obj are valid values for this ArrayType
we know obj's dimension is this.dimension
if previous tests did not return, then obj is not a value for this ArrayType instance
if the elements of x_dim_Array are themselves array: go down recursively....
...else, for a non-empty array, each element must be a valid value: either null or of the right openType
if obj is null, return false
if obj is not an ArrayType, return false
if other's dimension is different than this instance's, return false
Test if other's elementType field is the same as for this instance
Test if other's primitiveArray flag is the same as for this instance
Calculate the hash code value if it has not yet been done (ie 1st call to hashCode())
return always the same hash code for this instance (immutable)
Calculate the string representation if it has not yet been done (ie 1st call to toString())
return always the same string representation for this instance (immutable)
can't get appropriate T for primitive array
Check if the supplied parameter is an array
Calculate array dimension and component type name
Check if the array's component type is a primitive type
Map component type name to corresponding SimpleType
Build primitive array
should not happen
compare zero if same object
Traverse snapshot to avoid iterator exceptions
also remove if already cancelled
Override AbstractExecutorService methods
Sanity check; x could conceivably be a
ScheduledFutureTask from some other pool.
don't retain ref while waiting
don't retain ref while waiting
In this order, in case add() throws.
In this order, in case add() throws.
index of next element to return
index of last element, or -1 if no such
ask the currently installed security manager if we
can replace it.
New security manager class is not on bootstrap classpath.
Cause policy to get initialized before we install the new
security manager, in order to prevent infinite loops when
trying to initialize the policy (which usually involves
accessing some security and/or system properties, which in turn
calls the installed security manager's checkPermission method
which will loop infinitely if there is a non-system class
(in this case: the new security manager class) on the stack).
VM might invoke JNU_NewStringPlatform() to set those encoding
sensitive properties (user.home, user.name, boot.class.path, etc.)
during "props" initialization, in which it may need access, via
System.getProperty(), to the related system encoding property that
have been initialized (put into "props") at early stage of the
initialization. So make sure the "props" is available at the
very beginning of the initialization and all system properties to
be put into it directly.
initialized by the VM
There are certain system configurations that may be controlled by
VM options such as the maximum amount of direct memory and
Integer cache size used to support the object identity semantics
of autoboxing.  Typically, the library will obtain these values
from the properties set by the VM.  If the properties are for
internal implementation use only, these properties should be
removed from the system properties.
See java.lang.Integer.IntegerCache and the
sun.misc.VM.saveAndRemoveProperties method for example.
Save a private copy of the system properties object that
can only be accessed by the internal implementation.  Remove
certain system properties that are not intended for public access.
Load the zip library now in order to keep java.util.zip.ZipFile
from trying to use itself to load this library later.
Setup Java signal handlers for HUP, TERM, and INT (where available).
Initialize any miscellenous operating system settings that need to be
set for the class libraries. Currently this is no-op everywhere except
for Windows where the process-wide error mode is set before the java.io
classes are used.
The main thread is not added to its thread group in the same
way as other threads; we must do it ourselves here.
register shared secrets
Subsystems that are invoked during initialization can invoke
sun.misc.VM.isBooted() in order to avoid doing things that should
wait until the application class loader has been set up.
IMPORTANT: Ensure that this remains the last initialization action!
Allow privileged classes outside of java.lang
lockInfo is a new attribute added in 1.6 ThreadInfo
If cd is a 5.0 version, construct the LockInfo object
from the lockName value.
serialVersionUID not constant
OK: exception means no compat with 1.0, too bad
should not happen as this class is cloneable
largest numerical value
These would not be used for EN. Only used for traditional numbering
These only used for mutiplicative-additive numbering
Note that we are using longs and that the last two
multipliers are not supported. This is a known limitation.
Let the delegate do everything, including error handling.
Same code as in javax.rmi.CORBA.Util. Can not be shared because they
are in different packages and the visibility needs to be package for
security reasons. If you know a better solution how to share this code
then remove it from here.
ignore, then try RMIClassLoader
This will not throw a SecurityException because this
class was loaded from rt.jar using the bootstrap classloader.
if (source instanceof DOMSource)
TODO: Not sure if the BaseID is really the same thing as the ID.
What can we do?
TODO: User diagnostics.
NOTE: do not make this method private as it affects stack traces
Cache for tool classes.
Use weak references to avoid keeping classes around unnecessarily
Cache for tool classloader.
Use a weak reference to avoid keeping it around unnecessarily
try loading class directly, in case tool is on the bootclasspath
if tool not on bootclasspath, look in default tools location (tools.jar)
if tools not found, no point in trying a URLClassLoader
so rethrow the original exception.
Fix for 4503661.
Reset the stream so that it doesn't keep a reference to the
Ignore the exception.
Contants identifying the various Fonts that are Theme can support
these are blue in Metal Default Theme
these are gray in Metal Default Theme
private objects to cache the locale and resource bundle
memorize the most-recent locale
add this message to fix bug 21478
Earlier (JDK 1.4 XALAN 2.2-D11) at key code '204' the key name was ER_PRIORITY_NOT_PARSABLE
In latest Xalan code base key name is  ER_VALUE_SHOULD_BE_NUMBER. This should also be taken care
in locale specific files like XSLTErrorResources_de.java, XSLTErrorResources_fr.java etc.
NOTE: Not only the key name but message has also been changed.
Note to translators:  The following message should not normally be displayed
to users.  It describes a situation in which the processor has detected
an internal consistency problem in itself, and it provides this message
for the developer to help diagnose the problem.  The name
'ElemTemplateElement' is the name of a class, and should not be
Note to translators:  The following message should not normally be displayed
to users.  It describes a situation in which the processor has detected
an internal consistency problem in itself, and it provides this message
for the developer to help diagnose the problem.  The substitution text
provides further information in order to diagnose the problem.  The name
'RedundentExprEliminator' is the name of a class, and should not be
This code is shared with warning codes.
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "QNAME" is the XML data-type of
The following codes are shared with the warning codes...
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "ENUM" is the XML data-type of
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "NMTOKEN" is the XML data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "NCNAME" is the XML data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "boolean" is the XSLT data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "number" is the XSLT data-type
End of shared codes...
Note to translators:  A "match pattern" is a special form of XPath expression
that is used for matching patterns.  The substitution text is the name of
a function.  The message indicates that when this function is referenced in
a match pattern, its argument must be a string literal (or constant.)
ER_ARG_LITERAL - new error message for bugzilla 5202
Note to translators:  The following message indicates that two definitions of
a variable.  A "global variable" is a variable that is accessible everywher
in the stylesheet.
ER_DUPLICATE_GLOBAL_VAR - new error message for bugzilla #790
Note to translators:  The following message indicates that two definitions of
a variable were encountered.
ER_DUPLICATE_VAR - new error message for bugzilla #790
Note to translators:  "xsl:template, "name" and "match" are XSLT keywords
which must not be translated.
ER_TEMPLATE_NAME_MATCH - new error message for bugzilla #789
Note to translators:  "exclude-result-prefixes" is an XSLT keyword which
should not be translated.  The message indicates that a namespace prefix
encountered as part of the value of the exclude-result-prefixes attribute
was in error.
ER_INVALID_PREFIX - new error message for bugzilla #788
Note to translators:  An "attribute set" is a set of attributes that can
be added to an element in the output document as a group.  The message
was never defined.
ER_NO_ATTRIB_SET - new error message for bugzilla #782
Note to translators:  This message indicates that there was a reference
Note to translators:  This message indicates that the XSLT instruction
instructions (content) or a "select" attribute.  The word "select" is
an XSLT keyword in this case and must not be translated.
Note to translators:  This message indicates that the value argument
of setParameter must be a valid Java Object.
Following are the new WARNING keys added in XALAN code base after Jdk 1.4 (Xalan 2.2-D11)
Note to translators:  "name" and "xsl:processing-instruction" are keywords
and must not be translated.
Note to translators:  "name" and "xsl:processing-instruction" are keywords
and must not be translated.  "NCName" is an XML data-type and must not be
Note to translators:  This message is reported if the stylesheet that is
being processed attempted to construct an XML document with an attribute in a
place other than on an element.  The substitution text specifies the name of
Check: WHY THERE IS A GAP B/W NUMBERS in the XSLTErrorResources properties file?
Other miscellaneous text used inside the code...
Note to translators:  The following messages provide usage information
for the Xalan Process command line.  "Process" is the name of a Java class,
and should not be translated.
Note to translators: The option name and the parameter name do not need to
be translated. Only translate the messages in parentheses.  Note also that
leading whitespace in the messages is used to indent the usage information
for each option in the English messages.
Do not translate the keywords: XSLTC, SAX, DOM and DTM.
Following are the new options added in XSLTErrorResources.properties files after Jdk 1.4 (Xalan 2.2-D11)
Added by sboag/scurcuru; experimental
AddITIONAL  STRINGS that need L10n
Note to translators:  The following message describes usage of a particular
command-line option that is used to enable the "template inlining"
optimization.  The optimization involves making a copy of the code
generated for a template in another template that refers to it.
================= INFRASTRUCTURE ======================
A class with only static fields and methods.
Each PlatformComponent represents one management
interface. Some MXBean may extend another one.
The MXBean instances for one platform component
(returned by pc.getMXBeans()) might be also
the MXBean instances for another platform component.
So need to check if an MXBean instance is registered
before registering into the platform MBeanServer
Only allow MXBean interfaces from rt.jar loaded by the
bootstrap class loader
skip the isInstanceOf check for LoggingMXBean
check if the registered MBean is a notification emitter
create an MXBean proxy
Make DynamicMBean out of MXBean by wrapping it with a StandardMBean
Read in the action, then initialize the rest
Not serialized; see serialization section at end of class.
Convert Iterator into Enumeration
Need to maintain serialization interoperability with earlier releases,
which had the serializable field:
Don't call out.defaultWriteObject()
Write out Vector
Don't call defaultReadObject()
Read in serialized fields
Get the one we want
-- This file was mechanically generated: Do not edit! --
Cached unsafe-access object
Cached array base offset
Cached unaligned-access capability
Base address, used in all indexing calculations
NOTE: moved up to Buffer.java for speed in JNI GetDirectBufferAddress
An object attached to this buffer. If this buffer is a view of another
buffer then we use this field to keep a reference to that buffer to
ensure that its memory isn't freed before we are done with it.
For duplicates and slices
End of file.
Uses our default code sets (see CodeSetComponentInfo)
1 in CORBA 2.3.1 13.6.3
recognized features and properties
no system id was available
next state is markup decls regardless of whether there
is a TextDecl or not
keep dispatching "events"
return that there is more to scan
reset entity scanner
xxx:stax getText() is supposed to return only DTD internal subset
shouldn't we record position here before we go ahead ??
set starting state for internal subset
keep dispatching "events"
we're done, set starting state for external subset
we're done scanning DTD.
return that there is more to scan
this is made for something like XMLDTDLoader--XMLComponentManager-free operation...
Revisit : Create new grammar until we implement GrammarPool.
if there is no data after the doctype
Handle end of PE
check well-formedness of the enity
throw fatalError if this entity was incomplete and
was a freestanding decl
Proper nesting of parameter entities is a Validity Constraint
and must not be enforced when validation is off
XML (Document Entity) is the last opened entity, however
if for some reason DTD Scanner receives this callback
there is something wrong (probably invalid XML), throw exception.
For standalone DTD loader, it might be the last opened entity
and if this is the last opened entity and fMarkUpDepth != 0 or
fIncludeSectDepth != 0 or fExtEntityDepth != 0 throw Exception
if we actually got a new entity and it's external
parse text decl if there is any
NOTE: special case where document starts with a PI
whose name starts with "xml" (e.g. "xmlfoo")
standard Text declaration
Mixed content model
The following check must be done in a single call (as opposed to one
for ')' and then one for '*') to guarantee that callbacks are
properly nested. We do not want to trigger endEntity too early in
case we cross the boundary of an entity between the two characters.
we are done
push current op on stack and reset it
restore previous op
The following checks must be done in a single call (as
opposed to one for ')' and then one for '?', '*', and '+')
to guarantee that callbacks are properly nested. We do not
want to trigger endEntity too early in case we cross the
boundary of an entity between the two characters.
no occurrence specified
no space, is it the end yet?
yes, stop here
REVISIT: Should we do anything with the non-normalized
default attribute value? -Ac
yes--according to bug 5073.  - neilg
Determine whether the default value to be passed should be null.
REVISIT: should probably check whether fLiteral.ch is null instead. LM.
<!ENTITY x "x">
<!ENTITY % x "x">
<!ENTITY %%x; "x"> is legal
<!ENTITY[^ ]...> or <!ENTITY[^ %]...>
check whether there was space before NDATA
since we need it's value anyway, let's snag it so it doesn't get corrupted
if a new load takes place before we store the entity values
skip possible trailing space
register entity and make callback
Venu Revisit : why false has been removed in expandSYstem
store at which depth of entities we start
REVISIT: [Q] Why do we skip spaces here? -Ac
REVISIT: This will make returning the non-
normalized value harder. -Ac
if it's not the delimiting quote or if it is but from a
different entity than the one this literal started from,
simply append the character to our buffer
skip possible trailing space
Venu Revisit wby false has been removed.
just stop there and go back to the main loop
These tests are split so that we handle cases like
'<<![' and '<!<![' which we might otherwise miss.
The same thing goes for ']<![' and '<]]>', etc.
we're done with this decl
end of conditional section?
this is the end of the internal subset, let's stop here
report end/start calls
reset state related data
set starting state
Information about the system-wide policy.
the system-wide policy
a flag indicating if the system-wide policy has been initialized
PolicyInfo is stored in an AtomicReference
Cache mapping ProtectionDomain.Key to PermissionCollection
Use double-check idiom to avoid locking if system-wide policy is
install the bootstrap provider to avoid recursion
we want the extension loader
assume it has all
cache of pd to permissions
DefaultHandler.java - default implementation of the core handlers.
Written by David Megginson
NO WARRANTY!  This class is in the public domain.
$Id: DefaultHandler.java,v 1.3 2006/04/13 02:06:32 jeffsuttor Exp $
Default implementation of the EntityResolver interface.
Default implementation of DTDHandler interface.
Default implementation of ContentHandler interface.
Default implementation of the ErrorHandler interface.
end of DefaultHandler.java
The platform default encoding
The system should always have the platform default
(numChars-i)/3 is an upper bound for the number
of remaining bytes
A trailing, incomplete byte encoding such as
"%x" will cause an exception to be thrown
The parent class loader for delegation
Note: VM hardcoded the offset of this field, thus all new fields
must be added *after* it.
the set of parallel capable loader types
register the class loader as parallel capable
if and only if all of its super classes are.
Note: given current classloading sequence, if
the immediate super class is parallel capable,
all the super classes higher up must be too.
Maps class name to the corresponding lock object when the current
class loader is parallel capable.
Note: VM also uses this field to decide if the current class loader
is parallel capable and the appropriate lock object for class loading.
Hashtable that maps packages to certs
Shared among all packages with unsigned classes
The classes loaded by this class loader. The only purpose of this table
is to keep the classes from being GC'ed until the loader is GC'ed.
The "default" domain. Set as the default ProtectionDomain on newly
The initiating protection domains for all classes loaded by this loader
Invoked by the VM to record every loaded class with this loader.
The packages defined in this class loader.  Each package name is mapped
to its corresponding Package object.
no finer-grained lock; lock on the classloader instance
-- Class --
First, check if the class has already been loaded
ClassNotFoundException thrown if class not found
from the non-null parent class loader
If still not found, then invoke findClass in order
to find the class.
this is the defining class loader; record the stats
This method is invoked by the virtual machine to load a class.
For backward compatibility, explicitly lock on 'this' when
the current class loader is not parallel capable.
Invoked by the VM after loading class with this loader.
Note:  Checking logic in java.lang.invoke.MemberName.checkForTypeAlias
relies on the fact that spoofing is impossible if a class has a name
of the form "java.*"
Use byte[] if not a direct ByteBufer:
no array, or read-only array
get bytes out of byte buffer.
true if the name is null or has the potential to be a valid binary name
certs can be null, indicating no certs.
the length must be the same at this point
go through and make sure all the certs in one array
are in the other and vice-versa.
now do the same for pcerts
return null if not found
-- Resource --
Returns the URLClassPath that is used for finding system resources.
-- Hierarchy --
Check access to the parent class loader
If the caller's class loader is same as this class loader,
permission check is performed.
wrap the exception
Returns true if the specified class loader can be found in this class
loader's delegation chain.
Tests if class loader access requires "getClassLoader" permission
check.  A class loader 'from' can access class loader 'to' if
class loader 'from' is same as class loader 'to' or an ancestor
of 'to'.  The class loader in a system domain can access
any class loader.
Returns the class's class loader, or null if none.
This can be null if the VM is requesting it
Circumvent security check since this is package-private
caller can be null if the VM is requesting it
The class loader for the system
Set to true once the system class loader has been set
-- Package --
-- Native library access --
opaque handle to native library, used in native code.
the version of JNI environment the native library requires.
the class from which the library is loaded, also indicates
the loader this native library belongs.
the canonicalized name of the native library.
or static library name
Indicates if the native library is linked into the VM
Indicates if the native library is loaded
Invoked in the VM to determine the context class in
All native library names we've loaded.
Native libraries belonging to system classes.
Native libraries associated with the class loader.
native libraries being loaded/unloaded.
The paths searched for libraries
Count the separators in the path
allocate the array of paths - n :'s = n + 1 path elements
Fill the array with paths from the ldpath
Invoked in the java.lang.Runtime class to implement load and loadLibrary.
Oops, it failed
Check to see if we're attempting to access a static library
Invoked in the VM class linking code.
-- Assertion management --
The default toggle for assertion checking.
Maps String packageName to Boolean package default assertion status Note
that the default package is placed under a null map key.  If this field
is null then we are delegating assertion status queries to the VM, i.e.,
none of this ClassLoader's assertion status modification methods have
Maps String fullyQualifiedClassName to Boolean assertionStatus If this
field is null then we are delegating assertion status queries to the VM,
i.e., none of this ClassLoader's assertion status modification methods
have been invoked.
Check for a class entry
Check for most specific package entry
Return the classloader default
Set up the assertions with information provided by the VM.
Note: Should only be called inside a synchronized block
Retrieves the assertion directives from the VM.
if obj extends UnicastRemoteObject, set its ref.
FileURL.java - Construct a file: scheme URL
lazy initialization of default file system
returns default file system
load default provider
return file system
returns default provider
if the property java.nio.file.spi.DefaultFileSystemProvider is
set then its value is the name of the default provider (or a list)
must be "file"
check installed providers
if not found, use service-provider loading facility
check installed providers
if not found, use service-provider loading facility
implementors should override this method
convert file to appropriate URI, f.toURI().toASCIIString()
converts the URI to string as per rule specified in
convert file to appropriate URI, f.toURI().toASCIIString()
converts the URI to string as per rule specified in
Constants returned by startElement and acceptNode
-- Channel and selector operations --
-- Operation-set accessors --
-- Operation bits and bit-testing convenience methods --
-- Attachments --
The index of the first parameter (after dom/iterator/handler/current)
While still string
Start of choice
read and discard the repository ID
write the repository ID
Turn off character escaping if so is wanted.
Call characters(String) or characters(char[],int,int), as
Restore character escaping setting to whatever it was.
Note: setEscaping(bool) returns the original (old) value
Magic number!  21845*3 == 65535.  BCEL uses a DataOutputStream to
serialize class files.  The Java run-time places a limit on the size
of String data written using a DataOutputStream - it cannot require
more than 64KB when represented as UTF-8.  The number of bytes
required to represent a Java string as UTF-8 cannot be greater
than three times the number of char's in the string, hence the
check for 21845.
The XSLTC object keeps track of character data
that is to be stored in char arrays.
-- This file was mechanically generated: Do not edit! --
These fields are declared here rather than in Heap-X-Buffer in order to
reduce the number of virtual method invocations needed to access these
values, which is especially costly when coding small buffers.
Non-null only for heap buffers
Valid only for heap buffers
Creates a new buffer with the given mark, position, limit, capacity,
backing array, and array offset
Creates a new buffer with the given mark, position, limit, and capacity
-- Singleton get/put methods --
-- Bulk get operations --
-- Bulk put operations --
-- Other stuff --
-- Other char stuff --
-- Other byte stuff: Access to binary data --
First, a variety of minor information about the target database.
Functions describing which features are supported.
The following group of methods exposes various limitations
based on the target database with the current driver.
Unless otherwise specified, a result of zero means there is no
limit, or the limit is not known.
------------------------- JDBC 4.0 -----------------------------------
--------------------------JDBC 4.1 -----------------------------
--------------------------JDBC 4.2 -----------------------------
pre-1.5 style setCertificateEntry did not allow password
pre-1.5 style setKeyEntry required password
pre-1.5 style setKeyEntry required password
Empty finalizer (for improved performance; no need to call
super.finalize() in this case)
private objects to cache the locale and resource bundle
memorize the most-recent locale
-- This file was mechanically generated: Do not edit! --
For duplicates and slices
If length == 0, leave it null
Type-specific CORBA::Object operations
-- This file was mechanically generated: Do not edit! --
Introduce more information about WHY we are re-trying a request
so we can properly handle the two cases:
- BEFORE_RESPONSE means that the retry is caused by
something that happened BEFORE the message was sent: either
an exception from the SocketFactory, or one from the
Client side send_request interceptor point.
- AFTER_RESPONSE means that the retry is a result either of the
request sent to the server (from the response), or from the
Client side receive_xxx interceptor point.
The default implementation, to preserve backwards compatibility in the
test cases, calls the old resolver API.
This method used to be abstract, so any calls to "super" are bogus.
To preserve backward compatibility with existing resolvers that might override the old method,
call the old deprecated API.
handle platform dependent strings
str =~ /^\W:\/([^/])/ # to speak perl ;-))
Bulk Modification Operations
Comparison and hashing
Positional Access Operations
calculate new URI
we're running M$ Windows, so this works fine
we're running some UNIX, so we have to prepend a slash
if the URI contains a fragment, ignore it
Note: this is just a default object that gets returned in the
absence of any more specific information from a surfaceManager.
Subclasses of Image should either override this method or
make sure that they always have a non-null SurfaceManager
to return an ImageCapabilities object that is appropriate
for their given subclass type.
The following field strives to maintain the following:
If coalesce is true, only allow one Runnable to be queued on the
EventQueue and be pending (ie in the process of notifying the
ActionListener). If we didn't do this it would allow for a
situation where the app is taking too long to process the
actionPerformed, and thus we'ld end up queing a bunch of Runnables
and the app would never return: not good. This of course implies
you can get dropped events, but such is life.
notify is used to indicate if the ActionListener can be notified, when
the Runnable is processed if this is true it will notify the listeners.
notify is set to true when the Timer fires and the Runnable is queued.
It will be set to false after notifying the listeners (if coalesce is
true) or if the developer invokes stop.
This field is maintained by TimerQueue.
eventQueued can also be reset by the TimerQueue, but will only ever
happen in applet case when TimerQueues thread is destroyed.
access to this field is synchronized on getLock() lock.
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
We must do this as otherwise if the Timer once notified
in !coalese mode notify will be stuck to true and never
Prevent recursion. See BugId 4484411
Check that the type is valid
Result object should never be null!
Empty XPath result object
If specified result was ANY_TYPE, determine XObject type
If the context node supports DOM Events and the type is one of the iterator
types register this result as an event listener
else can we handle iterator types if contextNode doesn't support EventTarget??
If this is an iterator type get the iterator
probably not a node type
If user requested ordered nodeset and result is unordered
need to sort...TODO
if ((m_resultType == ORDERED_NODE_ITERATOR_TYPE) &&
If it's a snapshot type, get the nodelist
probably not a node type
Type check above should prevent this exception from occurring.
Type check above should prevent this exception from occurring.
Type check above should prevent this exception from occurring.
This method applies only to types ANY_UNORDERED_NODE_TYPE and FIRST_ORDERED_NODE_TYPE."
Wrap "namespace node" in an XPathNamespace
Document mutated since result was returned. Iterator is invalid.
Wrap "namespace node" in an XPathNamespace
Wrap "namespace node" in an XPathNamespace
invalidate the iterator
deregister as a listener to reduce computational load
XPath 2.0 types
case XObject.CLASS_YMDURATION: return STRING_TYPE;  treat all date types as strings?
throw exception ?
throw exception ?
we don't allow instantiation
-- This file was mechanically generated: Do not edit! --
these declarations are here as documentation
Note: should we really call .toString() below, since
sometimes the message is not properly set?
Try to find the locator closest to the cause.
Find the current locator, if one present
A SAXSourceLocator is a Xalan helper class
that implements both a SourceLocator and a SAX Locator
@todo check that the new locator actually has
as much or more information as the
current one already does
Then walk back down the chain of exceptions
Formatting note: mimic javac-like errors:
Bail immediately if we get SystemId-Unknown
@todo future improvement: attempt to get resource
from a publicId if possible
@todo attempt to get DOM backpointer or other ids
Get a URL from the sourceUrl
Try to get a URL from it as-is
The url is already absolute, but we could not get
the system to form it, so bail
The url is relative, so attempt to get absolute
If this fails, allow the exception to propagate
Open the URL and read to our specified line
Not the most efficient way, but it works
(Feel free to patch to seek to the appropriate line)
Allow exceptions to propagate from here, but ensure
streams are closed!
Return whatever we found
-- This file was mechanically generated: Do not edit! --
Cached unsafe-access object
Cached array base offset
Cached unaligned-access capability
Base address, used in all indexing calculations
NOTE: moved up to Buffer.java for speed in JNI GetDirectBufferAddress
An object attached to this buffer. If this buffer is a view of another
buffer then we use this field to keep a reference to that buffer to
ensure that its memory isn't freed before we are done with it.
For duplicates and slices
--- Methods to support CharSequence ---
the CRL type
Some standard tags
Count how many bytes have their 8th bit to 0
-> this gives the number of components in the oid
The 8th bit of the first byte should always be set to 0
The first sub Id cannot be greater than 2
This is the byte array containing the encoding.
This is the current location. It is the next byte
to be decoded. It's an index in bytes[].
This is the stack where end of sequences are kept.
A value is computed and pushed in it each time openSequence()
A value is pulled and checked each time closeSequence() is called.
Repaint the whole thing as the Borders that are used have
different colors for active vs inactive
This is a croak, if state becomes bound, this can
Not contained in a Frame
As state isn't bound, we need a convenience place to check
if it has changed. Changing the state typically changes the
assumes all buttons have the same dimensions
these dimensions include the borders
Frame.state isn't currently bound.
%REVIEW% Is there a better way?
From the draft: "Two expanded names are equal if they
have the same local part, and either both have no URI or
both have the same URI."
"A node test * is true for any node of the principal node type.
For example, child::* will select all element children of the
context node, and attribute::* will select all attributes of
the context node."
"A node test can have the form NCName:*. In this case, the prefix
is expanded in the same way as with a QName using the context
namespace declarations. The node test will be true for any node
of the principal type whose expanded name has the URI to which
the prefix expands, regardless of the local part of the name."
From the draft: "Two expanded names are equal if they
have the same local part, and either both have no URI or
both have the same URI."
"A node test * is true for any node of the principal node type.
For example, child::* will select all element children of the
context node, and attribute::* will select all attributes of
the context node."
"A node test can have the form NCName:*. In this case, the prefix
is expanded in the same way as with a QName using the context
namespace declarations. The node test will be true for any node
of the principal type whose expanded name has the URI to which
the prefix expands, regardless of the local part of the name."
This is only used for its system menu, but we need a reference to it so
we can remove its listeners.
padding between icon and label
An underhanded way of creating a system popup menu.
Forward mouse events to titlebar for moves.
draw text -- clipping to truncate text like CDE/Motif
Forward mouse events to titlebar for moves.
if we drag or move we should deengage the popup
assume that class of this instance is
annotated with @XmlRootElement.
BAD_MSGKEY needs translation
BAD_MSGFORMAT needs translation
ER_STRAY_ATTRIBUTE needs translation
ER_ILLEGAL_CHARACTER needs translation
DOM Level 3: namespace URI is never empty string.
there is no prefix
when local name is known
Support for DOM Level 3 renameNode method.
Note: This only deals with part of the pb. It is expected to be
called after the Attr has been detached for one thing.
CoreDocumentImpl does all the work.
DOM2: Namespace methods
REVIST: This code could/should be done at a lower-level, such that
the namespaceURI is set properly upon creation. However, there still
seems to be some DOM spec interpretation grey-area.
update node name with new qualifiedName
Cheaper than instanceof Enum followed by getDeclaringClass
Lower bound on index of next element to return
Index of last returned element, or -1 if none
Comparison and hashing
Key types match, compare each value
Write out the key type and any hidden stuff
Write out size (number of Mappings)
Write out keys and values (alternating)
Read in the key type and any hidden stuff
Read in size (number of Mappings)
Read the keys and values, and put the mappings in the HashMap
always create a platform logger with the resource bundle name
Declare serialVersionUID to be compatible with JDK1.1
This exception will be thrown if the implementation of
Collections.unmodifiableMap.entrySet() is changed such that it
no longer calls entrySet() on the backing Map.  (Provider's
entrySet implementation depends on this "implementation detail",
which is unlikely to change.
let javadoc show doc from superclass
let javadoc show doc from superclass
let javadoc show doc from superclass
let javadoc show doc from superclass
legacy properties changed since last call to any services method?
serviceMap changed since last call to getServices()
used for services added via putService(), initialized on demand
used for services added via legacy methods, init on demand
Unmodifiable set of all services. Initialized on demand.
register the id attributes for this provider
this is to ensure that equals() and hashCode() do not incorrectly
report to different provider objects as the same
note: name and info may be null
used as key in the serviceMap and legacyMap HashMaps
aliasKey ~ MessageDigest.SHA
kill additional spaces
avoid allocating a new key object if possible
ServiceKey from previous getService() call
by re-using it if possible we avoid allocating a new object
and the toUpperCase() call.
re-use will occur e.g. as the framework traverses the provider
list and queries each provider with the same values until it finds
a matching service
remove existing service
use super() to avoid permission check and other processing
use super() to avoid permission check and other processing
Wrapped String that behaves in a case insensitive way for equals/hashCode
describe relevant properties of a type of engine
built in knowledge of the engine types shipped as part of the JDK
also index by canonical name to avoid toLowerCase() for some lookups
Smart Card I/O
get the "standard" (mixed-case) engine name for arbitary case engine name
if there is no known engine by that name, return s
try original case first, usually correct
Reference to the cached implementation Class object
flag indicating whether this service has its attributes for
supportedKeyFormats or supportedKeyClasses set
if null, the values have not been initialized
if TRUE, at least one of supportedFormats/Classes is non null
supported encoding formats
names of the supported key (super) classes
whether this service has been registered with the Provider
this constructor and these methods are used for parsing
the legacy string properties.
unknown engine type, use generic code
this is the code path future for non-core
return the implementation Class object for this service
create instance with public no-arg constructor if it exists
find first public constructor that can take the
argument as parameter
unknown engine type, return true by default
allow null for keys without attributes for compatibility
get the key class object of the specified name
RAMESH: PENDING=> Add proper implementation for the below DOM L3 additions
we don't have any alternate node, either this node does the job
or we don't have anything that does
in theory nodeName can't be null but better be careful
who knows what other implementations may be doing?...
REVISIT: is it possible that prefix is empty string?
looking for default namespace
non default namespace
at this point we are dealing with DOM Level 2 nodes only
non default namespace
type is unknown
REVISIT: When Namespaces 1.1 comes out this may not be true
Prefix can't be bound to null namespace
type is unknown
we do not use any wrapper so the answer is obvious
overriden in some subclasses
The labels preferred size may be derived from the font
of the slider, so we must update the UI of the slider first, then
that of labels.  This way when setSize is called the right
font is used.
Check that there is a label with such image
Save the labels that were added by the developer
Add the saved labels
TIGER - 4422535
TIGER - 4422362
Mutually exclusive casting of DOM interface to known implementations
always attempt load for better behavior after deserialization
additional query for group provider when null allows for possibility
that the provider was updated after the ZoneId was created
CLASSNAME X JAVACLASS
should not happen as this class is cloneable
Check if orb.properties exists
Write properties to orb.properties
should never be called
should never be called
should never be called
should never be called
should never be called
should never be called
should never be called
should never be called
should never be called
should never be called
should never be called
should never be called
should never be called
private objects to cache the locale and resource bundle
memorize the most-recent locale
read and discard the repository ID
write the repository ID
end class RadioButtonIcon
End class CheckBoxMenuItemIcon
End class RadioButtonMenuItemIcon
End class MenuItemCheckIcon
End class MenuItemArrowIcon
End class MenuArrowIcon
Treat putValue("enabled") the same way as a call to setEnabled.
If we don't do this it means the two may get out of sync, and a
bogus property change notification would be sent.
To avoid dependencies between putValue & setEnabled this
directly changes enabled. If we instead called setEnabled
to change enabled, it would be possible for stack
overflow in the case where a developer implemented setEnabled
in terms of putValue.
Remove the entry for key if newValue is null
else put in the newValue for key.
Store the default fields
And the keys
Type-specific CORBA::Object operations
This throws an IllegalArgument exception if the delegate
is not assignable from method.getDeclaring class.
Propagate the underlying exception as the
result of the invocation
else value not from 1 to 4, so drop through
calls getFrom() to check if supported
leniently check from 1 to 92 TODO: check
only allow exact range
allow 1-92 rolling into next quarter
calls getFrom() to check if supported
strictly check from 1 to 4
calls getFrom() to check if supported
only allow exact range
allow 1-53 rolling into next year
4th is guaranteed to be in week one
53 weeks if standard year starts on Thursday, or Wed in a leap year
adjust to mid-week Thursday (which is 3 indexed from zero)
no overflow (256 is multiple of 4)
this shouldn't happen, since we are Cloneable
1.0 LocateReply body does not contain SystemException
raises exception on error
The code below reads the reply body if status is OBJECT_FORWARD
Note, this writes only the header information. SystemException or
IOR may be written afterwards into the reply mesg body.
resolve entity using DOM entity resolver
For entity resolution the type of the resource would be  XML TYPE
DOM L3 LS spec mention only the XML 1.0 recommendation right now
unable to resolve entity
Parse the "test" expression
Make sure required attribute(s) have been set
Ignore xsl:if when test is false (function-available() and
Type-check the "test" expression
Type check the element contents
remember end of condition
[block | final]Default
represents whether this is a chameleon schema (i.e., whether its TNS is natural or comes from without)
the root of the schema Document tree itself
all namespaces that this document can refer to
attribute checker to which we'll return the attributes
once we've been told that we're done with them
array of objects on the schema's root element.  This is null
once returnSchemaAttrs has been called.
list of annotations contained in the schema document. This is null
once removeAnnotations has been called.
note that the caller must ensure to call returnSchemaAttrs()
to avoid memory leaks!
schemaAttrs == null means it's not an <xsd:schema> element
throw an exception, but we don't know the document systemId,
so we leave that to the caller.
set namespace support
pass null as the schema document, so that the namespace
context is not popped.
don't return the attribute array yet!
Check if attribute is an ns decl -- requires ns support
Declare prefix if not set -- moving upwards
backup the current ns support, and use the one passed-in.
if no ns support is passed-in, use the one for <schema> element
some Object methods
store whether we have reported an error about that this document
can't access components from the given namespace
check whether we need to report an error against the given uri.
otherwise we reported the error, and remember this fact.
return the attributes on the schema element itself:
deallocate the storage set aside for the schema element's
adds an annotation to the list of annotations
returns the list of annotations conatined in the
schema document or null if the document contained no annotations.
removes reference to annotation list
happens on rollover, and when pressed
happens when mouse was depressed while over thumb
ComponentUI Interface Implementation methods
handle scaling for sizeVarients for special case components. The
key "JComponent.sizeVariant" scales for large/small/mini
components are based on Apples LAF
Get the insets for the track.
Get the insets for the track.
Calculate the height of all the subcomponents so we can center
Check if any of the labels will paint out of bounds.
Calculate the track rectangle.  It is necessary for
xPositionForValue to return correct values.
Iterate through the keys in the dictionary and find the
first and last labels indices that fall within the
Calculate the pad necessary for the labels at the first
and last visible indices.
Calculate the painting rectangles for each of the different
Calculate the width of all the subcomponents so we can center
Get the max width of the min or max value of the slider.
Layout the components.
Value rect is tied to the thumb location.  We need to repaint when
the thumb repaints.
For horizontal sliders, make sure value is not painted
outside slider bounds.
/ Track Listener Class
End of file.
eliminate loops in case of the boot
ClassLoader returning itself as a parent
already failed to re-start by another thread
restart process has been called by another thread
we need to wait
be asked to give up
restarted is failed by another thread
We know there is a problem.
We will check the state at the following steps
XXX stop checking?
Log wrapper class for Sun private system exceptions in group UTIL
Generated by MC.java version 1.0, DO NOT EDIT BY HAND!
Generated from input file c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/corba/src/share/classes/com/sun/corba/se/spi/logging/data/Util.mc on Fri Jul 21 21:58:45 PDT 2017
Private method to configure a SocketHandler from LogManager
properties and/or default values as specified in the class
doing a setEncoding with null should always work.
We are going to use the logging defaults.
Check the arguments are valid.
Try to open a new socket.
Private Data members
REVISIT: is this implemenation correct?
concatenate text of logically adjacent text nodes to the left of this node in the tree
concatenate text of logically adjacent text nodes to the right of this node in the tree
boolean to indicate whether node is a child of an entity reference
if the parent node is an entity reference node, must
check nodes to the right of the parent entity reference node for logically adjacent
boolean to indicate whether node is a child of an entity reference
if the parent node is an entity reference node, must
check nodes to the left of the parent entity reference node for logically adjacent
if the content is null
remove current node
check if node in the tree
make sure we can make the replacement
make sure we can make the replacement
replace the text node
check if node in the tree
check logically-adjacent text nodes
If the logically-adjacent next node can be removed
remove it. A logically adjacent node can be removed if
it is a Text or CDATASection node or an EntityReference with
Text and CDATA only children.
check logically-adjacent text nodes
If the logically-adjacent next node can be removed
remove it. A logically adjacent node can be removed if
it is a Text or CDATASection node or an EntityReference with
Text and CDATA only children.
If the previous sibling was entityreference
check if its content is replaceable
if the entity reference has no children
The replacement text of the entity reference should
be either only text,cadatsections or replaceable entity
reference nodes or the last child should be neither of these
If the EntityReference child contains
only text, or non-text or ends with a
If the last child was replaceable and others are not
Text or CDataSection or replaceable EntityRef nodes
If the previous sibling was text or cdatasection move to next
If the previous sibling was anything but text or
cdatasection or an entity reference, stop search and
If the previous sibling was entityreference
check if its content is replaceable
if the entity reference has no children
The replacement text of the entity reference should
be either only text,cadatsections or replaceable entity
reference nodes or the last child should be neither of these
If the EntityReference child contains
only text, or non-text or ends with a
If the first child was replaceable text and next
children are not, then return false
If the previous sibling was text or cdatasection move to next
If the next sibling was anything but text or
cdatasection or an entity reference, stop search and
split text into two separate nodes
insert new text node
-- This file was mechanically generated: Do not edit! --
These fields are declared here rather than in Heap-X-Buffer in order to
reduce the number of virtual method invocations needed to access these
values, which is especially costly when coding small buffers.
Non-null only for heap buffers
Valid only for heap buffers
Creates a new buffer with the given mark, position, limit, capacity,
backing array, and array offset
Creates a new buffer with the given mark, position, limit, and capacity
-- Singleton get/put methods --
-- Bulk get operations --
-- Bulk put operations --
-- Other stuff --
-- Other char stuff --
-- Other byte stuff: Access to binary data --
End of file.
local or not: equals, toString, hashCode
ignore the finalizer invocation via proxy
found method in one of our interfaces
did not find in any interface
SAXParserHandler.java - An entity-resolving DefaultHandler
We've already got enough data cached
pos >= length but length isn't getting any bigger, so return it
Copy a buffer's worth of data from the source to the cache
BUFFER_LENGTH will always fit into an int so this is safe
Fix 4430357 - if off + len < 0, overflow occurred
len will always fit into an int so this is safe
this will close/delete the cache file
Empty finalizer: for performance reasons we instead use the
Disposer mechanism for ensuring that the underlying
RandomAccessFile is closed/deleted prior to garbage collection
Note: Explicit removal of the stream from the StreamCloser
queue is not mandatory in this case, as it will be removed
automatically by GC shortly after this method is called.
using equals because can not use UIResource for Boolean
construct a NMTOKEN datatype validator
the in-memory representation of cookies
the cookies are indexed by its domain and associated uri (if present)
CAUTION: when a cookie removed from main data structure (i.e. cookieJar),
it won't be cleared in domainIndex & uriIndex. Double-check the
presence of cookie when retrieve one form index store.
use ReentrantLock instead of syncronized for scalability
pre-condition : argument can't be null
remove the ole cookie if there has had one
add new cookie if it has a non-zero max-age
and add it to domain index
add it to uri index, too
argument can't be null
check domainIndex first
check uriIndex then
no cookies list or an empty list associated with
this uri entry, delete it
argument can't be null
if there's no embedded dot in domain and domain is not .local
if the host name contains no dot and the domain name is .local
if the host name and the domain name are just string-compare euqal
need to check H & D component
if domain is actually .host
Use a separate list to handle cookies that need to be removed so
that there is no conflict with iterators.
the cookie still in main cookie store
don't add twice and make sure it's the proper
the cookie has beed removed from main store,
so also remove it from domain indexed store
Clear up the cookies that need to be removed
a cookie in index should be returned
check the list of cookies associated with this domain
the cookie still in main cookie store
don't add twice
the cookie has beed removed from main store,
so also remove it from domain indexed store
end of indexedCookies != null
end of comparator.compareTo(index) == 0
end of cookieIndex iteration
add 'cookie' indexed by 'index' into 'indexStore'
there may already have the same cookie, so remove it first
for cookie purpose, the effective uri should only be http:host
the path will be taken into account when path-match algorithm applied
The accessoryPanel is a container to place the JFileChooser accessory component
we return all selected file names
plus the file name typed into the text field, if not already there
construct the resulting string
Ancestor was added, set initial focus
Strip trailing ".."
That's ok, we'll use f as is
ComponentUI Interface Implementation methods
Top row of buttons
CENTER: left, right, accessory
SPLIT PANEL: left, right
left panel - Filter & directoryList
Add the Directory List
Create a label that looks like button (should be a table header)
create files list
add the fileName field
Add the filter combo box
PENDING - this is inefficient - should sent out
incremental adjustment values instead of saying that the
whole list has changed.
PENDING - fire the correct interval changed - currently sending
out that everything has changed
PENDING - this is inefficient - should sent out
incremental adjustment values instead of saying that the
whole list has changed.
PENDING - fire the interval changed
DataModel for DirectoryComboxbox
Add the current directory to the model, and make it the
Get the canonical (full) path. This has the side
benefit of removing extraneous chars from the path,
for example /foo/bar/ becomes /foo/bar
Maybe drive is not ready. Can't abort here.
create File instances of each directory leading up to the top
Strip trailing ".."
Ok, use f as is
Renderer for Filter ComboBox
As SynthComboBoxRenderer's are asked for a size BEFORE they
are parented getName is overriden to force the name to be
ComboBox.renderer if it isn't set. If we didn't do this the
wrong style could be used for size calculations.
DataModel for Filter Combobox
Ensure that the current filter is in the list.
NOTE: we shouldnt' have to do this, since JFileChooser adds
the filter to the choosable filters list when the filter
is set. Lets be paranoid just in case someone overrides
setFileFilter in JFileChooser.
This shouldn't happen. Try to recover gracefully.
DynFixed is constructed but not a subclass of DynAnyConstructedImpl
Extracts a member value according to the given TypeCode from the given complex Any
(at the Anys current internal stream position, consuming the anys stream on the way)
and returns it wrapped into a new Any
Extracts a member value according to the given TypeCode from the given complex Any
(at the Anys current internal stream position, consuming the anys stream on the way)
and returns it wrapped into a new Any
Creates a default Any of the given type.
The spec for DynAny differs from Any on initialization via type code:
- false for boolean
- zero for numeric types
- zero for types octet, char, and wchar
- the empty string for string and wstring
- nil for object references
- a type code with a TCKind value of tk_null for type codes
- for Any values, an Any containing a type code with a TCKind value of tk_null
type and no value
false for boolean
zero for numeric types
zero for numeric types
zero for numeric types
zero for numeric types
zero for numeric types
zero for numeric types
zero for numeric types
zero for numeric types
zero for types octet, char, and wchar
zero for types octet, char, and wchar
zero for types octet, char, and wchar
the empty string for string and wstring
Make sure that type code for bounded strings gets respected
Doesn't erase the type of bounded string
the empty string for string and wstring
Make sure that type code for bounded strings gets respected
Doesn't erase the type of bounded string
nil for object references
a type code with a TCKind value of tk_null for type codes
We can reuse the type code that's already in the any.
for Any values, an Any containing a type code with a TCKind value
of tk_null type and no value.
This is exactly what the default AnyImpl constructor provides.
_REVISIT_ Note that this inner Any is considered uninitialized.
There are no default value for complex types since there is no
concept of a hierarchy of Anys. Only DynAnys can be arrange in
a hierarchy to mirror the TypeCode hierarchy.
on how this DynAny hierarchy is created from TypeCodes.
Any is already initialized to null
Unspecified for Java
if copy flag wasn't true we would be using our DynAny with
a foreign Any in it.
Returning simply the value of Any.isInitialized() is not enough.
The DynAny spec says that Anys containing null strings do not contain
a "legal value" (see ptc 99-10-07, 9.2.3.3)
This is a convenient method to reset the current component to where it was
before we changed it. See DynAnyConstructedImpl.equal for use.
Flag to ensure that infinite loops do not occur with ActionEvents.
Flag to ensure the we don't get multiple ActionEvents on item selection.
set the current selected item.
For non editable combo boxes, an invalid selection
will be rejected.
Must toggle the state of this flag since this method
call may result in ListDataEvents being fired.
in case a users implementation of ComboBoxModel
doesn't fire a ListDataEvent when the selection
Don't add if it is already a listener
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
if (changeEvent == null)
Set flag to ensure that an infinite loop is not created
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
set the new selected item.
combo box popup list
set the combo box editor's accessible name and description
Get the popup list
Listen for changes to the popup menu selection.
Listen for popup menu show/hide events
set the combo box editor's accessible name
may be null
save the initial selection
Get the selected popup list item.
Fire a FOCUSED lost PropertyChangeEvent for the
previously selected list item.
Fire a FOCUSED gained PropertyChangeEvent for the
currently selected list item.
Fire the ACCESSIBLE_ACTIVE_DESCENDANT_PROPERTY event
for the combo box.
Save the previous selection.
Always delegate to the UI if it exists
Always delegate to the UI if it exists
TIGER - 4489748
Get the popup
get the popup list
return the i-th selection in the popup list
TIGER - 4856195
do nothing since multiple selection is not supported
return a;  the editor
return getAccessibleChild(0);  the list
pure java orb, caching the servant IOR per ORB
Vector holding deferred Requests
XXX Should we move invocation tracking to the first level server dispatcher?
thread local variable to store a boolean to detect deadlock in
This map is caching TypeCodes created for a certain class (key)
and is used in Util.writeAny()
Cache to hold ValueFactories (Helper classes) keyed on repository ids
thread local variable to store the current ORB version.
default ORB version is the version of ORB with correct Rep-id
Needed here to implement connect/disconnect
Needed here for set_delegate
The interceptor handler, which provides portable interceptor services for
subcontracts and object adapters.
All access to resolver, localResolver, and urlOperation must be protected using
resolverLock.  Do not hold the ORBImpl lock while accessing
resolver, or deadlocks may occur.
Note that we now have separate locks for each resolver type.  This is due
to bug 6980681 and 6238477, which was caused by a deadlock while resolving a
corbaname: URL that contained a reference to the same ORB as the
ORB making the call to string_to_object.  This caused a deadlock between the
client thread holding the single lock for access to the urlOperation,
and the server thread handling the client is_a request waiting on the
same lock to access the localResolver.
Used for resolver_initial_references and list_initial_services
Used for register_initial_references
Converts strings to object references for resolvers and string_to_object
resolverLock must be used for all access to either resolver or
localResolver, since it is possible for the resolver to indirectly
refer to the localResolver.  Also used to protect access to
Methods that are synchronized MUST stay synchronized.
Methods that are NOT synchronized must stay that way to avoid deadlock.
checkShutDownState - lock on different object - and normalize usage.
starting/FinishDispatch and Shutdown
All initialization is done through set_parameters().
preInit initializes all non-pluggable ORB data that is independent
of the property parsing.
Before ORBConfiguration we need to set a PINoOpHandlerImpl,
because PersisentServer Initialization inside configurator will
invoke orb.resolve_initial_references( ) which will result in a
check on piHandler to invoke Interceptors. We do not want any
Interceptors to be invoked before the complete ORB initialization.
piHandler will be replaced by a real PIHandler implementation at the
end of this method.
This is the unique id of this server (JVM). Multiple incarnations
of this server will get different ids.
Compute transientServerId = milliseconds since Jan 1, 1970
Note: transientServerId will wrap in about 2^32 / 86400000 = 49.7 days.
If two ORBS are started at the same time then there is a possibility
of having the same transientServerId. This may result in collision
and may be a problem in ior.isLocal() check to see if the object
belongs to the current ORB. This problem is taken care of by checking
to see if the IOR port matches ORB server port in legacyIsLocalServerPort()
XXX need to move server ID to a string for CORBA 3.0.  At that point,
make this more unique (possibly use java.rmi.server.UID).
set default to version of the ORB with correct Rep-ids
If there is a public boolean data member in this class
named token + "DebugFlag", set it to true.
ignore it XXX log this as info
Class that defines a parser that gets the name of the
The default here is the ORBConfiguratorImpl that we define,
but this can be replaced.
First, create the standard ORB config data.
This must be initialized before the ORBConfigurator
Set the debug flags early so they can be used by other
parts of the initialization.
REVISIT: this should go away after more transport init cleanup
and going to ORT based ORBD.
Create a parser to get the configured ORBConfigurator.
Finally, run the configurator.  Note that the default implementation allows
other configurators with their own parsers to run,
using the same DataCollector.
Last of all, create the PIHandler and run the ORB initializers.
Initialize the thread manager pool and byte buffer pool
so they may be initialized & accessed without synchronization
Invoke the send_oneway on each new Request
add the new Requests to pending dynamic Requests
Invoke the send_deferred on each new Request
poll on each pending request
check if there already is a response
get the response for this successfully polled Request
wait for a response
reinitialize the response flag
Handle the null objref case
Throw MARSHAL instead if this is a LOCAL_OBJECT_NOT_ALLOWED error.
Not a local object problem: just rethrow the exception.
Do not wrap and log this, since it was already logged at its
point of origin.
pure java orb support, moved this method from FVDCodeBaseImpl.
Note that we connect this if we have not already done so.
i.e. We are already connected to it
backward compatability 4365188
TypeCodeFactory interface methods.
Keeping track of type codes by repository id.
Keeping a cache of TypeCodes associated with the class
they got created from in Util.writeAny().
Store only one TypeCode per class.
Make all remote object references available for INS.
This is to avoid deadlock: don't allow a thread that is
processing a request to call shutdown( true ), because
the shutdown would block waiting for the request to complete,
while the request would block waiting for shutdown to complete.
Avoid more than one thread performing shutdown at a time.
At this point, the ORB status is certainly STATUS_SHUTTING_DOWN.
If wait is true, another thread already called shutdown( true ),
and so we wait for completion
NOP: just loop and wait until state is changed
perform the actual shutdown
Cause all ObjectAdapaterFactories to clean up all of their internal state, which
may include activated objects that have associated state and callbacks that must
complete in order to shutdown.  This will cause new request to be rejected.
Note that the caller must hold the ORBImpl lock.
ORBServerId is specified then use that value
XXX All of the isLocalXXX checking needs to be revisited.
First of all, all three of these methods are called from
only one place in impl.ior.IORImpl.  Second, we have problems
both with multi-homed hosts and with multi-profile IORs.
A possible strategy: like the LocalClientRequestDispatcher, we need
to determine this more abstractly at the ContactInfo level.
This level should probably just get the CorbaContactInfoList from
the IOR, then iterator over ContactInfo.  If any ContactInfo is
local, the IOR is local, and we can pick one to create the
LocalClientRequestDispatcher as well.  Bottom line: this code needs to move.
XXX What about multi-homed host?
XXX isTransient info should be stored in subcontract registry
This is a new call - not a retry.
Reset retry so recursive calls will get a new info object.
6763340: don't pop if this is a retry!
/ Helper class for a Synchronization Variable
set Flag to true
reset Flag to true
End of file.
Class name of type
Missing Content Handler property, load default using OutputPropertiesFactory
this is one of the supplied serializers
user defined serializer does not implement
ContentHandler, ... very bad
If we make it to here ser is not null.
Case where hit backspace and only characters before
offset are fixed.
Don't go beyond last editable character.
Pending: should not assume forward!
bypass the filter
bypass the filter
forward the call to the UI directly
bypass the filter
bypass the filter
bypass the filter
ZIP64 end header size
ZIP64 end loc header size
EXT header size
Extra field Zip64 header ID
size of zip64 end of central dir
version made by
version needed to extract
number of this disk
disk number of start
total number of entries on this disk
total number of entries
central directory size in bytes
offset of first CEN header
zip64 extensible data sector
disk number start
offset of zip64 end
total number of disks
uncompressed file crc-32 value
compressed size, 8-byte
uncompressed size, 8-byte
If this bit is set the filename and
comment fields for this file must be
encoded using UTF-8.
Info-ZIP Extended Timestamp
"Invalid context passed to evaluate "
Number of arguments on stack (number of stack slots), called "count" in vmspec2
Skip 0 byte
nargs is given in byte-code
nargs includes this reference
GETTERS AND SETTERS
but scanContent doesn't do entity expansions...
is this *really* necessary???  - NG
remember where we are in case we get an endEntity before we
could flush the buffer out - this happens when we're parsing an
entity which ends with a ]
We work on a single character basis to handle cases such as:
']]]>' which we might otherwise miss.
WFC & VC: Entity Declared
note that none of these characters should ever get through
XML11EntityScanner.  Not sure why
this check was originally necessary.  - NG
we need to override these methods in both places.
this needs to be refactored!!!  - NG
skip leading whitespace
REVISIT:  none of these except \n and 0x20 should make it past the entity scanner
take the first whitespace as a space and skip the others
if we finished on a space let's trim it
returns true if the given character is not
valid with respect to the version of
XML understood by this scanner.
returns true if the given character is not
valid or may not be used outside a character reference
with respect to the version of XML understood by this scanner.
returns true if the given character is
a valid nameChar with respect to the version of
XML understood by this scanner.
returns true if the given character is
a valid nameStartChar with respect to the version of
XML understood by this scanner.
returns true if the given character is
a valid NCName character with respect to the version of
XML understood by this scanner.
returns true if the given character is
a valid high surrogate for a nameStartChar
with respect to the version of XML understood
by this scanner.
returns the error message key for unsupported
versions of XML with respect to the version of
XML understood by this scanner.
Type-specific CORBA::Object operations
support for deferred invocations.
protected instead of private since it needs to be set by the
thread object doing the asynchronous invocation.
REVISIT - used to be protected.  Now public so it can be
accessed from xgiop.
initialize the orb
initialize target, context and operation name
initialize argument list if not passed in
set result container.
initialize exception list if not passed in
initialize context list if not passed in
this method has to be synchronized even though it seems
"readonly" since the thread object doing the asynchronous
invocation can potentially update this variable in parallel.
updates are currently simply synchronized againt the request
release the lock. wait to be notified by the thread that is
doing the asynchronous invocation.
private helper methods
Initiate Client Portable Interceptors.  Inform the PIHandler that
this is a DII request so that it knows to ignore the second
inevitable call to initiateClientPIRequest in createRequest.
Also, save the RequestImpl object for later use.
REVISIT - minor code.
This is already handled in subcontract.
REVISIT - uncomment.
NOTE: The exception should not be thrown.
However, JDK 1.4 and earlier threw the exception,
so we keep the behavior to be compatible.
REVISIT -  make protected after development - so xgiop can get it.
First unmarshal the return value if it is not void
Now unmarshal the out/inout args
Cannot happen since we only iterate till _arguments.count()
the referred attribute decl
use information: SchemaSymbols.USE_OPTIONAL, REQUIRED, PROHIBITED
value constraint type: default, fixed or !specified
value constraint value
REVISIT: SCAPI: what's the proper representation
Static methods of the Pack200 class.
The first time, we must decide which class to use.
We have a class.  Now instantiate it.
Magic used in our object keys for JDK 1.2, 1.3, RMI-IIOP OP,
Magic used only in JDK 1.3.1.  No format changes in object keys.
New magic used in our object keys for JDK 1.4, J2EE 1.3 and later.
Format changes: all object keys have version string; POA key format
Beginning in JDK 1.3.1_01, we introduced changes which required
the ability to distinguish between JDK 1.3.1 FCS and the patch
versions.  See OldJIDLObjectKeyTemplate.
XXX The handlers still need to be made pluggable.
I think this can be done as follows:
1. Move the Handler interface into the SPI as ObjectKeyHandler.
2. Add two methods to ObjectAdapterFactory:
3. Move the implementation of the fullKey handler and the
oktempOnly handler into TOAFactory and POAFactory.
4. Move the ObjectKey impl classes into the impl/oa packages.
5. Create an internal interface
and modify create(InputStream,Handler,OctetSeqHolder)
to take a HandlerFinder instead of a Handler.
6. Modify create( byte[] ) and createTemplate( InputStream )
to create an instance of HandlerFinder: something like:
ObjectKeyHandler get( int scid )
and similarly for getHandlerForObjectKeyTemplate.
XXX log this error
ignore this: error handled below because oktemp == null
If we did not successfully construct a oktemp, reset the
stream so that WireObjectKeyTemplate can correctly construct the
XXX log this error
REVISIT: Rewrite rmic.HelloTest and rmic.LocalStubTest
(which directly call servant_preinvoke)
then revert to exception again.
End of file.
SAX default handler base class.
No warranty; no copyright -- use this as you will.
$Id: HandlerBase.java,v 1.2 2005/06/10 03:50:47 jeffsuttor Exp $
Default implementation of the EntityResolver interface.
Default implementation of DTDHandler interface.
Default implementation of DocumentHandler interface.
Default implementation of the ErrorHandler interface.
end of HandlerBase.java
GETTERS AND SETTERS
private objects to cache the locale and resource bundle
memorize the most-recent locale
base of tmp array slice
length of tmp array slice
Number of pending runs on stack
Allocate temp storage (which may be increased later if necessary)
Arrays of size 0 and 1 are always sorted
If array is small, do a "mini-TimSort" with no merges
Identify next run
If run is short, extend to min(minRun, nRemaining)
Push run onto pending-run stack, and maybe merge
Advance to find next run
Merge all remaining runs to complete sort
Set left (and right) to the index where a[start] (pivot) belongs
The number of elements to move
Switch is just an optimization for arraycopy in default case
Find end of run, and reverse range if descending
Becomes 1 if any 1 bits are shifted off
Invariant is established
Merge remaining runs, using tmp array with min(len1, len2) elements
Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
Make offsets relative to base
key <= a[base + hint]
Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
Make offsets relative to base
a[base + m] < key
key <= a[base + m]
so a[base + ofs - 1] < key <= a[base + ofs]
Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
Make offsets relative to b
a[b + hint] <= key
Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
Make offsets relative to b
key < a[b + m]
a[b + m] <= key
so a[b + ofs - 1] <= key < a[b + ofs]
Copy first run into temp array
Indexes into tmp array
Indexes int a
Indexes int a
Move first element of second run and deal with degenerate cases
Last elt of run 1 to end of merge
Use local variable for performance
"    "       "     "      "
Number of times in a row that first run won
Number of times in a row that second run won
len1 == 1 || len1 == 0
Penalize for leaving gallop mode
End of "outer" loop
Write back to field
Last elt of run 1 to end of merge
Copy second run into temp array
Indexes into a
Indexes into tmp array
Indexes into a
Move last element of first run and deal with degenerate cases
Use local variable for performance
"    "       "     "      "
Number of times in a row that first run won
Number of times in a row that second run won
len2 == 1 || len2 == 0
Penalize for leaving gallop mode
End of "outer" loop
Write back to field
Move first elt of run2 to front of merge
Compute smallest power of 2 > minCapacity
Not bloody likely!
fill in the options list
end of opts
set index of first operand
end of options
simple option token such as '-s' found
stacked options found, such as '-shm'
iterate thru the tokens after the dash and
add them to theOptions list
case 1- there are not options stored yet therefore
this must be an command argument, not an option argument
stop processing options
there are options stored, check to see if
this arg belong to the last arg stored
case 3 -
the last option stored does not take
an argument, so again, this argument
must be a command argument, not
an option argument
end of options
end option does not start with "-"
end for args loop
attach an iterator to list of options
options are done, now fill out cmd arg list with remaining args
inner class to model an option
end class Option
inner class to query optString for a possible option match,
and whether or not a given legal option takes an argument.
reached end of theOptString
end class OptionMatcher
end class GetOpt
hashCode depends on 'index', 'start', and 'end'.
Therefore before changing any of these values we
need to unregister 'this' from any HashSet where
this is registered, and then we need to add it
Unregister 'this' from the HashSet held by 'start'.
Since hashCode() is going to change we need to unregister
'this' both form 'start' and 'end'.
Unregister 'this' from the HashSet held by 'end'.
hashCode depends on 'index', 'start', and 'end'.
Therefore before changing any of these values we
need to unregister 'this' from any HashSet where
this is registered, and then we need to add it
Register 'this' in the HashSet held by start.
Since hashCode() has changed we need to register
'this' again in 'end'.
Add back 'this' in the HashSet held by 'end'.
Call notifyTargetChanging *before* modifying this,
as the code triggered by notifyTargetChanging
depends on this pointing to the 'old' start.
call notifyTargetChanged *after* modifying this,
as the code triggered by notifyTargetChanged
depends on this pointing to the 'new' start.
call notifyTargetChanging *before* modifying this,
as the code triggered by notifyTargetChanging
depends on this pointing to the 'old' end.
Unregister 'this' from the HashSet held by the 'old' end.
call notifyTargetChanged *after* modifying this,
as the code triggered by notifyTargetChanged
depends on this pointing to the 'new' end.
Register 'this' in the HashSet held by the 'new' end.
ExtendedXMLCatalogReader.java - Read XML Catalog files
Check before calling the super because super will report our
namespace as an extension namespace, but that doesn't count
for this element.
This is an Extended XML Catalog entry
This is equivalent to an invalid catalog entry type
Check after popping the stack so we don't erroneously think we
are our own extension namespace...
Do not instantiate this class
Create an outputstream for debugging
Emit first message
Create an outputstream for errors
-- This file was mechanically generated: Do not edit! --
Translate all full groups from byte array elements to Base64
Translate partial group if present
Translate all full groups from base64 to byte array elements
Translate partial group, if present
-- Byte streams from channels --
Invoker's previous array
Invoker's previous array
Invoker's previous array
-- Channels from streams --
Not really interruptible
block at most once
Not really interruptible
-- Character streams from channels --
end of HeapNode
Last node returned by this MultiValuedNodeHeapIterator to the caller of
next; used to prune duplicates
cached returned last for use in gotoMark
cached heap size for use in gotoMark
iterator _heap[0] is done
Swap first and last (iterator must be restartable)
fallthrough if not returned above
to get the first node
rebuild heap after call last() function. fix for bug 20913
-- This file was mechanically generated: Do not edit! --
Flags needed to implement the hysteresis mechanism.
GETTERS AND SETTERS
The gauge difference mode is used.
The previous scan gauge has been initialized.
The previous scan gauge has not been initialized.
We cannot update the derived gauge...
The gauge difference mode is not used.
Send high notification if notifyHigh is true.
Send low notification if notifyLow is true.
Should never occur...
Should never occur...
Should never occur...
Check that the observed attribute is either of type
"Integer" or "Float".
Update the derived gauge attributes and check the
validity of the new value. The derived gauge value
is invalid when the differenceMode flag is set to
true and it is the first notification, i.e. we
haven't got 2 consecutive values to update the
Notify the listeners if the updated derived
gauge value is valid.
make separate passes through glyphs in order of decreasing priority
until justifyDelta is zero or we run out of priorities.
pass through glyphs, first collecting weights and limits
ignore left of first character
ignore right of last character
did we hit the limit?
negative for negative deltas
predivide delta by weight
not used if weight == 0
now allocate this based on ratio of weight to total weight
factor in sign
sign factored in already
sign factored in already
Is the variable fetched always the same?
This should now never happen...
"VariableReference given for variable out "+
Hack city... big time.  This is needed to evaluate xpaths from extensions,
pending some bright light going off in my head.  Some sort of callback?
if(null != vvar)
J2SE does not support Xalan interpretive
J2SE does not support Xalan interpretive
J2SE does not support Xalan interpretive
The position in the current iterator
Number of nodes in the current iterator
Number of key levels extracted from DOM
Contains Comparable  objects
-- W. Eliot Kimber (eliot@isogen.com)
If we can't read the propery, just use default collator
Get value from our array if possible
Get value from DOM if accessed for the first time
Get value from our vector if possible
Get value from DOM if accessed for the first time
Treat number as NaN if it cannot be parsed as a double
Compare the two nodes either as numeric or text values
Return inverse compare value if inverse sort order
Compare based on document order if all sort keys are equal
-- This file was mechanically generated: Do not edit! --
For duplicates and slices
Note that this repository ID must reflect the implementation
of the abstract valuetype (that is, this class), not the
repository ID of the org.omg.PortableInterceptor.ObjectReferenceTemplate
class.  This allows for multiple independent implementations
of the abstract valuetype, should that become necessary.
scheme specific part
suffix must not contain '/' chars
this "*" implies all others
that "*" can only be implied by this "*"
covers all cases of literal IP addresses and fixed
this "*.foo.com" implies "bub.bar.foo.com"
eliminate loops in case of the boot
ClassLoader returning itself as a parent
this will ensure bootclassloader is used
Package private method for setting an attributes table for the encoder
do not throw any exception here. user may want to
manage his/her own factories using this manager
by explicit registratation (by registerXXX) methods.
one factory failed, but check other factories...
do not throw any exception here. user may want to
manage his/her own factories using this manager
by explicit registratation (by registerXXX) methods.
look for registered name first
look for registered extension first
look for registered types first
Declare serialVersionUID to be compatible with JDK1.1
An empty ListMode, this is used when the UI changes to allow
the JList to be gc'ed.
Listeners that are required by the ComboPopup interface
Listeners that are attached to the list
Added to the combo box for bound properties
Added to the combo box model
begin ComboPopup method implementations
We do this, otherwise the listener the ui installs on
the model (the combobox model in this case) will keep a
reference to the list, causing the list (and us) to never get gced.
end ComboPopup method implementations
XXX - shouldn't call this method
begin Initialization routines
UI construction of the popup.
Overriden PopupMenuListener notification methods to inform combo box
comboBox.firePopupMenuWillBecomeVisible() is called from BasicComboPopup.show() method
to let the user change the popup menu from the PopupMenuListener.popupMenuWillBecomeVisible()
Fix for 4234053. Filter out the Control Key from the list.
ie., don't allow CTRL key deselection.
end Initialization routines
begin Event Listenters
NOTE: this is added to both the JList and JComboBox
JList mouse listener
workaround for cancelling an edited item (bug 4530953)
JComboBox mouse listener
NOTE: this is added to both the List and ComboBox
Pass along the new component orientation
to the list and the scroller
end Event Listeners
begin Autoscroll methods
XXX - should be a private method within InvocationMouseMotionHandler
end Autoscroll methods
begin Utility methods
Set the cached value of the minimum row count
Calculate the desktop dimensions relative to the combo box.
reduce the width of the scrollpane by the insets so that the popup
is the same width as the combo box.
XXX - only seems to be called from this class. shouldScroll flag is
end Utility methods
End of file.
no need to synchronize again
public and system ids
certain classloaders need it without the leading /
certain classloaders need it without the leading /
certain classloaders need it without the leading /
certain classloaders need it without the leading /
size of stack to hold globals:
globals for building XSComplexTypeDecls
our own little stack to retain state when getGlobalDecls is called:
need to add the type to the grammar for later constraint checking
need to add the type to the grammar for later constraint checking
also add it to extended map
discard valid Block/Final 'Default' values that are invalid for Block/Final
First, handle any ANNOTATION declaration and get next child
Process the content of the complex type definition
EMPTY complexType with complexContent
set the base to the anyType
We must have ....
GROUP, ALL, SEQUENCE or CHOICE, followed by optional attributes
Note that it's possible that only attributes are specified.
set the base to the anyType
Set content type
If there are no children, return
The content should be either "restriction" or "extension"
Need a base type.
If the base type is complex, it must have simpleContent
base is a CT with simple content (both restriction and extension are OK)
base is a CT with mixed/emptiable content (only restriction is OK)
base is a ST (only extension is OK)
Check that the base permits the derivation
Skip over any potential annotations
traverse annotation if any
Process a RESTRICTION
There may be a simple type definition in the restriction element
The data type validator will be based on it, if specified
check that this datatype validator is validly derived from the base
according to derivation-ok-restriction 5.1.2.1
this only happens when restricting a mixed/emptiable CT
but there is no <simpleType>, which is required
Traverse any facets
Recreate the type, ignoring the facets
Traverse any attributes
Prohibited uses must be removed after merge for RESTRICTION
Process a EXTENSION
Traverse any attributes
Remove prohibited uses.   Should be done prior to any merge.
and finally, since we've nothing more to traverse, we can
return the attributes (and thereby reset the namespace support)
Determine if this is mixed content
Since the type must have complex content, set the simple type validators
If there are no children, return
The content should be either "restriction" or "extension"
Need a base type.  Check that it's a complex type
Check that the base permits the derivation
Skip over any potential annotations
traverse annotation if any
Process the content.  Note:  should I try to catch any complexType errors
here in order to return the attr array?
Compose the final content and attribute uses
This is an RESTRICTION
N.B. derivation-ok-restriction.5.3 is checked under schema
full checking.   That's because we need to wait until locals are
traversed so that occurrence information is correct.
Remove prohibited uses.   Must be done after merge for RESTRICTION.
This is an EXTENSION
Create the particle
Check if the contentType of the base is consistent with the new type
if the content of either type is an "all" model group, error.
the "sequence" model group to contain both particles
the particle to contain the above sequence
Remove prohibited uses.   Must be done before merge for EXTENSION.
and *finally* we can legitimately return the attributes!
end of traverseComplexContent
This method merges attribute uses from the base, into the derived set.
LM: may want to merge with attributeGroup processing.
Recover by using the attribute use from the base type,
to make the resulting schema "more valid".
For extension, the wildcard must be formed by doing a union of the wildcards
REVISIT: XML Schema 1.0 2nd edition doesn't actually specify this constraint. It's a bug in the spec
which will eventually be fixed. We're just guessing what the error code will be. If it turns out to be
something else we'll need to change it. -- mrglavas
whether there is a particle with empty model group
GROUP, ALL, SEQUENCE or CHOICE, followed by attributes, if specified.
Note that it's possible that only attributes are specified.
Should be attributes here - will check below...
if the particle is empty because there is no non-annotation chidren,
we need to make the particle itself null (so that the effective
content is empty).
get the first child
if it's annotation, get the next one
if there is no (non-annotation) children, mark particle empty
child != null means we might have seen an element with
minOccurs == maxOccurs == 0
Set the content type
Now, process attributes
Only remove prohibited attribute uses if this isn't a derived type
Derivation-specific code worries about this elsewhere
Generate a unique name for the anonymous type by concatenating together the
names of parent nodes
The name is quite good for debugging/error purposes, but we may want to
revisit how this is done for performance reasons (LM).
Mock up the typeInfo structure so that there won't be problems during
REVISIT: do we need to remove all attribute uses already added into
the attribute group? maybe it's ok to leave them there. -SG
let's save ourselves a couple of objects...
it isn't very likely that there will be more than one annotation
in a complexType decl.  This saves us fromhaving to push/pop
one more object from the fGlobalStore, and that's bound
to be a savings for most applications
generic array construction
-- Channel operations --
-- Other operations --
-- Memory-mapped buffers --
-- Locks --
ORB from another vendor
JDK 1.3.0 or earlier
JDK 1.3.1 FCS
PEORB in JDK 1.5, S1AS 8, J2EE 1.4
Add code to use a URIResolver. Patch from Dmitri Ilyin.
If the href value has parameters to be passed to a
servlet(something like "foobar?id=12..."),
we want to make sure we get them added to
the href value. Without this check, we would move on
to try to process another attribute and that would be
We need to set lookedAhead here to flag that we
already have the next token.
Add code to use a URIResolver. Patch from Dmitri Ilyin.
just in case...
return the child at location "index".
no more elements
get a handle to the element on top of the stack
get a handle to the element on top of the stack
current is the root, nothing before it.
restore the top item.
should never get here.
don't go recursive
This method was added later, it has no equivalent
engineResolvePrivateKey() in the old API.
We cannot throw UnsupportedOperationException because
KeyResolverSpi implementations who don't know about
this method would stop the search too early.
name of current class
file to write to
Write them to the Attributes.html file with anchor "<name>[<i>]"
Reference attribute in _attributes.html
Get raw signature
Get array of strings containing the argument types
Get return type string
Get method name
Get method's access flags
Get the method's attributes, the Code Attribute in particular
Check for thrown exceptions
whether this pool is locked
the number of grammars in the pool
retrieveInitialGrammarSet (String): Grammar[]
create a new entry
clear this entry; useful to promote garbage collection
since reduces reference count of objects to be destroyed
use a privileged block as reading a system property
use default if any Exceptions
set serialVersionUID to desired value
map null Namespace URI to default
to preserve compatibility with QName 1.0
local part is required.
"" is allowed to preserve compatibility with QName 1.0
prefix is required
null is not valid
"" local part is valid to preserve compatible behavior with QName 1.0
local part only?
Namespace URI improperly specified?
Namespace URI and local part specified
Make sure that extra field data for first JAR
entry includes JAR magic number id.
Prepend magic to existing extra data
extra field id
extra field size
Invalid extra field data
Rather than have separate CDR subcontract,
use same CorbaClientRequestDispatcherImpl but have
different MessageMediator finishSendingRequest and waitForResponse
handle what is done below.
Benefit: then in ContactInfo no need to do a direct new
of subcontract - does not complicate subcontract registry.
Create server-side input object.
REVISIT: Impl cast.
InputStream must be closed on the InputObject so that its
ByteBuffer can be released to the ByteBufferPool. We must do
this before we re-assign the cdrInputObject reference below.
No need to do anything since we're done with the input stream
and cdrInputObject will be re-assigned a new client-side input
object, (i.e. won't result in a corba error).
Create client-side input object
End of file.
$$fb2002-11-01: fix for 4672864: AudioFileFormat.toString() throws unexpected NullPointerException
FILE FORMAT TYPE DEFINES
char + OFFSET is outside of LATIN-1
Potential number, some are not used
instruction list as string
map instruction list to array
Create a string with length equal to il length
Map opcodes to characters
Where to start search from (index)
Initialize pattern map
Precompile some aliases first
Omit already precompiled patterns
precompile all patterns
Add instruction alias to match anything
Not an invalid opcode
The ORB is required to do string_to_object() operations
All the references are stored in the files in the form of IOR strings
The ObjectKey will be in the format NC<Index> which uniquely identifies
The NamingContext internaly
Hash table contains all the entries in the NamingContexts. The
CORBA.Object references will be stored in the form of IOR strings
and the Child Naming Contexts will have it's key as the entry in the
table. This table is written into File everytime an update is made
on this context.
The NameServiceHandle is required to get the ObjectId from the
NamingContext's references. These references are created using
POA in the NameService.
ServantManager is the single point of contact to Read, Write and
Update the NamingContextFile
All the INS (Interoperable Naming Service) methods are defined in this class
All the calls to INS will be delegated to this class.
insImpl will be null if the NamingContext graph is rebuilt from
the persistence store.
doBind implements all four flavors of binding
doBind implements all four flavors of binding
doBind implements all four flavors of binding
This should not happen
doBind implements all four flavors of binding
This should not happen
doResolve actually resolves
doUnbind actually unbinds
List actually generates the list
Create actually creates a new naming context
The obvious solution:
The context is empty so it can be destroyed
This context is not empty!
At bottom level?
The identifier must be set
Ensure synchronization of backend
Yes: bind object in this context under the name
Refer Naming Service Doc:00-11-01 section 2.2.3.4
If there is an object already bound with the name
and the binding type is not ncontext a NotFound
Exception with a reason of not a context has to be
Fix for bug Id: 4384628
Previously a Context was bound and now trying to
bind Object. It is invalid.
Now there are no other bindings under this name
No: bind in a different context
How should we propagate the bind
Bind as object
Narrow to a naming context using Java casts. It must work.
Bind as context
This should not happen
Length must be greater than 0
The identifier must be set
Resolve first level in this context
Object was not found
n.length > 1
Compute restOfName = name[1..length]
Resolve rest of name in context
The identifier must be set
Yes: unbind in this context
It was not bound
No: unbind in a different context
Resolve first  - must be resolveable
Propagate unbind to this context
Resolve first  - must be resolveable
It was not bound
Was it bound as a context?
It was not a context
Narrow to a naming context
It was not a context
Hmm. must be ok
Raise a Valid Exception and Return
If the BindingType is an ObjectRef then Stringify this ref and
Store it in InternalBindingValue instance. This is required
because the Object References has to be stored in file
If the BindingType is a NamingContext then get it's object key
from the NameService and store it in the Internal Binding Value instance
There was an entry with this name in the Hashtable and hence throw CTX_ALREADY_BOUND
Everything went smooth so update the NamingContext file with the
latest Hashtable image
Something went wrong while updating the context
so speak the error
Something went wrong while Binding the Object Reference
Speak the error again.
If the NameComponent list has no entry then it means the current
context was requested
No entry was found for the given name and hence return NULL
NamingContextDataStore throws appropriate exception if
Check whether the entry found in the Hashtable starts with NC
Which means it's a name context. So get the NamingContext reference
from ServantManager, which would either return from the cache or
read it from the File.
Else, It is a Object Reference. Check whether Object Reference
can be obtained directly, If not then convert the stringified
reference to object and return.
Ignore the exception in Hashtable.remove
Have it set the binding list
Get the object reference for the binding iterator servant
XXX note that orb.disconnect is illegal here, since the
POA is used.  However, there may be some associated state
that needs to be cleaned up in ServerManagerImpl which we will
look into further at another time.
If there is a name component whose id and kind null or
zero length string, then an invalid name exception needs to be
Extra check to see that corba name url created is valid as per
INS spec grammer.
booleans to check for various operation invocation restrictions
if we support contexts, this would
presumably also  be available on
the server invocation
unmarshal the value into the Any
hang on to the NVList for marshaling the result
check for invocation restrictions
Notify portable interceptors of the result so that
ServerRequestInfo.result() functions as desired.
actual marshaling of the reply msg header and params takes place
after the DSI returns control to the ORB.
except can be called by the DIR at any time (CORBA 2.2 section 6.3).
Ensure that the Any contains a SystemException or a
UserException. If the UserException is not a declared exception,
the client will get an UNKNOWN exception.
Inform Portable interceptors of the exception that was set
so sending_exception can return the right value.
The user can only call arguments once and not at all after
set_exception.  (internal flags ensure this).  However, the user
can call set_exception multiple times.  Therefore, we only
invoke receive_request the first time set_exception is
called (if they haven't already called arguments).
We need to invoke intermediate points here.
actual marshaling of the reply msg header and exception takes place
after the DSI returns control to the ORB.
Two things to be checked (CORBA 2.2 spec, section 6.3):
1. Unless it calls set_exception(), the DIR must call arguments()
exactly once, even if the operation signature contains
2. Unless set_exception() is called, if the invoked operation has a
non-void result type, set_result() must be called exactly once
before the DIR returns.
normal invocation return
Neither a result nor an exception has been set.
Assume that the return type is void. If this is not so,
the client will throw a MARSHAL exception while
unmarshaling the return value.
marshal the operation return value
marshal the inouts/outs
End of file.
-- This file was mechanically generated: Do not edit! --
These fields are declared here rather than in Heap-X-Buffer in order to
reduce the number of virtual method invocations needed to access these
values, which is especially costly when coding small buffers.
Non-null only for heap buffers
Valid only for heap buffers
Creates a new buffer with the given mark, position, limit, capacity,
backing array, and array offset
Creates a new buffer with the given mark, position, limit, and capacity
-- Singleton get/put methods --
-- Bulk get operations --
-- Bulk put operations --
-- Other stuff --
-- Other char stuff --
-- Other byte stuff: Access to binary data --
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of TextFieldPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of TextFieldPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
search for identical symbol
Rehash the table if the threshold is exceeded
Select a new hash function and rehash the table if
the collision threshold is exceeded.
create new entry
search for identical symbol
Rehash the table if the threshold is exceeded
Select a new hash function and rehash the table if
the collision threshold is exceeded.
add new entry
search for identical symbol
search for identical symbol
Copyright (c) 1995-96 by Cisco Systems, Inc.
IntStack is trying to see this directly
Attributes2.java - extended Attributes
Public Domain: no warranty.
$Id: Attributes2.java,v 1.2 2004/11/03 22:49:07 jsuttor Exp $
The setRoot operation can take place with a reset operation,
and so we may not be in the context of LocPathIterator#nextNode,
so we have to set up the variable context, execute the expression,
and then restore the variable context.
These three statements need to be combined into one operation.
These two statements need to be combined into one operation.
XXX these should probably be WeakHashMaps.
At this point, rootSet contains those remote interfaces
that are not related by inheritance, and gr contains
all reachable remote interfaces.
rootSet just contains root here
Use this class and its superclasses (not Object) as initial roots
Expand all nodes into the graph
remove the roots and find roots again
List<String> for the typeids
If the rootSet has more than one element, we must
put the type id of the implementation class first.
Root represents the implementation class here.
different sorts of declarations; should make lookup and
traverser calling more efficient/less bulky.
this string gets appended to redefined names; it's purpose is to be
as unlikely as possible to cause collisions.
protected data that can be accessible by any traverser
the Security manager in effect.
These tables correspond to the symbol spaces defined in the
They are keyed with a QName (that is, String("URI,localpart) and
their values are nodes corresponding to the given name's decl.
By asking the node for its ownerDocument and looking in
XSDocumentInfoRegistry we can easily get the corresponding
Compensation for the above maps to locate XSDocumentInfo,
Since we may take Schema Element directly, so can not get the
corresponding XSDocumentInfo object just using above maps.
Stores XSDocumentInfo (keyed by component name), to check for duplicate
components declared within the same xsd document
this map is keyed on by XSDocumentInfo objects.  Its values
are Vectors containing the XSDocumentInfo objects <include>d,
<import>ed or <redefine>d by the key XSDocumentInfo.
this map is keyed on by a target namespace.  Its values
are Vectors containing namespaces imported by schema documents
with the key target namespace.
if an imported schema has absent namespace, the value "null" is stored.
all namespaces that imports other namespaces
if the importing schema has absent namespace, empty string is stored.
(because the key of a map can't be null.)
stores instance document mappings between namespaces and schema hints
Records which nodes are hidden when the input is a DOMInputSource.
use Schema Element to lookup the SystemId.
This vector stores strings which are combinations of the
publicId and systemId of the inputSource corresponding to a
schema document.  This combination is used so that the user's
EntityResolver can provide a consistent way of identifying a
schema document that is included in multiple other schemas.
this map contains a mapping from Schema Element to its systemId
this is useful to resolve a uri relative to the referring document
the primary XSDocumentInfo we were called to parse
This map's job is to act as a link between the Schema Element and its
map between <redefine> elements and the XSDocumentInfo
objects that correspond to the documents being redefined.
map between <redefine> elements and the namespace support
these objects store a mapping between the names of redefining
groups/attributeGroups and the groups/AttributeGroups which
they redefine by restriction (implicitly).  It is up to the
Group and AttributeGroup traversers to check these restrictions for
a variable storing whether the last schema document
processed (by getSchema) was a duplicate.
validate annotations feature
handle multiple import feature
handle namespace growth feature
handle tolerate duplicates feature
the symbol table
the Grammar description
the Grammar Pool
the security property manager
************ Traversers **********
these data members are needed for the deferred traversal
of local elements.
the initial size of the array to store deferred local elements
the incremental size of the array to store deferred local elements
current position of the array (# of deferred local elements)
these data members are needed for the deferred traversal
the initial size of the array to store deferred keyrefs
the incremental size of the array to store deferred keyrefs
current position of the array (# of deferred keyrefs)
global decls: map from decl name to decl object
it should be possible to use the same XSDHandler to parse
multiple schema documents; this will allow one to be
Note: don't use SchemaConfiguration internally
we will get stack overflaw because
XMLSchemaValidator will be instantiating XSDHandler...
if loading using JAXP schemaSource property, or using grammar caching loadGrammar
the desc.targetNamespace is always null.
Therefore we should not attempt to find out if
the schema is already in the bucket, since in the case we have
no namespace schema in the bucket, findGrammar will always return the
no namespace schema.
first try to find it in the bucket/pool, return if one is found
REVISIT: return the grammar?
handle empty string URI as null
before parsing a schema, need to clear registries associated with
first phase:  construct trees.
is instanceof XMLInputSource
something went wrong right off the hop
Since now we've discovered a namespace, we need to update xsd key
and store this schema in traversed schemas bucket
When namespace growth is enabled and a null location is provided we cannot tell
whether we've loaded this schema document before so we must assume that we haven't.
before constructing trees and traversing a schema, need to reset
all traversers and clear all registries
second phase:  fill global registries.
third phase:  call traversers
fourth phase: handle local element decls
fifth phase:  handle Keyrefs
sixth phase:  validate attribute of non-schema namespaces
REVISIT: skip this for now. we really don't want to do it.
seventh phase:  store imported grammars
for all grammars with <import>s
get its target namespace
get all namespaces it imports
get the grammar
for imported namespace
get imported grammar
reuse the same vector
set the imported grammars
put this grammar into the bucket, along with grammars
imported by it (directly or indirectly)
REVISIT: a conflict between new grammar(s) and grammars
in the bucket. What to do? A warning? An exception?
may wish to have setter methods for ErrorHandler,
This method does several things:
It constructs an instance of an XSDocumentInfo object using the
schemaRoot node.  Then, for each <include>,
<redefine>, and <import> children, it attempts to resolve the
requested schema document, initiates a DOM parse, and calls
itself recursively on that document's root.  It also records in
the DependencyMap object what XSDocumentInfo objects its XSDocumentInfo
It also makes sure the targetNamespace of the schema it was
called to parse is correct.
note that attributes are freed at end of traverseSchemas()
targetNamespace="" is not valid, issue a warning, and ignore it
the second index to the NS_ERROR_CODES array
if the caller/expected NS is not absent, we use the first column
for include and redefine
if the referred document has no targetNamespace,
it's a chameleon schema
if the referred document has a target namespace differing
from the caller, it's an error
for instance and import, the two NS's must be the same
now there is no caller/expected NS, it's an error for the referred
document to have a target namespace, unless we are preparsing a schema
set the target namespace of the description
the second index to the NS_ERROR_CODES array
if the caller/expected NS is absent, we use the second column
the other cases (callerTNS == currSchemaInfo.fTargetNamespce == null)
a schema document can always access it's own target namespace
we have a namespace collision
update all the grammars in the bucket to point to the new grammar.
update import list of the new grammar
store the document and its location
REVISIT: don't expose the DOM tree
have to handle some validation here too!
call XSAttributeChecker to fill in attrs
check contents and process optional annotations
promoting annotations to parent component
a document can't import another document with the same namespace
if this namespace has not been imported by this document,
then import if multiple imports support is enabled.
also record the fact that one namespace imports another one
convert null to ""
get all namespaces imported by this one
if no namespace was imported, create new Vector
record that this one imports other(s)
if a grammar with the same namespace and location exists (or being
built), ignore this one (don't traverse it).
if ((!fHonourAllSchemaLocations && findGrammar(fSchemaGrammarDescription) != null) || isExistingGrammar(fSchemaGrammarDescription))
If "findGrammar" returns a grammar, then this is not the
the first time we see a location for a given namespace.
Don't consult the location pair map in this case,
otherwise the location will be ignored because it'll get
resolved to the same location as the first hint.
validation for redefine/include will be the same here; just
make sure TNS is right (don't care about redef contents
store the namespace decls of the redefine element
check annotations.  Must do this here to avoid having to
re-parse attributes later
promoting annotations to parent component
promoting annotations to parent component
catch all other content errors later
schemaLocation is required on <include> and <redefine>
pass the systemId of the current document as the base systemId
no more possibility of schema references in well-formed
If the schema is duplicate, we needn't call constructTrees() again.
To handle mutual <include>s
must record which schema we're redefining so that we can
rename the right things later!
This method builds registries for all globally-referenceable
names.  A registry will be built for each symbol space defined
by the spec.  It is also this method's job to rename redefined
components, and to record which components redefine others (so
that implicit redefinitions of groups and attributeGroups can be handled).
Starting with fRoot, we examine each child of the schema
element.  Skipping all imports and includes, we record the names
of all other global components (and children of <redefine>).  We
also put <redefine> names in a registry that we look through in
case something needs renaming.  Once we're done with a schema we
set its Document node to hidden so that we don't try to traverse
it again; then we look to its Dependency map entry.  We keep a
stack of schemas that we haven't yet finished processing; this
is a depth-first traversal.
must have processed this already!
process this schema's global decls
this loop makes sure the <schema> element ordering is
skip it; traverse it later
an error we'll catch later
and all we need to do is error-check+rename our kkids:
and all we need to do is error-check+rename our kkids:
must be simpleType
and all we need to do is error-check+rename our kids:
end march through <redefine> children
and now set as traversed
an error we'll catch later
now we're done with this one!
now add the schemas this guy depends on
Beginning at the first schema processing was requested for
(fRoot), this method
examines each child (global schema information item) of each
schema document (and of each <redefine> element)
corresponding to an XSDocumentInfo object.  If the
readOnly field on that node has not been set, it calls an
appropriate traverser to traverse it.  Once all global decls in
an XSDocumentInfo object have been traversed, it marks that object
as traversed (or hidden) in order to avoid infinite loops.  It completes
when it has visited all XSDocumentInfo objects in the
DependencyMap and marked them as traversed.
the process here is very similar to that in
buildGlobalRegistries, except we can't set our schemas as
hidden for a second time; so make them all visible again
must have processed this already!
traverse this schema's global decls
includes and imports will not show up here!
use the namespace decls for the redefine, instead of for the parent <schema>
annotations will have been processed already; this is now
end march through <redefine> children
now we're done with this one!
now add the schemas this guy depends on
store whether we have reported an error about that no grammar
is found for the given namespace uri
check whether we need to report an error against the given uri.
otherwise we reported the error, and remember this fact.
add a global attribute decl from a current schema load (only if no existing decl is found)
add a global attribute group decl from a current schema load (only if no existing decl is found)
add a global element decl from a current schema load (only if no existing decl is found)
add a global group decl from a current schema load (only if no existing decl is found)
add a global notation decl from a current schema load (only if no existing decl is found)
add a global type decl from a current schema load (only if no existing decl is found)
add a identity constraint decl from a current schema load (only if no existing decl is found)
since it is forbidden for traversers to talk to each other
directly (except wen a traverser encounters a local declaration),
this provides a generic means for a traverser to call
for the traversal of some declaration.  An XSDocumentInfo is
required because the XSDocumentInfo that the traverser is traversing
may bear no relation to the one the handler is operating on.
This method will:
2. if so, determine if there is a path from currSchema to the
schema document where declToTraverse lives (i.e., do a lookup
3. depending on declType (which will be relevant to step 1 as
well), call the appropriate traverser with the appropriate
this will be an Object of some kind
that lives in the Grammar.
from the schema spec, all built-in types are present in all schemas,
so if the requested component is a type, and could be found in the
default schema grammar, we should return that type.
otherwise (since we would support user-defined schema grammar) we'll
use the normal way to get the decl
now check whether this document can access the requsted namespace
cannot get to this schema from the one containing the requesting decl
Recover and continue to look for the component.
check whether there is grammar for the requested namespace
if there is such grammar, check whether the requested component is in the grammar
if the component is parsed, return it
the component is not parsed, try to find a DOM element for it
no DOM element found, so the component can't be located
get the schema doc containing the component to be parsed
it should always return non-null value, but since null-checking
comes for free, let's be safe and check again
cannot get to this schema from the one containing the requesting decl
a component is hidden, meaning either it's traversed, or being traversed.
but we didn't find it in the grammar, so it's the latter case, and
a circular reference. error!
decl must not be null if we're here...
getGlobalDecl(XSDocumentInfo, int, QName):  Object
If we are tolerating duplicate declarations and allowing namespace growth
use the declaration from the current schema load (if it exists)
if the parent is <redefine> use the namespace delcs for it.
back up the current SchemaNamespaceSupport, because we need to provide
a fresh one to the traverseGlobal methods.
traverse the referenced global component
identity constraints should have been parsed already...
we should never get here
restore the previous SchemaNamespaceSupport, so that the caller can get
proper namespace binding.
This method determines whether there is a group
(attributeGroup) which the given one has redefined by
restriction.  If so, it returns it; else it returns null.
getGrpOrAttrGrpRedefinedByRestriction(int, QName, XSDocumentInfo):  Object
Since ID constraints can occur in local elements, unless we
wish to completely traverse all our DOM trees looking for ID
constraints while we're building our global name registries,
which seems terribly inefficient, we need to resolve keyrefs
after all parsing is complete.  This we can simply do by running through
fIdentityConstraintRegistry and calling traverseKeyRef on all
of the KeyRef nodes.  This unfortunately removes this knowledge
from the elementTraverser class (which must ignore keyrefs),
but there seems to be no efficient way around this...
need to set <keyref> to hidden before traversing it,
because it has global scope
an accessor method.  Just makes sure callers
who want the Identity constraint registry vaguely know what they're about.
an accessor method.
This method squirrels away <keyref> declarations--along with the element
decls and namespace bindings they might find handy.
now set up all the registries we'll need...
check array sizes
storeKeyref (Element, XSDocumentInfo, XSElementDecl): void
getSchema(String, String, String, boolean, short):  Document
contents of this method will depend on the system we adopt for entity resolution--i.e., XMLEntityHandler, EntityHandler, etc.
when the system id and byte stream and character stream
of the input source are all null, it's
impossible to find the schema document. so we skip in
this case. otherwise we'll receive some NPE or
file not found errors. but schemaHint=="" is perfectly
legal for import.
When the system id of the input source is used, first try to
expand it, and check whether the same document has been
parsed before. If so, return the document corresponding to
that system id.
getSchemaDocument(String, XMLInputSource, boolean, short, Element): Element
check whether the same document has been parsed before.
If so, return the document corresponding to that system id.
If something went wrong with the factory
just use our own SAX parser.
If this is a Xerces SAX parser set the security manager if there is one
If XML names and Namespace URIs are already internalized we
can avoid running them through the SymbolTable.
The feature isn't recognized or getting it is not supported.
In either case, assume that strings are not internalized.
Disconnect the schema loader and other objects from the XMLReader
Ignore any exceptions thrown by the XMLReader. Old versions of SAX
required an XMLReader to throw a NullPointerException if an attempt
to set a handler to null was made.
getSchemaDocument(String, SAXInputSource, boolean, short, Element): Element
check whether the same document has been parsed before.
If so, return the document corresponding to that system id.
getSchemaDocument(String, DOMInputSource, boolean, short, Element): Element
check whether the same document has been parsed before.
If so, return the document corresponding to that system id.
getSchemaDocument(String, StAXInputSource, boolean, short, Element): Element
now we need to store the mapping information from system id
to the document. also from the document to the system id.
getSchemaDocument0(XSDKey, String, Element): Element
either an error occured (exception), or empty input source was
returned, we need to report an error or a warning
getSchemaDocument1(boolean, boolean, XMLInputSource, Element): Element
check for existing grammars in our bucket
and if there exist any, and namespace growth is
not enabled - we do nothing
getSchemaDocument(String, XSInputSource, boolean, short, Element): Element
for all (recursively) imported grammars
get the grammar
we need to add grammars imported by sg1 too
for all grammars imported by sg2, but not in the vector
we add them to the vector
add any new locations
add any new imported grammars
add any new global components
update all the grammars in the bucket to point to the new grammar.
update import list of the new grammar
add global components
TODO: if not tolerating duplicate, generate an error message
add any extended (duplicate) global components
TODO: if not tolerating duplicate, generate an error message
add global components
add any extended (duplicate) global components
REVISIT - do we report an error?
add global components
add any extended (duplicate) global components
REVISIT - do we report an error?
add global components
add any extended (duplicate) global components
REVISIT - do we report an error?
add global components
add any extended (duplicate) global components
REVIST - do we report an error?
add global components
add any extended (duplicate) global components
REVISIT - do we report an error?
REVISIT - do we use == instead
store the declaration in the extended map, using an empty location
store the declaration in the extended map, using an empty location
store the declaration in the extended map, using an empty location
store the declaration in the extended map, using an empty location
store the declaration in the extended map, using an empty location
store the declaration in the extended map, using an empty location
shouldn't be null
REVIST: report an error message
REVIST: report an error message
NOTE: always assuming that fNamespaceGrowth is enabled
otherwise the grammar should have existed
initialize all the traversers.
this should only need to be called once during the construction
of this object; it creates the traversers that will be used to
before parsing a schema, need to clear registries associated with
before traversing a schema's parse tree, need to reset all traversers and
clear all registries
clear local element stack
and do same for keyrefs.
create traversers if necessary
set symbol table
set security manager
set entity manager
set entity resolver
set error reporter
Setting a parser property can be much more expensive
than checking its value.  Don't set the ERROR_HANDLER
or LOCALE properties unless they've actually changed.
Passing on the setting to the parser
If it's an empty particle, remove it from the containing component.
the purpose of this method is to keep up-to-date structures
we'll need for the feferred traversal of local elements.
if the stack is full, increase the size
REVISIT:  when we add derivation checking, we'll have to make
sure that ID constraint collisions don't necessarily result in error messages.
need to check whether we have a global declaration in the corresponding
just add it in!
case where we've collided with a redefining element
(the parent of the colliding element is a redefine)
case where we're a redefining element.
redefinition involved somehow
If both components belong to the same document then
report an error and return.
object comp. okay here
now have to do some renaming...
and take care of nested redefines by calling recursively:
we may be redefining the wrong schema
error that redefined element in wrong schema
we've just got a flat-out collision (we tolerate duplicate
declarations, only if they are defined in different schema
store the lastest current document info
checkForDuplicateNames(String, Map, Element, XSDocumentInfo):void
the purpose of this method is to take the component of the
specified type and rename references to itself so that they
refer to the object being redefined.  It takes special care of
<group>s and <attributeGroup>s to ensure that information
relating to implicit restrictions is preserved for those
now we have to do the renaming...
have to go one more level down; let another pass worry whether complexType is valid.
now we have to do the renaming...
if we get here then we must have reported an error and failed somewhere...
renameRedefiningComponents(XSDocumentInfo, Element, String, String, String):void
this method takes a name of the form a:b, determines the URI mapped
to by a in the current SchemaNamespaceSupport object, and returns this
information in the form (nsURI,b) suitable for lookups in the global
REVISIT: should have it return QName, instead of String. this would
save lots of string concatenation time. we can use
QName#equals() to compare two QNames, and use QName directly
as a key to the SymbolHash.
And when the DV's are ready to return compiled values from
validate() method, we should just call QNameDV.validate()
in this method.
findQName(String, XSDocumentInfo):  String
This function looks among the children of curr for an element of type elementSought.
If it finds one, it evaluates whether its ref attribute contains a reference
to originalQName.  If it does, it returns 1 + the value returned by
calls to itself on all other children.  In all other cases it returns 0 plus
the sum of the values returned by calls to itself on curr's children.
It also resets the value of ref so that it will refer to the renamed type from the schema
if ref was null some other stage of processing will flag the error
this method returns the XSDocumentInfo object that contains the
component corresponding to decl.  If components from this
document cannot be referred to from those of currSchema, this
method returns null; it's up to the caller to throw an error.
decl ref'ing us.
this method is superficial now. ---Jack
something went badly wrong; we don't know this doc?
findXSDocumentForDecl(XSDocumentInfo, Element):  XSDocumentInfo
returns whether more than <annotation>s occur in children of elem
make it visible
if it's visible already than so must be its children
get system id from document object
line/column numbers are stored in the element node
for inclue/redefine, this is the enclosing namespace
for import/preparse/instance, this is the target namespace
according to the description at the beginning of this class,
we use the hashcode of the namespace as the hashcoe of this key.
condition 1: both are redefine
condition 2: same namespace
condition 3: same non-null location
The class or interface representing the service being loaded
The class loader used to locate, load, and instantiate providers
The access control context taken when the ServiceLoader is created
Cached providers, in instantiation order
The current lazy-lookup iterator
Parse a single line from the given configuration file, adding the name
on the line to the names list.
Parse the content of the given URL as a provider-configuration file.
used to construct error detail strings
The URL naming the configuration file to be parsed
names in the given configuration file that are not yet members
of the returned set
If an I/O error occurs while reading from the given URL, or
if a configuration-file format error is detected
Private inner class implementing fully-lazy provider lookup
This cannot happen
no need to sync in the future
If the first two bytes are a JPEG SOI marker, it's probably
a JPEG file.  If they aren't, it definitely isn't a JPEG file.
We have to revalidate/repaint root if the style is JRootPane.NONE
only. When we needs to call revalidate/repaint with other styles
the installClientDecorations is always called after this method
imediatly and it will cause the revalidate/repaint at the proper
Reset the cursor, as we may have changed it to a resize cursor
This is potentially more than needs to be done,
but it rarely happens and makes the install/uninstall process
simpler. MetalTitlePane also assumes it will be recreated if
the decoration style changes.
NOTE: Ideally this would extends JRootPane.RootLayout, but that
would force this to be non-static.
Only overflows if 3 real non-MAX_VALUE heights, sum to > MAX_VALUE
Only will happen if sums to more than 2 billion units.  Not likely.
Similar overflow comment as above
Note: This is laying out the children in the layeredPane,
technically, these are not our children.
Some Window systems validate as you resize, others won't,
thus the check for validity before repainting.
Update the cursor
Defer repaint/validate on mouseReleased unless dynamic
layout is active.
Do this to keep format from crying.
This is better than making a bunch of conditional
code all over the place.
Re-declares the methods that are in class MBeanConstructorInfo of JMX 1.0
(methods will be removed when MBeanConstructorInfo is made a parent interface of this interface)
NOTE! This is a duplicate of utils.ClassLoaderUtils with public
modifiers changed to package-private. Make sure to integrate any future
changes to utils.ClassLoaderUtils to this file.
certain classloaders need it without the leading /
certain classloaders need it without the leading /
certain classloaders need it without the leading /
certain classloaders need it without the leading /
add listener for derived colors
remove listener for derived colors
Create the default font and default style. Also register all of the
regions and their states that this class will use for later lookup.
Additional regions can be registered later by 3rd party components.
These are simply the default registrations.
initialize the map of styles
--------------- Methods called by NimbusLookAndFeel
The global style definition
validate the method arguments
Add a LazyStyle for this region/prefix to m.
iterate over all the current styles and see if this prefix has
already been registered. If not, then register it.
add this region to the map of registered regions
validate method arguments
if there are no lazy styles registered for the region r, then return
the default style
Look for the best SynthStyle for this component/region pair.
replace the foundStyle if foundStyle is null, or
if the new style "s" is more specific (ie, its path was
longer), or if the foundStyle was "simple" and the new style
was not (ie: the foundStyle was for something like Button and
the new style was for something like "MyButton", hence, being
more specific.) In all cases, favor the most specific style
return the style, if found, or the default style if not found
validate the constructor arguments
set the values
always round size for now so we have exact int font size
(or we may have lame looking fonts)
See if we should use a separate ClassLoader
Fallback to the system class loader.
there is one odd case that needs to be supported here: cell
renderers. A cell renderer is defined as a named internal
component, so for example:
The problem is that the component named List.cellRenderer is not a
child of a JList. Rather, it is treated more as a direct component
Thus, if the prefix ends with "cellRenderer", then remove all the
previous dotted parts of the prefix name so that it becomes, for
Likewise, we have a hacked work around for cellRenderer, renderer,
otherwise, normal code path
if the component has overrides, it gets its own unique style
instead of the shared style.
lazily create the style if necessary
return the style
only get here if partIndex > 0 and c == null
so far so good, recurse
if c is not named, and parts[partIndex] has an expected class
type registered, then check to make sure c is of the
so far so good, recurse
special case the JInternalFrameTitlePane, because it
doesn't fit the mold. very, very funky.
it was the name of a region. So far, so good. Recurse.
found a character to split on.
true if this part represents a component name
TODO use a map of known regions for Synth and Swing, and
then use [classname] instead of org_class_name style
/ move to ARP.decodeColor() ?
this is a registered color
LAF has been installed, this is the first point at which we
can access our defaults table via UIManager so before now
all derived colors will be incorrect.
First we need to update
Since we implement Cloneable, this should never happen
okay because we never modify the contents of pageRanges
Return a copy because otherwise client code could circumvent the
the checks made in setPageRanges by modifying the returned
Store a copy because otherwise client code could circumvent the
the checks made above by holding a reference to the array and
modifying it after calling setPageRanges.
Assume the instance is either mutable or a singleton
if it has a nullary constructor.
Write out the properties of this instance.
Just handle the listeners of Components for now.
The ComponentListener is added automatically, when
Contatiner:add is called on the parent.
JMenuItems have a change listener added to them in
their "add" methods to enable accessibility support -
see the add method in JMenuItem for details. We cannot
instantiate this instance as it is a private inner class
and do not need to do this anyway since it will be created
and installed by the "add" method. Special case this for now,
ignoring all change listeners on JMenuItems.
Asssume the listeners are in the same order and that there are no gaps.
Eventually, this may need to do true differencing.
--- Object methods ---------------------------------
don't go recursive
create synth style factory
clear all cached images to free memory
We need to call super for basic's properties file.
Add Titled Border
Choose Dialog button positions
Store Table ScrollPane Corner Component
Setup the settings for ToolBarSeparator which is custom
installed for Nimbus
Populate UIDefaults with a standard set of properties
FileView icon keys are used by some applications, we don't have
a computer icon at the moment so using home icon for now
These properties affect style cached inside NimbusDefaults (6860433)
NOTE: we don't worry about component orientation or PAGE_END etc
because the BasicToolBarUI always uses an absolute position of
check specified state
check enabled state
check for defaults
All possible CSS attribute keys.
setup the css conversion table
PENDING(prinz) this is a 1.1 based implementation, need to also
have a 1.2 version.
translate border width into the cells, if it has non-zero value.
If table contains the BORDER attribute cells should have border width equals 1
Some browsers accept <TABLE BORDER> and <TABLE BORDER=""> with the same semantics as BORDER=1
load the attribute map
load the value map
initialize StyleConstants mapping
CSS-> internal CSS
Register all the CSS attribute keys for archival/unarchival
Register all the CSS Values for archival/unarchival
Conversion related methods/classes
Relative URL, try from base
sometimes get specified without leading #
Find the next numeric char
Skip non-decimal chars
Treat as 0
HR needs special handling due to us treating it as a leaf.
Used by ViewAttributeSet
it's an index, translate from size table
a is null, or no resolve parent.
relative sizes, larger | smaller (adjust from parent by
em, ex refer to parent sizes
lengths: pt, mm, cm, pc, in, px
em (font height 3em would be 3 times font height)
ex (height of X)
lengths are (+/-) followed by a number and two letter
Find next ','
PENDING(prinz) add support for relative values
CSS.Values are static, don't archive it.
Not pixels, use LengthUnit
PENDING: currently, we only support absolute values and
Assume its a length.
bitmask: bit 0, horizontal relative, bit 1 horizontal relative to
font size, 2 vertical relative to size, 3 vertical relative to
'top left' and 'left top' both mean the same as '0% 0%'.
'top', 'top center' and 'center top' mean the same as '50% 0%'.
'right top' and 'top right' mean the same as '100% 0%'.
'left', 'left center' and 'center left' mean the same as
'center' and 'center center' mean the same as '50% 50%'.
'right', 'right center' and 'center right' mean the same as
'bottom left' and 'left bottom' mean the same as '0% 100%'.
'bottom', 'bottom center' and 'center bottom' mean the same as
'bottom right' and 'right bottom' mean the same as '100% 100%'.
bit 0 for vert, 1 hor, 2 for center
First, check for keywords
vert and no horiz.
horiz and no vert.
no horiz, no vert, but center
PENDING: this base is wrong for linked style sheets.
Not sure about 1.3, determined by experiementation.
mapping according to the CSS2 spec
treat like points.
treat like points.
0 - value indicates real value
1 - % value, value relative to depends upon key.
50% will have a value = .5
2 - add value to parent value.
3 - em/ex relative to font size of element (except for
font-size, which is relative to parent).
font is of the form:
[ <font-style> || <font-variant> || <font-weight> ]? <font-size>
[ / <line-height> ]? <font-family>
bitmask, 1 for style, 2 for variant, 3 for weight
Check for font-style font-variant font-weight
string at index should be the font-size
Check for line height
remainder of strings are font-family
test for 100-900
bitmask: 0 for image, 1 repeat, 2 attachment, 3 position,
Currently, there is no good way to express this.
Identifies all values.
0 & 2 = strings[0], 1 & 3 = strings[1]
Part is non-parseable or occurred more than once.
Unspecified parts get default values.
Dispatch collected values to individual properties.
adjust for the spacing area
set return value
max gain we can get adjusting elements with adjustmentWeight <= i
max loss we can get adjusting elements with adjustmentWeight <= i
determine the adjustment to be made
adjustmentsArray[] is sorted. I do not bother about
binary search though
make the adjustments
while rounding we could lose several pixels.
check for infinite loop
try to distribute roundError. one pixel per cell
0 is the best weight WorstAdjustmentWeight is a worst one
Determine what values in valueConvertor need to be written out.
Should we throw an exception here?
Should we throw an exception here?
Reconstruct the hashtable.
XML 1.0 components
XML 1.1 components
create a vector to hold all the components in use
XML 1.0 specialized components
XML 1.1 specialized components
Common components for XML 1.1. and XML 1.0
create table for features and properties
add default recognized features
NOTE: These shouldn't really be here but since the XML Schema
validator is constructed dynamically, its recognized
features might not have been set and it would cause a
not-recognized exception to be thrown. -Ac
set state for default features
add default recognized properties
NOTE: These shouldn't really be here but since the XML Schema
validator is constructed dynamically, its recognized
properties might not have been set and it would cause a
not-recognized exception to be thrown. -Ac
add message formatters
REVISIT: What is the right thing to do? -Ac
REVISIT: this method used to reset all the components and
construct the pipeline. Now reset() is called
in parse (boolean) just before we parse the document
Should this method still throw exceptions..?
REVISIT: Should this be a property?
REVISIT - need to add new error message
close all streams opened by xerces
reset and configure pipeline and set InputSource.
mark configuration as fixed
resets and sets the pipeline.
make this feature special
forward to every XML 1.0 component
forward it to common components
forward to every XML 1.1 component
save state if noone "objects"
forward to every XML 1.0 component
forward it to every common Component
forward it to every XML 1.1 component
store value if noone "objects"
reset common components
reset every component
setup XML 1.1 document pipeline
non namespace document pipeline
setup document pipeline
If schema validator was not in the pipeline insert it.
add schema component
add schema message formatter
use XML 1.0 datatype library
setup DTD pipeline
setup document pipeline
add XML Schema validator if needed
If schema validator was not in the pipeline insert it.
add schema component
add schema message formatter
features and properties
Allows the parser to validate a document only when it
contains a grammar. Validation is turned on/off based
on each document instance, automatically.
Lets the user turn Schema validation support on/off.
activate full schema checking
Feature identifier: expose schema normalized value
Feature identifier: send element default value via characters()
special performance feature: only component manager is allowed to set it.
Value type: String
Get the literal string of characters associated with the
current event.  If the parser recognises and supports this
property but is not currently parsing text, it should return
null (this is a good way to check for availability before the
REVISIT - we should probably ask xml-dev for a precise
definition of what this is actually supposed to return, and
in exactly which circumstances.
don't add a component more than once
don't add a component more than once
don't add a component more than once
register component's recognized features
register component's recognized properties
set default values
Do not overwrite values already set on the configuration.
For newly added components who recognize this feature
but did not offer a default value, we need to make
sure these components will get an opportunity to read
the value before parsing begins.
Do not overwrite values already set on the configuration.
For newly added components who recognize this property
but did not offer a default value, we need to make
sure these components will get an opportunity to read
the value before parsing begins.
create datatype factory
setup XML 1.1 DTD pipeline
setup XML 1.1. document pipeline - namespace aware
if not try the PSVIDOMImplementation
if not try the XSImplementation
first check whether the CoreDOMImplementation would do
Add core DOMImplementations
Check the timerQ and restart if necessary.
NOTE: this uses setOpaque vs LookAndFeel.installProperty as there
is NO reason for the RootPane not to be opaque. For painting to
work the contentPane must be opaque, therefor the RootPane can
also be opaque.
everything moved to new parent, AccessibleApplet
strip out all the sub-components
register for events
(STEVE) - change data orientation here
define null private constructor.
The following are private because the implementation of the
Windows FileChooser L&F is not complete yet.
Preferred and Minimum sizes for the dialog box
Labels, mnemonics, and tooltips (oh my!)
ComponentUI Interface Implementation methods
Directory manipulation buttons
Add the top panel to the fileChooser
Must be small enough to not affect total width.
New Directory Button
View button group
Create icon for viewMenuButton
Forbid keyboard actions if the button is not in rollover state
Add the bottom panel to file chooser
file entry and filters
Decide whether to use the ShellFolder class to populate shortcut
panel and combobox.
Obsolete class, not used in this version.
Obsolete class, not used in this version.
Obsolete class, not used in this version.
Ancestor was added, set initial focus
PENDING(jeff) - get the name from the directory combobox
PENDING(jeff) - set the name in the directory combobox
Forbid keyboard actions if the button is not in rollover state
Reset other buttons
Renderer for DirectoryComboBox
DataModel for DirectoryComboxbox
Add the current directory to the model, and make it the
Get the canonical (full) path. This has the side
benefit of removing extraneous chars from the path,
for example /foo/bar/ becomes /foo/bar
Maybe drive is not ready. Can't abort here.
create File instances of each directory leading up to the top
Insert chain at appropriate place in vector
Renderer for Types ComboBox
DataModel for Types Comboxbox
Ensure that the current filter is in the list.
NOTE: we shouldnt' have to do this, since JFileChooser adds
the filter to the choosable filters list when the filter
is set. Lets be paranoid just in case someone overrides
setFileFilter in JFileChooser.
This shouldn't happen. Try to recover gracefully.
The array to hold all data
Number of elements in this list
Should never occurs...
This could change the preferred size of the Component.
inner class AccessibleAWTLabel
Most Javadoc is deferred to the DirContext interface.
Used by PhotoYCC only
Parameters for writing metadata
If it's there, use it
Add one for the thumbnails
If it's there, use it
Change if needed
/ End of Private variables
/ End of Protected variables
so this will always work
Set the native destination
There isn't much we can do.  If it's one of ours, then
return it.  Otherwise just return null.  We use it only
for tables, so we can't get a default and modify it,
as this will usually not be what is intended.
If it's one of ours, just return it
Can't convert stream metadata to image metadata
XXX Maybe this should put out a warning?
If it's not one of ours, create a default and set it from
the standard tree from the input, if it exists.
Other plug-in generates bogus standard tree
XXX Maybe this should put out a warning?
If the image type and metadata are JFIF compatible, return true
metadata must have a jfif node
if streamMetadata is not null, issue a warning
Obtain the raster and image, if there is one
Use the Raster directly.
Get the unique tile.
Ensure the Raster has dimensions of the image,
as the tile dimensions might differ.
Image is tiled so get a contiguous raster by copying.
Now determine if we are using a band subset
By default, we are using all source bands
Consult the param to determine if we're writing a subset
If this is a subset, we must adjust bandSizes
All the same
4450894 part 1: The IJG libraries are compiled so they only
handle <= 8-bit samples.  We now check the band sizes and throw
an exception for images, such as USHORT_GRAY, with > 8 bits
4450894 part 2: We expand IndexColorModel images to full 24-
or 32-bit in grabPixels() for each scanline.  For indexed
images such as BYTE_BINARY, we need to ensure that we update
bandSizes to account for the scaling from 1-bit band sizes
Destination type, if there is one
Ignore dest type if we are writing a complete image
Examine the param
We'll handle the metadata case later
Now examine the metadata
First set a default state
If it's there, use it
If it's there, use it
Change if needed
By default we'll do no conversion:
By default don't write one
PhotoYCC does this
Check the metadata against the destination type
Do we want to write an ICC profile?
no metadata, but there is a dest type
If we can add a JFIF or an Adobe marker segment, do so
Do we want to write an ICC profile?
re-create the metadata
no destination type
no dest, no metadata, full image
Use default metadata matching the image and param
else no dest, no metadata, not an image,
so no special headers, no color conversion
no dest type, but there is metadata
no dest, metadata, image
Check that the metadata and the image match
out colorspace remains unknown
consult the ids
if they don't resolve it,
consult the sampling factors
consult the ids
if they don't resolve it,
consult the sampling factors
else no dest, metadata, not an image.  Defaults ok
Might still be null
determine if thumbnails can be written
If we are going to add a default JFIF marker segment,
then thumbnails can be written
If there is no metadata, then we can't write thumbnails
There is metadata
If we are writing a raster or subbands,
then the user must specify JFIF on the metadata
Or we can't include thumbnails
It is a full image, and there is metadata
Can it have JFIF?
Nope, not JFIF-compatible
Set up a boolean to indicate whether we need to call back to
Now that we have dealt with metadata, finalize our tables set up
Are we going to write tables?  By default, yes.
But if the metadata has no tables, no.
Ignored if optimizeHuffman is true
Whether we write tables or not, we need to figure out which ones
Get them from metadata, or use defaults
If we are optimizing, we don't want any tables.
If they were for progressive scans, we can't use them.
By default, ids are 1 - N, no subsampling
Now override them with the contents of sof, if there is one,
else use JFIF-compatible default
Create an appropriate 1-line databuffer for writing
Create a raster from that
Call the writer, who will call back for every scanline
Note that getData disables acceleration on buffer, but it is
just a 1-line intermediate data transfer buffer that does not
affect the acceleration of the source image.
After a successful write
write a complete tables-only image at the beginning of
Check that we are
at the beginning of the stream, or can go there, and haven't
written out the metadata already.
Set the tables
If the metadata has no tables, use default tables.
Now write them out
In the case of JPEG this does nothing different from write
reset C structures
reset the native destination
reset C structures
reset local Java structures
End of public API
Provide access to protected superclass method
Provide access to protected superclass method
/ End of Package-access API
Does the metadata frame header, if any, match numBandsUsed?
type overrides metadata
out of for over sof comps
/ End of metadata handling
End of ColorSpace conversion
Native methods and callbacks
If the image has BITMASK transparency, we need to make sure
it gets converted to 32-bit ARGB, because the JPEG encoder
relies upon the full 8-bit alpha channel.
The first time through, converted is null, so
a new raster is allocated.  It is then reused
on subsequent lines.
Every 8 scanlines
it looks like that this reader instance is used
by multiple threads.
Fields for Image Descriptor
Fields for PixelsPerMeter
Fields for BI_BITFIELDS compression(Mask)
Fields for CIE XYZ for the LCS_CALIBRATED_RGB color space
Fields for Gamma values for the LCS_CALIBRATED_RGB color space
Fields for the Palette and Entries
Fields from CommentExtension
List of byte[]
Standard tree node methods
serialVersionUID not constant
Serialization compatibility stuff:
Two serial forms are supported in this class. The selected form depends
on system property "jmx.serial.form":
- "1.0" for JMX 1.0
- any other value for JMX 1.1 and higher
Serial version for old serial form
Serial version for new serial form
Serializable fields in old serial form
Serializable fields in new serial form
Actual serial version and serial form
OK : Too bad, no compat with 1.0
END Serialization compatibility stuff
Can throw InvalidRelationTypeException, ClassNotFoundException
No null RoleInfo allowed, so use get()
Trying to update a declared relation type
Checks if the role info has already been described
Sets the internal flag to specify that the relation type has been
declared in the Relation Service
Initializes the members, i.e. type name and role info list.
-param relationTypeName  Name of relation type
-param roleInfoArray  List of role definitions (RoleInfo objects)
-exception IllegalArgumentException  if null parameter
-exception InvalidRelationTypeException  If:
- the same name has been used for two different roles
- no role info provided
- one null role info provided
Verifies role infos before setting them
Can throw InvalidRelationTypeException
Checks the given RoleInfo array to verify that:
- the array is not empty
- it does not contain a null element
- a given role name is used only for one RoleInfo
-param roleInfoArray  array to be checked
-exception InvalidRelationTypeException  If:
- the same name has been used for two different roles
- no role info provided
- one null role info provided
No role info provided
Checks if the role info has already been described
Read an object serialized in the old serial form
Read an object serialized in the new serial form
Serializes this instance in the old serial form
Serializes this instance in the new serial form
are we already registered?
are we already registered?
Implements the method defined in SnmpMibNode.
Nothing is left... the oid is not valid
The oid is not complete...
Some children variable or subobject is being querried
getChild() will raise an exception if no child is found.
XXXX zzzz : what about null children?
(variables for nested groups)
if child==null, then we're dealing with a variable or
a table: we register this node.
This behaviour should be overriden in subclasses,
in particular in group meta classes: the group
meta classes that hold tables should take care
of forwarding this call to all the tables involved.
Implements the method defined in SnmpMibNode.
This should be considered as a genErr, but we do not want to
abort the whole request, so we're going to throw
search the element specified in the oid
Build up the leaf OID
If there is no such element go one level up ...
There is no need to carry the original oid ...
If a node has several children, let assume that we are one step to
far in order to get the MIB root.
Now query our child.
Check if the node is already defined
System.out.println("entering registration for val="
That 's the end of the trip.
Do not forward the registration
System.out.println("End of trip for val="
System.out.println("Create node for val="
The node is not yet registered
That 's the end of the trip.
Do not forward the registration
System.out.println("End of trip for val="
System.out.println("Create node for val=" +
The node is already registered
System.out.println("Node already registered val=" +
Now we're going to patch the tree the following way:
if a subgroup has been registered before its father,
we're going to replace the father OID node with
the actual group-node and export the children from
the temporary OID node to the actual group node.
`node' is a group => replace `child' with `node'
export the child's subtree to `node'.
`node' is a temporary node, and `child' is a
group => keep child and export the node's
subtree to `child'.
`node' and `child' are both temporary OID nodes
=> replace `child' with `node' and export child's
subtree to `node'.
first we need to retrieve the identifier in the list of children
Access the node
We need to get the next index ...
if (index > a[max])
never know ...we might find something ...
All the methods of the Vector class are synchronized.
Synchronization is a very expensive operation. In our case it is
not always required...
We will never serialize this
cast to E
which facets are allowed for this type
convert a string to an actual value. for example,
for number types (decimal, double, float, and types derived from them),
get the BigDecimal, Double, Flout object.
for some types (string and derived), they just return the string itself
for ID/IDREF/ENTITY types, do some extra checking after the value is
checked to be valid with respect to both lexical representation and
the following methods might not be supported by every DV.
but XSSimpleTypeDecl should know which type supports which methods,
and it's an *internal* error if a method is called on a DV that
doesn't support it.
where there is distinction between identity and equality, this method
will be overwritten
checks whether the two values are identical; for ex, this distinguishes
-0.0 from 0.0
check the order relation between the two values
the parameters are in compiled form (from getActualValue)
get the length of the value
the parameters are in compiled form (from getActualValue)
get the number of digits of the value
the parameters are in compiled form (from getActualValue)
get the number of fraction digits of the value
the parameters are in compiled form (from getActualValue)
check whether the character is in the range 0x30 ~ 0x39
if the character is in the range 0x30 ~ 0x39, return its int value (0~9),
otherwise, return -1
querying week-of-month or week-of-year should return the week value bound within the month/year
however, setting the week value should be lenient (use plus/minus weeks)
allow week-of-month outer range [0 to 6]
allow week-of-year outer range [0 to 54]
this is because callers shouldn't be expected to know the details of validity
Clamp the week of year to keep it in the same year
Day is in end of week of previous year; return the previous year
If getting close to end of year, use higher precision logic
Check if date of year is in partial week associated with next year
Day is in end of week of previous year
Recompute from the last day of the previous year
Back down into previous year
If getting close to end of year, use higher precision logic
Check if date of year is in partial week associated with next year
Overlaps with week of following year; reduce to week in following year
offset of first day corresponding to the day of week in first 7 days (zero origin)
The previous week has the minimum days in the current month to be a 'week'
Check the new value and get the old value of the field
lenient check range
replace year of WeekBasedYear
Create a new date object with the same chronology,
the desired year and the same week and dow.
Compute the difference and add that using the base unit of the field
broad limit makes overflow checking lighter
first convert localized day-of-week to ISO day-of-week
doing this first handles case where both ISO and localized were parsed and might mismatch
day-of-week is always strict as two different day-of-week values makes lenient complex
no leniency as too complex
can only build date if ISO day-of-week is present
not validated yet
week-of-week-based-year and year-of-week-based-year
safe from overflow
safe from overflow
safe from overflow
safe from overflow
safe from overflow
safe from overflow
only have values for week-of-year
Day is in end of week of previous year
Recompute from the last day of the previous year
Back down into previous year
Check if day of year is in partial week associated with next year
Overlaps with weeks of following year; recompute from a week in following year
Required SERVICE_CONTEXT_ID and getId definitions
Count size of arguments
indices 2, 3
Finalizer thread starts before System.initializeSystemClass
is called.  Wait until JavaLangAccess is available
delay until VM completes initialization
ignore and continue
ignore and continue
Internal buffer used to hold input
Size of internal character buffer
The index into the buffer currently held by the Scanner
Internal matcher used for finding delimiters
Pattern used to delimit tokens
Pattern found in last hasNext operation
Position after last hasNext operation
Result after last hasNext operation
The input source
Boolean is true if source is done
Boolean indicating more input is required
Boolean indicating if a delim has been skipped this operation
A store of a position that the scanner may fall back to
A cache of the last primitive type scanned
Boolean indicating if a match result is available
Boolean indicating if this scanner has been closed
The current radix used by this scanner
The default radix for this scanner
The locale used by this scanner
A cache of the last few recently used Patterns
A holder of the last IOException encountered
A pattern for java whitespace
A pattern for any token
A pattern for non-ASCII digits
Fields and methods to support scanning primitive types
here but what can we do? The final authority will be
whatever parse method is invoked, so ultimately the
Scanner will do the right thing
digit++ is the possessive form which is necessary for reducing
backtracking that would otherwise cause unacceptable performance
Once again digit++ is used for performance, as above
IllegalArgumentException should be thrown
Private primitives used to support scanning
Clears both regular cache and type cache
Also clears both the regular cache and the type cache
Also clears both the regular cache and the type cache
Tries to read more input. May block.
Prepare to receive data
Restore current position and limit for reading
After this method is called there will either be an exception
or else there will be space in the buffer
Gain space by compacting buffer
Gain space by growing buffer
When a buffer compaction/reallocation occurs the saved indexes must
be modified appropriately
If there is still input left then InputMismatch
Returns true if a complete token or partial token is in the buffer.
It is not necessary to find a complete token since a partial token
means that there will be another token with or without more input.
Skip delims first
If we are sitting at the end, no more tokens in buffer
Skip delims first
Enforcing only one skip of leading delims
If more input could extend the delimiters then we must wait
for more input
The delims were whole and the matcher should skip them
If we are sitting at the end, no more tokens in buffer
Must look for next delims. Simply attempting to match the
pattern at this point may find a match but it might not be
the first longest match because of missing input, or it might
match a partial token instead of the whole thing.
Then look for next delims
Zero length delimiter match; we should find the next one
Otherwise we have just found the same one we just skipped
In the rare case that more input could cause the match
to be lost and there is more input coming we must wait
for more input. Note that hitting the end is okay as long
as the match cannot go away. It is the beginning of the
next delims we want to be sure about, we don't care if
they potentially extend further.
There is a complete token.
Must continue with match to provide valid MatchResult
Attempt to match against the desired pattern
Complete token but it does not match
If we can't find the next delims but no more input is coming,
then we can treat the remainder as a whole token
Must continue with match to provide valid MatchResult
Last token; Match the pattern here or throw
Last piece does not match
There is a partial token in the buffer; must read more
to complete it
Finds the specified pattern in the buffer up to horizon.
Returns a match for the specified input pattern.
The match may be longer if didn't hit horizon or real end
Hit an artificial end; try to extend the match
The match could go away depending on what is next
Rare case: we hit the end of input and it happens
that it is at the horizon and the end of input is
required for the match.
Did not hit end, or hit real end, or hit horizon
If there is no specified horizon, or if we have not searched
to the specified horizon yet, get more input
Returns a match for the specified input pattern anchored at
the current position
Get more input and try again
Read more to find pattern
Throws if the scanner is closed
These must be literalized to avoid collision with regex
metacharacters such as dot or parenthesis
Quoting the nonzero length locale-specific things
to avoid potential conflict with metacharacters
Force rebuilding and recompilation of locale dependent
Force rebuilding and recompilation of radix dependent patterns
The next operation should occur in the specified radix but
the default is left untouched.
Force rebuilding and recompilation of radix dependent patterns
Did we already find this pattern?
Search for the pattern
Public methods that ignore delimiters
Expand buffer to include the next newline or end of input
up to next newline
up to end of input
If there is nothing between the current pos and the next
newline simply return null, invoking findWithinHorizon
with "horizon=0" will scan beyond the line bound.
Search for the pattern
Search for the pattern
up to end of input
Search for the pattern
Convenience methods for scanning primitives
Check cached result
Search for next byte
don't skip bad token
Check cached result
Search for next short
don't skip bad token
Check cached result
Search for next int
don't skip bad token
Check cached result
don't skip bad token
Translate non-ASCII digits
Check cached result
don't skip bad token
Check cached result
Search for next float
don't skip bad token
Convenience methods for scanning multi precision numbers
Check cached result
Search for next int
don't skip bad token
Check cached result
Search for next float
don't skip bad token
Make our own copy now, which is exactly the right size
must match order
ignore mixed text
element must match
can appear in any order
Get the current child out of the source index
If its PCDATA, then we just accept that
And try to find it in our list
REVISIT: What about checking for multiple ANY matches?
The content model ambiguity *could* be checked
by the caller before constructing the mixed
We did not find this one, so the validation failed
Everything seems to be in order, so return success
-- This file was mechanically generated: Do not edit! --
Other useful constants
Encoding related constants
1.1 & 1.2:
The ORB that created the factory this codec was created from
The GIOP version we are encoding for
_REVISIT_ Note that InvalidTypeForEncoding is never thrown in
the body of this method.  This is due to the fact that CDR*Stream
will never throw an exception if the encoding is invalid.  To
fix this, the CDROutputStream must know the version of GIOP it
is encoding for and it must check to ensure that, for example,
wstring cannot be encoded in GIOP 1.0.
As part of the GIOP 1.2 work, the CDRInput and OutputStream will
be versioned.  This can be handled once this work is complete.
Create output stream with default endianness.
This is an encapsulation, so put out the endian:
Sometimes encode type code:
Encode value and return.
_REVISIT_ Currently there is no way for us to distinguish between
a FormatMismatch and a TypeMismatch because we cannot get this
information from the CDRInputStream.  If a RuntimeException occurs,
it is turned into a FormatMismatch exception.
If type code not specified, read it from octet stream:
Create a new Any object:
See above note.
Check for trivial rejection - point is outside bounding rectangle
Check which corner point is in and do circular containment
test - otherwise simple acceptance
Check for trivial rejection - bounding rectangles do not intersect
Trivially accept if any point is inside inner rectangle
Trivially accept if either edge spans inner rectangle
Since neither edge spans the center, then one of the corners
must be in one of the rounded edges.  We detect this case if
a [xy]0class is 3 or a [xy]1class is 1.  One of those two cases
must be true for each direction.
We now find a "nearest point" to test for being inside a rounded
private constructor defined to "hide" the default public constructor
PUBLIC STATIC CONSTANTS
non-private to simplify nested class access
c.toArray might (incorrectly) not return Object[] (see 6260652)
replace with empty array.
any size if not default element table
larger than default for default empty table. It's already
supposed to be at default size.
minCapacity is usually close to size, so this is a win:
this shouldn't happen, since we are Cloneable
Make a new array of a's runtime type, but my contents:
Positional Access Operations
clear to let GC do its work
clear to let GC do its work
clear to let GC do its work
clear to let GC do its work
Preserve behavioral compatibility with AbstractCollection,
even if c.contains() throws.
clear to let GC do its work
Write out element count, and any hidden stuff
Write out size as capacity for behavioural compatibility with clone()
Write out all elements in the proper order.
Read in size, and any hidden stuff
Read in capacity
be like clone(), allocate array based upon size not capacity
Read in all elements in the proper order.
index of next element to return
index of last element returned; -1 if no such
update once at end of iteration to reduce heap write traffic
update once at end of iteration to reduce heap write traffic
current index, modified on advance/split
-1 until used; then one past last index
initialized when fence set
OK if null unless traversed
initialize fence to size on first use
(a specialized variant appears in method forEach)
divide range in half unless too small
hoist accesses and checks from loop
figure out which elements are to be removed
any exception thrown from the filter predicate at this stage
will leave the collection unmodified
shift surviving elements left over the spaces left by removed elements
Let gc do its work
the fix for 4785160 is undone
rebuild the view
the fix for 4785160 is undone
the fix for 4785160 is undone
build a view that support bidi
no limit if unwrapped
min is pref if unwrapped
We have been initially set to MAX_VALUE, but we
don't want this as our preferred.
The following methods don't do anything useful, they
simply keep the class from being abstract.
No reason to do this now, but will still call it.
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
if (e == null)
This is currently rather expensive.  Needs
to be better support from ListSelectionModel to speed this up.
Lead selection path doesn't have to be in the selection.
find the actual selection pathes corresponded to the
rows of the new selection
Can use == here since we know leadPath came from
Save the rowMapper, if it implements Serializable
Log wrapper class for Sun private system exceptions in group IOR
Generated by MC.java version 1.0, DO NOT EDIT BY HAND!
Generated from input file c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/corba/src/share/classes/com/sun/corba/se/spi/logging/data/IOR.mc on Fri Jul 21 21:58:44 PDT 2017
last modification time (in extended DOS time,
where milliseconds lost in conversion might
be encoded into the upper half)
last modification time, from extra field data
last access time, from extra field data
creation time, from extra field data
crc-32 of entry data
uncompressed size of entry data
compressed size of entry data
general purpose flag
optional extra field data for entry
optional comment string for entry
Avoid setting the mtime field if time is in the valid
range for a DOS time
extra fields are in "HeaderID(2)DataSize(2)Data... format
LOC extra zip64 entry MUST include BOTH original
and compressed file size fields.
If invalid zip64 extra fields, simply skip. Even
it's rare, it's possible the entry size happens to
be the magic value and it "accidently" has some
bytes in extra match the id.
reserved  4 bytes + tag 2 bytes + size 2 bytes
m[a|c]time 24 bytes
reserved 4 bytes
The CEN-header extra field contains the modification
time only, or no timestamp at all. 'sz' is used to
flag its presence or absence. But if mtime is present
in LOC it must be present in CEN as well.
This should never happen, since we are Cloneable
NamedNodeMap must be explicitly replicated to avoid sharing
_REVISIT_ cannot link to Stub.readObject directly... why not?
_REVISIT_ cannot link to Stub.writeObject directly... why not?
populate Object array
size - 1 == current
Set in endDocument()
Save the reference to the transformer
Set initial handler to the empty handler
Get a reference to the translet wrapped inside the transformer
Connect this object with output system directly
Run the transformation now, if not already done
What the hell are we supposed to do with this???
Make sure setResult() was called before the first SAX event
Create an internal DOM (not W3C) and get SAX2 input handler
Construct the DTM using the SAX events that come through
Set document URI
Signal to the DOMBuilder that the document is complete
Run the transformation now if we have a reference to a Result object
Signal that the internal DOM is built (see 'setResult()').
Set this DOM as the transformer's DOM
Some places assume margins are non-null.
Not needed in this case
Remove values from the parent's Client Properties.
Refetch the appropriate check indicator for the current state
Return just the name of the class, not the full qualified name.
ordered from large to small
Invariants: mark <= position <= limit <= capacity
Used only by direct buffers
NOTE: hoisted here for speed in JNI GetDirectBufferAddress
Creates a new buffer with the given mark, position, limit, and capacity,
after checking invariants.
-- Package-private methods for bounds checking, etc. --
true when the next token should be 'Step' (as defined in
the production rule [3] of XML Schema P1 section 3.11.6
if false, we are expecting either '|' or '/'.
this is to make sure we can detect a token list like
'abc' '/' '/' 'def' 'ghi'
unless this is the first step in this location path,
there's really no reason to keep them in LocationPath.
This amounts to shorten "a/././b/./c" to "a/b/c".
Also, the matcher fails to work correctly if XPath
has those redundant dots.
this cannot appear in arbitrary position.
it is only allowed right after '.' when
'.' is the first token of a location path.
we should have covered all the tokens that we can possibly see.
save location path
consume QName token
location path information
DEBUG: This code is just for debugging and should *not*
be left in because it will mess up hashcodes of
serialized versions of this object. -Ac
NOTE: The XPath implementation classes are kept internal because
this implementation is just a temporary hack until a better
and/or more appropriate implementation can be written.
keeping the code in separate source files would "muddy" the
CVS directory when it's not needed. -Ac
[37] NameTest ::= '*' | NCName ':' '*' | QName
followed by symbol handle of NCName or QName
[38] NodeType ::= 'comment' | 'text' | 'processing-instruction' | 'node'
[32] Operator ::= OperatorName
| '/' | '' | '|' | '+' | '-' | '=' | '!=' | '<' | '<=' | '>' | '>='
[33] OperatorName ::= 'and' | 'or' | 'mod' | 'div'
[34] MultiplyOperator ::= '*'
EXPRTOKEN_FIRST_OPERATOR                = EXPRTOKEN_OPERATOR_AND,
EXPRTOKEN_LAST_OPERATOR                 = EXPRTOKEN_OPERATOR_GREATER_EQUAL,
[35] FunctionName ::= QName - NodeType
followed by symbol handle
[6] AxisName ::= 'ancestor' | 'ancestor-or-self'
| 'descendant' | 'descendant-or-self'
| 'following' | 'following-sibling'
| 'preceding' | 'preceding-sibling'
[29] Literal ::= '"' [^"]* '"' | "'" [^']* "'"
followed by symbol handle for literal
[30] Number ::= Digits ('.' Digits?)? | '.' Digits
[31] Digits ::= [0-9]+
followed by number handle
[36] VariableReference ::= '$' QName
followed by symbol handle for QName
REVISIT: Code something better here. -Ac
REVISIT: Code something better here. -Ac
if (token < 0 || token >= fgTokenNames.length)
invalid XML character
one of "\t\n\r " (0x09, 0x0A, 0x0D, 0x20)
'\"' or '\'' (0x22 and 0x27)
'0'-'9' (0x30 to 0x39)
'A'-'Z' or 'a'-'z' (0x41 to 0x5A and 0x61 to 0x7A)
Non-ASCII Unicode codepoint (>= 0x80)
save pool and tokens
[39] ExprWhitespace ::= S
[28] ExprToken ::= '(' | ')' | '[' | ']' | '.' | '..' | '@' | ',' | '::'
| NameTest | NodeType | Operator | FunctionName
| AxisName | Literal | Number | VariableReference
[30] Number ::= Digits ('.' Digits?)? | '.' Digits
'.', '..' or '.' Digits
this is legal if the next token is non-existent or |
'/' and ''
'<' and '<='
'>' and '>='
[29] Literal ::= '"' [^"]* '"' | "'" [^']* "'"
'\"' or '\''
[30] Number ::= Digits ('.' Digits?)? | '.' Digits
[31] Digits ::= [0-9]+
[36] VariableReference ::= '$' QName
[37] NameTest ::= '*' | NCName ':' '*' | QName
[34] MultiplyOperator ::= '*'
3.7 Lexical Structure
If there is a preceding token and the preceding token is not one of @, ::, (, [, , or
an Operator, then a * must be recognized as a MultiplyOperator.
Otherwise, the token must not be recognized as a MultiplyOperator.
NCName, QName and non-terminals
possibly a valid non-ascii 'Letter' (BaseChar | Ideographic)
3.7 Lexical Structure
If there is a preceding token and the preceding token is not one of @, ::, (, [, , or
an Operator, then an NCName must be recognized as an OperatorName.
If the character following an NCName (possibly after intervening ExprWhitespace) is (,
then the token must be recognized as a NodeType or a FunctionName.
If the two characters following an NCName (possibly after intervening ExprWhitespace)
are ::, then the token must be recognized as an AxisName.
Otherwise, the token must not be recognized as an OperatorName, a NodeType, a
FunctionName, or an AxisName.
[33] OperatorName ::= 'and' | 'or' | 'mod' | 'div'
[38] NodeType ::= 'comment' | 'text' | 'processing-instruction' | 'node'
[35] FunctionName ::= QName - NodeType
[6] AxisName ::= (see above)
[37] NameTest ::= '*' | NCName ':' '*' | QName
[5] NCName ::= (Letter | '_') (NCNameChar)*
[?] NCNameChar ::= Letter | Digit | '.' | '-' | '_'  (ascii subset of 'NCNameChar')
[?] QName ::= (NCName ':')? NCName
[?] Letter ::= [A-Za-z]                              (ascii subset of 'Letter')
[?] Digit ::= [0-9]                                  (ascii subset of 'Digit')
[39] ExprWhitespace ::= S
If there is a preceding token and the preceding token is not one of @, ::, (, [, , or
an Operator, then an NCName must be recognized as an OperatorName.
REVISIT - NCName:* where an OperatorName is required
REVISIT - AxisName:: where an OperatorName is required
If the character following an NCName (possibly after intervening ExprWhitespace) is (,
then the token must be recognized as a NodeType or a FunctionName.
If the two characters following an NCName (possibly after intervening ExprWhitespace)
are ::, then the token must be recognized as an AxisName.
REVISIT - "NCName:* ::" where "AxisName ::" is required
Otherwise, the token must not be recognized as an OperatorName, a NodeType, a
FunctionName, or an AxisName.
[5] NCName ::= (Letter | '_') (NCNameChar)*
[6] NCNameChar ::= Letter | Digit | '.' | '-' | '_' | CombiningChar | Extender
[30] Number ::= Digits ('.' Digits?)? | '.' Digits
[31] Digits ::= [0-9]+
will replace the deserialized 'this' object
first lookup the hostname
XXX: if it looks a spoof just return the address?
let next provider resolve the hostname
put THIS in cache
purge any expired entries
As we iterate in insertion order we can
terminate when a non-expired entry is found.
create new entry and add it to the cache
-- as a HashMap replaces existing entries we
don't need to explicitly check if there is
already an entry for this host.
check if entry has expired
search both positive & negative caches
initialize the default name service
create the impl
get name service if provided and requested
if not designate any name services provider,
create a default one
called from deployment cache manager
This is supposed to be an IPv6 literal
This was supposed to be a IPv6 address, but it's not!
if host is an IP address, we won't do further lookup
see if it is IPv4 address
This is supposed to be an IPv6 literal
Check if a numeric or string zone id is present
Means an IPv4 litteral between brackets!
We were expecting an IPv6 Litteral, but got something else
Check whether the host is in the lookupTable.
1) If the host isn't in the lookupTable when
checkLookupTable() is called, checkLookupTable()
would add the host in the lookupTable and
return null. So we will do the lookup.
2) If the host is in the lookupTable when
checkLookupTable() is called, the current thread
would be blocked until the host is removed
from the lookupTable. Then this thread
should try to look up the addressCache.
i) if it found the addresses in the
addressCache, checkLookupTable()  would
return the addresses.
ii) if it didn't find the addresses in the
addressCache for any reason,
it should add the host in the
lookupTable and return null so the
following code would do  a lookup itself.
This is the first thread which looks up the addresses
this host or the cache entry for this host has been
expired so this thread should do the lookup.
More to do?
Cache the address.
Delete host from the lookupTable and notify
all threads waiting on the lookupTable monitor.
If the host isn't in the lookupTable, add it in the
lookuptable and return null. The caller should do
If the host is in the lookupTable, it means that another
thread is trying to look up the addresses of this host.
This thread should wait.
The other thread has finished looking up the addresses of
the host. This thread should retry to get the addresses
from the addressCache. If it doesn't get the addresses from
the cache, it will try to look up the addresses itself.
Less than 5s old?
we are calling getAddressesFromNameService directly
to avoid getting localHost from cache
Rethrow with a more informative error message.
Get two copies of the argument on the stack
Remove listeners previously registered in shared model
when a new UI component is replaced.  See bug 7189299.
case of JButton whose model is DefaultButtonModel
Need to remove stale ActionListener, ChangeListener and
ItemListener that are instance of AbstractButton$Handler.
case of JComboBox and JList
For JList, the stale ListDataListener is instance
For JComboBox, there are 2 stale ListDataListeners, which are
BasicListUI$Handler and BasicComboBoxUI$Handler.
case of JPasswordField, JTextField and JTextArea
All have 2 stale DocumentListeners.
setPage() may take significant time so schedule it to run later.
find the top-most JEditorPane holding the frameset view.
do nothing - this submit is not the trigger
images only result in data if they triggered
the submit and they require that the mouse click
coords be appended to the data.  Hence its
processing is handled by the view.
PENDING: When mime support is added to JFileChooser use the
accept value of attrs.
Potential values in mask.
valueToString doesn't throw, but stringToValue does, need to
update the editValid state appropriately
else: Could actually throw if else
Assume the mask isn't all literals.
This method is rather long, but much of the burden is in
maintaining a String and swapping to a StringBuilder only if
Backspace, adjust to actually delete next non-literal.
Evaluate the character in text again.
Interal classes used to represent the mask.
These message should be read from a locale-specific resource bundle
inline to avoid creating object and Instant checks
overflow caught later
find the march-based year
adjust to 0000-03-01 so leap day is at end of four year cycle
adjust negative years to positive for calculation
reset any negative year
convert march-based values back to january-based
check year now we are certain it is correct
override for Javadoc
override for Javadoc
override for Javadoc and performance
override for Javadoc
override for Javadoc and performance
override for Javadoc and performance
override for Javadoc
override for Javadoc and performance
need to handle case where there is a gap from 11:30 to 00:30
standard ZDT factory would result in 01:00 rather than 00:30
override for Javadoc and performance
override for Javadoc and performance
override for Javadoc and performance
override for Javadoc and performance
it must be older than 1.4.
keep it for the compability for the fix:
6174229: Environment parameter should be notification.buffer.size
instead of buffer.size
the default value re-specified in the system
try the old one
try the old one
ObjectOutputStream invalid after exception
returns a default value of 'false' if no property is found...
Comparison and hashing
There are 4 "looks" to the Motif CheckBox:
drawCheckBezelOut  -  default unchecked state
drawBezel          -  when we uncheck in toggled state
drawCheckBezel     -  when we check in toggle state
drawCheckBezelIn   -  selected, mouseReleased
toggled from unchecked to checked
show checked, unpressed state
show unchecked state
inner 3D border
black drop shadow  __|
end class CheckBoxIcon
end class RadioButtonIcon
end class MenuItemCheckIcon
end class MenuItemArrowIcon
These variables are kind of pointless as the following code
assumes the icon will be 10 x 10 regardless of their value.
End class MenuArrowIcon
if null, then Element namespace is empty.
Element name (String) -> Element
Child names (Strings)
Parent names (Strings)
List of attribute names in the order they were added
Attr name (String) -> Attribute
Meaningful only if valueType == VALUE_ENUMERATION
Meaningful only if valueType == VALUE_RANGE
Meaningful only if valueType == VALUE_LIST
Utility method for locating an attribute
Methods from IIOMetadataFormat
Standard format descriptor
public static final:  JLS says recommended style is to omit these modifiers
because they are the default
TO DO:  Consider placing intern logic here, to cut down on duplication.
lambdaForm = findPreexistingEquivalent(lambdaForm)
Always use uncustomized version for editing.
It helps caching and customized LambdaForms reuse transformCache field to keep a link to uncustomized version.
necessary because ordinal must be greater than zero
maybe add more for guard with test, catch exception, pointwise type conversions
turn on to disable most packing
incoming values must fit in *unsigned* byte
incoming value must fit in *unsigned* byte
The transformCache is one of null, Transform, Transform[], or ConcurrentHashMap.
one-element cache avoids overhead of an array
overwrite stale entry
expand one-element cache to small array
it is already expanded
remember 1st stale entry index
just fall through to cache update
The second iteration will update for this query, concurrently.
/ Editing methods for method handles.  These need to have fast paths.
/ Editing methods for lambda forms.
Each editing method can (potentially) cache the edited LF so that it can be reused later.
BMH holding the values
The newly created LF will run with a different BMH.
Switch over any pre-existing BMH field references to the new BMH class.
cannot bind the MH arg itself, unless oldData is empty
cannot spread the MH arg itself
insert the new expressions
adjust the arguments
pure side effect
return null if it requires more metadata (like String[].class)
cannot filter the MH arg itself
insert the new expression
insert new arguments
skip result parameter
cannot filter the MH arg itself
The newly created LF will run with a different BMH.
Switch over any pre-existing BMH field references to the new BMH class.
BMH holding the values
insert the two new expressions
insert new arguments, if needed
skip result parameter
Synthesize a constant zero value for the given type.
The newly created LF will run with a different BMH.
Switch over any pre-existing BMH field references to the new BMH class.
BMH holding the values
skip only the leading MH argument, names[0]
do not bother to cache
Necessary to pass the appropriate fields into the
defaultReadObjectDelegate method (which takes no
parameters since it's called from
which we can't change).
This is only used in the case where the fields had
to be obtained remotely because of a serializable
version difference.  Set in inputObjectUsingFVD.
Part of serialization evolution fixes for Ladybird,
The ActiveRecursionManager replaces the old RecursionManager which
used to record how many recursions were made, and resolve them after
an object was completely deserialized.
That created problems (as in bug 4414154) because when custom
unmarshaling in readObject, there can be recursive references
to one of the objects currently being unmarshaled, and the
passive recursion system failed.
Serialization machinery fields
TCKind TypeCodes used in FVD inputClassFields
removed TypeCodeImpl dependency
TESTING CODE - useFVDOnly should be made final before FCS in order to
optimize out the check.
Since java.io.OptionalDataException's constructors are
package private, but we need to throw it in some special
cases, we try to do it by reflection.
Grab the OptionalDataException boolean ctor and make
it accessible.  Note that any exceptions
will be wrapped in ExceptionInInitializerErrors.
XXX I18N, logging needed.
XXX I18N, logging needed.
Create a new OptionalDataException with the EOF marker
set to true.  See handleOptionalDataMarshalException.
XXX I18N, logging needed.
XXX I18N, logging needed.
Return the stream format version currently being used
to deserialize an object
At the beginning of data sent by a writeObject or
writeExternal method there is a byte telling the
reader the stream format version.
XXX I18N?  Logging for IOException?
XXX I18N?  Logging for IOException?
added setSender and getSender
4365188 this is added to enable backward compatability w/ wrong
The CDR stream had never seen the given offset before,
so check the recursion manager (it will throw an
IOException if it doesn't have a reference, either).
d4365188: backward compatability
XXX I18N, logging needed.
The array will be null unless fields were retrieved
remotely because of a serializable version difference.
Bug fix for 4365188.  See the definition of
defaultReadObjectFVDMembers for more information.
WARNING:  Be very careful!  What if some of
these fields actually have to do this, too?
This works because the defaultReadObjectFVDMembers
reference is passed to inputClassFields, but
there is no guarantee that
defaultReadObjectFVDMembers will point to the
same array after calling inputClassFields.
Use the remote fields to unmarshal.
Use the local fields to unmarshal.
The following three methods allow the implementing orbStream
to provide mark/reset behavior as defined in java.io.InputStream.
d11623 : implement readFully, required for serializing some core classes
d11623 : implement readFully, required for serializing some core classes
XXX I18N, logging needed.
If the ORB stream detects an incompatibility between what's
on the wire and what our Serializable's readObject wants,
it throws a MARSHAL exception with a specific minor code.
This is rethrown to the readObject as an OptionalDataException.
So far in RMI-IIOP, this process isn't specific enough to
tell the readObject how much data is available, so we always
set the OptionalDataException's EOF marker to true.
Java Object Serialization spec 3.4: "If the readObject method
of the class attempts to read more data than is present in the
optional part of the stream for this class, the stream will
return -1 for bytewise reads, throw an EOFException for
primitive data reads, or throw an OptionalDataException
with the eof field set to true for object reads."
XXX I18N, logging needed.
XXX I18N, logging needed.
XXX I18N, logging needed.
XXX I18N, logging needed.
Store this object and its beginning position
since there might be indirections to it while
it's been unmarshalled.
Read format version
end : if (currentClassDesc.isExternalizable())
current top of stack
d11861 we should stop when we find the highest serializable class
We need this so that when we allocate the new object below, we
can call the constructor of the non-serializable superclass.
Note that in the JRMP variant of this code the
ObjectStreamClass.lookup() method handles this, but we've put
this fix here rather than change lookup because the new behaviour
is needed in other cases.
found a superclass that matches this descriptor
end : for (cl = currclass; cl != null; cl = cl.getSuperclass())
Store this object and its beginning position
since there might be indirections to it while
it's been unmarshalled.
Changed since invokeObjectReader no longer does this.
Read format version
Read defaultWriteObject indicator
Error case of no readObject and didn't call
defaultWriteObject handled in default state
_REVISIT_ : Can we ever get here?
Make sure we exit at the same stack level as when we started.
We've completed deserializing this object.  Any
future indirections will be handled correctly at the
CDR level.  The ActiveRecursionManager only deals with
objects currently being deserialized.
This retrieves a vector of FVD's for the hierarchy of serializable classes stemming from
repositoryID.  It is assumed that the sender will not provide base_value id's for non-serializable
current top of stack
Store this object and its beginning position
since there might be indirections to it while
it's been unmarshalled.
Read format version
found a superclass that matches this descriptor
end : for (cl = currclass; cl != null; cl = cl.getSuperclass())
Store this object and its beginning position
since there might be indirections to it while
it's been unmarshalled.
d4365188: backward compatability
Read and throw away one level of the fvdslist
This seems to mean that the sender had a superclass that
we don't have
WARNING: If stream format version is 1 and there's
optional data, we'll get some form of exception down
the line or data corruption.
If the sender used custom marshaling, then it should have put
the two bytes on the wire indicating stream format version
and whether or not the writeObject method called
Read format version
Read defaultWriteObject indicator
Always use readObject if it exists, and fall back to default
unmarshaling if it doesn't.
See the definition of defaultReadObjectFVDMembers
for more information.  This concerns making sure
we use the remote FVD's members in defaultReadObject.
Note that the !usedReadObject !calledDefaultWriteObject
case is handled by the beginUnmarshalCustomValue method
of the default state
The remaining hierarchy of the local class does not match the sender's FVD.
So, use remaining FVDs to read data off wire.  If any remaining FVDs indicate
custom marshaling, throw MARSHAL error.
end : while(fvdsList.hasMoreElements())
Make sure we exit at the same stack level as when we started.
We've completed deserializing this object.  Any
future indirections will be handled correctly at the
CDR level.  The ActiveRecursionManager only deals with
objects currently being deserialized.
WARNING: If stream format version is 1 and there's
optional data, we'll get some form of exception down
Use default marshaling
end : while(fvdsList.hasMoreElements())
XXX I18N, logging needed.
discard any pending callbacks
XXX I18N, logging needed.
Make sure type = null
Decide what method call to make based on the type. If
it is a type for which we need to load a stub, convert
the type to the correct stub type.
NOTE : Since FullValueDescription does not allow us
to ask whether something is an interface we do not
have the ability to optimize this check.
RMI Object reference...
REVISIT.  If we don't have the local class,
we should probably verify that it's an RMI type,
query the remote FVD, and use is_abstract.
Our FVD seems to get NullPointerExceptions for any
This uses the local class in the same way as
inputObjectField(ObjectStreamField) does.  REVISIT
logic.  Assumption is that the given type cannot
evolve to become a CORBA abstract interface or
a RMI abstract interface.
Now that we have used the FVD of the field to determine the proper course
of action, it is ok to use the type (Class) from this point forward since
the rep. id for this read will also follow on the wire.
XXX I18N, logging needed.
fields have an API to provide the actual class
corresponding to the data type
This may change if stub loaded.
Decide what method call to make based on the fieldType. If
it is a type for which we need to load a stub, convert
the type to the correct stub type.
RMI Object reference...
IDL Object reference...
IDL Abstract Object reference...
RMI Abstract Object reference...
XXX I18N, logging needed.
Must have this local variable since defaultReadObjectFVDMembers
may get mangled by recursion.
Backwards compatibility.  Older Sun ORBs sent
_tk_char even though they read and wrote wchars
Fall through to the _tk_wchar case.
The CDR stream had never seen the given offset before,
so check the recursion manager (it will throw an
IOException if it doesn't have a reference, either).
XXX I18N, logging needed.
Handle the primitives first
XXX I18N, logging needed.
The CDR stream had never seen the given offset before,
so check the recursion manager (it will throw an
IOException if it doesn't have a reference, either).
The CDR stream had never seen the given offset before,
so check the recursion manager (it will throw an
IOException if it doesn't have a reference, either).
check input field type is a declared field type
input field is a subclass of the declared field
end : for loop
Backwards compatibility.  Older Sun ORBs sent
_tk_char even though they read and wrote wchars
Fall through to the _tk_wchar case.
The CDR stream had never seen the given offset before,
so check the recursion manager (it will throw an
IOException if it doesn't have a reference, either).
REVISIT.  Convert to a log message.
This is a normal case when fields have
been added as part of evolution, but
silently skipping can make it hard to
debug if there's an error
System.out.println("**** warning, not setting field: "
+ " since not on class "
XXX I18N, logging needed.
XXX I18N, logging needed.
XXX I18N, logging needed.
XXX I18N, logging needed.
Backwards compatibility.  Older Sun ORBs sent
_tk_char even though they read and wrote wchars
Fall through to the _tk_wchar case.
Make sure type = null
Decide what method call to make based on the type.
NOTE : Since FullValueDescription does not allow us
to ask whether something is an interface we do not
have the ability to optimize this check.
RMI Object reference...
RMI Abstract Object reference...
Now that we have used the FVD of the field to determine the proper course
of action, it is ok to use the type (Class) from this point forward since
the rep. id for this read will also follow on the wire.
XXX I18N, logging needed.
Since we are throwing this away, don't bother handling recursion.
XXX I18N, logging needed.
XXX I18N, logging needed.
A hash map is unsynchronized and allows
Called right after allocating a new object.
Offset is the starting position in the stream
of the object.
If the given starting position doesn't refer
to the beginning of an object currently being
deserialized, this throws an IOException.
Otherwise, it returns a reference to the
XXX I18N, logging needed.
Called when an object has been completely
deserialized, so it should no longer be in
this mapping.  The CDR level can handle
If the given offset doesn't map to an Object,
then it isn't an indirection to an object
currently being deserialized.
tracks which AppContext
created the FS window
this lock is used for making synchronous changes to the AppContext's
current full screen window
Check if this window is in fullscreen mode on another device.
if the window went into fs mode before it was realized it may
have (0,0) dimensions
Set the full screen window
Associate fullscreen window with current AppContext
Note that we use the graphics configuration of the device,
not the window's, because we're setting the fs window for
Update graphics configuration here directly and do not wait
asynchronous notification from the peer. Note that
setBounds() will reset a GC, if it was set incorrectly.
Only return a handle to the current fs window if we are in the
same AppContext that set the fs window
TODO: cache translucency capable GC
If the default GC supports translucency return true.
It is important to optimize the verification this way,
see CR 6661196 for more details.
... otherwise iterate through all the GCs.
Obtain all the keys from the property object
Common UI methods
Set the line color so the line border gets the correct
------------------------- JDBC 4.0 -----------------------------------
--------------------------JDBC 4.2 -----------------------------
End of file.
BasicMenuUI also uses this.
trace creates and disposes
show reuse hits/misses
show bad params, misc.
NOTE: BasicMenuUI also calls into this method.
use default if missing so that BasicMenuItemUI can be used in other
LAFs like Nimbus
MenuItem specific defaults
Get accelerator delimiter
In case of column layout, .checkIconFactory is defined for this UI,
the icon is compatible with it and useCheckAndArrow() is true,
then the icon is handled by the checkIcon.
The method also determines the preferred width of the
parent popup menu (through DefaultMenuLayout class).
The menu width equals to the maximal width
among child menu items.
Menu item width will be a sum of the widest check icon, label,
arrow icon and accelerator text among neighbor menu items.
For the latest menu item we will know the maximal widths exactly.
It will be the widest menu item and it will determine
the width of the parent popup menu.
There is a conceptual problem: if user sets preferred size manually
for a menu item, this method won't be called for it
maximal widths won't be calculated, other menu items won't be able
to take them into account and will be layouted in such a way,
as there is no the item with manual preferred size.
But after the first paint() method call, all maximal widths
will be correctly calculated and layout of some menu items
can be changed. For example, it can cause a shift of
the icon and text when user points a menu item by mouse.
Calculate the result width
Take into account mimimal text offset.
Calculate the result height
Take into account menu item insets
if the width is even, bump it up one. This is critical
for the focus dash line to draw properly
if the height is even, bump it up one. This is critical
for the text to center properly
Save original graphics font and color
Restore original graphics font and color
Use default icon
Text is HTML
Text isn't HTML
Uses protected field.
The parent popup menu is the last so far
A sibling menuitem is the current selection
This probably needs to handle 'exit submenu into
a menu item.  Search backwards along the current
selection until you find the parent popup menu,
then copy up to that and add yourself...
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
BasicMenuUI subclasses this.
4188027: drag enter/exit added in JDK 1.1.7A, JDK1.2
4188027: drag enter/exit added in JDK 1.1.7A, JDK1.2
remove the old html view client property if one
existed, and install a new one if the text installed
into the JLabel is html source.
Public static methods
get node factory
traverse source tree
copy this node
iterate over children
search for node
search for node
search for node
search for node
search for node
search for node
search for node
get next visible (un-hidden) node.
search for node
get next visible (un-hidden) node, overload previous method for non Xerces node impl
search for node
set this Node as being hidden
set this Node as being hidden, overloaded method
set this Node as being visible
set this Node as being visible, overloaded method
is this node hidden?
is this node hidden? overloaded method
search for node
search for node
search for node
search for node
search for node
search for node
search for node
search for node
search for node
search for node
search for node
search for node
search for node
search for node
search for node
is there anything to do?
concatenate children text
return text value
return the name of this element
get the Document of which this Node is a part
return this Document's root node
some methods for handling attributes:
return the right attribute node
return the right attribute node
get all the attributes for an Element
get attribute's value
It is noteworthy that, because of the way the DOM specs
work, the next two methods return the empty string (not
null!) when the attribute with the specified name does not
exist on an element.  Beware!
return the value of the attribute of the given element
with the given name
return the value of the attribute of the given element
with the given name
return the prefix
return the namespace URI
return synthetic annotation
Something went wrong. There's not much we can do about it.
Something went wrong. There's not much we can do about it.
Flag indicating whether or not Throwable methods available.
Attempt to get methods for java.lang.Throwable on class initialization.
ClassNotFoundException, NoSuchMethodException or SecurityException
Whatever the case, we cannot use java.lang.Throwable.initCause(java.lang.Throwable).
Message types. Used by the UI to determine what icon to display,
and possibly what behavior to give based on the type.
Let the defaultCloseOperation handle the closing
if the user closed the window without selecting a button
(newValue = null in that case).  Otherwise, close the dialog.
Once window gets focus, set initial focus
reset value to ensure closing works properly
Use reflection to get Container.startLWModal.
Use reflection to get Container.startLWModal.
Option dialogs should be closable only
Let the defaultCloseOperation handle the closing
if the user closed the iframe without selecting a button
(newValue = null in that case).  Otherwise, close the dialog.
Use reflection to get Container.stopLWModal().
We want dialog centered relative to its parent component
If possible, dialog should be fully visible
Save the icon, if its Serializable.
Save the message, if its Serializable.
Save the treeModel, if its Serializable.
Save the initialValue, if its Serializable.
Save the value, if its Serializable.
Save the selectionValues, if its Serializable.
Save the inputValue, if its Serializable.
Save the initialSelectionValue, if its Serializable.
inner class AccessibleJOptionPane
Insure that its one of the types we require
Store the nodes and init any data that needs it
Package, final methods
Package, inherited methods
If its an alternation, then if either child is nullable then
this node is nullable. If its a concatenation, then both of
them have to be nullable.
Protected, inherited methods
Its the the union of the first positions of our children.
If our left child is nullable, then its the union of our
children's first positions. Else is our left child's first
Its the the union of the first positions of our children.
If our right child is nullable, then its the union of our
children's last positions. Else is our right child's last
Private data members
These are the references to the two nodes that are on either
side of this binary operation.
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of TableHeaderRendererPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of TableHeaderRendererPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
this order reflects the overriding order
read system properties or jaxp.properties
only update if it shall override
only update if it shall override
internally, ordinal is used as index
invalid setting ignored
construct a NOTATION datatype validator
DOM Level 3 methods.
if here, openKey failed and logged
Check if a new node
Be greedy - open the longest possible path
Split the path and do the recursion
Find out the number of values
Get the values
Get number of children
check if Alt64
Decode from simple encoding
If a non-trivial character encountered, use altBase64
Convert to byte pairs
Use modified native2ascii algorithm
Range in which the variable is valid
Index in constant pool of variable name
Index of variable signature
w3c NodeList is on the stack from the external Java function call.
call BasisFunction to consume NodeList and leave Iterator on
push translet onto stack
push DOM onto stack
w3c Node is on the stack from the external Java function call.
call BasisLibrary.node2Iterator() to consume Node and leave
Iterator on the stack.
push translet onto stack
push DOM onto stack
Get next node from the iterator
Get the node's string value (from the DOM)
from an earlier version of the JMX API
TODO: What does it mean to translate a Pattern ?
Parsing something like the following:
(@rule | ruleset | block)*
is a block, ()[] is two blocks)
ruleset     selector decblock
declblock   declaration* block*
declaration (identifier* stopping when identifier ends with :)
(identifier* stopping when identifier ends with ;)
comments /* */ can appear any where, and are stripped.
identifier - letters, digits, dashes and escaped characters
in matching pairs, '' and "" also occur in pairs, except " may be
Indicates the type of token being parsed.
The delegate interface.
There is currently no way to distinguish between '"foo,"' and
'foo,'. But this generally isn't valid CSS. If it becomes
a problem, handleSelector will have to be told if the string is
Property names are mapped to lower case before being passed to
PENDING: make this more effecient.
Skip a tailing ';', not really to spec.
Parse the selectors
Not too sure about this, how we handle this isn't very
Prematurely hit end.
Make the property name to lowercase
No need to throw for these two, we return token and
caller can do whatever.
Hit the end
Prematurely hit end.
NOTE: this could be combined with readTill, as they contain somewhat
1 for '\', 2 for valid escape char [0-9a-fA-F], 3 for
Reached the end
Continue with escape.
no longer escaped
Make this simpler, reprocess the character.
1 for '\', 2 for valid escape char [0-9a-fA-F], 0 otherwise
Prematurely reached the end!
Continue with escape.
no longer escaped
Will never happen.
Invalid state, should do something.
Uncomment the following to do case insensitive parsing.
Should never happen.
Singleton instance of this class
Singleton instance of SkinPainter
Special case because XP has no skin for menus
TODO: The classic border uses this color, but we should
create a new UI property called "PopupMenu.borderColor"
Will cause L&F to use classic border
Ideally we'd have an interface defined for classes which
support margins (to avoid this hackery), but we've
decided against it for simplicity
special casing for comboboxes.
there may be more special cases in the future
note. in the future this should be replaced with a call
Ideally we'd have an interface defined for classes which
support margins (to avoid this hackery), but we've
decided against it for simplicity
if this is a toolbar button then ignore getMargin()
and subtract the padding added by the constructor
Note that stealData() requires a markDirty() afterwards
since we modify the data in it.
Note: All further access to the maps must be synchronized
We can use any widget name here, I guess.
Attribute name (incl. prefix)
push attribute name - namespace prefix set by parent node
push attribute value
Generate code that calls SerializationHandler.addUniqueAttribute()
if all attributes are unique.
Set the HTML flags
Type-specific CORBA::Object operations
GTKLookAndFeel installs a different LayoutManager, and sets it
to null after changing the look and feel, so, install the default
if the LayoutManager is null.
let the UI define the default size
FIXME:  [[[WDW - need to add orientation from BoxLayout]]]
FIXME:  [[[WDW - need to do SELECTABLE if SelectionModel is added]]]
inner class AccessibleJToolBar
serialVersionUID not constant
Serialization compatibility stuff:
Two serial forms are supported in this class. The selected form depends
on system property "jmx.serial.form":
- "1.0" for JMX 1.0
- any other value for JMX 1.1 and higher
Serial version for old serial form
Serial version for new serial form
Serializable fields in old serial form
Serializable fields in new serial form
Actual serial version and serial form
OK : Too bad, no compat with 1.0
END Serialization compatibility stuff
Read an object serialized in the old serial form
Read an object serialized in the new serial form
Serializes this instance in the old serial form
Serializes this instance in the new serial form
Don't bother checking the Scrollable methods if there is no room
for the viewport, we aren't going to show any scrollbars in this
vsbPolicy == VERTICAL_SCROLLBAR_AS_NEEDED
hsbPolicy == HORIZONTAL_SCROLLBAR_AS_NEEDED
You could argue that we should recheck the
Scrollable methods again until they stop changing,
but they might never stop changing, so we stop here
and don't do any additional checks.
This is used primarily for GTK L&F, which needs to
extend the vertical scrollbar to fill the upper
corner near the column header.  Note that we skip
this step (and use the default behavior) if the
user has set a custom corner component.
This is used primarily for GTK L&F, which needs to
extend the horizontal scrollbar to fill the lower
corner near the row header.  Note that we skip
this step (and use the default behavior) if the
user has set a custom corner component.
size without time zone: --MM-DD
validate and normalize
save unnormalized values
Required arguments must not be null
name we will provide a default value for
Ensure a pre-order traversal; add this hashes
items before recursing to child hashes
Save name and hash in two steps
Add item to node
Now go back and do the saved hashes
Retrieve name and hash in two steps
Ooops, just bail (suggestions for a safe thing
to do in this case appreciated)
inner class AccessibleJRadioButton
protected static final String GRAMMAR_POOL =
deferred expansion data
add recognized features
set default values
add recognized properties
set default values
normalize class name
verify that this class exists and is of the right type
set document class name
get feature state
reset dom information
reset string buffer
reset state information
Always create entity reference nodes to be able to recreate
entity as a part of doctype
remove dependency on our implementation when DOM L3 is REC
set base uri
set actual encoding
we don't need synchronization now, because entity ref will be
expanded anyway. Synch only needed when user creates entityRef node
find corresponding Entity decl
REVISIT: the constant FILTER_REJECT should be changed when new
DOM LS specs gets published
fall through to SKIP since comment has no children.
REVISIT: the constant FILTER_SKIP should be changed when new
DOM LS specs gets published
make sure we don't loose chars if next event is characters()
fall through to SKIP since PI has no children.
fFirstChunk must be set to true so that data
won't be lost in the case where the child before PI is
a text node and the next event is characters.
REVISIT: when DOM Level 3 is REC rely on Document.support
instead of specific class
set DOM error checking off
set actual encoding
REVISIT: when DOM Level 3 is REC rely on Document.support
instead of specific class
set DOM error checking off
set actual encoding
use specified document class
if subclass of our own class that's cool too
REVISIT: when DOM Level 3 is REC rely on
Document.support instead of specific class
set DOM error checking off
set actual encoding
won't happen we already checked that earlier
REVISIT: strict error checking is not implemented in deferred dom.
Document.support instead of specific class
set actual encoding
REVISIT: when DOM Level 3 is REC rely on Document.support
instead of specific class
Take special care of schema defaulted attributes. Calling the
non-namespace aware setAttributeNode() method could overwrite
another attribute with the same local name.
NOTE: The specified value MUST be set after you set
the node value because that turns the "specified"
flag to "true" which may overwrite a "false"
value from the attribute list. -Ac
REVISIT: currently it is possible that someone turns off
namespaces and turns on xml schema validation
To avoid classcast exception in AttrImpl check for namespaces
however the correct solution should probably disallow setting
namespaces to false when schema processing is turned on.
For DOM Level 3 TypeInfo, the type name must
be null if this attribute has not been declared
in the DTD.
REVISIT: Handle entities in attribute value.
fill value of the root element
make sure that if any char data is available
the fFirstChunk is true, so that if the next event
is characters(), and the last node is text, we will copy
the value already in the text node to fStringBuffer
(not to lose it).
Need to loop in reverse order so that the attributes
are processed in document order when the DOM is expanded.
set type information
REVISIT: currently it is possible that someone turns off
namespaces and turns on xml schema validation
To avoid classcast exception in AttrImpl check for namespaces
however the correct solution should probably disallow setting
namespaces to false when schema processing is turned on.
For DOM Level 3 TypeInfo, the type name must
be null if this attribute has not been declared
in the DTD.
if type is union (XML Schema) it is possible that we receive
character call with empty data
collect all the data into the string buffer.
The Text and CDATASection normalization is taken care of within
the DOM in the deferred case.
if type is union (XML Schema) it is possible that we receive
character call with empty data
The Text normalization is taken care of within the DOM in the
REVISIT: Should this happen after we call the filter?
Updating TypeInfo. If the declared type is a union the
[member type definition] will only be available at the
end of an element.
make sure that if any char data is available
the fFirstChunk is true, so that if the next event
is characters(), and the last node is text, we will copy
the value already in the text node to fStringBuffer
(not to lose it).
Setting TypeInfo. If the declared type is a union the
[member type definition] will only be available at the
end of an element.
fall through to SKIP since CDATA section has no children.
REVISIT: when DOM Level 3 is REC rely on Document.support
instead of specific class
set the actual encoding and set DOM error checking back on
set the actual encoding
get current entity declaration
Make entity ref node read only
make sure we don't loose chars if next event is characters()
move entity reference children to the list of
siblings of its parent and remove entity reference
get previous sibling of the entity reference
normalize text nodes
length > 0
find corresponding Entity decl
entity definition exists and it does not have any children
move children of entity ref before the entity ref.
remove entity ref.
holds a child of entity ref
REVISIT: remove dependency on our implementation when
DOM L3 becomes REC
if an element already has xml:base attribute
retrive the baseURI from the entity reference
retrieve baseURI from the entity reference
try baseURI of the entity declaration
internal subset string
NOTE: We only know how to create these nodes for the Xerces
DOM implementation because DOM Level 2 does not specify
that functionality. -Ac
create full node
don't add parameter entities!
create deferred node
internal subset string
NOTE: We only know how to create these nodes for the Xerces
DOM implementation because DOM Level 2 does not specify
that functionality. -Ac
create full node
don't add parameter entities!
create deferred node
internal subset string
NOTE: We only know how to create these nodes for the Xerces
DOM implementation because DOM Level 2 does not specify
that functionality. -Ac
create full node
create deferred node
unparsedEntityDecl(String,XMLResourceIdentifier, String, Augmentations)
internal subset string
NOTE: We only know how to create these nodes for the Xerces
DOM implementation because DOM Level 2 does not specify
that functionality. -Ac
create full node
create deferred node
internal subset string
internal subset string
REVISIT: This code applies to the support of domx/grammar-access
feature in Xerces 1
get the default value
get element definition
create element definition if not already there
add default attribute
DOM Level 2 wants all namespace declaration attributes
to be bound to "http:www.w3.org/2000/xmlns/"
So as long as the XML parser doesn't do it, it needs to
REVISIT: set ID type correctly
get the default value
get element definition node
REVISIT: Check for uniqueness of element name? -Ac
create attribute and set properties
DOM Level 2 wants all namespace declaration attributes
to be bound to "http:www.w3.org/2000/xmlns/"
So as long as the XML parser doesn't do it, it needs to
add default attribute to element definition
if NOT defer-node-expansion
attributeDecl(String,String,String,String[],String,XMLString, XMLString, Augmentations)
method to create an element node.
subclasses can override this method to create element nodes in other ways.
if we are using xerces DOM implementation, call our
own constructor to reuse the strings we have here.
method to create an attribute node.
subclasses can override this method to create attribute nodes in other ways.
if we are using xerces DOM implementation, call our
own constructor to reuse the strings we have here.
handle character data
if we have data in the buffer we must have created
a text node already.
REVISIT: should this check be performed?
reset string buffer
fall through to SKIP since Comment has no children.
accept node -- do nothing
end-if fDOMFilter !=null
end-if child !=null
Add segments before each match found
no empty leading substring included for zero-width match
at the beginning of the input char sequence.
If no match was found, return this
Add remaining segment
Read in all fields
if length > 0, the Pattern is lazily compiled
to use UNICODE_CASE if UNICODE_CHARACTER_CLASS present
Reset group index count
Convert pattern into normalizedD form
Modify pattern to match canonical equivalences
source has one character.
Add combined permutations
For each char, take it out and add the permutations
of the remaining chars
offset maintains the index in code units.
No \Q sequence found
double zero termination
Handle canonical equivalences
Copy pattern to int array for convenience
Use double zero to terminate pattern
Convert all chars into code points
patternLength now in code points
Allocate all temporary objects here.
Literal pattern handling
Start recursive descent parsing
Check extra pattern characters
Release temporary storage
if the node returned from sequence() is "end"
we have an empty expr, set a null atom into
the branch to indicate to go "next" directly.
the "tail.next" of each atom goes to branchConn
replace the "end" with "branchConn" at its tail.next
when put the "prev" into the branch as the first atom.
Because group handles its own closure,
we need to treat it differently
Check for comment or flag group
Double return: Tail was returned in root
Unwind one character
Slice is waiting; handle it first
No slice; just return the family node
Unwind meta escape sequence
Add another number if it doesn't make a group
that doesn't exist
'\v' was implemented as VT/0x0B in releases < 1.8 (though
undocumented). In JDK8 '\v' is specified as a predefined
character class for all vertical whitespace characters.
So [-1, root=VertWS node] pair is returned (instead of a
single 0x0B). This breaks the range if '\v' is used as
the start or end value, such as [\v-...] or [...-\v], in
which a single definite value (0x0B) is expected. For
compatibility concern '\013'/0x0B is returned if isrange.
Negates if first char in a class, otherwise literal
^ not first in class, treat as literal
treat as a literal &
I and i
S and s
K and k
(?:xxx) pure group
(?=xxx) and (?!xxx) lookahead
(?>xxx)  independent group
(?<xxx)  look behind
named captured group
(?xxx:) inlined match flags
Inline modifier only
(xxx) a regular group
Check for quantifiers
Zero length assertion
Discover if the group is deterministic
subFlag then fall through
Utility methods for code point support
Match a given Unicode character
Match a given BMP character
if ((ret = next.match(matcher, i, seq)) || i == guard)
Optimization to move to the next character. This is
faster than countChars(seq, i, 1).
Perl does not match ^ at end of input even after newline
Should treat /r/n as one newline
Perl does not match ^ at end of input even after newline
Matches before any line terminator; also matches at the
end of input
Before line terminator:
If multiline, we match here no matter what
If not multiline, fall through so that the end
is marked as hit; this must be a /r/n or a /n
at the very end so the end was hit; more input
could make this not match here
No match between \r\n
No line terminator, no match
Matched at current end so hit end
If a $ matches because of end of input, then more input
could cause it to fail!
If not multiline, then only possible to
match at very end or one before end
If multiline return next.match without setting
more input could change this so set hitEnd
If a $ matches because of end of input, then more input
could cause it to fail!
i is the index to start matching at
j is the number of atoms that have matched
We have matched the maximum... continue with the rest of
the regular expression
k is the length of this match
Zero length match
Move up index and number matched
We are greedy so match as many as we can
Handle backing off if match fails
Reluctant match. At this point, the minimum has been satisfied.
i is the index to start matching at
j is the number of atoms that have matched
Try finishing match without consuming any more
At the maximum, no match found
Okay, must try one more atom
If we haven't moved forward then must break out
Move up index and number matched
Save original info
arbitrary large number
Notify GroupTail there is no need to setup group info
because it will be set here
Aggressive group match
don't back off passing the starting "j"
Save original info
Arbitrary large number
arbitrary large enough num
This is the normal group case.
Save the group so we can unset it if it
backs off of a match.
This is a group reference case. We don't need to save any
group info because it isn't really a group.
local count index in matcher locals
group beginning index
Avoid infinite loop in zero-length case.
This block is for before we reach the minimum
iterations required for the loop to match
If match failed we must backtrack, so
the loop count should NOT be incremented
Return success or failure since we are under
This block is for after we have the minimum
iterations required for the loop to match
If match failed we must backtrack, so
the loop count should NOT be incremented
Check for zero length group
If match failed we must backtrack, so
the loop count should NOT be incremented
If match failed we must backtrack, so
the loop count should NOT be incremented
If the referenced group didn't match, neither can this
If there isn't enough input left no match
Check each new char to make sure it matches what the group
referenced matched last time around
If the referenced group didn't match, neither can this
If there isn't enough input left no match
Check each new char to make sure it matches what the group
referenced matched last time around
Relax transparent region boundaries for lookahead
Reinstate region boundaries
Relax transparent region boundaries for lookahead
If a negative lookahead succeeds then more input
could cause it to fail!
Reinstate region boundaries
Set end boundary
Relax transparent region boundaries for lookbehind
Set end boundary
Relax transparent region boundaries for lookbehind
Relax transparent region boundaries for lookbehind
Reinstate region boundaries
Relax transparent region boundaries for lookbehind
Reinstate region boundaries
Tried to access char past the end
The addition of another char could wreck a boundary
If the pattern is short don't use it, since
a shift larger than the pattern length cannot
be used anyway.
Precalculate part of the bad character shift
It is a table for where in the pattern each
lower 7-bit value occurs
Precalculate the good suffix shift
i is the shift amount being considered
j is the beginning index of suffix being considered
Testing for good suffix
src[j..len] is a good suffix
No match. The array has already been
filled up with correct values before.
This fills up the remaining of optoSft
any suffix can not have larger shift amount
then its sub-suffix. Why???
Set the guard value because of unicode compression
Loop over all possible match positions in text
Loop over pattern from right to left
Shift search to the right by the maximum of the
bad character shift and the good suffix shift
Entire pattern matched starting at i
BnM is only used as the leading node in the unanchored case,
and it replaced its Start() which always searches to the end
if it doesn't find what it's looking for, so hitEnd is true.
Loop over all possible match positions in text
Loop over pattern from right to left
Shift search to the right by the maximum of the
bad character shift and the good suffix shift
Entire pattern matched starting at i
Unicode character property aliases, defined in
Posix regular expression character classes, defined in
Space and tab characters
printable and visible
Java character properties, defined by methods in Character.java
The start position of the next sub-sequence of input
when current == input.length there are no more elements
null if the next element, if any, needs to obtained
> 0 if there are N next empty elements
Consume the next matching element
Count sequence of matching empty elements
no empty leading substring for zero-width
match at the beginning of the input
Consume last matching element
Ignore a terminal sequence of matching empty elements
Similar to AbstractTask but doesn't need to track child tasks
Size map to avoid concurrent re-sizes
Fork the parent task
Completion of the left and right children "happens-before"
completion of the parent
Completion of the left child "happens-before" completion of
the right child
If task is not on the left spine
Update association of left-predecessor to left-most
leaf node of right subtree
If replaced, adjust the pending count of the parent
to complete when its children complete
Left-predecessor has already completed, parent's
left child is ready to complete
Cannot complete just yet so buffer elements into a Node
for use when completion occurs
Dump buffered elements from this leaf into the sink
Dump elements output from this leaf's pipeline into the sink
The completion of this task *and* the dumping of elements
"happens-before" completion of the associated left-most leaf task
of right subtree (if any, which can be this task's right sibling)
OK : Try with next one...
--- JEditorPane ------------------------------------
bummer, get the SUN implementation
never happens, because we made sure the algorithm exists
JDK 1.1 based implementations subclass SecureRandom instead of
SecureRandomSpi. They will also go through this code path because
they must call a SecureRandom constructor as it is their superclass.
If we are dealing with such an implementation, do not set the
algorithm value as it would be inaccurate.
Declare serialVersionUID to be compatible with JDK1.1
Retain unused values serialized from JDK1.1
class data: instance map
Class data: currency data obtained from currency.data file.
- determine valid country codes
- determine valid currency codes
- map country codes to currency codes
- obtain default fraction digits for currency codes
sc = special case; dfd = default fraction digits
Simple countries are those where the country code is a prefix of the
currency code, and there are no known plans to change the currency.
- maps country code to 32-bit int
- 26*26 entries, corresponding to [A-Z]*[A-Z]
- \u007F -> not valid country
- bits 20-31: unused
- bits 10-19: numeric code (0 to 1023)
- bit 9: 1 - special case, bits 0-4 indicate which one
0 - simple country, bits 0-4 indicate final char of currency code
- bits 5-8: fraction digits for simple countries, 0 for special cases
- bits 0-4: final char for currency code for simple country, or ID of special case
- special case IDs:
- 0: country has no currency
- other: index into sc* arrays + 1
- scCutOverTimes: cut-over time in millis as returned by
System.currentTimeMillis for special case countries that are changing
currencies; Long.MAX_VALUE for countries that are not changing currencies
- scOldCurrencies: old currencies for special case countries
- scNewCurrencies: new currencies for special case countries that are
changing currencies; null for others
- scOldCurrenciesDFD: default fraction digits for old currencies
- scNewCurrenciesDFD: default fraction digits for new currencies, 0 for
countries that are not changing currencies
- otherCurrencies: concatenation of all currency codes that are not the
main currency of a simple country, separated by "-"
- otherCurrenciesDFD: decimal format digits for currencies in otherCurrencies, same order
handy constants - must match definitions in GenerateCurrencyData
number of characters from A to Z
entry for invalid country codes
entry for countries without currency
mask for simple case country entries
mask for simple case country entry final character
mask for simple case country entry default currency digits
shift count for simple case country entry default currency digits
maximum number for simple case country entry default currency digits
mask for special case country entries
mask for special case country index
delta from entry index component in main table to index into special case tables
mask for distinguishing simple and special case countries
mask for the numeric code of the currency
shift count for the numeric code of the currency
Currency data format version
look for the properties file for overrides
Try to look up the currency code in the instances table.
This does the null pointer check as a side effect.
Also, if there already is an entry, the currencyCode must be valid.
Currency code not internally generated, need to verify first
A currency code must have 3 characters and exist in the main table
or in the list of other currencies.
Check for '-' separately so we don't get false hits in the table.
Add simple currencies first
Now add other currencies
use currency code as symbol of last resort
use currency code as symbol of last resort
ignore invalid country code
format is not recognized.  ignore the data
if group(4) date string is null and we've 4 values, bad date value
If the local path is a relative path, then it is resolved against
the "user.dir" system property.
user.dir not accessible from applet
"fix" for Bugzilla Bug 22777
finding substring  before '#', '?', and '/'
return true if there is ':' before '#', '?', and '/'
On Windows, an absolute path starts with "[drive_letter]:\".
Replace space with "%20"
Replace backslash with forward slash
Only process the systemId if it starts with "file:".
Resolve the absolute path if the systemId starts with "file:/"
or "file:/". Don't do anything if it only starts with "file:".
A Windows path containing a drive letter can be relative.
A Unix path starting with "file:/" is always absolute.
AUDIO PORT TYPE DEFINES
use the current class loader
if this factory supports the given schemalanguage return this factory else thrown exception
Copyright (c) 1995-96 by Cisco Systems, Inc.
bits left at current index that are avail.
gif block count
This handles the GIF block count stuff
bits contents fit in current index byte
bits overflow from current byte to next.
if bits  > space left in current byte then the lowest order bits
of code are taken and put in current byte and rest put in next.
if bits  > space left in current byte then the highest order bits
of code are taken and put in current byte and rest put in next.
at highest order bit location !!
ok this many bits gone off the top
Cache of stateless traversers for this DTM
Share/reuse existing traverser
Generate new traverser
Don't want to throw an exception for this one.
"Axis traverser not supported: "
Process using identities
Is it a child?
If the parent occured before the subtree root, then
we know it is past the child axis.
Otherwise, it could be a descendant below the subtree root
children, or it could be after the subtree root.  So we have
to climb up until the parent is less than the subtree root, in
which case we return NULL, or until it is equal to the subtree
root, in which case we continue to look.
%REVIEW% Dead code. Eliminate?
Process in Identifier space
%REVIEW% Is there *any* cheaper way to do this?
Yes. In ID space, compare to axisRoot's successor
(next-sib or ancestor's-next-sib). Probably shallower search.
may call nextNode()
may call nextNode()
Trickological code: _exptype() has the side-effect of
running nextNode until the specified node has been loaded,
and thus can be used to ensure that incremental construction of
the DTM has gotten this far. Using it just for that side-effect
is quite a kluge...
make sure it's here.
Compute in ID space
%REVIEW% This looks like it might want shift into identity space
to avoid repeated conversion in the individual functions
Compute in identity space
Only works on IDs, not handles.
%REVIEW% Are we using handles or indexes?
may call nextNode()
Compute in ID space
may call nextNode()
Compute in ID space
%REVIEW% See comments in IsAfterAxis; using the "successor" of
contextIdent is probably more efficient.
compute in ID space
Compute in ID space
Compute in ID space
Compute in ID space
Compute in ID space
Kluge test: Just make sure +1 yielded a real node
may call nextNode()
Compute in ID space
may call nextNode()
%REVIEW% Shouldn't this always be 0?
This is guaranteed to be interned by the VM in the 1.4
Generics and annotations support
generic info repository; lazily initialized
Cached field accessor created without override
Cached field accessor created with override
For sharing of FieldAccessors. This branching structure is
currently only two levels deep (i.e., one root Field and
potentially many Field objects pointing to it.)
If this branching structure would ever contain cycles, deadlocks can
occur in annotation code.
Accessor for factory
create scope and factory
Accessor for generic info repository
lazily initialize repository if necessary
create and cache generic info repository
return cached repository
This routine enables sharing of FieldAccessor objects
among Field objects which refer to the same underlying
method in the VM. (All of this contortion is only necessary
because of the "accessibility" bit in AccessibleObject,
which implicitly requires that new java.lang.reflect
objects be fabricated for each reflective call on Class
Might as well eagerly propagate this if already present
security check is done before calling this method
NOTE that there is no synchronization used here. It is correct
(though not efficient) to generate more than one FieldAccessor
for a given Field. However, avoiding synchronization will
probably make the implementation more scalable.
First check to see if one has been created yet, and take it
Otherwise fabricate one and propagate it up to the root
Returns FieldAccessor for this Field object, not looking up
the chain to the root
Sets the FieldAccessor for this Field object and
(recursively) its root
PENDING(jeff) pick the size more sensibly
Obsolete - not used
First ignore case when comparing
May differ in case (e.g. "mail" vs. "Mail")
run through the file list, add directories and selectable files to fileCache
Note that this block must be OUTSIDE of Invoker thread because of
deadlock possibility with custom synchronized FileSystemView
First sort alphabetically by filename
To avoid loads of synchronizations with Invoker and improve performance we
execute the whole block on the COM thread
see if interval is added
see if interval is removed
NPCTE fix for bugId 4510777, esc 532372, MR October 2001
file TaskServer.java created for this bug fix
TODO: This is ugly ...
there is no way to know the current position(event) of
XMLEventReader.  peek() is the only way to know the next event.
The next event on the input stream should be
largest numerical value
These would not be used for EN. Only used for traditional numbering
These only used for mutiplicative-additive numbering
Note that we are using longs and that the last two
multipliers are not supported. This is a known limitation.
search for identical key
replace old value
Rehash the table if the number of entries
would exceed the number of buckets.
Select a new hash function and rehash the table if
MAX_HASH_COLLISIONS is exceeded.
create new entry
search for identical key
The 'key' in attrs is stored in the 'right case'.
If ignoreCase is true, key is aways lowercase.
If ignoreCase is false, key is stored as supplied by put().
%%% Not declared "private" due to bug 4064984.
Check case first
write out the ignoreCase flag
read in the ignoreCase flag
number of attributes
can't have initial size of 0 (grrr...)
Walking through the elements, rather than the keys, gives
us attribute IDs that have not been converted to lowercase.
may be null
!!! can be wildcard
does the corrent parent/child relationship exist?
cannot be a sibling of a null node
nextSibling contained by node?
does the corrent parent/child relationship exist?
cannot be a sibling of a null node
nextSibling contained by node?
does the corrent parent/child relationship exist?
cannot be a sibling of a null node
nextSibling contained by node?
does the corrent parent/child relationship exist?
cannot be a sibling of a null node
nextSibling contained by node?
Node name, followed by description
Node name + "/" + AttributeName, followed by description
in theory we want a deep clone of the combined arrays,
but since it only contains (immutable) Strings, this shallow
copy is sufficient
Sleep's for a specified time, before checking
the Servers health. This will repeat as long as
the ServerManager (ORBD) is up and running.
Check each ServerTableEntry to make sure that they
are in the right state.
Too late to complain, Just use the default
native JDK1.1 font pointer
NOTE: This method is called by privileged threads.
We implement this functionality in a package-private method
to insure that it cannot be overridden by client subclasses.
DO NOT INVOKE CLIENT CODE ON THIS THREAD!
expects the float value.
for streaming compatibility
for 1.5 streaming compatibility
not == 2f
not  == .2f
optimize for two cases:
1) FONT attribute, and nothing else
2) attributes, but no FONT
avoid turning the attributemap into a regular map for no reason
oh well, check for anything else
Otherwise, be extra conscious of pending temp file creation and
resourcefully handle the temp file resources, among other things.
can't get ascent and descent here, recursive call to this fn,
so use pointsize
let users combine super- and sub-scripting
note on placement and italics
We preconcatenate the transform because we don't want to translate along
the italic angle, but purely perpendicular to the baseline.  While this
looks ok for superscripts, it can lead subscripts to stack on each other
and bring the following text too close.  The way we deal with potential
collisions that can occur in the case of italics is by adjusting the
horizontal spacing of the adjacent glyphvectors.  Examine the italic
angle of both vectors, if one is non-zero, compute the minimum ascent
and descent, and then the x position at each for each vector along its
italic angle starting from its (offset) baseline.  Compute the difference
between the x positions and use the maximum difference to adjust the
position of the right gv.
x = r^0 + r^1 + r^2... r^n
rx = r^1 + r^2 + r^3... r^(n+1)
x - rx = r^0 - r^(n+1)
x (1 - r) = r^0 - r^(n+1)
x = (r^0 - r^(n+1)) / (1 - r)
x = (1 - r^(n+1)) / (1 - r)
scale ratio is 2/3
trans = 1/2 of ascent * x
assume ascent is 3/4 of point size
NOTE: This method is called by privileged threads.
We implement this functionality in a package-private
method to insure that it cannot be overridden by client
DO NOT INVOKE CLIENT CODE ON THIS THREAD!
NOTE: This method may be called by privileged threads.
DO NOT INVOKE CLIENT CODE ON THIS THREAD!
in 1.5, we always streamed out the font values plus
TRANSFORM, SUPERSCRIPT, and WIDTH, regardless of whether the
values were default or not.  In 1.6 we only stream out
defined values.  So, 1.6 streams in from a 1.5 stream,
it check each of these values and 'undefines' it if the
value is the default.
if legacy stream, undefine these
don't need it any more
FONT is not supported by Font
c2 could be CharacterIterator.DONE which is not a low surrogate.
REMIND always safe, but prevents caller optimize
need real index, assumes roman for everything
need real baselines eventually
this code should be in textlayout
quick check for simple text, assume GV ok to use if simple
need char array constructor on textlayout
!!! no custom layout engines
ordered from large to small
ordered so that bit 0 of the ordinal indicates stand-alone.
-- This file was mechanically generated: Do not edit! --
these declarations are here as documentation
name treated as AVT (7.1.3)
specified name is not AVT
if the ncname is an AVT, then the ncname has to be checked at runtime if it is a valid ncname
store the name into a variable first so _name.translate only needs to be called once
call checkNCName if the name is an AVT
Save the current handler base on the stack
first arg to "attributes" call
load name value again
Save the current handler base on the stack
first arg to "attributes" call
Push attribute name
translate contents with substituted handler
get String out of the handler
Restore old handler base from stack
fetch system property:
if property is not specified then use contents of
META_INF/org.w3c.dom.DOMImplementationSourceList from classpath
DOM Implementations can modify here to add *additional* fallback
mechanisms to access a list of default DOMImplementationSources.
fall back to JAXP implementation class com.sun.org.apache.xerces.internal.dom.DOMXSImplementationSourceImpl
make sure we have access to restricted packages
Assume that the DOM application is in a JRE 1.1, use the
try to find services in CLASSPATH
java.security.AccessController existed since 1.2 so, if no
exception was thrown, the DOM application is running in a JRE
1.2 or higher
Declare serialVersionUID to be compatible with JDK1.1
In case user sets rules later
this.useDaylight is set by decodeRules
TODO: this method doesn't check the initial values of dayOfMonth or dayOfWeek.
Get the year in local time
Clear time elements for the transition calculations
adjust y with the GregorianCalendar-style year numbering.
If the year isn't representable with the 64-bit long
integer in milliseconds, convert the year to an
equivalent year. This is required to pass some JCK test cases
which are actually useless though because the specified years
can't be supported by the Java time system.
y %= 28 also produces an equivalent year, but positive
year numbers would be convenient to use the UNIX cal
convert year to its 1-based month value
First, calculate time as a Gregorian date.
If the time value represents a time before the default
Gregorian cutover, recalculate time using the Julian
calendar system. For the Julian calendar system, the
normalized year numbering is ..., -2 (BCE 2), -1 (BCE 1),
1, 2 ... which is different from the GregorianCalendar
style year numbering (..., -1, 0 (BCE 1), 1, 2, ...).
The validation should be cdate.getDayOfWeek() ==
dayOfWeek. However, we don't check dayOfWeek for
TODO: support Gregorian cutover. The previous year
may be in the other calendar system.
TODO: support Gregorian cutover. The next year
may be in the other calendar system.
The start and end transitions are in multiple years.
The given date will be taken into account while
we have the historical time zone data in place.
Only check rules if using DST
indicate if this time zone uses DST
Exact day of month, "Mar 1"
Day of week in month, "lastSun"
Day of week after day of month, "Sun>=15"
Day of week before day of month, "Sun<=21"
Zero for backward compatibility
Proclaim compatibility with 1.1
the internal serial version which says which version was written
- 0 (default) for version up to JDK 1.1.3
- 1 for version from JDK 1.1.4, which includes 3 new fields
- 2 for JDK 1.3, which includes 2 new fields
We represent the following flavors of rules:
5        the fifth of the month
lastSun  the last Sunday in the month
lastMon  the last Monday in the month
Sun>=8   first Sunday on or after the eighth
Sun<=25  last Sunday on or before the 25th
This is further complicated by the fact that we need to remain
backward compatible with the 1.1 FCS.  Finally, we need to minimize
API changes.  In order to satisfy these requirements, we support
three representation systems, and we translate between them.
This is the format SimpleTimeZone objects take after construction or
streaming in is complete.  Rules are represented directly, using an
unencoded format.  We will discuss the start rule only below; the end
rule is analogous.
startMode      Takes on enumerated values DAY_OF_MONTH,
DOW_IN_MONTH, DOW_AFTER_DOM, or DOW_BEFORE_DOM.
startDay       The day of the month, or for DOW_IN_MONTH mode, a
value indicating which DOW, such as +1 for first,
+2 for second, -1 for last, etc.
startDayOfWeek The day of the week.  Ignored for DAY_OF_MONTH.
This is the format accepted by the constructor and by setStartRule()
and setEndRule().  It uses various combinations of positive, negative,
and zero values to encode the different rules.  This representation
allows us to specify all the different rule flavors without altering
MODE              startMonth    startDay    startDayOfWeek
DOW_IN_MONTH_MODE >=0           !=0         >0
DOM_MODE          >=0           >0          ==0
DOW_GE_DOM_MODE   >=0           >0          <0
DOW_LE_DOM_MODE   >=0           <0          <0
(no DST)          don't care    ==0         don't care
We must retain binary compatibility with the 1.1 FCS.  The 1.1 code only
handles DOW_IN_MONTH_MODE and non-DST mode, the latter indicated by the
flag useDaylight.  When we stream an object out, we translate into an
approximate DOW_IN_MONTH_MODE representation so the object can be parsed
and used by 1.1 code.  Following that, we write out the full
representation separately so that contemporary code can recognize and
parse it.  The full representation is written in a "packed" format,
consisting of a version number, a length, and an array of bytes.  Future
versions of this class may specify different versions.  If they wish to
include additional data, they should do so by storing them after the
packed representation below.
A day-of-month of 1 is equivalent to DOW_IN_MONTH_MODE
that is, Sun>=1 == firstSun.
A day-of-month of 1 is equivalent to DOW_IN_MONTH_MODE
that is, Sun>=1 == firstSun.
Back 1 day
Forward 1 day
Back 1 day
Forward 1 day
As of serial version 2, include time modes
As of serial version 2, include time modes
Construct a binary rule
Convert to 1.1 FCS rules.  This step may cause us to lose information.
Write out the 1.1 FCS rules
Write out the binary rules in the optional data area of the stream.
Recover the original rules.  This recovers the information lost
Fix a bug in the 1.1 SimpleTimeZone code -- namely,
startDayOfWeek and endDayOfWeek were usually uninitialized.  We can't do
too much, so we assume SUNDAY, which actually works most of the time.
The variables dstSavings, startMode, and endMode are post-1.1, so they
won't be present if we're reading from a 1.1 stream.  Fix them up.
For 1.1.4, in addition to the 3 new instance variables, we also
store the actual rules (which have not be made compatible with 1.1)
in the optional area.  Read them in here and parse them.
Generate 8 bytes of random data.
-- This file was mechanically generated: Do not edit! --
Cached unsafe-access object
Cached array base offset
Cached unaligned-access capability
Base address, used in all indexing calculations
NOTE: moved up to Buffer.java for speed in JNI GetDirectBufferAddress
An object attached to this buffer. If this buffer is a view of another
buffer then we use this field to keep a reference to that buffer to
ensure that its memory isn't freed before we are done with it.
For duplicates and slices
--- Methods to support CharSequence ---
/  DragPane class
/  MotifDesktopManager class
PENDING(klobad) this should be optimized
We need to know Motif icon size
/ END of MotifDesktopManager
NOTE: This constructor is not required according to the spec. Only JCK expects it now.
NOTE: This constructor is not required according to the spec. We keep it as a convenience method.
Type-specific CORBA::Object operations
--------------------------JDBC 4.1 -----------------------------
-1 if no upper bound
Store away our index and pools in members
Create some string pool indexes that represent the names of some
magical nodes in the syntax tree.
(already done in static initialization...
Ok, so lets grind through the building of the DFA. This method
handles the high level logic of the algorithm, but it uses a
number of helper classes to do its thing.
In order to avoid having hundreds of references to the error and
string handlers around, this guy and all of his helper classes
just throw a simple exception and we then pass it along.
there was an error last time; so just go find correct Object in fElemmMap.
... after resetting state[0].
Increment counter if constant space algorithm applies
Increment counter if constant space algorithm applies
if we still can't find a match, set the state to first_error
and return null
It's likely that we looped too many times on the current state
however it's possible that we actually matched another particle
which allows the same name.
<xs:element name="foo" type="xs:string" minOccurs="3" maxOccurs="3"/>
<xs:element name="foo" type="xs:string" fixed="bar"/>
<xs:element name="foo" type="xs:string" minOccurs="3" maxOccurs="3"/>
<xs:any namespace="##any" processContents="skip"/>
In the DFA there will be two transitions from the current state which
allow "foo". Note that this is not a UPA violation. The ambiguity of which
transition to take is resolved by the current value of the counter. Since
we've already seen enough instances of the first "foo" perhaps there is
another element declaration or wildcard deeper in the element map which
not enough loops on the current state.
Exiting a counting state. If we're entering a new
counting state, reset the counter.
Entering a new counting state. Reset the counter.
If we've already seen one instance of the looping
particle set the counter to 1, otherwise set it
oneTransition(QName, int[], SubstitutionGroupHandler):  Object
findMatchingDecl(QName, SubstitutionGroupHandler): Object
if we still can't find a match, set the state to FIRST_ERROR and return null
if we found a match, set the next state and reset the
counter if the next state is a counting state.
findMatchingDecl(QName, int[], SubstitutionGroupHandler, int): Object
This method returns the start states of the content model.
Clear all constant space algorithm counters in use
[0] : the current state
[1] : if [0] is an error state then the
last valid state before the error
[2] : occurence counter for counting states
this method returns whether the last state was a valid final state
not enough loops on the current state to be considered final.
Killed off whatCanGoHere; we may need it for DOM canInsert(...) etc.,
but we can put it back later.
The first step we need to take is to rewrite the content model
using our CMNode objects, and in the process get rid of any
repetition short cuts, converting them into '*' style repetitions
or getting rid of repetitions altogether.
The conversions done are:
x+ -> (x|x*)
x? -> (x|epsilon)
This is a relatively complex scenario. What is happening is that
we create a top level binary node of which the special EOC value
is set as the right side node. The the left side is set to the
rewritten syntax tree. The source is the original content model
info from the decl pool. The rewrite is done by buildSyntaxTree()
which recurses the decl pool's content of the element and builds
a new tree in the process.
Note that, during this operation, we set each non-epsilon leaf
node's DFA state position and count the number of such leafs, which
is left in the fLeafCount member.
The nodeTmp object is passed in just as a temp node to use during
the recursion. Otherwise, we'd have to create a new node on every
level of recursion, which would be piggy in Java (as is everything
for that matter.)
And handle specially the EOC node, which also must be numbered
and counted as a non-epsilon leaf node. It could not be handled
in the above tree build because it was created before all that
started. We save the EOC position since its used during the DFA
Ok, so now we have to iterate the new tree and do a little more
work now that we know the leaf count. One thing we need to do is
to calculate the first and last position sets of each node. This
is cached away in each of the nodes.
Along the way we also set the leaf count in each node as the
maximum state count. They must know this in order to create their
first/last pos sets.
We also need to build an array of references to the non-epsilon
leaf nodes. Since we iterate it in the same way as before, this
will put them in the array according to their position values.
And, moving onward... We now need to build the follow position
sets for all the nodes. So we allocate an array of state sets,
one for each leaf node (i.e. each DFA position.)
And finally the big push... Now we build the DFA using all the
states and the tree we've built up. First we set up the various
data structures we are going to use while we do this.
First of all we need an array of unique element names in our
content model. For each transition table entry, we need a set of
contiguous indices to represent the transitions for a particular
input element. So we need to a zero based range of indexes that
map to element types. This element map provides that mapping.
optimization from Henry Zongaro:
If it was not in the list, then add it, if not the EOC node
the last entry in the element map must be the EOC element.
remove it from the map.
Next lets create some arrays, some that hold transient
information during the DFA build and some that are permament.
These are kind of sticky since we cannot know how big they will
get, but we don't want to use any Java collections because of
Basically they will probably be about fLeafCount*2 on average,
but can be as large as 2^(fLeafCount*2), worst case. So we start
with fLeafCount*4 as a middle ground. This will be very unlikely
to ever have to expand, though it if does, the overhead will be
Ok we start with the initial set as the first pos set of the
head node (which is the seq node that holds the content model
and the EOC node.)
Init our two state flags. Basically the unmarked state counter
is always chasing the current state counter. When it catches up,
that means we made a pass through that did not add any new states
to the lists, at which time we are done. We could have used a
expanding array of flags which we used to mark off states as we
complete them, but this is easier though less readable maybe.
Init the first transition table entry, and put the initial state
into the states to do list, then bump the current state.
Ok, almost done with the algorithm... We now enter the
loop where we go until the states done counter catches up with
the states to do counter.
Get the first unmarked state out of the list of states to do.
And get the associated transition table entry.
Mark this one final if it contains the EOC state
Bump up the unmarked state count, marking this state done
Loop through each possible input symbol in the element map
Build up a set of states which is the union of all of
the follow sets of DFA positions that are in the current
state. If we gave away the new set last time through then
create a new one. Otherwise, zero out the existing one.
If this leaf index (DFA position) is in the current set...
If this leaf is the current input symbol, then we
want to add its follow list to the set of states to
transition to from the current state.
If this new set is not empty, then see if its in the list
of states to do. If not, then add it.
Search the 'states to do' list to see if this new
state set is already in there.
If we did not find it, then add it
Put this new state into the states to do and init
a new entry at the same index in the transition
We now have a new state to do so bump the count
Null out the new set to indicate we adopted it.
This will cause the creation of a new set on the
next time around the loop.
Now set this state in the transition table's entry
for this element (using its index), with the DFA
state we will move to from the current state when we
see this input element.
Expand the arrays if we're full
Yikes, we overflowed the initial array size, so
we've got to expand all of these arrays. So adjust
up the size by 50% and allocate new arrays.
Copy over all of the existing content
Store the new array size
Fill in the occurence information for each looping state
if we're using counters.
And now we can say bye bye to the temp representation since we've
built the DFA.
Recurse as required
Now handle our level. We use our left child's last pos
set and our right child's first pos set, so go ahead and
get them ahead of time.
Now, for every position which is in our left child's last set
add all of the states in our right child's first set to the
follow set for that position.
Now handle our level. We use our own first and last position
sets, so get them up front.
For every position which is in our last position set, add all
of our first position states to the follow set for that
Set the maximum states on this node
Recurse as required
Put this node in the leaf list at the current index if its
a non-epsilon leaf.
Unique Particle Attribution
store the conflict results between any two elements in fElemMap
0: not compared; -1: no conflict; 1: conflict
initialize the conflict table (all 0 initially)
for each state, check whether it has overlap transitions
If "i" is a counting state and exactly one of the transitions
loops back to "i" then the two particles do not overlap if
minOccurs == maxOccurs.
report all errors
REVISIT: do we want to report all errors? or just one?
if there is a other or list wildcard, we need to check this CM
again, if this grammar is cached.
Do not include transitions which loop back to the
current state if we've looped the maximum number
of times or greater.
Do not include transitions which advance past the
current state if we have not looped enough times.
add schema message formatter to error reporter
read and discard the repository ID
write the repository ID
End of class CommentView.CommentBorder
End of CommentView
Private method to configure a MemoryHandler from LogManager
properties and/or default values as specified in the class
Initialize.  Size is a count of LogRecords.
Empty the buffer.
Branch target relative to this instruction
Target object in instruction list
Byte code offset
too large for short
May be negative, i.e., point backwards
DOMLocatorImpl (int lineNumber, int columnNumber, String uri )
DOMLocatorImpl (int lineNumber, int columnNumber, int utf16Offset, String uri )
DOMLocatorImpl (int lineNumber, int columnNumber, int offset, Node errorNode, String uri )
DOMLocatorImpl (int lineNumber, int columnNumber, int offset, Node errorNode, String uri )
Returns the sum of absolute differences
Returns the sum of absolute differences
Use type 0 for palette images
sigh -- 1.3 expects transform is never null, so we need to always write one out
Added for serial backwards compatibility (4348425)
We do not use system properties for applets in order to
avoid security exceptions.
The printStackTrace method of the Throwable class in jdk 1.4
and higher will include the cause when printing the backtrace.
The following code is only required when using jdk 1.3 or lower
-- This file was mechanically generated: Do not edit! --
enforce limit == capacity
read and discard the repository ID
write the repository ID
NPCTE fix for bugId 4464388, esc 0,  MR , to be added after modification of jmx spec
end of NPCTE fix for bugId 4464388
NPCTE fix for bugId 4464388, esc 0,  MR, to be added after modification of jmx spec
public synchronized Integer addNotification(String type, String message, Serializable userData,
Date date, long period, long nbOccurences)
end of NPCTE fix for bugId 4464388
NPCTE fix for bugId 4464388, esc 0,  MR , to be added after modification of jmx spec
public synchronized Integer addNotification(String type, String message, Serializable userData,
Date date, long period)
end of NPCTE fix for bugId 4464388 */
NPCTE fix for bugId 4464388, esc 0,  MR , to be added after modification of jmx spec
public synchronized Integer addNotification(String type, String message, Serializable userData,
Date date, long period)
end of NPCTE fix for bugId 4464388 */
NPCTE fix for bugId 4464388, esc 0,  MR, to be added after modification of jmx spec
public synchronized Integer addNotification(String type, String message, Serializable userData, Date date)
end of NPCTE fix for bugId 4464388
GETTERS AND SETTERS
NPCTE fix for bugId 4464388, esc 0 , MR , 03 sept 2001 , to be added after modification of jmx spec
end of NPCTE fix for bugId 4464388
-- This file was mechanically generated: Do not edit! --
Cached unsafe-access object
Cached array base offset
Cached unaligned-access capability
Base address, used in all indexing calculations
NOTE: moved up to Buffer.java for speed in JNI GetDirectBufferAddress
An object attached to this buffer. If this buffer is a view of another
buffer then we use this field to keep a reference to that buffer to
ensure that its memory isn't freed before we are done with it.
For duplicates and slices
End of file.
REVISIT: The test data gets put into a Properties object where
order is not guaranteed.  Thus the above array is in reverse.
testValue, testData (string or Pair[])
Where did this come from?
Boolean.TRUE, "27314" ),
NOTE: We are putting SERVER_HOST_NAME configuration info into
DataCollectorBase to avoid a security hole.  However, that forces
us to also set LISTEN_ON_ALL_INTERFACES at the same time.
This all needs to be cleaned up for two reasons: to get configuration
out of DataCollectorBase and to correctly support multihoming.
REVISIT after switch
testServicesURL, testServicesString ),
"Fooref", "Fooref" ),
Note that the same property is used to set two different
fields here.  This requires that both entries use the same test
data, or the test will fail.
No default - must be set by user if they are using
legacy socket factory.
useNIOSelector == true
useSelectThreadToWait = true
useWorkerThreadForEvent = false
useSelectThreadToWait = false
useWorkerThreadForEvent = true
useNIOSelector == true
useSelectThreadToWait = true
useWorkerThreadForEvent = true
useSelectThreadToWait = false
useWorkerThreadForEvent = true
For security reasons avoid creating an instance if
this socket factory class is not one that would fail
the class cast anyway.
InstantiationException, SecurityException or
For security reasons avoid creating an instance if
this socket factory class is not one that would fail
the class cast anyway.
InstantiationException, SecurityException or
For security reasons avoid creating an instance if
this socket factory class is not one that would fail
the class cast anyway.
InstantiationException, SecurityException or
For security reasons avoid creating an instance if
this socket factory class is not one that would fail
the class cast anyway.
InstantiationException, SecurityException or
For security reasons avoid creating an instance if
this socket factory class is not one that would fail
the class cast anyway.
InstantiationException, SecurityException or
For security reasons avoid creating an instance
if this class is one that would fail the class cast
to ORBInitializer anyway.
Now that we have a class object, instantiate one and
Unwrap the exception, as we don't care exc here
REVISIT - this is a cut and paste modification of makeROIOperation.
For security reasons avoid creating an instance
if this class is one that would fail the class cast
to ORBInitializer anyway.
Now that we have a class object, instantiate one and
Unwrap the exception, as we don't care exc here
Object is String[] of length 2.
End of file.
If you change this name you will need to change a unit test
tells the adminor to restart waiting with timeout
tell Timeout to terminate
wait until there is no more job
Socket-factory client constructor.
REVISIT - probably need a contact info for both
client and server for removing connections from cache?
REVISIT - case - needs interface method
IMPORTANT: non-channel-backed sockets must use
dedicated reader threads.
Note: public to override parent.
End of file.
fallback to client property
construct synchronized symbol table of default size
construct synchronized symbol table of given size
HashMap that maps CodeSource to ProtectionDomain
this is to make the stack depth consistent with 1.1
this is to make the stack depth consistent with 1.1
ProtectionDomain defers the binding
Don't support chains of references at this time. If do support in the future, this is where the code
would go to validate that don't have a cycle, resulting in an infinite loop. This may be unrealistic
to implement, and/or very expensive given remote URI references.
Retrieved resource is a byte stream
there are 45 types. 89 is the closest prime number to 45*2=90.
create all built-in types
create base types first
full schema simple type names
number of annotations in this identity constraint
get the name of the owning element
equals:  returns true if and only if the String
representations of all members of both objects (except for
the elenemtName field) are equal.
Must ignore interrupt on re-acquire
Must ignore interrupt on re-acquire
rather than build a big table or switch statement here, we'll
just check that the key isn't VK_UNDEFINED and assume that the
peer implementations will throw an exception for other bogus
values e.g. -1, 999999
need to sync the toolkit prior to grabbing the pixels since in some
cases rendering to the screen may be delayed
post a dummy event to the queue so we know when
all the events before it have been processed
Sep 14, 2000:
Fixed problem with namespace handling. Contributed by
David Blondeau <blondeau@intalio.com>
Sep 14, 2000:
Fixed serializer to report IO exception directly, instead at
the end of document processing.
Reported by Patrick Higgins <phiggins@transzap.com>
Aug 21, 2000:
Fixed bug in startDocument not calling prepare.
Reported by Mikael Staldal <d96-mst-ingen-reklam@d.kth.se>
Aug 21, 2000:
Added ability to omit DOCTYPE declaration.
DOM Level 3 implementation: variables intialized in DOMSerializerImpl
is node dom level 1 node?
counter for new prefix names
SAX content handler serializing methods
Check if text should be print as CDATA section or unescaped
based on elements listed in the output format (the element
state) or whether we are inside a CDATA section or entity.
Print a CDATA section. The text is not escaped, but ']]>'
appearing in the code must be identified and dealt with.
The contents of a text node is considered space preserving.
check if it is surrogate
The character is not printable -- split CDATA section
If preserving space then hold of indentation so no
excessive spaces are printed at line breaks, escape
the text content without replacing spaces and print
the text breaking only at line breaks.
overwrite printing functions to make sure serializer prints out valid XML
check for ']]>'
REVISIT: this means that if DOM Error handler is not registered we don't report any
fatal errors and might serialize not wellformed document
issue fatal error
split CDATA section
check if it is surrogate
The character is not printable -- split CDATA section
note that this "int" should, in all cases, be a char.
REVISIT:  make it a char...
character sequence "]]>" can't appear in content, therefore
we should escape '>'
Preserving spaces: the text must print exactly as it is,
without breaking when spaces appear in the text and without
consolidating spaces. If a line terminator is used, a line
break will occur.
check if it is surrogate
Not preserving spaces: print one part at a time, and
use spaces between parts to break them into different
lines. Spaces at beginning of line will be stripped
by printing mechanism. Line terminator is treated
no different than other text part.
check if it is surrogate
Preserving spaces: the text must print exactly as it is,
without breaking when spaces appear in the text and without
consolidating spaces. If a line terminator is used, a line
break will occur.
check if it is surrogate
Not preserving spaces: print one part at a time, and
use spaces between parts to break them into different
lines. Spaces at beginning of line will be stripped
by printing mechanism. Line terminator is treated
no different than other text part.
check if it is surrogate
These imports needed only as a workaround for a JavaDoc bug
Relative to this node
Ignoring exception causes default to be returned
Ignoring exception causes specified default to be returned
Ignoring exception causes specified default to be returned
Ignoring exception causes specified default to be returned
Ignoring exception causes specified default to be returned
Ignoring exception causes specified default to be returned
Absolute path.  Note that we've dropped our lock to avoid deadlock
Check for consecutive slashes
Absolute path.  Note that we've dropped our lock to avoid deadlock
Check for consecutive slashes
Ensure that all children are cached
Recursively remove all cached children
Now we have no descendants - it's time to die!
Wait on eventQueue till an event is present
XXX Log "Event dispatch thread interrupted. Exiting"
Now we have event & hold no locks; deliver evt to listeners
XXX Log "Starting event dispatch thread"
Note that when adding constants for newer releases, the
behavior of latest() and latestSupported() must be updated too.
-- This file was mechanically generated: Do not edit! --
Lazily created when first use. Mainly when
addNotificationListener is first called.
We should call reqIncomming() here... shouldn't we?
remove all registered listeners
we must not call fetchNotifs() if the server is
terminated (timeout elapsed).
returns null to force the client to stop fetching
Method IDs for doOperation
TRACES & DEBUG
REVISIT impl/poa specific
BEGIN Legacy support.
END Legacy support.
BEGIN Legacy support.
END Legacy support.
BEGIN Legacy support.
END Legacy support.
Determine the listening port (for the IOR).
This is important when using emphemeral ports (i.e.,
when the port value to the constructor is 0).
Register with transport (also sets up monitoring).
Configure to use listener and reader threads.
NOTE: The connection MUST be put in the cache BEFORE being
registered with the selector.  Otherwise if the bytes
are read on the connection it will attempt a time stamp
but the cache will be null, resulting in NPE.
A connection needs to be timestamped before putting to the cache.
Otherwise the newly created connection (with 0 timestamp) could be
incorrectly reclaimed by concurrent reclaim() call OR if there
will be no events on this connection then it could be reclaimed
by upcoming reclaim() call.
REVISIT - need to close - recreate - then register new one.
NOTE: if register cycling we do not want to shut down ORB
since local beans will still work.  Instead one will see
a growing log file to alert admin of problem.
REVISIT - how does this play with legacy ORBD port exchange?
IMPORTANT: To avoid bug (4953599), we force the
Thread that does the NIO select to also do the
enable/disable of Ops using SelectionKey.interestOps().
Otherwise, the SelectionKey.interestOps() may block
NOTE: If "acceptorSocketUseWorkerThreadForEvent" is
set to to false in ParserTable.java, then this method,
doWork(), will get executed by the same thread
(SelectorThread) that does the NIO select.
If "acceptorSocketUseWorkerThreadForEvent" is set
to true, a WorkerThread will execute this method,
doWork(). Hence, the registering of the enabling of
the SelectionKey's interestOps is done here instead
of calling SelectionKey.interestOps(<interest op>).
REVISIT: refactor into common base or delegate.
REVISIT - no factoring so cheat to avoid code dup right now.
REVISIT **** COUPLING !!!!
REVISIT: refactor into common base or delegate.
REVISIT - no factoring so cheat to avoid code dup right now.
REVISIT **** COUPLING !!!!
BEGIN Legacy support
LegacyServerSocketEndPointInfo and EndPointInfo
Work and Legacy both define getName.
Try to make this behave best for most cases.
END Legacy support
End of file.
The style/insets of a scrollbar can depend on a number of
factors (see GTKStyle.getScrollBarInsets()) so use a
complex key here.
The style/insets of a checkbox or radiobutton can depend
on the component orientation, so use a complex key here.
The style/insets of a button can depend on whether it is
default capable or in a toolbar, so use a complex key here.
Otherwise, just use the WidgetType as the key.
Check that since getting the lock this reference hasn't already been
enqueued (and even then removed)
Unchecked due to the next field having a raw type in Reference
Check if the pool is empty.
Remove object from end of free pool.
Check if the pool is empty.
Create a new object if so.
Throw unchecked exception for error in pool configuration.
Remove object from end of free pool.
Make sure the object is of the correct type.
Remove safety.  -sb
increaseSize not currently used.
No point in removing elements that "don't exist"...
%OPT% Does this really buy us anything? Test versus division for small,
test _plus_ division for big docs.
Last block may need to stop before end
The vector where all the slot data for the current thread is stored
Required for instantiating Any object.
The flag to check whether there are any updates in the current SlotTable.
The slots will be reset to null, only if this flag is set.
First check whether the slot is allocated
If not, raise the invalid slot exception
First check whether the slot is allocated
If not, raise the invalid slot exception
Attributes that exist in XML Signature in the same way
Attributes new in XML Encryption
we don't allow instantiation
Request focus if it isn't set.
Note: the SampleModel for the child Raster should have the same
width and height as that for the parent, since it represents
the physical layout of the pixel data.  The child Raster's width
and height represent a "virtual" view of the pixel data, so
they may be different than those of the SampleModel.
Clip to this raster
Grab one scanline at a time
Grab one scanline at a time
IntStack is trying to see this directly
Create a copy of Proxy as a security measure
SocketImpl.connect() is a protected method, therefore we need to use
getDeclaredMethod, therefore we need permission to access the member
java.net.SocketImpl class will always have this abstract method.
If we have not found it by now in the hierarchy then it does not
exist, we are an old style impl.
No need to do a checkOldImpl() here, we know it's an up to date
This is for backward compatibility
Shouldn't happen as we're connected
shouldn't happen as we're bound
not supported if socket already connected
Solaris returns error in such cases
Before 1.3 Sockets were always connected during creation
Before 1.3 Sockets were always bound during creation
If the stream is SORTED then it should also be ORDERED so the following will also
preserve the sort order
Holder of null state since ConcurrentHashMap does not support null values
If null has been seen then copy the key set into a HashSet that supports null values
and add null
TODO Implement a more efficient set-union view, rather than copying
Not lazy, barrier required to preserve order
Set compression types ("BI_RGB" denotes uncompressed).
Set compression flag.
Update the mnemonic binding.
Disabled buttons ignore all input...
button not armed, should be
Support for multiClickThreshhold
Get the height
Get the width
Abstract methods that must be implemented to be concrete.
AbstractTreeState does not directly become a TreeModelListener on
the model, it is up to some other object to forward these methods.
Local methods that subclassers may wish to use that are primarly
we don't need to add members because the ip address is a
Something wrong with attributes.
Force the bounding box to be recalced.
ComponentUI Interface Implementation methods
PENDING(jeff) - I18N
Change to folder on return
CENTER: left, right accessory
left panel - Filter & folderList
add the filter PENDING(jeff) - I18N
Add the Folder List PENDING(jeff) - I18N
create files list
add the filename field PENDING(jeff) - I18N
Since motif doesn't have button icons, leave this empty
which overrides the supertype icon loading
Since motif doesn't have button icons, leave this empty
which overrides the supertype icon loading
PENDING(jeff) - this is inefficient - should sent out
incremental adjustment values instead of saying that the
whole list has changed.
PENDING(jeff) - fire the correct interval changed - currently sending
out that everything has changed
PENDING(jeff) - this is inefficient - should sent out
incremental adjustment values instead of saying that the
whole list has changed.
PENDING(jeff) - fire the interval changed
DataModel for Types Comboxbox
Renderer for Types ComboBox
Ensure that the current filter is in the list.
NOTE: we shouldnt' have to do this, since JFileChooser adds
the filter to the choosable filters list when the filter
is set. Lets be paranoid just in case someone overrides
setFileFilter in JFileChooser.
This shouldn't happen. Try to recover gracefully.
UTF-8 only for now. Other ArrayDeocder only handles
CodingErrorAction.REPLACE mode. ZipCoder uses
UTF-8 only for now. Other ArrayDeocder only handles
assume invoked only if "this" is not utf8
build the ASN.1 encoding
get the type name
get the attributes of the struct
set the type name
this shouldn't happen, since we are Cloneable
create transport read timeouts
XXX This could probably be further extended by using more reflection and
a dynamic proxy that satisfies the interfaces that are inherited by the
more derived class.  Do we want to go that far?
Construct a map that maps field names to test or default values,
then use setFields from the parent class.  A map is constructed
by implementing AbstractMap, which requires implementing the
entrySet() method, which requires implementing a set of
map entries, which requires implementing an iterator,
which iterates over the ParserData, extracting the
correct (key, value) pairs (nested typed lambda expression).
index of next element to return
CONTROL TYPE DEFINES
to be constructed unmodifiable
As this instance is immutable, these two values need only
be calculated once.
Construct parent's state
Initialize this instance's specific state
replace null by empty
We already converted the array into an unmodifiable Set
in the descriptor.
Check and initialize defaultValue
Default value not supported for ArrayType and TabularType
Cast to Object because "OpenType<T> instanceof" is illegal
Check defaultValue's class
Check that we don't have both legalValues and min or max
Check minValue and maxValue
Check that defaultValue is a legal value
Check that minValue <= defaultValue <= maxValue
legalValues not supported for TabularType and arrays
Check legalValues are valid with openType
Check that, if both specified, minValue <= maxValue
Look for: public static T valueOf(String)
It is safe to call this plain Class.getMethod because the class "c"
Look for: public T(String)
It is safe to call this plain Class.getConstructor because the class "c"
check access to the provided base type class name and bail out early
String or String[] etc
Special case for ArrayType and TabularType
[JF] TODO: clone it so that it cannot be altered,
[JF] TODO: if we decide to support defaultValue as an array itself.
[JF] As of today (oct 2000) it is not supported so
defaultValue is null for arrays. Nothing to do.
Special case for ArrayType and TabularType
[JF] TODO: clone values so that they cannot be altered,
[JF] TODO: if we decide to support LegalValues as an array itself.
[JF] As of today (oct 2000) it is not supported so
legalValues is null for arrays. Nothing to do.
Returns our legalValues Set (set was constructed unmodifiable)
Note: only comparable values have a minValue,
so that's not the case of arrays and tabulars (always null).
Note: only comparable values have a maxValue,
so that's not the case of arrays and tabulars (always null).
cast to Comparable
Calculate the hash code value if it has not yet been done
(ie 1st call to hashCode())
return always the same hash code for this instance (immutable)
Calculate the string value if it has not yet been done
(ie 1st call to toString())
return always the same string representation for this
GETTERS AND SETTERS
If the counter that is monitored rolls over when it reaches a
maximum value, then the modulus value needs to be set to that
maximum value. The threshold will then also roll over whenever
it strictly exceeds the modulus value. When the threshold rolls
over, it is reset to the value that was specified through the
latest call to the monitor's setInitThreshold method, before
any offsets were applied.
The counter difference mode is used.
The previous scan counter has been initialized.
If derived gauge is negative it means that the
counter has wrapped around and the value of the
threshold needs to be reset to its initial value.
The previous scan counter has not been initialized.
We cannot update the derived gauge...
The counter difference mode is not used.
Send notification if notify is true.
Calculate the new threshold value if the threshold has been
exceeded and if the offset value is greater than zero.
Increment the threshold until its value is greater
than the one for the current derived gauge.
Set threshold attribute.
Should never occur...
If the counter can wrap around when it reaches
its maximum and we are not dealing with counter
differences then we need to reset the threshold
to its initial value too.
Threshold value has been modified so we can notify again.
Should never occur...
Check that the observed attribute is of type "Integer".
Check if counter has wrapped around.
Update the derived gauge attributes and check the
validity of the new value. The derived gauge value
is invalid when the differenceMode flag is set to
true and it is the first notification, i.e. we
haven't got 2 consecutive values to update the
Notify the listeners and update the threshold if
the updated derived gauge value is valid.
make this XMLReader the parent of this filter
call parse on the parent
create common built-in types
all schema simple type names
---------------------------- jdbc 3.0 -----------------------------------
Common UI methods
localized level name
private constructor to specify whether this instance should be added
to the KnownLevel list from which Level.parse method does its look up
package-private getLevelName() is used by the implementation
instead of getName() to avoid calling the subclass's version
This is a trick to determine whether the name has been translated
or not. If it has not been translated, we need to use Locale.ROOT
when calling toUpperCase().
ALL CAPS in a resource bundle's message indicates no translation
needed per Oracle translation guideline.  To workaround this
in Oracle JDK implementation, convert the localized level name
to uppercase for compatibility reason.
Avoid looking up the localizedLevelName twice if we already
OK: our cached value was looked up with the same
locale. We can use it.
No resource bundle: just use the name.
We need to compute the localized name.
Either because it's the first time, or because our cached
value is for a different locale. Just return null.
See if we have a cached localized name
No cached localized name or cache invalid.
Need to compute the localized name.
Returns a mirrored Level object that matches the given name as
specified in the Level.parse method.  Returns null if not found.
It returns the same Level object as the one returned by Level.parse
method if the given name is a non-localized name or integer.
If the name is a localized name, findLevel and parse method may
return a different level value if there is a custom Level subclass
that overrides Level.getLocalizedName() to return a different string
than what's returned by the default implementation.
Look for a known Level with the given non-localized name.
Now, check if the given name is an integer.  If so,
first look for a Level with the given value and then
if necessary create one.
add new Level
Not an integer.
Serialization magic to prevent "doppelgangers".
This is a performance optimization.
Woops.  Whoever sent us this object knows
about a new log level.  Add it to our list.
Check that name is not null.
Look for a known Level with the given non-localized name.
Now, check if the given name is an integer.  If so,
first look for a Level with the given value and then
if necessary create one.
add new Level
Not an integer.
Finally, look for a known level with the given localized name,
in the current default locale.
This is relatively expensive, but not excessively so.
OK, we've tried everything and failed
KnownLevel class maintains the global list of all known levels.
The API allows multiple custom Level instances of the same name/value
be created. This class provides convenient methods to find a level
by a given name, by a given value, or by a given localized name.
KnownLevel wraps the following Level objects:
1. levelObject:   standard Level object or custom Level object
2. mirroredLevel: Level object representing the level specified in the
Level.getName, Level.getLocalizedName, Level.getResourceBundleName methods
are non-final but the name and resource bundle name are parameters to
the Level constructor.  Use the mirroredLevel object instead of the
levelObject to prevent the logging framework to execute foreign code
implemented by untrusted Level subclass.
If Level.getName, Level.getLocalizedName, Level.getResourceBundleName methods
were final, the following KnownLevel implementation can be removed.
Future API change should take this into consideration.
instance of Level class or Level subclass
mirror of the custom Level
this mirrored level object is hidden
the mirroredLevel object is always added to the list
before the custom Level instance
Returns a KnownLevel with the given non-localized name.
Returns a KnownLevel with the given value.
Returns a KnownLevel with the given localized name matching
by calling the Level.getLocalizedLevelName() method (i.e. found
from the resourceBundle associated with the Level object).
This method does not call Level.getLocalizedName() that may
be overridden in a subclass implementation
Delegates to different icons based on component orientation
Delegates to different icons based on button state
.30 0 DDE8F3 white secondary2
Other possible properties that aren't defined:
Used when generating the disabled Icons, provides the region to
constrain grays to.
Button.disabledGrayRange -> Object[] of Integers giving min/max
InternalFrame.inactiveTitleGradient -> Gradient when the
internal frame is inactive.
makes use of getIconResource() to fetch an icon and then hastens it
- calls createValue() on it and returns the actual icon
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of FileChooserPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of FileChooserPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
REVISIT - Right now, EncapsOutputStream's do not use
pooled byte buffers. This is controlled by the following
static constant. This should be re-factored such that
the EncapsOutputStream doesn't know it's using pooled
REVISIT - Right now, valuetypes in encapsulations will
only use stream format version 1, which may create problems
for service contexts or codecs (?).
GIOP version 1.2 with no fragmentation, big endian,
REVISIT.  A UTF-16 encoding with GIOP 1.1 will not work
with byte order markers.
Used by IIOPProfileTemplate
In the case of GIOP 1.1, we take the byte order of the stream and don't
use byte order markers since we're limited to a 2 byte fixed width encoding.
Assume anything else meets GIOP 1.2 requirements
Use byte order markers?  If not, use big endian in GIOP 1.2.
(formal 00-11-03 15.3.16)
javadoc inherited from Throwable.java
-- This file was mechanically generated: Do not edit! --
these declarations are here as documentation
TODO: use arrays for faster access
the list containing the events
use a hashset to detect duplicate events in add(MidiEvent)
start with the end of track event
get the last event
sanity check that we have a correct end-of-track
if there is no eot event, add our immutable instance again
set eotEvent's tick to the last tick of the track
if the events list is empty, just set the tick to 0
we needn't check for a duplicate of eotEvent in "eventsList",
since then it would appear in the set.
first see if we are trying to add
and endoftrack event.
since end of track event is useful
for delays at the end of a track, we want to keep
the tick value requested here if it is greater
than the one on the eot we are maintaining.
Otherwise, we only want a single eot event, so ignore.
insert event such that events is sorted in increasing
we're adding an event after the
tick value of our eot, so push the eot out.
Always add at the end for better performance:
this saves all the checks and arraycopy when inserting
overwrite eot with new event
set new time of eot, if necessary
add eot again at the end
this implementation allows removing the EOT event.
pretty bad, but would probably be too risky to
change behavior now, in case someone does tricks like:
also, would it make sense to adjust the EOT's time
to the last event, if the last non-EOT event is removed?
Or: document that the ticks() length will not be reduced
by deleting events (unless the EOT event is removed)
Write the fields to the stream in the order
provided by the ObjectStreamClass.  (They should
be sorted appropriately already.)
Stream format version, saved/restored during recursive calls
Return the stream format version currently being used
to serialize an object
User uses PutFields to simulate default data.
The following is a State pattern implementation of what
should be done when a Serializable has a
writeObject method.  This was especially necessary for
RMI-IIOP stream format version 2.  Please see the
state diagrams in the docs directory of the workspace.
Description of possible actions
XXX I18N, logging needed.
We didn't write any data, so write the
called defaultWriteObject indicator as false
If we're in stream format verison 2, we must
put the "null" marker to say that there isn't
any optional data
The writeObject method called defaultWriteObject
or writeFields, so put the called defaultWriteObject
indicator as true
The writeObject method first called a direct
write operation.  Write the called defaultWriteObject
indicator as false, put the special stream format
version 2 header (if stream format version 2, of course),
and write the data
We only wrote default data, so if in stream format
version 2, put the null indicator to say that there
is no optional data
XXX I18N, logging needed.
The writeObject method called a direct write operation.
If in stream format version 2, put the fake valuetype
In stream format version 2, we must tell the ORB
stream to close the fake custom valuetype.
XXX I18N, logging needed.
We don't have to do anything special here, just let
the stream write the data.
override for covariant return type
inline TemporalAccessor.super.query(query) as an optimization
non-JDK classes are not permitted to make this optimization
override for Javadoc
%%% JMB. Agreed. Add code here to throw a SQLException if no
support is available for locatorsUpdateCopy=false
Serializing locators is not supported.
Note: get an ASCII stream in order to null-check it,
even though we don't do anything with it.
increment pos, and i
increment pos only
need check to ensure length + offset !> bytes.length
values in the array are at position one less
re-size the buffer
this shouldn't happen, since we are Cloneable
Note: this check to see if it is an instance of Serializable
is for backwards compatibiity
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
end of ChildrenIterator
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
%OPT% The most common case is handled first.
end of ParentIterator
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
%OPT% If the nodeType is element (matching child::*), we only
need to compare the expType with DTM.NTYPES. A child node of
an element can be either an element, text, comment or
processing instruction node. Only element node has an extended
type greater than or equal to DTM.NTYPES.
end of TypedChildrenIterator
end of TypedRootIterator
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
end of FollowingSiblingIterator
end of TypedFollowingSiblingIterator
assumes caller will pass element nodes
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
end of AttributeIterator
assumes caller will pass element nodes
singleton iterator, since there can only be one attribute of
a given type.
end of TypedAttributeIterator
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
Be careful to handle the Document node properly
end of PrecedingSiblingIterator
end of TypedPrecedingSiblingIterator
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
iterator is not a clone
Pop actual root node (if not start) back off the stack
Last parent before root node
Bugzilla 8324: We were forgetting to skip Attrs and NS nodes.
Also recoded the loop controls for clarity and to flatten out
redefine DTMAxisIteratorBase's reset
end of PrecedingIterator
end of TypedPrecedingIterator
DTMAxisTraverser m_traverser;  easier for now
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
_currentNode precedes possible following(node) nodes
end of FollowingIterator
end of TypedFollowingIterator
The initial size of the ancestor array
The array for ancestor nodes. This array will grow dynamically.
Number of ancestor nodes in the array
must set to false for any clone
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
Start from the current node's parent if
_includeSelf is false.
end of AncestorIterator
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
end of TypedAncestorIterator
%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily
%OPT% If the startNode is the root node, do not need
to do the isDescendant() check.
end of DescendantIterator
%OPT% If the start node is root (e.g. in the case of node),
we can save the isDescendant() check, because all nodes are
descendants of root.
end of TypedDescendantIterator
end of TypedSingletonIterator
%OPT% Array references which are used to cache the map0 arrays in
SuballocatedIntVectors. Using the cached arrays reduces the level
of indirection and results in better performance than just calling
Double array references to the map arrays in SuballocatedIntVectors.
%OPT% Cache the array of extended types in this class
A Vector which is used to store the values of attribute, namespace,
comment and PI nodes.
%OPT% These values are unlikely to be equal. Storing
them in a plain Vector is more efficient than storing in the
DTMStringPool because we can save the cost for hash calculation.
%REVISIT% Do we need a custom class (e.g. StringVector) here?
The current index into the m_values Vector.
The maximum value of the current node index.
Cache the shift and mask values for the SuballocatedIntVectors.
The number of bits for the length of a Text node.
The number of bits for the offset of a Text node.
The maximum length value
The maximum offset value
True if we want to build the ID index table.
Constant for empty String
Constant for empty XMLString
Initialize the values of m_SHIFT and m_MASK.
Some documents do not have attribute nodes. That is why
we set the initial size of this Vector to be small and set
the increment to a bigger number.
Set the map0 values in the constructor.
SPECIAL CASE: Implied declaration at root element
go to the next attribute.
Bit of a hack... if somehow valString is null, stringToIndex will
return -1, which will make things very unhappy.
for the children.
If no one noticed, startPrefixMapping is a drag.
Pop the context for the last child (the one pushed by startElement)
Do it again for this one (the one pushed by the last endElement).
ignore comments if we're inside the DTD
%OPT% Saving the comment string in a Vector has a lower cost than
saving it in DTMStringPool.
for the next element.
Add a NULL entry to the end of the node arrays as
the end indication.
Set the cached references after the document is built.
Common to all nodes:
Have we overflowed a DTM Identity's addressing range?
if(m_dtmIdent.size() == (nodeIndex>>>DTMManager.IDENT_DTM_NODE_BITS))
Note that nextSibling is not processed until charactersFlush()
is called, to handle successive characters() events.
Special handling by type: Declare namespaces, attach first child
-1 indicates no-text-in-progress
Discard accumulated text
Guard against characters/ignorableWhitespace events that
contained no characters.  They should not result in a node.
If the offset and length do not exceed the given limits
(offset < 2^21 and length < 2^10), then save both the offset
and length in a bitwise encoded value.
Store offset and length in the m_data array if one exceeds
the given limits. Use a negative dataIndex as an indication.
Reset for next text block
Assume that attributes and namespaces immediately follow the element.
Assume this can not be null.
Assume that attributes and namespaces immediately follow the element.
Assume this can not be null.
Assume that attributes and namespace nodes immediately follow the element
optimization: only create StringBuffer if > 1 child
%OPT% Optimization for documents which does not have any explicit
namespace nodes. For these documents, there is an implicit
namespace node (xmlns:xml="http:www.w3.org/XML/1998/namespace")
declared on the root element node. In this case, there is no
need to do namespace copying. We can safely return without
Find the first namespace node
Retrieve the name of the namespace node
Retrieve the node value of the namespace node
Mark 1 as composite
Find primes and remove their multiples from sieve
Construct the large sieve at an even offset specified by base
Calculate base mod convertedStep
Take each multiple of step out of sieve
Find next prime from small sieve
Examine the sieve one long at a time to find possible primes
Bounds check for 'b' will be performed automatically
Bounds check for 'b' will be performed automatically
Bounds check for 'b' will be performed automatically
Bounds check for 'b' will be performed automatically
Bounds check for 'b' will be performed automatically
If we implement equals() we must also implement hashCode
No action for the moment.
time to fire off startElement event
In final output state we do process the characters!
This for() loop always increments i by one at the end
of the loop.  Additional increments of i adjust for when
two input characters (a high/low UTF16 surrogate pair)
one input char processed
one input char processed
I think we can just emit the message,
not crash and burn.
Older behavior was to throw the message,
but newer gentler behavior is to write a message to System.err
two input chars processed
Don't know what to do with this char, it is
not in the encoding and not a high char in
a surrogate pair, so write out as an entity ref
not in the encoding, so write out a character reference
I think we can just emit the message,
not crash and burn.
Older behavior was to throw the message,
but newer gentler behavior is to write a message to System.err
one input char was processed
flush anything pending first
do nothing, just forget all about the attribute
time to fire off startlement event.
do nothing, forget about the attribute
do nothing, forget about the attribute
no namespace support for HTML
no namespace support for HTML
no namespace support for HTML
Declare serialVersionUID to be compatible with JDK1.1
No need to normalize if already normalized.
If kid is a text node, we need to check for one of two
1) There is an adjacent text node
2) There is no adjacent text node, but kid is
an empty text node.
If an adjacent text node, merge it with kid
Don't advance; there might be another.
If kid is empty, remove it
localize all params
main and workspace arrays
localize all params
split larger, find point in smaller
localize all params
main and workspace arrays
localize all params
split larger, find point in smaller
localize all params
main and workspace arrays
localize all params
split larger, find point in smaller
localize all params
main and workspace arrays
localize all params
split larger, find point in smaller
localize all params
main and workspace arrays
localize all params
split larger, find point in smaller
localize all params
main and workspace arrays
localize all params
split larger, find point in smaller
localize all params
main and workspace arrays
localize all params
split larger, find point in smaller
localize all params
main and workspace arrays
localize all params
split larger, find point in smaller
End of file.
REVISIT: we are losing the type information in DOM during serialization
DOM Level 3: namespace URI is never empty string.
convert the empty string to 'null'
1. if the qualified name is 'null' it is malformed.
2. or if the qualifiedName is null and the namespaceURI is different from null,
We dont need to check for namespaceURI != null, if qualified name is null throw DOMException.
there is no prefix
there is a prefix
1. if the qualifiedName has a prefix and the namespaceURI is null,
2. or if the qualifiedName has a prefix that is "xml" and the namespaceURI
is different from " http:www.w3.org/XML/1998/namespace"
when local name is known
Support for DOM Level 3 renameNode method.
Note: This only deals with part of the pb. CoreDocumentImpl
does all the work.
remove children first
set owner document
synchronizeData will initialize attributes
DOM2: Namespace methods.
update node name with new qualifiedName
Absolute base URI is computed according to XML Base (http:www.w3.org/TR/xmlbase/#granularity)
1.  the base URI specified by an xml:base attribute on the element, if one exists
attribute value is always empty string
This may be a relative URI.
Start from the base URI of the parent, or if this node has no parent, the owner node.
Make any parentURI into a URI object to use with the URI(URI, String) constructor.
This should never happen: parent should have checked the URI and returned null if invalid.
REVISIT: what should happen in this case?
2.the base URI of the element's parent element within the document or external entity,
if one exists
base URI of parent element is not null
return valid absolute base URI
REVISIT: what should happen in this case?
3. the base URI of the document entity or external entity containing the element
return valid absolute base URI
REVISIT: what should happen in this case?
add this message to fix bug 21478
Earlier (JDK 1.4 XALAN 2.2-D11) at key code '204' the key name was ER_PRIORITY_NOT_PARSABLE
In latest Xalan code base key name is  ER_VALUE_SHOULD_BE_NUMBER. This should also be taken care
in locale specific files like XSLTErrorResources_de.java, XSLTErrorResources_fr.java etc.
NOTE: Not only the key name but message has also been changed.
Note to translators:  The following message should not normally be displayed
to users.  It describes a situation in which the processor has detected
an internal consistency problem in itself, and it provides this message
for the developer to help diagnose the problem.  The name
'ElemTemplateElement' is the name of a class, and should not be
Note to translators:  The following message should not normally be displayed
to users.  It describes a situation in which the processor has detected
an internal consistency problem in itself, and it provides this message
for the developer to help diagnose the problem.  The substitution text
provides further information in order to diagnose the problem.  The name
'RedundentExprEliminator' is the name of a class, and should not be
This code is shared with warning codes.
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "QNAME" is the XML data-type of
The following codes are shared with the warning codes...
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "ENUM" is the XML data-type of
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "NMTOKEN" is the XML data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "NCNAME" is the XML data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "boolean" is the XSLT data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "number" is the XSLT data-type
End of shared codes...
Note to translators:  A "match pattern" is a special form of XPath expression
that is used for matching patterns.  The substitution text is the name of
a function.  The message indicates that when this function is referenced in
a match pattern, its argument must be a string literal (or constant.)
ER_ARG_LITERAL - new error message for bugzilla 5202
Note to translators:  The following message indicates that two definitions of
a variable.  A "global variable" is a variable that is accessible everywher
in the stylesheet.
ER_DUPLICATE_GLOBAL_VAR - new error message for bugzilla #790
Note to translators:  The following message indicates that two definitions of
a variable were encountered.
ER_DUPLICATE_VAR - new error message for bugzilla #790
Note to translators:  "xsl:template, "name" and "match" are XSLT keywords
which must not be translated.
ER_TEMPLATE_NAME_MATCH - new error message for bugzilla #789
Note to translators:  "exclude-result-prefixes" is an XSLT keyword which
should not be translated.  The message indicates that a namespace prefix
encountered as part of the value of the exclude-result-prefixes attribute
was in error.
ER_INVALID_PREFIX - new error message for bugzilla #788
Note to translators:  An "attribute set" is a set of attributes that can
be added to an element in the output document as a group.  The message
was never defined.
ER_NO_ATTRIB_SET - new error message for bugzilla #782
Note to translators:  This message indicates that there was a reference
Note to translators:  This message indicates that the XSLT instruction
instructions (content) or a "select" attribute.  The word "select" is
an XSLT keyword in this case and must not be translated.
Note to translators:  This message indicates that the value argument
of setParameter must be a valid Java Object.
Following are the new WARNING keys added in XALAN code base after Jdk 1.4 (Xalan 2.2-D11)
Note to translators:  "name" and "xsl:processing-instruction" are keywords
and must not be translated.
Note to translators:  "name" and "xsl:processing-instruction" are keywords
and must not be translated.  "NCName" is an XML data-type and must not be
Note to translators:  This message is reported if the stylesheet that is
being processed attempted to construct an XML document with an attribute in a
place other than on an element.  The substitution text specifies the name of
Check: WHY THERE IS A GAP B/W NUMBERS in the XSLTErrorResources properties file?
Other miscellaneous text used inside the code...
Note to translators:  The following messages provide usage information
for the Xalan Process command line.  "Process" is the name of a Java class,
and should not be translated.
Note to translators: The option name and the parameter name do not need to
be translated. Only translate the messages in parentheses.  Note also that
leading whitespace in the messages is used to indent the usage information
for each option in the English messages.
Do not translate the keywords: XSLTC, SAX, DOM and DTM.
Following are the new options added in XSLTErrorResources.properties files after Jdk 1.4 (Xalan 2.2-D11)
Added by sboag/scurcuru; experimental
AddITIONAL  STRINGS that need L10n
Note to translators:  The following message describes usage of a particular
command-line option that is used to enable the "template inlining"
optimization.  The optimization involves making a copy of the code
generated for a template in another template that refers to it.
================= INFRASTRUCTURE ======================
--> can be moved to XSLT
a  single instance cached here
XXX Getting rid of this requires introducing an ObjectAdapterManager abstraction
as an interface into the OA framework.
Make sure that the POAManager is activated if no other
POAManager state management has taken place.
Common UI methods
If our parent is a DefaultFrame, we need to dispose it, too.
Do not call pack() if window is not visible to
avoid early native peer creation
Generally not useful, bail.
Popups are typically transient and most likely won't benefit
from true double buffering.  Turn it off here.
Try to set "always-on-top" for the popup window.
Applets usually don't have sufficient permissions to do it.
In this case simply ignore the exception.
setAlwaysOnTop is restricted,
the exception is ignored
sets editorExplicitlySet true
We want the spinner's increment/decrement actions to be
active vs those of the JFormattedTextField. As such we
put disabled actions in the JFormattedTextField's actionmap.
A binding to a disabled action is treated as a nonexistant
Indicates we aren't installed anywhere.
Try to set the new value
SpinnerModel didn't like new value, reset
Still bogus, nothing else we can do, the
SpinnerModel and JFormattedTextField are now out
If the value in the JFormattedTextField is legal, this will have
the result of pushing the value to the SpinnerModel
by way of the <code>propertyChange</code> method.
PENDING(hmuller): more example javadoc
This is here until SimpleDateFormat gets a constructor that
takes a Locale: 4923525
PENDING(hmuller): more example javadoc
This is here until DecimalFormat gets a constructor that
takes a Locale: 4923525
Get the pattern for the default locale.
TBD should throw a chained error here
model is guaranteed to be non-null
entire text may have changed
the JSpinner has one child, the editor
the JSpinner has one child, the editor
try to set the new value
SpinnerModel didn't like new value
try to set the new value
SpinnerModel didn't like new value
convert point from the JSpinner bounds (source) to
editor bounds (destination)
return rectangle in the the JSpinner bounds
State for <html>, <head> and <body>.  Since people like to slap
together HTML documents without thinking, occasionally they
have multiple instances of these tags.  These booleans track
the first sightings of these tags so they can be safely ignored
by the parser if repeated.
To correctly identify the start of a tag/comment/text we need two
ivars. Two are needed as handleText isn't invoked until the tag
after the text has been parsed, that is the parser parses the text,
then a tag, then invokes handleText followed by handleStart.
default behavior is to call handleText. Subclasses
can override if necessary.
We've reached EOF.  Our recovery strategy is to
if so, we pretend that the comment was an unterminated
single line comment, and reparse the lines after the
first line as normal HTML content.
no newline, so signal an error
enlarge buffer if needed
output pending space
Handles cases of bad html where the title tag
was getting lost when we did error recovery.
If the tag is an empty tag and texpos != 0
this implies that there is text before the
start tag that needs to be processed before
handling the tag.
this variable gets updated in handleText().
Since in this case we do not call handleText()
we need to update it here.
Note that we should really check last.breakFlows before
assuming this should be false.
check required attributes
handle the tag
Refer to note in definition of buf for details on this.
Deal with the empty stack
Is it allowed in the current context
The use of all error recovery strategies are contingent
on the value of the strict property.
These are commonly occurring errors.  if insertTag is true,
then we want to adopt an error recovery strategy that
involves attempting to insert an additional tag to
legalize the context.  The two errors addressed here
1) when a <td> or <th> is seen soon after a <table> tag.
In this case we insert a <tr>.
2) when any other tag apart from a <tr> is seen
in the context of a <tr>.  In this case we would
like to add a <td>.  If a <tr> is seen within a
<tr> context, then we will close out the current
This insertion strategy is handled later in the method.
The reason for checking this now, is that in other cases
we would like to apply other error recovery strategies for example
In certain cases it is better to ignore a tag than try to
fix the situation.  So the first test is to see if this
is what we need to do.
Check for anything after the start of the table besides tr, td, th
or caption, and if those aren't there, insert the <tr> and call
They try to find a legal context by checking if the current
tag is valid in an enclosing context.  If so
close out the tags by outputing end tags and then
insert the current tag.  If the tags that are
being closed out do not have an optional end tag
specification in the DTD then an html error is
Check if we know what tag is expected next.
If so insert the tag.  Report an error if the
tag does not have its start tag spec in the DTD as optional.
Traverse the list of expected elements and determine if adding
any of these elements would make for a legal context.
Ensure that this element has not been included as
part of the exclusions in the DTD.
Ensure that no tag that has required attributes
Check if the stack can be terminated.  If so add the appropriate
end tag.  Report an error if the tag being ended does not have its
end tag spec in the DTD as optional.
At this point we know that something is screwed up.
Avoid putting a block tag in a flow tag.
Avoid putting something wierd in the head of the document.
REMIND: it's not clear whether this version should set strpos or not
not officially allowed
parse decimal reference
parse hexadecimal reference
entities are case sensitive - however if strict
is false then we will try to make a match by
converting the string to all lowercase.
outside unicode BMP.
match end tag
Check for a delimiter
Parse the rest of the value
Bug ID 4102750
Load the NAME of an Attribute Case Sensitive
The case of the NAME  must be intact
Make it null so that NULL_ATTRIBUTE_VALUE is
allows for comma separated attribute-value pairs
allows for quoted attributes
Check out the value
ignore all data upto the close bracket '>'
Parse comment. [92] 391:7
send over any text you might see
before parsing and sending the
deal with marked sections
parse end tag [19] 317:4
empty end tag. either </> or </<
Ignore RE before end tag
If the stack is null, we're seeing end tags without any begin
tags.  Ignore them.
Ignore RE before end tag
In a pre tag, if there are blank lines
we do not want to remove the newline
before the end tag.  Hence this code.
If the end tag is a form, since we did not put it
on the tag stack, there is no corresponding start
start tag to find. Hence do not touch the tag stack.
we will not see a corresponding start tag
on the the stack.  If we are seeing an
end tag, lets send this on as an empty
tag with the end tag attribute set to
find the corresponding start tag
A commonly occurring error appears to be the insertion
of extra end tags in a table.  The intent here is ignore
such extra end tags.
If it is not a valid end tag ignore it and return
People put font ending tags in the darndest places.
Don't close other contexts based on them being between
a font tag and the corresponding end tag.  Instead,
ignore the end tag like it doesn't exist and allow the end
of the document to close us out.
Since closing out a center tag can have real wierd
effects on the formatting,  make sure that tags
for which omitting an end tag is legimitate
get closed out.
People do the same thing with center tags.  In this
case we would like to close off the center tag but
not necessarily all enclosing tags.
start tag [14] 314:1
ignore RE after start tag
ensure a legal context for the tag
Smlly, if a tag is unknown, we will apply
no legalTagContext logic to it.
If skip tag is true,  this implies that
the tag was illegal and that the error
recovery strategy adopted is to ignore
it isn't end script tag, but may be it's start comment tag?
resignal the interrupt
means: if after starting <script> tag
null end tag.
enlarge buffer if needed
output pending space
NOTE: interruption may have occurred.  Control flows out
of here normally.
This loop allows us to ignore interrupts if the flag
These message should be read from a locale-specific resource bundle
1.0 LocateReply body does not contain SystemException
raises exception on error
The code below reads the reply body if status is OBJECT_FORWARD
Note, this writes only the header information.
IOR may be written afterwards into the reply mesg body.
-- This file was mechanically generated: Do not edit! --
Cached unsafe-access object
Cached array base offset
Cached unaligned-access capability
Base address, used in all indexing calculations
NOTE: moved up to Buffer.java for speed in JNI GetDirectBufferAddress
An object attached to this buffer. If this buffer is a view of another
buffer then we use this field to keep a reference to that buffer to
ensure that its memory isn't freed before we are done with it.
For duplicates and slices
Double.MIN_VALUE doesn't work with math below
so just use a big number and hope I never get caught.
Normalize end index.
set content model source
get content model source
Message keys used by the serializer
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The localname is the portion after the optional colon; the message indicates
that there is a problem with that part of the QNAME.
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The prefix is the portion before the optional colon; the message indicates
that there is a problem with that part of the QNAME.
From NotificationEmitter extends NotificationBroacaster
From NotificationEmitter extends NotificationBroacaster
From NotificationEmitter extends NotificationBroacaster
From NotificationEmitter extends NotificationBroacaster
skip chunk type
The number of bands by PNG color type
gray + alpha
rgb + alpha
The number of source pixels processed
The total number of pixels in the source image
Clear all values based on the previous stream contents
Re-use signature array to bulk-read these unsigned byte values
Skip IHDR CRC
Round array sizes up to 2^2^n
RGB or RGB_ALPHA
Decompress the text
Alpha table may have fewer entries than RGB palette
We've reached the image data
Skip the chunk plus the 4 CRC bytes that follow
verify the chunk length
If chunk type is 'IDAT', we've reached the image data.
Read an unknown chunk
double check whether all chunk data were consumed
Data filtering methods
GA in GA order
RGB in RGB order
RGBA in RGBA order
Read the image row-by-row
Skip filter byte and the remaining row bytes
If read has been aborted, just return
processReadAborted will be called later
Determine which pixels will be updated in this pass
If no pixels need updating, just skip the input data
Update count of pixels read
Skip filter byte and the remaining row bytes
Backwards map from destination pixels
(dstX = updateMinX + k*updateXStep)
to source pixels (sourceX), and then
to offset and skip in passRow (srcX and srcXStep)
Compute the step factor in the source
Create a 1-row tall Raster to hold the data
Create an array suitable for holding one pixel
Handle source and destination bands
Determine if all of the relevant output bands have the
same bit depth as the source data
If the bit depths differ, create a lookup table per band to perform
Limit passRow to relevant area for the case where we
will can setRect to copy a contiguous span
Decode the (sub)image row-by-row
Update count of pixels read
Read the filter type byte and a row of data
Swap curr and prior
TODO - throw a more meaningful exception
Copy data into passRow byte by byte
True Y position in source
If read has been aborted, just return
processReadAborted will be called later
If read has been aborted, just return
processReadAborted will be called later
Init default values
If an ImageReadParam is available, get values from it
At this point the header has been read and we know
how many bands are in the image, so perform checking
of the read param.
some standard types of buffered images
which can be used as destination
Component R, G, B
Need tRNS chunk
Alpha from tRNS chunk may have fewer entries than
the RGB LUTs from the PLTE chunk; if so, pad with
Component G, A
some standard types of buffered images
wich can be used as destination
Component R, G, B, A (non-premultiplied)
This hashCode is used by the sun.awt implementation as an array
-- This file was mechanically generated: Do not edit! --
important: The ds:Reference must be added to the associated ds:Manifest
or ds:SignedInfo _before_ the this.resolverResult() is called.
there is one InclusiveNamespaces element
log a warning
log a warning
if signing and c14n11 property == true explicitly add
C14N11 transform if needed
The required element is not in the XML!
In an ideal world, we would do an assertion here
to help developers know they are probably doing
if this is the first listener added,
initialize the lists
Otherwise copy the array and add the new listener
In an ideal world, we would do an assertion here
to help developers know they are probably doing
Is l on the list?
If so,  remove it
Copy the list up to index
Copy from two past the index, up to
the end of tmp (which is two elements
shorter than the old list)
set the listener array to the new array or null
Save the non-null event listeners:
Implementation of org.xml.sax.Locator
Setters for the properties (not in org.xml.sax.Locator)
end of LocatorImpl.java
Used to establish initial head or SHARED marker
Used by addWaiter
Used by Condition
See below for intrinsics setup to support this
Try the fast path of enq; backup to full enq on failure
loop to recheck cases
loop on failed CAS
loop if head changed
Record old head for check below
Utilities for various versions of acquire
Ignore if node doesn't exist
Skip cancelled predecessors
predNext is the apparent node to unsplice. CASes below will
fail if not, in which case, we lost race vs another cancel
or signal, so no further action is necessary.
Can use unconditional write instead of CAS here.
After this atomic step, other Nodes can skip past us.
Before, we are free of interference from other threads.
If we are the tail, remove ourselves.
If successor needs signal, try to set pred's next-link
so it will get one. Otherwise wake it up to propagate.
Main exported methods
Queue inspection methods
handle only fast path, else relay
The correctness of this depends on head being initialized
before tail and on head.next being accurate if the current
thread is first in queue.
Read fields in reverse initialization order
Instrumentation and monitoring methods
Internal support methods for Conditions
If has successor, it must be on queue
Instrumentation methods for conditions
If lastWaiter is cancelled, clean out.
clean up if cancelled
support for instrumentation
This could change the preferred size of the Component.
no selection or selection shifted up
This could change the preferred size of the Component.
This could change the preferred size of the Component.
This could change the preferred size of the Component.
This could change the preferred size of the Component.
REMIND: remove when filtering is done at lower level
skip value for unrecognized key
To be fully implemented in a future release
To be fully implemented in a future release
To be fully implemented in a future release
inner class AccessibleAWTChoice
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of MenuPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of MenuPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
First we try if the bootclassloader finds the requested
class. This way we can avoid to run in a privileged block.
If the bootclassloader fails, we try again with the
initialize the values
By default (local graphics environment), simply check the
Default implementation: return the center of the usable bounds of the
default screen device.
Default implementation: return the usable bounds of the default screen
device.  This is correct for Microsoft Windows and non-Xinerama X11.
read and discard the repository ID
write the repository ID
else component has changed unexpectedly, so return null
--- AbstractDocument.Content methods -------------------------
spans the gap
partial return allowed, return amount before the gap
partial return not allowed, must copy
position references the correct StickyPostition
--- variables --------------------------------------
--- gap management -------------------------------
shift gap in the character array
update the marks
Move gap up, move data and marks down.
Move gap down, move data and marks up.
Push aside all marks from oldGapStart down to newGapStart.
no more marks to adjust
shift the gap in the character array
shift the gap in the character array
return the first in the series
(ie. there may be duplicates).
found a match
didn't find it, but we indicate the index of where it would belong.
Completely passed gap
--- serialization -------------------------------------
--- undo support --------------------------------------
Find the index of the marks.
findMarkAdjustIndex start at 1!
Find the indexs of the end points.
Reset the location of the refenences.
We have to resort the marks in the range startIndex to endIndex.
We can take advantage of the fact that it will be in
increasing order, accept there will be a bunch of MarkData's with
the index g1 (or 0 if offset == 0) interspersed throughout.
If the offset is 0, the positions won't have incremented,
have to do the reverse thing.
Find the elements in startIndex whose index is 0
End of GapContent.UndoPosRef
Get the Positions in the range being removed.
Update the Positions that were in the range removed.
Update the Positions that were in the range removed.
Get the Positions in the range being removed.
Since we implement Cloneable, this should never happen
Branch for object_key
Branch for profile
Branch for ior
XML Component API
features and properties
JAXP property: schema source
is Schema Full Checking enabled
boolean that tells whether we've tested the JAXP property.
if features/properties has not been changed, the value of this attribute is "false"
xml schema parsing
component mgr will be set later
default constructor.  Create objects we absolutely need:
store properties and features in configuration
make sure error reporter knows about schemas...
entity manager is null if XMLSchemaValidator creates the loader
by default augment PSVI (i.e. don't use declaration pool)
getFeature (String):  boolean
REVISIT: this method should have a namespace parameter specified by
user. In this case we can easily detect if a schema asked to be loaded
is already in the local cache.
none of the other fields make sense for preparsing
Process external schema location properties.
We don't call tokenizeSchemaLocationStr here, because we also want
to check whether the values are valid URI.
NOTE: we only need to verify full checking in case the schema was not provided via JAXP
since full checking already verified for all JAXP schemas
unless application alters JAXPSource in the mean time.
loadSchema(XSDDescription, XMLInputSource):  SchemaGrammar
we consider the schema location properties for import
use empty string as the key for absent namespace
get the location hint for that namespace
if it's not import, or if the target namespace is not set
in the schema location properties, use location hint
add external schema locations to the location pairs
get the attribute decl for xsi:schemaLocation
because external schema location property has the same syntax
validation the string value to get the list of URI's
report warning (odd number of items)
report warning (not list of URI's)
similarly for no ns schema location property
report warning (not a URI)
this method takes a SchemaLocation string.
otherwise, true is returned.  In either case, locations
is augmented to include as many tokens as possible.
tokenizeSchemaLocation(String, HashMap):  boolean
Not an array
it is possible that we won't be able to resolve JAXP schema-source location
Not an Object[], String[], File[], InputStream[], InputSource[]
JAXP spec. allow []s of type String, File, InputStream,
InputSource also, apart from [] of type Object.
make local vector for storing targetn namespaces of schemasources specified in object arrays.
when an array of objects is passed it is illegal to have two schemas that share same namespace.
REVISIT: What should be the acutal behavior if grammar can't be loaded as specified in schema source?
String value is treated as a URI that is passed through the
REVISIT: can this happen?
Treat value as a URI and pass in as systemId
Convert a SAX InputSource to an equivalent XNI XMLInputSource
need to reprocess JAXP schema sources
reinitialize grammar bucket
pass the component manager to the factory..
get registered entity manager to be able to resolve JAXP schema-source property:
Note: in case XMLSchemaValidator has created the loader,
the entity manager property is null
get the error reporter
Determine schema dv factory to use
get schema location properties
get JAXP sources if available
clear grammars, and put the one for schema namespace there
get continue-after-fatal-error feature
set full validation to false
get generate-synthetic-annotations feature
put this grammar into the bucket, along with grammars
imported by it (directly or indirectly)
REVISIT: a conflict between new grammar(s) and grammars
in the bucket. What to do? A warning? An exception?
REVISIT: type mismatch
REVISIT: type mismatch
need to wrap the LSInput with an XMLInputSource
check whether there is a Reader
according to DOM, we need to treat such reader as "UTF-16".
check whether there is an InputStream
if there is a string data, use a StringReader
according to DOM, we need to treat such data as "UTF-16".
otherwise, just use the public/system/base Ids
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of TableEditorPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of TableEditorPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
Marked -> refs > 0 unless ref was a target.
Do not mark liternal strings. Other strings, which might,
for example, come from resource bundles should still be marked.
Bump the reference counts of all arguments
Pending: Why does the reference count need to
be incremented here?
Don't do this in constructor - it throws ... pending.
Make sure that character types are quoted correctly.
Special cases for targets.
Special cases for methods.
Use XML's short form when there is no body.
read and discard the repository ID
write the repository ID
We don't write DHT segments; the IJG library does.
0 == DC, 1 == AC
0 - 4
# of codes of each length
processing instructions must be sent all in one chunk
toCharArray() creates a newly allocated array, so it's okay
to keep a reference to it.
Instance variables initialized at installation
Transient variables (recalculated each time TabbedPane is layed out)
Private instance data
PENDING(api): See comment for ContainerHandler
For use when tabLayoutPolicy = SCROLL_TAB_LAYOUT
Remove all the tabComponents, making sure not to notify
Fix for 6711145 BasicTabbedPanuUI should not throw a NPE if these
keys are missing. So we are setting them to there default values here
if the keys are missing.
This calls in with false otherwise it could trigger a validate,
which should NOT happen if the user is only dragging the
Default to LayoutManager's minimumLayoutSize
Default to LayoutManager's maximumLayoutSize
The offset is not applied to the tab component, and so
in general we can't get good alignment like with components
in the tab.
left/right, tabs may be different sizes.
assume different baseline
Paint content border and tab area
If scrollable tabs are enabled, the tab area will be
painted by the scrollable tab panel instead.
Paint tabRuns of tabs from back to front
Paint selected tab if its in the front run
since it may overlap other tabs
LEFT or RIGHT
bottom dark shadow
top-right dark shadow
bottom-right dark shadow
right dark shadow
bottom dark shadow
bottom dark shadow
bottom-right dark shadow
right dark shadow
Fill region behind content area
Draw unbroken line if tabs are not on TOP, OR
selected tab is not in run adjacent to content, OR
selected tab is not visible (SCROLL_TAB_LAYOUT)
Break line to show visual connection to selected tab
Draw unbroken line if tabs are not on LEFT, OR
selected tab is not in run adjacent to content, OR
selected tab is not visible (SCROLL_TAB_LAYOUT)
Break line to show visual connection to selected tab
Draw unbroken line if tabs are not on BOTTOM, OR
selected tab is not in run adjacent to content, OR
selected tab is not visible (SCROLL_TAB_LAYOUT)
Break line to show visual connection to selected tab
Draw unbroken line if tabs are not on RIGHT, OR
selected tab is not in run adjacent to content, OR
selected tab is not visible (SCROLL_TAB_LAYOUT)
Break line to show visual connection to selected tab
We didn't recalculate the layout, runs and tabCount may not
line up, bail.
Need to translate coordinates based on viewport location &
Tab Navigation methods
If we have no tabs then don't navigate.
Just move focus (not selection)
If we're not valid that means we will shortly be validated and
painted, which means we don't have to do anything here.
REMIND(aim,7/29/98): This method should be made
protected in the next release where
API changes are allowed
Determine minimum size required to display largest
child in each dimension
Add content border insets to minimum size
Calculate how much space the tabs will need, based on the
minimum size required to display largest child + content border
The last tab was removed, so remove the component
In order to allow programs to use a single component
as the display for multiple tabs, we will not change
the visible compnent if the currently selected tab
has a null component.  This is a bit dicey, as we don't
explicitly state we support this in the spec, but since
programs are now depending on this, we're making it work.
Calculate bounds within which a tab run must fit
Run through tabs and partition them into runs
Tabs on TOP or BOTTOM....
Never move a TAB down a run if it is in the first column.
Even if there isn't enough room, moving it to a fresh
line won't help.
Initialize y position in case there's just one run
Tabs on LEFT or RIGHT...
Never move a TAB over a run if it is in the first run.
Even if there isn't enough room, moving it to a fresh
column won't help.
Initialize x position in case there's just one column
Re-distribute tabs in case last run has leftover space
Rotate run array so that selected run is first
Step through runs from back to front to calculate
tab y locations and to pad runs appropriately
Pad the selected tab so that it appears raised in front
if right to left and tab placement on the top or
the bottom, flip x positions and adjust by widths
At this point the tab runs are packed to fit as many
tabs as possible, which can leave the last run with a lot
of extra space (resulting in very fat tabs on the last run).
So we'll attempt to distribute this extra space more evenly
across the runs in order to make the runs look more consistent.
Starting with the last run, determine whether the last tab in
the previous run would fit (generously) in this run; if so,
move tab to current run and shift tabs accordingly.  Cycle
through remaining runs using the same algorithm.
Check if the run has enough extra space to fit the last tab
from the previous row...
Insert tab from previous row and shift rest over
no more room left in last run, so we're done!
check previous run next...
check last run again...but require a higher ratio
of extraspace-to-tabsize because we don't want to
end up with too many tabs on the last run!
do not expand selected tab more then necessary
The last tab was removed, so remove the component
In order to allow programs to use a single component
as the display for multiple tabs, we will not change
the visible compnent if the currently selected tab
has a null component.  This is a bit dicey, as we don't
explicitly state we support this in the spec, but since
programs are now depending on this, we're making it work.
tab area bounds
content area bounds
calculate tab area bounds
calculate content area bounds
calculate tab area bounds
calculate content area bounds
calculate tab area bounds
calculate content area bounds
calculate tab area bounds
calculate content area bounds
Allow space for scrollbuttons
Scrolled to the end, so ensure the viewport size is
such that the scroll offset aligns with a tab
Need to allow space for scrollbuttons
Scrolled to the end, so ensure the viewport size is
such that the scroll offset aligns with a tab
All content children...
Calculate bounds within which a tab run must fit
Run through tabs and lay them out in a single run
Tabs on TOP or BOTTOM....
Tabs on LEFT or RIGHT...
Pad the selected tab so that it appears raised in front
if right to left and tab placement on the top or
the bottom, flip x positions and adjust by widths
tabPlacement = LEFT || RIGHT
no room left to scroll
tabPlacement == LEFT || tabPlacement == RIGHT
no room left to scroll
We've scrolled to the end, so adjust the viewport size
to ensure the view position remains aligned on a tab boundary
We've scrolled to the end, so adjust the viewport size
to ensure the view position remains aligned on a tab boundary
If the tab isn't right aligned, adjust it.
Controller: event listeners
remove the current index
to let updateHtmlViews() insert the correct one
Vector already exists
Clicking on unselected tab, change selection, do NOT
This will trigger the focusIndex to change by way
Clicking on selected tab, try and give the tabbedpane
focus.  Repaint will occur in focusGained.
NOTE 4/15/2002 (joutwate):
This fix is implemented using client properties since there is
currently no IndexPropertyChangeEvent.  Once
IndexPropertyChangeEvents have been added this code should be
modified to use it.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
We layout tabComponents in JTabbedPane's layout manager
and use this method as a hook for repainting tabs
to update tabs area e.g. when the size of tabComponent was changed
signal completion of last generation
set up next generation
loop until tripped, broken, interrupted, or timed out
We're about to finish waiting even if we had not
been interrupted, so this interrupt is deemed to
"belong" to subsequent execution.
break the current generation
start a new generation
This is also used in DynamicStubImpl to implement readResolve.
Create an invocation handler for the methods defined on DynamicStub,
which extends org.omg.CORBA.Object.  This handler delegates all
calls directly to a DynamicStubImpl, which extends
Create an invocation handler that handles any remote interface
Create a composite handler that handles the DynamicStub interface
as well as the remote interfaces.
If the method passed to invoke is not from DynamicStub or its superclasses,
it must be from an implemented interface, so we just handle
all of these with the stubMethodHandler.  This used to be
done be adding explicit entries for stubMethodHandler for
each remote interface, but that does not work correctly
for abstract interfaces, since the graph analysis ignores
abstract interfaces in order to compute the type ids
correctly (see PresentationManagerImpl.NodeImpl.getChildren).
Rather than produce more graph traversal code to handle this
problem, we simply use a default.
This also points to a possible optimization: just use explict
checks for the three special classes, rather than a general
table lookup that usually fails.
read and discard the repository ID
write the repository ID
PENDING: Currently we don't correctly deal with optional start
tags. This can most notably be seen with the 4.01 spec where
TBODY's start and end tags are optional.
Uncommenting this and the PENDING in ContentModel will
correctly skip the omit tags, but the delegate is not notified.
Some additional API needs to be added to track skipped tags,
and this can then be added back.
We used to throw this exception at this point.  However, it
was determined that throwing this exception was more expensive
than returning null, and we could not justify to ourselves why
it was necessary to throw an exception, rather than simply
returning null.  I'm leaving it in a commented out state so
that it can be easily restored if the situation ever arises.
GETTERS AND SETTERS
Construct the dynamic proxy that implements this stub
using the composite handler
The ORB from which to get PICurrent and other info
The number of interceptors actually invoked for this client request.
See setFlowStackIndex for a detailed description.
The type of starting point call to make to the interceptors
See ClientRequestInfoImpl and ServerRequestInfoImpl for a list of
The type of intermediate point call to make to the interceptors
See ServerRequestInfoImpl for a list of appropriate constants.
This does not currently apply to client request interceptors but is
here in case intermediate points are introduced in the future.
The type of ending point call to make to the interceptors
See ClientRequestInfoImpl and ServerRequestInfoImpl for a list of
The reply status to return in reply_status.  This is initialized
to UNINITIALIZED so that we can tell if this has been set or not.
Constant for an uninitizlied reply status.
Which points we are currently executing (so we can implement the
Set to true if all interceptors have had all their points
Sources of request information
The ForwardRequest object if this request is being forwarded.
Either the forwardRequest or the forwardRequestIOR field is set.
When set, the other field is set to null initially.  If the other
field is queried, it is lazily calculated and cached.  These
two attributes are always kept in sync.
The exception to be returned by received_exception and
Please keep these in the same order as declared above.
We don't need to reset the Slots because they are
already in the clean state after recieve_<point> interceptor
Method IDs for all methods in RequestInfo.  This allows for a
convenient O(1) lookup for checkAccess().
The last value from RequestInfo (be sure to update this):
Capture the current TSC and make it the RSC of this request.
REVISIT - get from MessageMediator
access is currently valid for all states:
Delegate the call to the slotTable which was set when RequestInfo was
NOTE: When adding a method, be sure to:
1. Add a MID_* constant for that method
2. Call checkAccess at the start of the method
3. Define entries in the validCall[][] table for interception points
in both ClientRequestInfoImpl and ServerRequestInfoImpl.
Extract the UserException from the ApplicationException.
Look up class name from repository id:
Find the read method on the helper class:
Invoke the read method, passing in the input stream to
retrieve the user exception.  Mark and reset the stream
as to not disturb it.
Insert this UserException into the provided Any using the
Insert this UserException into the provided Any using the
Find insert( Any, class ) method
Call helper.insert( result, userException ):
_REVISIT_ This utility method should probably be doing a deep
copy so interceptor can't accidentally change the arguments.
ParameterMode spec can be found in 99-10-07.pdf
nv.flags spec can be found in 99-10-07.pdf
nv.flags has ARG_IN as 1, ARG_OUT as 2 and ARG_INOUT as 3
To convert this into enum PARAM_IN, PARAM_OUT and
PARAM_INOUT the value is subtracted by 1.
Note: exception should never be null here since we will throw
a BAD_INV_ORDER if this is not called from receive_exception.
Use the Helper class for this exception to insert it into an
Insert the user exception inside the application exception
into the Any result:
As per ptc/00-08-06, 21.3.13.4. if we cannot find the
appropriate class, then return an any containing UNKNOWN,
with a minor code of 1.  This is conveniently the same
exception that is returned from the
insertApplicationException utility method.
Search cache first:
null could normally mean that either we cached the value null
or it's not in the cache.  However, there is no way for us to
cache the value null in the following code.
Not in cache.  Find it and put in cache.
Get the desired "core" service context.
Convert the "core" service context to an
"IOP" ServiceContext by writing it to a
CDROutputStream and reading it back.
Good citizen: For increased efficiency, we assume that interceptors
will not modify the returned ServiceContext.  Otherwise, we would
have to make a deep copy.
Convert IOP.service_context to core.ServiceContext:
Constructor expects id to already have been read from stream.
Place IOP.ServiceContext in cache as well:
Convert the internal IOR to a forward request exception
by creating an object reference.
never be null
components obtained from a manager / property
configure wiring between internal components.
configure validator with proper EntityResolver/ErrorHandler.
erors thrown by the callback is not supposed to be
reported to users.
mostly to make it easy to find any bug.
since a validator may change the contents,
let this one go through a validator
since a validator may change the contents,
let this one go through a validator
obtain references from the manager
we "consumed" this augmentation.
start namespace prefix mappings
send endPrefixMapping events
newly added attribute. add to the current attribute list.
the attribute is present.
but the value was changed.
no property/feature supported
form is not private so that invokers can easily fetch it
asTypeCache is not private so that invokers can easily fetch it
customizationCount should be accessible from invokers
TO DO:  Try to delay this step until just before invocation.
Return 'this' if the conversion will be a no-op.
Return 'this.asTypeCache' if the conversion is already memoized.
elicit an error:
throw CCE if needed
Sub-classes can override these default implementations.
All these methods assume arguments are already validated.
Other transforms to do:  convert, explicitCast, permute, drop, filter, fold, GWT, catch
No actual conversions, just a new view of the same method.
Note that this operation must not produce a DirectMethodHandle,
because retyped DMHs, like any transformed MHs,
cannot be cracked into MethodHandleInfo.
DMH returns DMH.member
caller-bound MH for @CallerSensitive method returns caller
no special intrinsic meaning to most MHs
The required internaMemberName is null, and this MH (like most) doesn't have one.
The following case is rare. Mask the internalMemberName by wrapping the MH in a BMH.
DMH.Special returns true
Override to something to follow this.form, like "\n& FOO=bar"
Method handle implementation methods.
Sub-classes can override these default implementations.
All these methods assume arguments are already validated.
as in MethodHandle.<init>
Update lastFocusOwner for parent.
don't allow resizing when maximized.
The InternalFrame may already be selected, but the focus
may be outside it, so restore the focus to the subcomponent
which previously had it. See Bug 4302764.
The internal frame or the desktop icon must be showing to allow
selection.  We may deselect even if neither is showing.
Normally we want to do this, as it causes the LayeredPane
to draw properly.
Try to do the right thing
Search upward for desktop
search its icon parent for desktop
FocusPropertyChangeListener will eventually update
lastFocusOwner. As focus requests are asynchronous
lastFocusOwner may be accessed before it has been correctly
updated. To avoid any problems, lastFocusOwner is immediately
set, assuming the request will succeed.
Make sure focus is restored somewhere, so that
we don't leave a focused component in another frame while
this frame is selected.
remind: sync ??
turn on the newEventsOnly flag in Component.
remind: name ok? all one method ok? need to be synchronized?
match the behavior of setVisible(true): do nothing
need to disable rootpane checking for InternalFrame: 4172083
======= begin optimized frame dragging defence code ==============
======= end optimized frame dragging defence code ==============
TIGER - 4422535
don't do this if UI not created yet
TIGER - 4422535
subclass must set the version, since we don't have the object key here.
throws NPE if locale == null
Private data of the instance
needed for tracking
the first occurrence of
Indicates whether the one of splitpane sides is expanded
This is used by the LayoutManager to determine when it should use
the divider location provided by the JSplitPane. This is used as there
is no way to determine when the layout process has completed.
note: don't rename this temp variable to dividerSize
since it will conflict with "this.dividerSize" field
focus forward traversal key
focus backward traversal key
sets the focus forward and backward traversal keys to null
to restore the defaults
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
This is all done so that the nonContinuousLayoutDivider will
be drawn on top of the other components, without this, one
of the heavyweights will draw over the divider!
If the splitpane has a zero size then no op out of here.
If we execute this function now, we're going to cause ourselves
Reset the bounds of each component
This is tricky, there is never a good time for us
to push the value to the splitpane, painted appears to
the best time to do it. What is really needed is
notification that layout has completed.
This is not always needed, but is rather tricky
to determine when... The case this is needed for
is if the user sets the divider location to some
bogus value, say 0, and the actual value is 1, the
call to setDividerLocation(1) will preserve the
old value of 0, when we really want the divider
location value  before the call. This is needed for
the one touch buttons.
Set the sizes to the preferred sizes (if fits), otherwise
set to min sizes and distribute any extra space.
Both aren't valid, force them both to be valid
both below min, just make sure > 0
both below min, just make sure > 0
don't change the focus if the new focused component belongs
to the same splitpane and the same side
focus next side of the parent split pane
the type of certificates in this chain
We only report the first error, to avoid clogging
These message should be read from a locale-specific resource bundle
These message should be read from a locale-specific resource bundle
getIndex(qName) seems to be more reliable than getIndex(uri, localName),
in the case of the xmlns attribute anyway.
end of MutableAttrListImpl.java
user has specified initial context factory; try to get it
Most Javadoc is deferred to the Context interface.
fetches background color from stylesheet if specified
Find out if frame is inactive
Fix for XP bug where sometimes these sizes aren't updated properly
Assume for now that height is correct and derive width using the
ratio from the uxtheme part
outter left arc
outter right arc
inner left arc
inner right arc
indicate whether selected or not
end class RadioButtonIcon
End class CheckBoxMenuItemIcon
End class RadioButtonMenuItemIcon
End class MenuItemCheckIcon
End class MenuItemArrowIcon
End class MenuArrowIcon
this should never happen
use icon from the UI table if it does not match this one.
remove package name, dot and the first character
End class VistaMenuItemCheckIconFactory
Flags for enabling/disabling performance optimizations for file
read and discard the repository ID
write the repository ID
Create a principal
Create an AclEntry
The name of the ShortHand pointer
The name of the ShortHand pointer
On startElement or emptyElement, if no matching elements or parent
elements were found, check for a matching idenfitier.
On endElement, decrease the matching child count if the child or
its parent was resolved.
The identifiers of an element are determined by the
ShortHand Pointer as follows:
1. If an element information item has an attribute information item
among its [attributes] that is a schema-determined ID, then it is
identified by the value of that attribute information item's
2. If an element information item has an element information item among
its [children] that is a schema-determined ID, then it is identified by
3. If an element information item has an attribute information item among
its [attributes] that is a DTD-determined ID, then it is identified by the
value of that attribute information item's [normalized value] property.
An attribute information item is a DTD-determined ID if and only if it has
a [type definition] property whose value is equal to ID.
4. No externally determined ID's
An element or attribute information item is a schema-determined
ID if and only if one of the following is true:]
1. It has a [member type definition] or [type definition] property
whose value in turn has [name] equal to ID and [target namespace]
3. It has a [base type definition] whose value has a [base type definition]
whose value has that [name] and [target namespace], and so on following
4 & 5 NA
Should only happen if size() != keys.length, which should only
happen if mutated from multiple threads (or a bogus subclass).
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of ProgressBarPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of ProgressBarPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
should not happen as this class is cloneable
If MBeanOperationInfo was created in our implementation,
signature cannot be null - because our constructors replace
However, signature could be null if an  MBeanOperationInfo is
deserialized from a byte array produced by another implementation.
This is not very likely but possible, since the serial form says
nothing against it. (see 6373150)
if signature is null simply return an empty array .
if signature is null simply return an empty array .
see getSignature() above.
LOC header size
EXT header size
CEN header size
END header size
version needed to extract
general purpose bit flag
uncompressed file crc-32 value
extra field length
uncompressed file crc-32 value
version made by
version needed to extract
encrypt, decrypt flags
uncompressed file crc-32 value
extra field length
disk number start
internal file attributes
external file attributes
LOC header offset
number of entries on this disk
total number of entries
central directory size in bytes
offset of first CEN header
zip file comment length
Sets the current position to -1 and the value to zero.
DynAny interface methods
DynFixed interface methods
Initializes the value of the DynFixed.
The val string must contain a fixed string constant in the same format
as used for IDL fixed-point literals.
It may consist of an integer part, an optional decimal point,
a fraction part and an optional letter d or D.
The integer and fraction parts both must be sequences of decimal (base 10) digits.
Either the integer part or the fraction part, but not both, may be missing.
If val contains a value whose scale exceeds that of the DynFixed or is not initialized,
the operation raises InvalidValue.
The return value is true if val can be represented as the DynFixed without loss of precision.
If val has more fractional digits than can be represented in the DynFixed,
fractional digits are truncated and the return value is false.
If val does not contain a valid fixed-point literal or contains extraneous characters
other than leading or trailing white space, the operation raises TypeMismatch.
First get rid of leading or trailing whitespace which is allowed
Now scan for the sign
Now get rid of the letter d or D.
Just to be sure
Now look for the dot to determine the integer part
Let's see if we have to drop some precision
truncate the fraction part
currentScale > 0
drop the fraction completely
integerPart.length() > digits
unable to truncate fraction part
If val contains a value whose scale exceeds that of the DynFixed or is not initialized,
the operation raises InvalidValue.
Reinterpreted to mean raise InvalidValue only if the integer part exceeds precision,
which is handled above (integerPart.length() > digits)
Now check whether both parts are valid numbers
both are namespaces
attr0 is a namespace, attr1 is not
attr1 is a namespace, attr0 is not
none is a namespace
return type is void, no need for checkCallToOpen
WARNING: If you directly access this field you should also change the
SortManager.modelRowSizes field as well.
Set the model last, that way if the autoCreatColumnsFromModel has
been set above, we will automatically populate an empty columnModel
with suitable columns for the new model.
Make certain we are the viewPort's view and not, for
example, the rowHeaderView of the scrollPane -
an implementor of fixed columns might do this.
configure the scrollpane for any LAF dependent settings
Make certain we are the viewPort's view and not, for
example, the rowHeaderView of the scrollPane -
an implementor of fixed columns might do this.
add JScrollBar corner component if available from LAF and not already set by the user
just ignore and don't set corner
Make certain we are the viewPort's view and not, for
example, the rowHeaderView of the scrollPane -
an implementor of fixed columns might do this.
remove ScrollPane corner if one was added by the LAF
Release the old header
Set the rowMargin here and columnMargin in the TableColumnModel
Remove any current columns
Create new columns from the data model info
If I'm currently editing, then I should stop editing
this is done to restore the anchor and lead
this is done to restore the anchor and lead
this is a Windows-only behavior that we want for file lists
Check the selection here rather than in each selection model.
This is significant in cell selection mode if we are supposed
to be toggling the selection. In this case it is better to
ensure that the cell's selection state will indeed be changed.
If this were done in the code for the selection model it
might leave a cell in selection state if the row was
selected but the column was not - as it would toggle them both.
Scroll after changing the selection as blit scrolling is immediate,
so that if we cause the repaint after the scroll we end up painting
Informally implement the TableModel interface.
Adding and removing columns in the view
Cover methods for various models and helper methods
Bound the margins by their associated dimensions to prevent
returning bounds with negative dimensions.
This is not the same as grow(), it rounds differently.
JTable behaves like a layout manger - but one in which the
user can come along and dictate how big one of the children
(columns) is supposed to be.
A column has been resized and JTable may need to distribute
any overall delta to other columns, according to the resize mode.
If the delta cannot be completely accomodated, then the
resizing column will have to take any remainder. This means
that the column is not being allowed to take the requested
width. This happens under many circumstances: For example,
AUTO_RESIZE_NEXT_COLUMN specifies that any delta be distributed
to the column after the resizing column. If one were to attempt
to resize the last column of the table, there would be no
columns after it, and hence nowhere to distribute the delta.
It would then be given entirely back to the resizing column,
preventing it from changing size.
At this point the JTable has to work out what preferred sizes
would have resulted in the layout the user has chosen.
Thereafter, during window resizing etc. it has to work off
the preferred sizes as usual - the idea being that, whatever
the user does, everything stays in synch and things don't jump
Distribute delta over columns, as indicated by the autoresize mode.
Use the mode to determine how to absorb the changes.
Check for zero. This happens when the distribution of the delta
finishes early due to a series of "fixed" entries at the end.
In this case, lowerBound == upperBound, for all subsequent terms.
We'd need to round manually in an all integer version.
size[i] = (int)(((totalUpperBound - target) * lowerBound +
Locate the renderer under the event location
Now have to see if the component is a JComponent before
getting the tip
Convert the event to the renderer's coordinate system
No tip from the renderer get our own tip
Update the UIs of the cell renderers, cell editors and header renderers.
Update the UIs of all the default renderers.
Update the UIs of all the default editors.
Update the UI of the table header
Update UI applied to parent ScrollPane
Set the column model of the header as well.
Selection, in terms of the model. This is lazily created
Set to true while in the process of changing the selection.
If this is true the selection change is ignored.
Temporary cache of selection, in terms of model. This is only used
if we don't need the full weight of modelSelection.
Heights of the rows in terms of the model.
sort order changed. If modelSelection is null and filtering
is enabled we need to cache the selection in terms of the
underlying model, this will allow us to correctly restore
the selection even if rows are filtered out.
Sorting changed, haven't cached selection in terms
of model and no filtering. Temporarily cache selection.
All the rows have changed, chuck any cached selection.
Table changed, reflect changes in cached selection model.
table changed, but haven't cached rows, temporarily
Restore the lead
Starting index of the change, in terms of the model
Ending index of the change, in terms of the model
Type of change
Number of rows in the model
The event that triggered this.
Length of the change (end - start + 1)
True if the event indicates all the contents have changed
If the Sorter is unsorted we will not have received
notification, force treating insert/delete as a change.
Update the editing row
And handle the appropriate repainting.
Check if lead/anchor need to be reset.
Too much has changed, punt
Convert the selection from model to view
Check for the common case of no change in selection for 1 row
And apply the new selection
Editing row no longer being shown, cancel editing
First try and cancel
CellEditor didn't cede control, forcefully
Repositioning handled in BasicTableUI
range checking handled by RowSorterEvent
Make sure the viewIndex is valid
Implementing TableModelListener interface
The whole thing changed
This will effect invalidation of the JTable and JTableHeader.
The totalRowHeight calculated below will be incorrect if
there are variable height rows. Repaint the visible region,
but don't return as a revalidate may be necessary as well.
1 or more rows changed
A cell or column of cells has changed.
Unlike the rest of the methods in the JTable, the TableModelEvent
uses the coordinate system of the model instead of the view.
This is the only place in the JTable where this "reverse mapping"
Now adjust the height of the dirty region according to the value of "end".
Check for Integer.MAX_VALUE as this will cause an overflow.
In fact, if the end is Integer.MAX_VALUE we need to revalidate anyway
because the scrollbar may need repainting.
Adjust the selection to account for the new rows.
If we have variable height rows, adjust the row model.
PENDING(milne) revalidate calls repaint() if parent is a ScrollPane
repaint still required in the unusual case where there is no ScrollPane
Adjust the selection to account for the new rows
If we have variable height rows, adjust the row model.
PENDING(milne) revalidate calls repaint() if parent is a ScrollPane
repaint still required in the unusual case where there is no ScrollPane
Implementing TableColumnModelListener interface
If I'm currently editing, then I should stop editing
If I'm currently editing, then I should stop editing
Need to do this here, before the parent's
layout manager calls getPreferredSize().
The assumption is that when the model is no longer adjusting
we will have already gotten all the changes, and therefore
don't need to do an additional paint.
The getCellRect() call will fail unless there is at least one row.
nothing to repaint, return
only thing to repaint is the lead
We need to consider more than just the range between
the min and max selected index. The lead row, which could
be outside this range, should be considered also.
Implementing ListSelectionListener interface
The assumption is that when the model is no longer adjusting
we will have already gotten all the changes, and therefore
don't need to do an additional paint.
The getCellRect() calls will fail unless there is at least one column.
Implementing the CellEditorListener interface
Take in the new value
Implementing the Scrollable interface
Couldn't find leading row - return some default value
Couldn't find leading col - return some default value
Note that it's possible for one of leadingCol or leadingRow to be
-1, depending on the orientation.  This is okay, as getCellRect()
still provides enough information to calculate the unit increment.
#1: Leading cell fully visible, reveal next cell
#2: Leading cell fully visible, hide leading cell
#3: Leading cell partially visible, hide rest of leading cell
#4: Leading cell partially visible, reveal rest of leading cell
Leading cell is fully
Case #1: Reveal previous cell
Loop past any zero-height rows
Loop past any zero-width cols
Case #2: hide leading cell
Leading cell is partially hidden
Compute visible, hidden portions
Case #3: hide showing portion of leading cell
Case #4: reveal hidden portion of leading cell
Short-circuit empty table model
Shortcut for vertical scrolling of a table w/ uniform row height
Measure back from visible leading edge
If we hit the cell on its leading edge, it becomes the leading cell.
Else, use following cell
Roughly determine the new leading edge by measuring back from the
leading visible edge by the size of the visible rect, and find the
If we're measuring past the beginning of the table, we get an invalid
cell.  Just go to the beginning of the table in this case.
Refine our measurement
Usually, we hit in the middle of newCell, and want to scroll to
the beginning of the cell after newCell.  But there are a
couple corner cases where we want to scroll to the beginning of
newCell itself.  These cases are:
1) newCell is so large that it ends at or extends into the
visibleRect (newCell is the leading cell, or is adjacent to
the leading cell)
2) newEdge happens to fall right on the beginning of a cell
Common case: scroll to cell after newCell
Find the cell at the trailing edge.  Return the distance to put
that cell at the leading edge.
If we couldn't find trailing cell, just return the size of the
visibleRect.  Note that, for instance, we don't need the
trailingCol to proceed if we're scrolling vertically, because
cellRect will still fill in the required dimensions.  This would
happen if we're scrolling vertically, and the table is not wide
enough to fill the visibleRect.
The visibleRect contains a single large cell.  Scroll to the end
of this cell, so the following cell is the first cell.
The trailing cell happens to end right at the end of the
visibleRect.  Again, scroll to the beginning of the next cell.
Common case: the trailing cell is partially visible, and isn't
big enough to take up the entire visibleRect.  Scroll so it
becomes the leading cell.
Start editing when a key is typed. UI classes can disable this behavior
by setting the client property JTable.autoStartsEdit to Boolean.FALSE.
We do not have a binding for the event.
Only attempt to install the editor on a KEY_PRESSED,
Don't start when just a modifier is pressed
Try to install the editor
If the editorComponent is a JComponent, pass the event to it.
If we have started an editor as a result of the user
pressing a key and the surrendersFocusOnKeystroke property
is true, give the focus to the new editor.
Doubles and Floats
Icons and ImageIcons
Here we are dealing with the case where a user
has deleted the string value in a cell, possibly
after a failed validation. Return null, so that
they have the option to replace the value with
null or use escape to restore the original.
For Strings, return "" for backward compatibility.
Since our obligation is to produce a value which is
assignable for the required type it is OK to use the
String constructor for columns which are declared
to contain Objects. A String is an Object.
I'm registered to do tool tips so we can draw tips for the renderers
Only indicate the selection and focused cell if not printing
If ToolTipText != null, then the tooltip has already been
registered by JComponent.readObject() and we don't want
to re-register here
If ToolTipText != null, then the tooltip has already been
unregistered by JComponent.compWriteObjectNotify()
This class tracks changes in the keyboard focus state. It is used
when the JTable is editing to determine when to cancel the edit.
If focus switches to a component outside of the jtable, but in the
same window, this will cancel editing.
focus remains inside the table
complain early if an invalid parameter is specified for headless mode
Get a PrinterJob.
Do this before anything with side-effects since it may throw a
security exception - in which case we don't want to do anything else.
try to stop cell editing, and failing that, cancel it
fetch the Printable
wrap the Printable so that we can print on another thread
to please compiler
set the printable on the PrinterJob
if specified, set the PrintService on the PrinterJob
if requested, show the print dialog
the user cancelled the print dialog
if not interactive, just print on this thread (no dialog)
do the printing
make sure this is clear since we'll check it after
to synchronize on
copied so we can access from the inner class
this runnable will be used to do the printing
(and save any throwables) on another thread
do the printing
save any Throwable to be rethrown
we're finished - hide the dialog
start printing on another thread
look for any error that the printing may have generated
check the type of error and handle it
a subclass of PrinterException meaning the job was aborted,
in this case, by the user
can not happen
We'll use this Runnable
call into the delegate and save the return value
save any Throwable to be rethrown
notify the caller that we're done
make sure these are initialized
call into the EDT
wait for the runnable to finish
short process, safe to ignore interrupts
if the delegate threw a throwable, rethrow it here
can not happen
Listeners to track model, etc. changes to as to re-place the other
re-set tableModel listeners
re-set selectionModel listeners
row selection model
re-set columnModel listeners
and column's selection property listener as well
re-se cellEditor listeners
Listeners to echo changes to the AccessiblePropertyChange mechanism
Fire a property change event indicating the table model
Fire a property change event indicating the table model
Fire a property change event indicating the table model
Fire a property change event indicating the table model
Fire a property change event indicating the table model
Fire property change events indicating the table model
we should now re-place our TableColumn listener
it'd be great if we could figure out which cell, and pass that
somehow as a parameter
nothing to report, 'cause nothing changed
Using lead selection index to cover both cases: node selected and node
is focused but not selected (Ctrl+up/down)
children increase across, and then down, for tables
a contiguous block
a column swath and a row swath, with a shared block
just one or more rows in selection
just one or more rows in selection
JTable doesn't allow selections
a contiguous block
a column swath and a row swath, with a shared block
We have a table, like the 6x3 table below,
wherein three colums and one row selected
(selected cells marked with "*", unselected "0"):
0 * 0 * * 0
* * * * * *
0 * 0 * * 0
State machine below walks through the array of
selected rows in two states: in a selected row,
and not in one; continuing until we are in a row
in which the ith selection exists.  Then we return
the appropriate cell.  In the state machine, we
always do rows above the "current" selected row first,
then the cells in the selected row.  If we're done
with the state machine before finding the requested
selected child, we handle the rows below the last
selected row at the end.
on individual row full of selections
is the next row in table selected or not?
we didn't return earlier, so go to next row
sparse bunch of rows of selections
we got here, so we didn't find it yet; find it in
the last sparse bunch of rows
we shouldn't get to this spot in the code!
one or more rows selected
one or more columns selected
TIGER - 4495286
begin AccessibleExtendedTable implementation -------------
end of AccessibleExtendedTable implementation ------------
start of AccessibleTable implementation ------------------
row headers are not supported
row headers are not supported
TIGER - 4715503
XXX not implemented
end of AccessibleTable implementation --------------------
return the cell renderer's AccessibleName
fall back to the client property
to override getBounds()
Fixes 4529616 - AccessibleJTableCell.isShowing()
returns false when the cell on the screen
if no parent
inner class AccessibleJTableCell
Begin AccessibleJTableHeader ==========  TIGER - 4715503
AccessibleContext methods ==========
to override getBounds()
AccessibleComponent methods ==========
Fixes 4529616 - AccessibleJTableCell.isShowing()
returns false when the cell on the screen
if no parent
inner class AccessibleJTableHeaderCell
inner class AccessibleJTable
End of Class JTable
Copyright (c) 1995-96 by Cisco Systems, Inc.
import debug stuff
TIME BOMB HERE
no serialVersionUID but never serialized
This boolean is used to stop handling requests while the corresponding SnmpQManager
is being destroyed.
no serialVersionUID, but never serialized
This boolean is used to stop handling requests while the corresponding SnmpQManager
is being destroyed.
This class is immutable and it is important that it remains so.
Base name of the bundle.
Bundle set through setResourceBundle.
This instance will be shared by all loggers created by the system
This instance indicates that no resource bundle has been specified yet,
and it will be shared by all loggers which have no resource bundle.
Cache to speed up behavior of findResourceBundle:
Cached resource bundle
name associated with catalog
locale associated with catalog
The fields relating to parent-child relationships and levels
are managed under a separate lock, the treeLock.
We keep weak references from parents to children, but strong
references from children to parents.
our nearest parent.
WeakReferences to loggers that have us as parent
current effective level value
In order to break a cyclic dependence between the LogManager
and Logger static initializers causing deadlocks, the global
logger is created with a special constructor that does not
initialize its log manager.
If an application calls Logger.getGlobal() before any logger
has been initialized, it is therefore possible that the
LogManager class has not been initialized yet, and therefore
Logger.global.manager will be null.
In order to finish the initialization of the global logger, we
will therefore call LogManager.getLogManager() here.
To prevent race conditions we also need to call
LogManager.getLogManager() unconditionally here.
Indeed we cannot rely on the observed value of global.manager,
because global.manager will become not null somewhere during
the initialization of LogManager.
If two threads are calling getGlobal() concurrently, one thread
will see global.manager null and call LogManager.getLogManager(),
but the other thread could come in at a time when global.manager
is already set although ensureLogManagerInitialized is not finished
Calling LogManager.getLogManager() unconditionally will fix that.
Now the global LogManager should be initialized,
and the global logger should have been added to
it, unless we were called within the constructor of a LogManager
subclass installed as LogManager, in which case global.manager
would still be null, and global will be lazily initialized later on.
This constructor is used only to create the global Logger.
It is needed to break a cyclic dependence between the LogManager
and Logger static initializers causing deadlocks.
The manager field is not initialized here.
It is called from LoggerContext.addLocalLogger() when the logger
is actually added to a LogManager.
Complete initialization of the global Logger.
Until all JDK code converted to call sun.util.logging.PlatformLogger
(see 7054233), we need to determine if Logger.getLogger is to add
a system logger or user logger.
As an interim solution, if the immediate caller whose caller loader is
null, we assume it's a system logger and add it to the system context.
These system loggers only set the resource bundle to the given
resource bundle name (rather than the default system resource bundle).
ends up calling new Logger(name, resourceBundleName, caller)
iff the logger doesn't exist already
Synchronization is not required here. All synchronization for
adding a new Logger object is handled by LogManager.addLogger().
This method is intentionally not a wrapper around a call
to getLogger(name, resourceBundleName). If it were then
would throw an IllegalArgumentException in the second call
because the wrapper would result in an attempt to replace
the existing "resourceBundleForFoo" with null.
Synchronization is not required here. All synchronization for
adding a new Logger object is handled by LogManager.addLogger().
MissingResourceException or IllegalArgumentException can be
thrown by setupResourceInfo().
We have to set the callers ClassLoader here in case demandLogger
above found a previously created Logger.  This can happen, for
example, if Logger.getLogger(name) is called and subsequently
Logger.getLogger(name, resourceBundleName) is called.  In this case
we won't necessarily have the correct classloader saved away, so
we need to set it here, too.
Add a platform logger to the system context.
i.e. caller of sun.util.logging.PlatformLogger.getLogger
all loggers in the system context will default to
the system logger's resource bundle
Synchronization is not required here. All synchronization for
adding a new anonymous Logger object is handled by doSetParent().
cleanup some Loggers that have been GC'ed
Post the LogRecord to all our Handlers, and then to
our parents' handlers, all the way up the tree.
private support method for logging.
We fill in the logger name, resource bundle name, and
resource bundle and then call "void log(LogRecord)".
Start of convenience methods WITHOUT className and methodName
Start of convenience methods WITH className and methodName
Start of convenience methods WITH className, methodName and bundle name.
Private support method for logging for "logrb" methods.
We fill in the logger name, resource bundle name, and
resource bundle and then call "void log(LogRecord)".
Private support method for logging for "logrb" methods.
Start of convenience methods for logging method entries and returns.
Start of simple convenience methods using level names as method names
Start of simple convenience methods using level names as method names
and use Supplier<String>
End of convenience methods
Check for null handler
This method should ideally be marked final - but unfortunately
it needs to be overridden by LogManager.RootLogger
the resource bundle is in a restricted package
For all lookups, we first check the thread context class loader
if it is set.  If not, we use the system classloader.  If we
still haven't found it we use the callersClassLoaderRef if it
is set and useCallersClassLoader is true.  We set
callersClassLoaderRef initially upon creating the logger with a
non-null resource bundle name.
Return a null bundle for a null name.
Normally we should hit on our simple one entry cache.
Use the thread's context ClassLoader.  If there isn't one, use the
We can't find the ResourceBundle in the default
ClassLoader.  Drop through.
Try with the caller's ClassLoader
Private utility method to initialize our one entry
resource bundle name cache and the callers ClassLoader
Note: for consistency reasons, we are careful to check
that a suitable ResourceBundle exists before setting the
Synchronized to prevent races in setting the fields.
this Logger already has a ResourceBundle
the names match so there is nothing more to do
cannot change ResourceBundles once they are set
We've failed to find an expected ResourceBundle.
unset the caller's ClassLoader since we were unable to find the
the bundle using it
if lb.userBundle is not null we won't reach this line.
Will throw NPE if bundle is null.
bundle must have a name
Note: this used to be synchronized on treeLock.  However, this only
provided memory semantics, as there was no guarantee that the caller
would synchronize on treeLock (in fact, there is no way for external
callers to so synchronize).  Therefore, we have made parent volatile
check permission for all loggers, including anonymous loggers
Private method to do the work for parenting a child
Logger onto a parent logger.
System.err.println("doSetParent \"" + getName() + "\" \""
Remove ourself from any previous parent.
ref is used down below to complete the reparenting
We have now removed ourself from our parents' kids.
Set our new parent.
we didn't have a previous parent
As a result of the reparenting, the effective level
may have changed for us and our children.
Remove the weak reference for the specified child Logger from the
kid list. We should only be called from LoggerWeakRef.dispose().
Recalculate the effective level for this node and
recursively for our children.
Figure out our current effective level.
This may happen during initialization.
If our effective value hasn't changed, we're done.
Recursively update the level on each of our kids.
Private method to get the potentially inherited
resource bundle and resource bundle name for this Logger.
This method never returns null.
first take care of this logger
either lb.userBundle is null or getResourceBundle() is
no resource bundle was specified on this logger, look up the
ancestor of a system logger is expected to be a system logger.
ignore resource bundle name if it's not.
-- This file was mechanically generated: Do not edit! --
This is a temporary workaround.
This code does not correctly deal with Synth (Synth doesn't use
properties like this), nor does it deal with the situation where
the developer grabs the color from a JLabel and sets it as
the background for a JTextArea in all look and feels. The problem
scenario results if the Color obtained for the Label and TextArea
is ==, which is the case for the windows look and feel.
Until an appropriate solution is found, the code is being
reverted to what it was before the original fix.
backward compatibility support... keymaps for the UI
are now installed in the more friendly input map.
create a view hierarchy
paint the background
paint the highlights
paint the view hierarchy
paint the caret
--- ComponentUI methods --------------------------------------------
common case is background painted... this can
easily be changed by subclasses or from outside
of the component.
attach to the model and editor
no model, create a default one.  This will
fire a notification to the updateHandler
which takes care of the rest.
by default, use default LayoutManger implementation that
will position the components associated with a View object.
detach from the model
Probably haven't been layed out yet, force some sort of
---- TextUI methods -------------------------------------------
--- ViewFactory methods ------------------------------
----- member variables ---------------------------------------
get rid of back reference so that the old
hierarchy can be garbage collected.
--- PropertyChangeListener methods -----------------------
Changes in ComponentOrientation require the views to be
--- DocumentListener methods -----------------------
i18n flag changed, rebuild the view
normal insert update
--- LayoutManager2 methods --------------------------------
remove the constraint record
should not be called (JComponent uses UI instead)
should not be called (JComponent uses UI instead)
should not be called (JComponent uses UI instead)
Read in a block at a time, mapping \r\n to \n, as well as single
\r to \n.
else nothing to do, can skip \r, next write will
--- TransferHandler methods ------------------------------------
only remove the text if shouldRemove has not been set to
false by importData and only if the action is a move
if we are importing to the same component that we exported from
then don't actually do anything if the drop location is inside
the drag location and set shouldRemove to false so that exportDone
knows not to remove any data
---- EditorKit other than plain or HTML text -----------------------
fall through to unsupported (should not happen)
End of file.
/ Field layout queries parallel to sun.misc.Unsafe:
e.g., returns vmindex
e.g., returns vmindex
e.g., returns clazz
The JVM calls MethodHandleNatives.<clinit>.  Cascade the <clinit> calls as needed:
All compile-time constants go here.
There is an opportunity to check them against the JVM's idea of them.
The JVM uses values of -2 and above for vtable indexes.
Field values are simple positive offsets.
This value is negative enough to avoid such numbers,
but not too negative.
method (not constructor)
The SEARCH_* bits are not for MN.flags but for the matchFlags argument of MHN.getMembers:
T_ARRAY    = 13
T_ADDRESS  = 15
Limit to tags found in classfiles
ignore exotic ops the JVM cares about; we just wont issue them
Up-calls from the JVM.
These must NOT be public.
fields are not caller sensitive
Msym overrides Mdef
Mdef implements Msym
SAX Output API
Command Input API
Parse Thread Convenience API
type arg is c
for cast to Comparable
(The javadoc description is true upon serialization.
Additionally, if the table array has not been allocated, this
field holds the initial array capacity, or zero signifying
all other fields defaulted
always check first node
-1 for 1st
existing mapping for key
initial capacity was placed in threshold
zero initial threshold signifies using defaults
Overrides of JDK8 Map extension methods
Cloning and serialization
this shouldn't happen, since we are Cloneable
These methods are also used when serializing HashSets
Write out the threshold, loadfactor, and any hidden stuff
Read in the threshold (ignored), loadfactor, and any hidden stuff
Read and ignore number of buckets
Read number of mappings (size)
(if zero, use defaults)
Size the table using given load factor only if within
range of 0.25...4.0
Read the keys and values, and put the mappings in the HashMap
next entry to return
advance to first entry
current index, modified on advance/split
one past last index
for comodification checks
initialize fence and size on first use
Create a regular (non-tree) node
For conversion from TreeNodes to plain nodes
Create a tree bin node
Callbacks to allow LinkedHashMap post-actions
Called only from writeObject, to ensure compatible ordering.
red-black tree links
needed to unlink next upon deletion
p was s's direct parent
Relink into lo and hi lists, preserving order
(else is already treeified)
Red-black tree methods, all adapted from CLR
XMLFilter.java - filter SAX2 events.
Written by David Megginson
NO WARRANTY!  This class is in the Public Domain.
$Id: XMLFilter.java,v 1.2 2004/11/03 22:55:32 jsuttor Exp $
end of XMLFilter.java
The value's data type
If name unknown statically, there's nothing we can do
Run type check on the key name (first argument) - must be a string,
and if it is not it must be converted to one using string() rules.
Run type check on the value for this key. This value can be of
any data type, so this should never cause any type-check errors.
If the value is a reference, then we have to defer the decision
of how to process it until run-time.
If the value is known not to be a node-set, then it should be
converted to a string before the lookup is done. If the value is
known to be a node-set then this process (convert to string, then
do lookup) should be applied to every node in the set, and the
result from all lookups should be added to the resulting node-set.
If in a top-level element, create dependency to the referenced key
Returns the KeyIndex object of a given name
KeyIndex.setDom(Dom, node) => void
Initialises a KeyIndex to return nodes with specific values
Initialise the index specified in the first parameter of key()
Generate following byte code:
KeyIndex ki = translet.getKeyIndex(_name)
ki.getKeyIndexIterator(_value, true)  - for key()
ki.getKeyIndexIterator(_value, false)  - for id()
If you add or remove anything from here, make sure you
Save this value for later - important for testing for special
combinations of steps and patterns than can be optimised
Special case for '.'
in the case where '.' has a context such as book/.
or .[false()] we can not optimize the nodeset to a single node.
Type check all predicates (expressions applied to the step)
Return either Type.Node or Type.NodeSet
If it is an attribute, but not '@*', '@pre:*' or '@node()',
and has no parent
Special case for '.'
Put context node on stack if using Type.Node
Wrap the context node in a singleton iterator if not.
Special case for /foo/*/bar
"ELEMENT" or "*" or "@*" or ".." or "@attr" with a parent.
Get the typed iterator we're after
Special case for predicates that can use the NodeValueIterator
instead of an auxiliary class. Certain path/predicates pairs
are translated into a base path, on top of which we place a
node value iterator that tests for the desired value:
foo[@attr = 'str']  ->  foo/@attr + test(value='str')
foo[bar = 'str']    ->  foo/bar + test(value='str')
foo/bar[. = 'str']  ->  foo/bar + test(value='str')
If the predicate's Step is simply '.' we translate this Step
and place the node test on top of the resulting iterator
Otherwise we create a parent location path with this Step and
the predicates Step, and place the node test on top of that
Handle '*[n]' expression
Handle 'elem[n]' expression
Backwards branches are prohibited if an uninitialized object
is on the stack by section 4.9.4 of the JVM Specification,
2nd Ed.  We don't know whether this code might contain
backwards branches, so we mustn't create the new object until
after we've created the suspect arguments to its constructor.
Instead we calculate the values of the arguments to the
constructor first, store them in temporary variables, create
the object and reload the arguments from the temporaries to
avoid the problem.
Backwards branches are prohibited if an uninitialized object
is on the stack by section 4.9.4 of the JVM Specification,
2nd Ed.  We don't know whether this code might contain
backwards branches, so we mustn't create the new object until
after we've created the suspect arguments to its constructor.
Instead we calculate the values of the arguments to the
constructor first, store them in temporary variables, create
the object and reload the arguments from the temporaries to
avoid the problem.
create new CurrentNodeListIterator
^ $ ...
( and )
\1 \2 ...
for CLOSURE, QUESTION
CharOp  for CHAR, BACKREFERENCE, CAPTURE, ANCHOR,
XML 1.0 components
XML 1.1 components
common components (non-configurable)
common components (configurable)
add default recognized features
set state for default features
add default recognized properties
add message formatters
REVISIT: What is the right thing to do? -Ac
make this feature special
forward to every XML 1.0 component
forward to every XML 1.1 component
ignore the exception.
ignore the exception
save state if noone "objects"
forward to every XML 1.0 component
forward to every XML 1.1 component
ignore the exception.
ignore the exception
store value if noone "objects"
REVISIT: this method used to reset all the components and
construct the pipeline. Now reset() is called
in parse (boolean) just before we parse the document
Should this method still throw exceptions..?
reset and configure pipeline and set InputSource.
Unrecoverable error reported during version detection
mark configuration as fixed
resets and sets the pipeline.
REVISIT - need to add new error message
close all streams opened by xerces
initialize the common components
use XML 1.0 datatype library
setup document pipeline
setup dtd pipeline
use XML 1.1 datatype library
setup document pipeline
setup dtd pipeline
features and properties
Allows the parser to validate a document only when it
contains a grammar. Validation is turned on/off based
on each document instance, automatically.
register component's recognized features
register component's recognized properties
set default values
Do not overwrite values already set on the configuration.
For newly added components who recognize this feature
but did not offer a default value, we need to make
sure these components will get an opportunity to read
the value before parsing begins.
Do not overwrite values already set on the configuration.
For newly added components who recognize this property
but did not offer a default value, we need to make
sure these components will get an opportunity to read
the value before parsing begins.
Reset XML 1.0 components
Reset XML 1.1 components
REVISIT: to implement: introduce a node pool to reuse DTM nodes.
reset this pool here.
create datatype factory
setup XML 1.1 DTD pipeline
setup XML 1.1. document pipeline - namespace aware
spec default values
zephyr (implementation) specific properties which can be set by the application.
interning is always done
recognizing java encoding names by default
in stax mode, namespace declarations are not added as attributes
default value of escaping characters is 'true'
add internal stax property
check if the property is managed by security manager
check if the property is managed by security property manager
fall back to the existing property manager
Get CORBA type
Get org.omg.CosNaming types
Import transient naming context
Default constructor uses "NameService" as the key for the Root Naming
Context. If default constructor is used then INS's object key for
Transient Name Service is "NameService"
This constructor gives the flexibility of providing the Object Key
for the Root Naming Context that is registered with INS.
Create an initial context
The initial naming context for this name service
Now sequence number is handled by MBeanServerDelegate.
Check that the MBean can be instantiated by the MBeanServer.
Check the JMX MBean compliance of the class
Includes case where getMBeanInfo() returns null
in another execution sequence it could have
may throw InstanceNotFoundException
Unregisters the MBean from the repository.
Returns the resource context that was used.
The returned context does nothing for regular MBeans.
For ClassLoader MBeans and JMXNamespace (and JMXDomain)
MBeans - the context makes it possible to unregister these
objects from the appropriate framework artifacts, such as
the CLR or the dispatcher, from within the repository lock.
In case of success, we also need to call context.done() at the
end of this method.
Check if the caller has the right to invoke 'queryMBeans'
Perform query without "query".
Check if the caller has the right to invoke 'queryMBeans'
on each specific classname/objectname in the list.
OK: Do not add this ObjectInstance to the list
Apply query to allowed MBeans only.
Query the MBeans on the repository
Check if the caller has the right to invoke 'queryNames'
Perform query without "query".
Check if the caller has the right to invoke 'queryNames'
on each specific classname/objectname in the list.
OK: Do not add this ObjectInstance to the list
Apply query to allowed MBeans only.
Query the MBeans on the repository
isRegistered is always unchecked as per JMX spec.
Check if the caller has the right to invoke 'getDomains'
Check if the caller has the right to invoke 'getDomains'
on each specific domain in the list.
OK: Do not add this domain to the list
Make an array from result.
Check if the caller has the right to invoke 'getAttribute'
Check if the caller has the right to invoke 'getAttribute'
on each specific attribute
OK: Do not add this attribute to the list
Check if the caller has the right to invoke 'setAttribute'
Check if the caller has the right to invoke 'setAttribute'
on each specific attribute
OK: Do not add this attribute to the list
should not happen
preRegister returned successfully, so from this point on we
must call postRegister(false) if there is any problem.
until we succeed
Register the MBean with the repository.
Returns the resource context that was used.
The returned context does nothing for regular MBeans.
For ClassLoader MBeans the context makes it possible to register these
objects with the appropriate framework artifacts, such as
the CLR, from within the repository lock.
In case of success, we also need to call context.done() at the
end of this method.
neither Error nor Exception??
Get listener object
Add a listener on an MBean
Get listener object
No query ...
Access the filter
No query ...
Access the filter
Access the filter.
Dealing with registration of special MBeans in the repository.
Creates a registration context, if needed.
May throw InstanceAlreadyExistsException
Send create event
Creates a registration context, if needed.
Send deletion event
For backward compatibility generate an empty paint
event.  Not doing this broke parts of Netbeans.
Assumes big endian (can use consumeEndian to read and set
the endianness if it is an encapsulation with a byte order
mark at the beginning)
Wide characters don't exist in GIOP 1.0
In GIOP 1.1, we shouldn't have byte order markers.  Take the order
of the stream if we don't see them.
Assume anything else adheres to GIOP 1.2 requirements.
Our UTF_16 converter will work with byte order markers, and if
they aren't present, it will use the provided endianness.
With no byte order marker, it's big endian in GIOP 1.2.
formal 00-11-03 15.3.16.
recognized features and properties
The current element depth.
This is used to access the appropriate level of the following stacks.
The depth of the first element to actually be part of the result infoset.
This will normally be 1, but it could be larger when the top-level item
is an include, and processing goes to the fallback.
this value must be at least 1
Used to ensure that fallbacks are always children of include elements,
and that include elements are never children of other include elements.
An index contains true if the ancestor of the current element which resides
at that depth was an include element.
Ensures that only one fallback element can be at a single depth.
An index contains true if we have seen any fallback elements at that depth,
and it is only reset to false when the end tag of the parent is encountered.
The state of the processor at each given depth.
START OF IMPLEMENTATION OF XMLComponent methods
componentManager doesn't support this feature,
so we won't worry about it
/ END OF IMPLEMENTATION  OF XMLComponents methods.
START OF  IMPLEMENTATION OF XMLDOCUMENTSOURCE INTERFACE /
/   END OF IMPLENTATION OF XMLDOCUMENTSOURCE INTERFACE /
/ Implementation of XPointerSchema Methods
/End Implementation of XPointerSchema Methods
Tokens Playground /
0 Notype; 1 for integer; 2 for string.
/  END TOKEN PLAYGROUND /
/   START OF IMPLEMTATION OF XMLDocumentHandler methods
we won't worry about when error reporter is null, since there should always be
at least the default error reporter
used to know whether to pass declarations to the document handler
CLASSPATH X REPOSITORY
CLASSNAME X JAVACLASS
Just in case, canonical form
We don't need to worry about client code changing the values of
these variables. Since TransferableProxy is a protected class, only
subclasses of DropTargetContext can access it. And DropTargetContext
cannot be subclassed by client code because it does not have a
copy set and check for nulls (CCE will be thrown if an element is not
Message keys used by the serializer
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The localname is the portion after the optional colon; the message indicates
that there is a problem with that part of the QNAME.
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The prefix is the portion before the optional colon; the message indicates
that there is a problem with that part of the QNAME.
factory which contains global state
for all POAManagers
current state of this POAManager
all poas controlled by this POAManager
Number of invocations in progress
Number of threads waiting for
invocations to complete
This POAManager's ID
initially false, set true as soon as
one of activate, hold_request,
discard_request, or deactivate is called.
XXX This is probably not the correct error
set the state to ACTIVE
Notify any invocations that were waiting because the previous
state was HOLDING, as well as notify any threads that were waiting
inside hold_requests() or discard_requests().
set the state to HOLDING
Notify any threads that were waiting in the wait() inside
discard_requests. This will cause discard_requests to return
(which is in conformance with the spec).
set the state to DISCARDING
Notify any invocations that were waiting because the previous
state was HOLDING. Those invocations will henceforth be rejected with
a TRANSIENT exception. Also notify any threads that were waiting
Notify any invocations that were waiting because the previous
state was HOLDING. Those invocations will then be rejected with
an OBJ_ADAPTER exception. Also notify any threads that were waiting
inside hold_requests() or discard_requests().
Make sure that poas cannot change while we copy it!
Each RETAIN+USE_SERVANT_MGR poa
must call etherealize for all its objects
called from POA.find_POA before calling
This notifies any threads that were in the
wait_for_completion loop in hold/discard/deactivate().
ignore the exception.
bootstrap class loader and system class loader if present
thread context class loader if and only if present
fallback to user's class loader
ignore secured class loaders
got a class name
just in case
Do not add subType.hashCode() to the total. equals uses
MimeType.match which reports a match if one or both of the
subTypes is '*', regardless of the other subType.
JCK Test DataFlavor0117: if 'mimeType' is null, throw NPE
Ensure backward compatibility.
Old versions didn't write the representation class to the stream.
A cache used by first().  This cache was found to speed parsing
by about 10% (based on measurements of the 4-12 code base after
buffering was fixed).
PENDING: refer to comment in ContentModelState
(PENDING) Hate having to hard code!
If "[on]" missing then ObjectName("*:*")
If "[]" then ObjectName("*:*")
Note that we include the "." in the required prefix
check for the known strings
make sure we didn't just match the tail of a word
like "ackbarfaccept".  Also, skip to the comma.
point i at the location of the comma minus one (or -1).
The actions in 'this' permission must be a
superset of the actions in 'that' permission
The 'className' check is true iff:
1) the className in 'this' permission is omitted or "*", or
2) the className in 'that' permission is omitted or "*", or
3) the className in 'this' permission does pattern
matching with the className in 'that' permission.
The 'member' check is true iff:
1) the member in 'this' permission is omitted or "*", or
2) the member in 'that' permission is omitted or "*", or
3) the member in 'this' permission equals the member in
The 'object name' check is true iff:
1) the object name in 'this' permission is omitted or "*:*", or
2) the object name in 'that' permission is omitted or "*:*", or
3) the object name in 'this' permission does pattern
matching with the object name in 'that' permission.
bottom is implied
bottom implies nothing but itself
exact never implies wildcard
exact match fails
prefix match, works even if "that" is also a wildcard
e.g. a.* implies a.* and a.b.*
bottom is implied
bottom implies nothing but itself
wildcard implies everything (including itself)
bottom is implied
bottom implies nothing but itself
This commented-out block is used for testing flush scrollbars.
end class ScrollBarListener
calculate new URI
check if Basic authentication is required
do http basic authentication
set authentication property in the http header
if the URI contains a fragment, ignore it
size without time zone: ---09
validate and normalize
save unnormalized values
A new ORB started server registers itself with the Activator
Install a particular kind of endpoint
list active servers
If the server is not running, start it up.
If the server is running, shut it down
currently running, this method will activate it.
list all registered ORBs for a server
After this hook completes, the server may still be running.
Type-specific CORBA::Object operations
Import general CORBA classes
Import org.omg.CosNaming types
XXX: the wrapper calls are all preceded by logger updates.
These can be combined, and then we simply use 3 NamingSystemException wrappers,
for read, update, and lifecycl.
Create a key and a value
Is the initial naming context requested?
Create a key and lookup the value
Copy out binding type and object reference
Create a key and remove it from the hashtable
Return what was found
Create a new binding iterator servant with a copy of this
hashtable. nsPOA is passed to the object so that it can
de-activate itself from the Active Object Map when
Binding Iterator.destroy is called.
Have it set the binding list
Get the object reference for the binding iterator servant
Convert to a CORBA system exception
Create a new servant
Destroy the object reference by disconnecting from the ORB
A hashtable to store the bindings
components of these namespaces are stored in this map
number of namespaces
each entry contains components in one namespace
store all components from all namespace.
used when this map is accessed as a list.
store the number of components.
used when this map is accessed as a list.
Set of Map.Entry<QName,XSObject> for the java.util.Map methods
because all components are from the same target namesapce,
get the namespace from the first one.
copy elements to the Vector
when this map is created from SymbolHash's
get the component from SymbolHash
Otherwise (it's created from an array)
go through the array to find a matching name
calculate the total number of elements
get components from all SymbolHashes
Defer creation of the entry set until it is actually needed.
Create a view of this immutable map.
Notes on concurrency.
The POA requires careful design for concurrency management to correctly
implement the specification and avoid deadlocks.  The order of acquiring
locks must respect the following locking hierarchy:
1. Lock POAs before POAManagers
2. Lock a POA before locking its child POA
Also note that there are 3 separate conditions on which threads may wait
in the POA, as defined by invokeCV, beingDestroyedCV, and
adapterActivatorCV.  This means that (for this reason as well as others)
we cannot simply use the standard Java synchronized primitive.
This implementation uses a modified version of Doug Lea's
util.concurrent (version 1.3.0) that supports reentrant
mutexes to handle the locking.  This will all be replaced by the new JSR
166 concurrency primitives in J2SE 1.5 and later once the ORB moves to
POA state constants
Note that ordering is important here: we must have the state defined in
this order so that ordered comparison is possible.
DO NOT CHANGE THE VALUES OF THE STATE CONSTANTS!!!  In particular, the
initialization related states must be lower than STATE_RUN.
POA is created in STATE_START
Valid state transitions:
START to INIT                        after find_POA constructor call
START to RUN                         after initialize completes
INIT to INIT_DONE                    after initialize completes
INIT to DESTROYED                    after failed unknown_adapter
INIT_DONE to RUN                     after successful unknown_adapter
STATE_RUN to STATE_DESTROYING        after start of destruction
STATE_DESTROYING to STATE_DESTROYED  after destruction completes.
waiting for adapter activator
adapter activator called create_POA
initialized and running
Current state of the POA
The POA request handler that performs all policy specific operations
Note that POAImpl handles all synchronization, so mediator is (mostly)
Representation of object adapter ID
counts depth of tree.  Root = 1.
the actual object adapter ID for this POA
the name of this POA
This POA's POAManager
ID for this POA that is unique relative
to the POAFactory, which has the same
lifetime as the ORB.
The POA that created this POA.
Map from name to POA of POAs created by
pending invocations on this POA.
Data used to control POA concurrency
XXX revisit for JSR 166
Master lock for all POA synchronization.  See lock and unlock.
package private for access by AOMEntry.
Wait on this CV for AdapterActivator upcalls to complete
Wait on this CV for all active invocations to complete
Wait on this CV for the destroy method to complete doing its work
thread local variable to store a boolean to detect deadlock in
This includes the most important information for debugging
package private for mediator implementations.
package private for access to servant to POA map
package private so that POAFactory can access it.
package private so that POAPolicyMediatorBase can access it.
package private so that POAPolicyMediator can access it.
package private so that POAPolicyMediator can access it.
package private so that DelegateImpl can access it.
Note that the parent POA must be locked when this constructor is called.
This was done in initialize, but I moved it here
to get better searchability when tracing.
This is the root POA, which counts as 1 level
My level is one more than that of my parent
Get an array of all of the POA names in order to
create the poaid.
The POA lock must be held when this method is called.
Construct the object key template
Note that parent == null iff this is the root POA.
This was used to avoid executing interceptors on the RootPOA.
That is no longer necessary.
XXX extract codebase from policies and pass into initializeTemplate
after the codebase policy change is finalized.
The poaMutex must be held when this method is called
Note that a POA could be destroyed while in STATE_INIT due to a
failure in the AdapterActivator upcall.
This method checks that the AdapterActivator finished the
initialization of a POA activated in find_POA.  This is
determined by checking the state of the POA.  If the state is
STATE_INIT, the AdapterActivator did not complete the
inialization.  In this case, we destroy the POA that was
partially created and return false.  Otherwise, we return true.
In any case, we must wake up all threads waiting for the adapter
activator, either to continue their invocations, or to return
errors to their client.
The poaMutex must NOT be held when this method is called.
Don't just use destroy, because the check for
deadlock is too general, and can prevent this from
Extract the ObjectId from the first TaggedProfile in the IOR.
If ior was created in this POA, the same ID was used for
every profile through the profile templates in the currentFactory,
so we will get the same result from any profile.
Converted from anonymous class to local class
so that we can call performDestroy() directly.
Catch exceptions since setDaemon can cause a
security exception to be thrown under netscape
in the Applet mode
Returns true if destruction must be completed, false
if not, which means that another thread is already
Note that we do not synchronize on this, since this is
the PerformDestroy instance, not the POA.
destroy may be called multiple times, and each call
is allowed to proceed with its own setting of the wait
flag, but the etherealize value is used from the first
call to destroy.  Also all children should be destroyed
before the parent POA.  If the poa is already destroyed,
we can just return.  If the poa has started destruction,
but not completed, and wait is true, we need to wait
until destruction is complete, then just return.
Make a copy since we can't hold the lock while destroying
the children, and an iterator is not deletion-safe.
We are not holding the POA mutex here to avoid holding it
while destroying the POA's children, since this may involve
upcalls to etherealize methods.
NOTE: If we are here, poa is in STATE_DESTROYING state. All
other state checks are taken care of in prepareForDestruction.
No other threads may either be starting new invocations
by calling enter or starting to destroy poa.  There may
still be pending invocations.
Note that we must lock the parent before the child.
The parent lock is required (if poa is not the root)
to safely remove poa from parent's children Map.
We have just destroyed the root POA, so we need to
make sure that the next call to
resolve_initial_reference( "RootPOA" )
will recreate a valid root POA.
Public POA API
We cannot create children of a POA that is (being) destroyed.
This has been added to the CORBA 3.0 spec.
Do not hold the parent POA lock while
waiting for child to complete initialization.
Make sure that the child has completed its initialization,
if it was created by an AdapterActivator, otherwise throw
a standard TRANSIENT exception with minor code 4 (see
CORBA 3.0 11.3.9.3, in reference to unknown_adapter)
Note that found may be in state DESTROYING or DESTROYED at
this point.  That's OK, since destruction could start at
Create a child, but don't initialize it.  The newly
created POA will be in state STATE_START, which will
cause other calls to find_POA that are creating the same
POA to block on the waitUntilRunning call above.
Initialization must be completed by a call to create_POA
inside the unknown_adapter upcall.  Note that
this.poaMutex must be held here so that this.children
can be safely updated.  The state is set to STATE_INIT
so that initialize can make the correct state transition
when create_POA is called inside the AdapterActivator.
This avoids activating the new POA too soon
by transitioning to STATE_RUN after unknown_adapter
assert (found != null)
assert not holding this.poaMutex OR found.poaMutex
We must not hold either this.poaMutex or found.poaMutex here while
waiting for intialization of found to complete to prevent possible
Prevent more than one thread at a time from executing in act
in case act is shared between multiple POAs.
ignore most non-system exceptions, but log them for
At this point, we have completed adapter activation.
Whether this was successful or not, we must call
destroyIfNotInitDone so that calls to enter() and create_POA()
that are waiting can execute again.  Failing to do this
will cause the system to hang in complex tests.
OMG Issue 3740 is resolved to throw AdapterNonExistent if
unknown_adapter() returns false.
This is to avoid deadlock
Allocate a new system-generated object-id.
This will throw WrongPolicy if not SYSTEM_ID
This exception can not occur in this case,
since id is always brand new.
Clone the id to avoid possible errors due to aliasing
(e.g. the client passes the id in and then changes it later).
Clone the id to avoid possible errors due to aliasing
(e.g. the client passes the id in and then changes it later).
reference_to_id should throw WrongAdapter
if the objref was not created by this POA
Implementation of ObjectAdapter interface
Avoid deadlock if this is the thread that is processing the
POA.destroy because this is the only thread that can notify
waiters on beingDestroyedCV.  This can happen if an
etherealize upcall invokes a method on a colocated object
served by this POA.
Fill element QName and XMLAttributes
Add namespace declarations if necessary
local part may be an empty string if this is a namespace declaration
local part may be an empty string if this is a namespace declaration
must be a parser exception; mine it for locator info and throw
why did we create an XMLParseException?
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of ComboBoxPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of ComboBoxPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
DSAKeyValue (P, Q, G, Y, J?, (Seed, PgenCounter)?)
RSAKeyValue (Modulus, Exponent)
X509Data ((X509IssuerSerial | X509SKI | X509SubjectName | X509Certificate)+ | X509CRL)
X509IssuerSerial (X509IssuerName, X509SerialNumber)
PGPData ((PGPKeyID, PGPKeyPacket?) | (PGPKeyPacket))
we don't allow instantiation
Keep running with MAX_ARRAY_SIZE buckets
Rehash the table if the threshold is exceeded
Creates the new entry.
Make sure the value is not null
Makes sure the key is not already in the hashtable.
this shouldn't happen, since we are Cloneable
Comparison and hashing
Mark hashCode computation in progress
Mark hashCode computation complete
explicit check required in case
table is empty.
explicit check required in case
table is empty.
Makes sure the key is not already in the hashtable.
Hashtable not accept null value
Write out the threshold and loadFactor
Write out the length and count of elements
Stack copies of the entries in the table
Write out the key/value objects from the stacked entries
Read in the threshold and loadFactor
Validate loadFactor (ignore threshold - it will be re-computed)
Read the original length of the array and number of elements
Validate # of elements
Clamp original length to be more than elements / loadFactor
(this is the invariant enforced with auto-growth)
Compute new length with a bit of room 5% + 3 to grow but
no larger than the clamped original length.  Make the length
odd if it's large enough, this helps distribute the entries.
Guard against the length ending up zero, that's not valid.
Read the number of elements and then all the key/value objects
sync is eliminated for performance
Makes sure the key is not already in the hashtable.
This should not happen in deserialized version.
Creates the new entry.
Types of Enumerations/Iterations
largest numerical value
These would not be used for EN. Only used for traditional numbering
These only used for mutiplicative-additive numbering
Suppresses default constructor, ensuring non-instantiability.
key not found
key not found
key not found
key not found
instead of using a raw type here, it's possible to capture
the wildcard but it will require a call to a supplementary
Dump array back into list
instead of using a raw type here, it's possible to capture
the wildcard but it will require a call to a supplementary
instead of using a raw type here, it's possible to capture
the wildcard but it will require a call to a supplementary
Element mismatch, try next cand
All elements of candidate matched target
Iterator version of above algorithm
Back up source iterator to next candidate
No candidate matched the target
Index access version
Element mismatch, try next cand
All elements of candidate matched target
Iterator version of above algorithm
Back up source iterator to next candidate
No candidate matched the target
Use backing collection version
Override default methods in Collection
Override default methods in Map
Safe cast as we don't change the value
Need to cast to raw in order to work around a limitation in the type system
We don't pass a to c.toArray, to avoid window of
vulnerability wherein an unscrupulous multithreaded client
could get his hands on raw (unwrapped) Entries from c.
Invokes safe contains() above
Invokes safe containsAll() above
Object on which to synchronize
Must be manually synched by user!
Override default methods in Collection
Must be manually synched by user!
Must be manually synched by user!
Must be manually synched by user!
Must be manually synched by user
Must be manually synched by user
Object on which to synchronize
Override default methods in Map
Dynamically typesafe collection wrappers
JDK-6363904 - unwrapped iterator could be typecast to
ListIterator with unsafe set()
Defend against coll violating the toArray contract
To get better and consistent diagnostics,
we call typeCheck explicitly on each element.
We call clone() to defend against coll retaining a
reference to the returned array and storing a bad
element into it after it has been type checked.
A slight abuse of the type system, but safe here.
Doing things this way insulates us from concurrent changes
in the contents of coll and provides all-or-nothing
semantics (which we wouldn't get if we type-checked each
element as we added it)
Override default methods in Collection
Satisfy the following goals:
- good diagnostics in case of type mismatch
- all-or-nothing semantics
- protection from malicious t
- correct behavior if t is a concurrent map
Override default methods in Map
We don't pass a to s.toArray, to avoid window of
vulnerability wherein an unscrupulous multithreaded client
could get his hands on raw (unwrapped) Entries from s.
Invokes safe contains() above
Invokes safe containsAll() above
Override default methods in Collection
Preserves singleton property
Override default methods in Collection
Preserves singleton property
Override default methods in Map
Preserves singleton property
Override default methods for Collection
Override default methods for Collection
Override default methods in Map
Override default methods in Collection
The collection to be used for contains(). Preference is given to
the collection who's contains() has lower O() complexity.
The collection to be iterated. If the collections' contains() impl
are of different O() complexity, the collection with slower
contains() will be used for iteration. For collections who's
contains() are of the same complexity then best performance is
achieved by iterating the smaller collection.
Performance optimization cases. The heuristics:
1. Generally iterate over c1.
2. If c1 is a Set then iterate over c2.
3. If either collection is empty then result is always true.
4. Iterate over the smaller Collection.
Use c1 for contains as a Set's contains() is expected to perform
better than O(N/2)
Both are mere Collections. Iterate over smaller collection.
Example: If c1 contains 3 elements and c2 contains 50 elements and
assuming contains() requires ceiling(N/2) comparisons then
checking for all c1 elements in c2 would require 75 comparisons
(3 * ceiling(50/2)) vs. checking all c2 elements in c1 requiring
100 comparisons (50 * ceiling(3/2)).
At least one collection is empty. Nothing will match.
Found a common element. Collections are not disjoint.
No common elements were found.
The backing map
addAll is the only inherited implementation
Override default methods in Collection
We use inherited addAll; forwarding addAll would be wrong
Override default methods in Collection
These message should be read from a locale-specific resource bundle
PENDING(sky): If this becomes a problem, make it sort.
should this use .equals?
no tabs after the passed in location.
probably can't happen
probably can't happen
root -> Version
root -> LogicalScreenDescriptor
root -> GlobalColorTable
root -> GlobalColorTable -> ColorTableEntry
If rirFlag is set to true that means internal
boot strapping technique will be used. If set to
false then the EndpointInfo will be used to create the
Service Object reference.
Locate redundant state
Remove redundant state
End of class StateEdit
May throw IOException
Returns the string value for a node in the DOM
safe from overflow
safe from overflow
If validating, provide a default ErrorHandler that prints
validation errors with a warning telling the user to set an
"namespaceAware" == SAX Namespaces feature
Set various parameters obtained from DocumentBuilderFactory
Avoid setting the XInclude processing feature if the value is false.
This will keep the configuration from throwing an exception if it
does not support XInclude.
Must set before calling setDocumentHandler()
setAttribute override those that may be set by other means
Nothing to do
JAXP 1.2 support
None of the properties will take effect till the setValidating(true) has been called
this should allow us not to emit DTD errors, as expected by the
spec when schema validation is enabled
check if the property is managed by security manager
check if the property is managed by security property manager
fall back to the existing property manager
This should never be thrown from the schema validator.
The compiled regular expression 'program'
The amount of the instruction buffer in use
Prefix string optimization
Optimization flags (REProgram.OPT_*)
Ensure program has been compiled!
Return copy of program
Save reference to instruction array
Initialize other program-related variables
Try various compile-time optimizations if there's a program
If the first node is a branch
to the end node
and the branch starts with an atom
then get that atom as an prefix because there's no other choice
Check for backreferences
Register it by its aliases
Absence of Hijrah calendar is fatal to initializing this class.
no name or not a simple name of a calendar
do not duplicate the default
Create and register the variant
Log error and continue
Keep this short so it can be inlined for performance
override with covariant return type
override for return type
ensure that the chronology is initialized
change to 1-based.
change to 1-based.
ensure that the chronology is initialized
The very last entry in the epochMonth table is not the start of a month
Everything else is either a year or invalid
Now create and validate the array of epochDays indexed by epochMonth
Compute the min and max year length in days.
Log error and throw a DateTimeException
Compute the size for the array of dates
Initialize the running epochDay as the corresponding ISO Epoch day
index into array of epochMonths
Only whole years are valid, any zero's in the array are illegal
must not be gaps
Insert the final epochDay
Parse the Reference children and Id attribute in the Manifest
the c14n is not a secure one and can rewrite the URIs or like
so reparse the SignedInfo to be sure
make defensive copy
Maximum size of stack used by this method
Number of local variables
Length of code in bytes
Actual byte code
Table of handled exceptions
Attributes of code: LineNumber
Initialize with some default values which will be overwritten later
Read byte code
should not happen
Check that the function was passed exactly two arguments
The first argument must be a String, or cast to a String
The second argument must also be a String, or cast to a String
Fields that form the context of the element
this assignment means can never pop this context off
depth 0 because it doesn't correspond to any element
Initialize, or reset values in the new or re-used stack frame.
is_Raw is already set in the HTML startElement() method
Common UI methods
Increase array size by only 1 at a time.  Fix this
if it looks to be a problem.
Note that we are assuming there are no positional predicates!
TODO: Fix this.
validate and normalize
REVISIT: do we need SchemaDateTimeException?
save unnormalized values
Comparison and hashing
Create a 6x6x6 color cube
And populate the rest of the cmap with gray values
The gray ramp will be between 18 and 252
Will be set below
Force the raster data alpha state to match the premultiplied
state in the color model
Check if this might be a child raster (fix for bug 4240596)
Check if the raster params and the color model
Now check on the DirectColorModel params
if (dcm.getRedMask() == DCM_RED_MASK &&
if (rmask == DCM_BGR_RED_MASK &&
if (iraster.getPixelStride() == 1
((raster instanceof IntegerComponentRaster) &&
if (raster instanceof BytePackedRaster)
else if (cm instanceof IndexColorModel) && (numBands == 1))
else if ((cm instanceof IndexColorModel) && (numBands == 1))
else if ((raster instanceof ByteComponentRaster) &&
Make the color model do the conversion
REMIND : this allocates a whole new tile if raster is a
subtile.  (It only copies in the requested area)
We should do something smarter.
Clip to the current Raster
remind use get/setDataElements for speed if Rasters are
Java to IDL ptc 02-01-12 1.4.11
the permission that caused the exception to be thrown.
Methods unique to this class
org.w3c.dom.NodeList API follows
These three statements need to be combined into one operation.
Yuck.  Just to shut up the compiler!
These two statements need to be combined into one operation.
Reference to the compiler object.
Reference to the XPath parser.
Contains all compilation errors
Contains all compilation errors
Maps instructions to classes
reqd and opt attrs
Maps QNames to syntax-tree nodes
Reference to the template being parsed.
Used for validity check
parse and retrieve namespace
Get the namespace uri from the symbol table
parse and retrieve namespace
Get the namespace uri from the symbol table
Map the default NS if not already defined
Parse the input document and build the abstract syntax tree
Find the start of the stylesheet within the tree
Create a SAX parser and get the XMLReader object it uses
Assume that this is a pure XSL stylesheet if there is not
<?xml-stylesheet ....?> processing instruction
Find the xsl:stylesheet or xsl:transform with this reference
Check if the location is URL or a local file
The following functions are inlined
The following functions are implemented in the basis library
Operators +, -, *, /, % defined on real types.
Operators +, -, * defined on integer types.
Operators / and % are not  defined on integers (may cause exception)
Operators <, <= >, >= defined on real types.
Operators <, <= >, >= defined on int types.
Operators <, <= >, >= defined on boolean types.
Operators 'and' and 'or'.
Check if the element belongs in our namespace
Check if this is an XSLTC extension element
Check if this is an extension of some other XSLT processor
Ignore if special or if it has a prefix
Workaround for the TCK failure ErrorListener.errorTests.error001..
Get the textual representation of the expression (if any)
Use the default expression if none was found
Invoke the XPath parser
Get the textual representation of the pattern (if any)
Use the default pattern if none was found
Invoke the XPath parser
Return a dummy pattern (which is an expression)
Unexpected internal errors, such as null-ptr exceptions, etc.
Immediately terminates compilation, no translet produced
XSLT elements that are not implemented and unsupported ext.
Immediately terminates compilation, no translet produced
Fatal error in the stylesheet input (parsing or content)
Immediately terminates compilation, no translet produced
Other error in the stylesheet input (parsing or content)
Does not terminate compilation, no translet produced
Other error in the stylesheet input (content errors only)
Does not terminate compilation, a translet is produced
If this is the root element of the XML document we need to make sure
that it contains a definition of the XSL namespace URI
Extension elements and excluded elements have to be
handled at this point in order to correctly generate
Fallback elements from <xsl:fallback>s.
If this text occurs within an <xsl:text> element we append it
as-is to the existing text element
Ignore text nodes that occur directly under <xsl:stylesheet>
Add it as a regular text node otherwise
We only handle the <?xml-stylesheet ...?> PI
URI of stylesheet found
Media of stylesheet found
Title of stylesheet found
Charset of stylesheet found
Get the attributes from the processing instruction
Set the target to this PI's href if the parameters are
null or match the corresponding attributes of this PI.
1.1 Compatibility: "" is not converted to null in 1.1
Add a new ProtectionDomain with the null codesource/signers, and
the empty permission set, to the end of the array containing the
'current' protections domains, i.e. the ones that will be augmented
with the permissions granted to the set of principals present in
the supplied subject.
Need to build a runnable object for the Thread.
So far, all pixels are already sent in TDLR order
First get the rendered image
And its ColorModel
Set up the ImageConsumers
Get RGB pixels from the raster scanline by scanline and
send to consumers.
Now send the scanline to the Consumers
Now tell the consumers we're done.
Could be 1 to 4
We don't write DQT segments; the IJG library does.
Determine if the table is all the same values
if so, use the same table
Otherwise, find the largest coefficient less than 255.  This is
the largest value that we know did not clamp on scaling.
Compute the scale factor by dividing it by the value in the
same position from the "standard" table.
If the given table was not generated by scaling the standard,
the resulting table will still be reasonable, as it will reflect
a comparable scaling of chrominance frequency response of the
generate a new table
64 elements, in natural order
IJG is compiled for 8-bits, so this shouldn't happen
Read from zig-zag order to natural order
creating a stream pipe-line, from a to b
write and flush the object content to byte array
now sign the encapsulated object
creating a stream pipe-line, from b to a
initialize the signing engine
pay particular attention to where the version is being read from!
is contains an encapsulation, ServiceContext reads off the
encapsulation and leaves the pointer in the variable "in",
which points to the long value.
Required SERVICE_CONTEXT_ID and getId definitions
current ORB Version
-- This file was mechanically generated: Do not edit! --
tell Selector Thread there's an update to a SelectorKey's Ops
wakeup Selector thread to process close request
wakeup Selector thread to process close request
IMPORTANT: ignore all errors so the select thread keeps running.
Otherwise a guaranteed hang.
REVISIT - better handling/reporting
Need to check if the SelectionKey is valid because a
connection's SelectionKey could be put on the list to
have its OP enabled and before it's enabled be reclaimed.
Otherwise, the enabling of the OP will throw an exception
here and exit this method an potentially not enable all
So, we ignore SelectionKeys that are invalid. They will get
cleaned up on the next Selector.select() call.
Private class to contain a SelectionKey and a SelectionKey op.
Used only by SelectorImpl to register and enable SelectionKey
REVISIT - Could do away with this class and use the EventHanlder
End of file.
Find the handle for "this" JsrInstruction object.
Return the physical successor
J2SE does not support Xalan interpretive
Constructor used for factory/utility cases
Constructor used by getIdFromString.  All non-static
RepositoryId methods will use the provided delegate.
A null locale means use the default locale.
Save lookup for future use, as forName is slow.
In order to pick up the security policy in effect at the
time of creation we use a doPrivileged with the
AccessControlContext that was in place when this was created.
See if we should use a separate ClassLoader
Fallback to the system class loader.
Ideally we would throw an exception, unfortunately
often times there are errors as an initial look and
feel is loaded before one can be switched. Perhaps a
flag should be added for debugging, so that if true
the exception would be thrown.
Number of lines to format to.
characters in source text
Bidi for this paragraph
Levels array for chars in this paragraph - needed to reorder
trailing counterdirectional whitespace
line components in logical order
index where components begin
index where components end
used to find valid starting points for line components
paragraph, with resolved fonts and styles
paragraph data - same across all layouts
set paragraph attributes
If there's an embedded graphic at the start of the
paragraph, look for the first non-graphic character
and use it and its font to initialize the paragraph.
If not, use the first graphic to initialize.
hmmm what to do here?  Just try to supply reasonable
values I guess.
no extra info yet, bidi determines run and line direction
either of these statements removes the bug:
tlcStart is now the start of the tlc at tlcIndex
format more text and try again
Back up over counterdirectional whitespace
sigh I really hate to do this here since it's part of the
cdWsStart is the start of the trailing counterdirectional
tlcStart is now the start of the tlc at tlcIndex
If we've already gone past the layout window, format to end of paragraph
could cache line in case getLayout is called with same start, limit
Hidden classes, constants, and operations for parsing a MIME media type
Class for a lexical analyzer.
Looking for a token, quoted string, or tspecial
In a quoted string
In a quoted string, backslash seen
In a comment
In a comment, backslash seen
In a token
Parse media type.
Parse zero or more parameters.
Parse parameter name.
Parse parameter value.
Make sure we've consumed everything.
Save the pieces. Parameters are not in ascending order yet.
Sort the parameters into ascending order using an insertion sort.
Store real into a local variable
Compare it to 0.0
!!! call isNaN
Compare it to itself to see if NaN
NaN != NaN
0 is reserved for NodeIterator.END
used by some node iterators to know which node to return
Constants used by getResultTreeFrag to indicate the types of the RTFs.
regardless of what type of node this is, fire start and end document events
Release references to application objects
fCurrentElement = null; -- keep the reference to support current-element-node property
Performs a non-recursive traversal of the DOM. This
will avoid a stack overflow for DOMs with high depth.
push namespace context
Ignore other node types.
pop namespace context
If there's no DOMResult, unset the validator handler
If the source node and result node are the same use the DOMResultAugmentor.
Otherwise use the DOMResultBuilder.
Is this a DOM level1 document?
REVISIT: Assuming all attributes are of type CDATA. The actual type may not matter. -- mrglavas
REVISIT: Should we be looking at non-namespace attributes
for additional mappings? Should we detect illegal namespace
declarations and exclude them from the context? -- mrglavas
process namespace attribute
REVISIT: Should we be looking at non-namespace attributes
for additional mappings? Should we detect illegal namespace
declarations and exclude them from the context? -- mrglavas
process namespace attribute
resize array, if needed
bind prefix to uri in current context
find prefix in the DOM context
prefix not found
BEGIN: Keys needed for exception messages of  JAXP 1.3 XPath API implementation
END: Keys needed for exception messages of  JAXP 1.3 XPath API implementation
Note to translators:  A relative location path is a form of XPath expression.
The message indicates that such an expression was expected following the
characters '/' or '', but was not found.
Note to translators:  A location path is a form of XPath expression.
The message indicates that syntactically such an expression was expected,but
the characters specified by the substitution text were encountered instead.
Note to translators:  A location path is a form of XPath expression.
The message indicates that syntactically such a subexpression was expected,
but no more characters were found in the expression.
Note to translators:  A location step is part of an XPath expression.
The message indicates that syntactically such an expression was expected
following the specified characters.
Note to translators:  A node test is part of an XPath expression that is
used to test for particular kinds of nodes.  In this case, a node test that
consists of an NCName followed by a colon and an asterisk or that consists
of a QName was expected, but was not found.
Note to translators:  A step pattern is part of an XPath expression.
The message indicates that syntactically such an expression was expected,
but the specified character was found in the expression instead.
Note to translators: A relative path pattern is part of an XPath expression.
The message indicates that syntactically such an expression was expected,
but was not found.
Note to translators:  The substitution text is the name of a data type.  The
message indicates that a value of a particular type could not be converted
to a value of type boolean.
Note to translators: Do not translate ANY_UNORDERED_NODE_TYPE and
Note to translators: Do not translate UNORDERED_NODE_SNAPSHOT_TYPE and
Note to translators: This message indicates that the document being operated
upon changed, so the iterator object that was being used to traverse the
document has now become invalid.
Note to translators:  The substitution text is the name of a data type.  The
message indicates that a value of a particular type could not be converted
to a value of type string.
Note to translators: Do not translate snapshotItem,
UNORDERED_NODE_SNAPSHOT_TYPE and ORDERED_NODE_SNAPSHOT_TYPE.
Note to translators:  XPathEvaluator is a Java interface name.  An
XPathEvaluator is created with respect to a particular XML document, and in
this case the expression represented by this object was being evaluated with
respect to a context node from a different document.
Note to translators:  The XPath expression cannot be evaluated with respect
to this type of node.
BEGIN:  Definitions of error keys used  in exception messages of  JAXP 1.3 XPath API implementation
END:  Definitions of error keys used  in exception messages of  JAXP 1.3 XPath API implementation
Other miscellaneous text used inside the code...
================= INFRASTRUCTURE ======================
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of ButtonPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of ButtonPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
Drop through.  Use record message as format
Do the formatting.
No parameters.  Just return format string.
Is it a java.text style format?
Ideally we could match with
However the cost is 14% higher, so we cheaply check for
1 of the first 4 parameters
Formatting failed: use localized format string.
trace creates and disposes
show reuse hits/misses
show bad params, misc.
TIGER - 4840653
Removed code which fired an AccessibleState.SELECTED
PropertyChangeEvent since this resulted in two
identical events being fired since
AbstractButton.fireItemStateChanged also fires the
same event. This caused screen readers to speak the
name of the item twice.
Set location of popupMenu (pulldown or pullright)
Figure out the sizes needed to caclulate the menu position
For the first time the menu is popped up,
the size has not yet been initiated
take screen insets (e.g. taskbar) into account
We are a submenu (pull-right)
First determine x:
Prefer placement to the right
popup doesn't fit - place it wherever there's more room
First determine x:
Prefer placement to the left
popup doesn't fit - place it wherever there's more room
Then the y:
Prefer dropping down
popup doesn't fit - place it wherever there's more room
We are a toplevel menu (pull-down)
First determine the x:
Extend to the right
popup doesn't fit - place it wherever there's more room
First determine the x:
Extend to the left
popup doesn't fit - place it wherever there's more room
Then the y:
Prefer dropping down
popup doesn't fit - place it wherever there's more room
Otherwise drop 'up'
Are we in the MenuItem part of the menu
Are we in the PopupMenu?
Are we in a Component on the PopupMenu
Are we in the current component?
Hmmm, what about Non-menu containers?
Recursive call for the Menu case
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Overriden to do nothing, JMenu doesn't support an accelerator
FIXME:  [[[WDW - probably should set this when
the component is added to the menu.  I tried
to do this in most cases, but the separators
added by addSeparator are hard to get to.]]]
this menu is selected
if i is a sub-menu & popped, return it
this menu is selected
so find the next JMenuItem in the MenuElement
array, and return it!
if i is a sub-menu and is pop-ed up, return true, else false
if this menu is selected, reset selection to only go
to this menu; else do nothing
menu is in the selection!
inner class AccessibleJMenu
Encoding and version info will be available only after startElement
is called for first time. So, defer START_DOCUMENT event of StAX till
that point of time.
Do not call writeStartElement with prefix and namespaceURI, as it writes out
No need to write namespaces, as they are written as part of attributes.
namespace declaration disguised as an attribute.
write it as an namespace
-- This file was mechanically generated: Do not edit! --
For duplicates and slices
--- Methods to support CharSequence ---
Initialize DOM navigation
Initialize DTM navigation
Apparently the domSource root may not actually be the
Document node. If it's an Element node, we need to immediately
add its attributes. Adapted from nextNode().
%REVIEW% Move this logic into addNode and recurse? Cleaner!
(If it's an EntityReference node, we're probably scrod. For now
I'm just hoping nobody is ever quite that foolish... %REVIEW%)
%ISSUE% What about inherited namespaces in this case?
Do we need to special-case initialize them into the DTM model?
start with no previous sib
addNode() will take care of switching it from
Attr to Namespace if necessary.
Terminate list of attrs, and make sure they aren't
considered children of the element
IMPORTANT: This does NOT change m_last_parent or m_last_kid!
if attrs exist
Initialize DTM-completed status
Have we overflowed a DTM Identity's addressing range?
Handle as Extended Addressing
%REVIEW% Wrong error message, but I've been told we're trying
not to add messages right not for I18N reasons.
%REVIEW% Should this be a Fatal Error?
%REVIEW% The Namespace Spec currently says that Namespaces are
processed in a non-namespace-aware manner, by matching the
QName, even though there is in fact a namespace assigned to
these nodes in the DOM. If and when that changes, we will have
to consider whether we check the namespace-for-namespaces
rather than the node name.
%TBD% Note that the DOM does not necessarily explicitly declare
all the namespaces it uses. DOM Level 3 will introduce a
namespace-normalization operation which reconciles that, and we
can request that users invoke it or otherwise ensure that the
tree is namespace-well-formed before passing the DOM to Xalan.
But if they don't, what should we do about it? We probably
don't want to alter the source DOM (and may not be able to do
so if it's read-only). The best available answer might be to
synthesize additional DTM Namespace Nodes that don't correspond
to DOM Attr Nodes.
If the DTM parent had no children, this becomes its first child.
Deal with the difference between Namespace spec and XSLT
definitions of local name. (The former says PIs don't have
localnames; the latter says they do.)
Hack to make DOM1 sort of work...
%TBD% Nodes created with the old non-namespace-aware DOM
calls createElement() and createAttribute() will never have a
localname. That will cause their expandedNameID to be just the
nodeType... which will keep them from being matched
successfully by name. Since the DOM makes no promise that
those will participate in namespace processing, this is
officially accepted as Not Our Fault. But it might be nice to
issue a diagnostic message!
This should be done after m_exptype has been set, and probably should
always be the last thing we do
Non-recursive one-fetch-at-a-time depth-first traversal with
attribute/namespace nodes and white-space stripping.
keeping track of both at once is a trifle baroque but at least
we've avoided most of the special cases.
%REVIEW% Is this local copy Really Useful from a performance
point of view?  Or is this a false microoptimization?
Navigate DOM tree
Look down to first child.
%REVIEW% There's probably a more elegant way to skip
the doctype. (Just let it go and Suppress it?
Push DTM context -- except for children of Entity References,
which have no DTM equivalent and cause no DTM navigation.
Whitespace-handler context stacking
If that fails, look up and right (but not past root!)
Last node posted at this level had no more children
If it has _no_ children, we need to record that.
%REVIEW% There's probably a more elegant way to
skip the doctype. (Just let it go and Suppress it?
No next-sibling found. Pop the DOM.
%TBD% Should never arise, but I want to be sure of that...
Freeze right here!
The only parents in the DTM are Elements.  However,
the DOM could contain EntityReferences.  If we
encounter one, pop it _without_ popping DTM.
Nothing needs doing
Fix and pop DTM
Popping from an element
Popping from anything else
If it's an entity ref, advance past it.
%REVIEW% Should we let this out the door and just suppress it?
More work, but simpler code, more likely to be correct, and
it doesn't happen very often. We'd get rid of the loop too.
Did we run out of the tree?
Text needs some special handling:
DTM may skip whitespace. This is handled by the suppressNode flag, which
when true will keep the DTM node from being created.
DTM only directly records the first DOM node of any logically-contiguous
sequence. The lastTextNode value will be set to the last node in the
contiguous sequence, and -- AFTER the DTM addNode -- can be used to
advance next over this whole block. Should be simpler than special-casing
the above loop for "Was the logically-preceeding sibling a text node".
Finally, a DTM node should be considered a CDATASection only if all the
contiguous text it covers is CDATASections. The first Text should
force DTM to Text.
If filtering, initially assume we're going to suppress the node
Scan logically contiguous text (siblings, plus "flattening"
of entity reference boundaries).
Any Text node means DTM considers it all Text
Any non-whitespace in this sequence blocks whitespace
Special handling for PIs: Some DOMs represent the XML
Declaration as a PI. This is officially incorrect, per the DOM
spec, but is considered a "wrong but tolerable" temporary
workaround pending proper handling of these fields in DOM Level
3. We want to recognize and reject that case.
Inserting next. NOTE that we force the node type; for
coalesced Text, this records CDATASections adjacent to
ordinary Text as Text.
start with no previous sib
Process attributes _now_, rather than waiting.
Simpler control flow, makes NS cache available immediately.
addNode() will take care of switching it from
Attr to Namespace if necessary.
If the xml: prefix is explicitly declared
we don't need to synthesize one.
NOTE that XML Namespaces were not originally
defined as being namespace-aware (grrr), and
while the W3C is planning to fix this it's
safer for now to test the QName and trust the
parsers to prevent anyone from redefining the
reserved xmlns: prefix
Terminate list of attrs, and make sure they aren't
considered children of the element
if attrs exist
The DOM might not have an explicit declaration for the
implicit "xml:" prefix, but the XPath data model
requires that this appear as a Namespace Node so we
have to synthesize one. You can think of this as
being a default attribute defined by the XML
Namespaces spec rather than by the DTD.
Text postprocessing: Act on values stored above
%TBD% If nexttype was forced to TEXT, patch the DTM node
Advance the DOM cursor over contiguous text
Remember where we left off.
Is Node actually within the same document? If not, don't search!
This would be easier if m_root was always the Document node, but
we decided to allow wrapping a DTM around a subtree.
If node _is_ in m_root's tree, find its handle
%OPT% This check may be improved significantly when DOM
Level 3 nodeKey and relative-order tests become
We know this node; find its handle.
for ancestors of node
if node and m_root in same Document
%OPT% This is probably slower than it needs to be.
Assume that attributes immediately follow the element.
Assume this can not be null.
Should namespace nodes be retrievable DOM-style as attrs?
If not we need a separate function... which may be desirable
architecturally, but which is ugly from a code point of view.
(If we REALLY insist on it, this code should become a subroutine
of both -- retrieve the node, then test if the type matches
what you're looking for.)
if (DTM.NAMESPACE_NODE != type)
%TBD% If an element only has one text node, we should just use it
If this is a DTM text node, it may be made of multiple DOM text
nodes -- including navigating into Entity References. DOM2DTM
records the first node in the sequence and requires that we
pick up the others when we retrieve the DTM node's value.
%REVIEW% DOM Level 3 is expected to add a "whole text"
retrieval method which performs this function for us.
If this is a DTM text node, it may be made of multiple DOM text
nodes -- including navigating into Entity References. DOM2DTM
records the first node in the sequence and requires that we
pick up the others when we retrieve the DTM node's value.
%REVIEW% DOM Level 3 is expected to add a "whole text"
retrieval method which performs this function for us.
Never a child but might be our starting node
assume not null.
assume not null.
XSLT treats PIs, and possibly other things, as having QNames.
Match old default for this function
This conversion may or may not be necessary
assume not null.
assume not null.
assume not null.
assume not null.
%TBD% Handle DOM1?
Walk out of any EntityReferenceNodes that ended with text
Walk into any EntityReferenceNodes that start with text
Found a logical next sibling. Is it text?
The _type(nodeHandle) call was taking the lion's share of our
time, and was wrong anyway since it wasn't coverting handle to
identity. Inlined it.
If this is a DTM text node, it may be made of multiple DOM text
nodes -- including navigating into Entity References. DOM2DTM
records the first node in the sequence and requires that we
pick up the others when we retrieve the DTM node's value.
%REVIEW% DOM Level 3 is expected to add a "whole text"
retrieval method which performs this function for us.
then it's unparsed
The draft says: "The XSLT processor may use the public
identifier to generate a URI for the entity instead of the URI
specified in the system identifier. If the XSLT processor does
not use the public identifier to generate the URI, it must use
the system identifier; if the system identifier is a relative
URI, it must be resolved into an absolute URI using the URI of
the resource containing the entity declaration as the base
So I'm falling a bit short here.
This should be resolved to an absolute URL, but that's hard
to do from here.
========== Direct SAX Dispatch, for optimization purposes ========
Take the easy way out for now.
Text coalition -- a DTM text node may represent multiple
NOTE: Because this operation works in the DOM space, it does _not_ attempt
to perform Text Coalition. That should only be done in DTM space.
/* case Node.PROCESSING_INSTRUCTION_NODE :
Redundant - maintained for performance
delegate to this instance of DatatypeConverter
also indicate the print methods produce a lexical
representation for given Java datatypes.
dom ref must be below node index
dom ref must be below node index
Create a new instance of SingletonIterator
dom ref must be below node index
If the LocalVariableGen uses a slot index beyond any previously
encountered, expand the _variables, padding with intervening null
entries as required.
If the LocalVariableGen reuses a slot, make sure the entry
in _variables contains an ArrayList and add the newly
registered LocalVariableGen to the list.  If the entry in
_variables just contains null padding, store the
If this slot index was never used, _variables.get will return
more than once it will return an ArrayList of all the
LocalVariableGens for variables stored in that slot.  For each
LocalVariableGen, check whether its range includes the
specified offset, and return the first such encountered.
No local variable stored in the specified slot at the specified
If no start handle is recorded for the LocalVariableGen, it is
assumed to be in use from the beginning of the method.
If no end handle is recorded for the LocalVariableGen, it is assumed
to be in use to the end of the method.
Does the range of the instruction include the specified offset?
Note that the InstructionHandle.getPosition method returns the
offset of the beginning of an instruction.  A LocalVariableGen's
range includes the end instruction itself, so that instruction's
length must be taken into consideration in computing whether the
varible is in range at a particular offset.
Get the current number of local variable slots
Get numer of actual variables
We want at least 5 local variable slots (for parameters)
Scan instructions in the method, keeping track of the nesting level
of outlineable chunks.
keeps track of the child chunks of a chunk.  For each chunk,
there will be a pair of entries:  the InstructionHandles for the
start and for the end of the chunk
a stack containing the partially accumulated currLevelChunks for
each chunk that's still open at the current position in the
the list of chunks which have been accepted as candidates chunks
Get the next instruction.  The loop will perform one extra
iteration after it reaches the end of the InstructionList, with
currentHandle set to null.
At the first iteration, create a chunk representing all the
code in the method.  This is done just to simplify the logic -
this chunk can never be outlined because it will be too big.
Found a new chunk
If last MarkerInstruction encountered was an
OutlineableChunkStart, this represents the first chunk
nested within that previous chunk - push the list of chunks
from the outer level onto the stack
Close off an open chunk
If the last MarkerInstruction encountered was an
OutlineableChunkEnd, it means that the current instruction
marks the end of a chunk that contained child chunks.
Those children might need to be examined below in case they
are better candidates for outlining than the current chunk.
Get the handle for the start of this chunk (the last entry
Two ranges of chunk size to consider:
Keep this chunk in consideration as a candidate,
and ignore its subchunks, if any - there's nothing to be
gained by outlining both the current chunk and its
Ignore this chunk - it's too big.  Add its subchunks
as candidates, after merging adjacent chunks to produce
chunks that are as large as possible
Gather all the child chunks of the current chunk
Merge adjacent siblings
Add chunks that mean minimum size requirements
to the list of candidate chunks for outlining
Drop the chunk which was too big
currLevelChunks contains pairs of InstructionHandles.  If
its size is an odd number, the loop has encountered the
start of a chunk at this level, but not its end.
Loop through chunks, and record in adjacencyRunStart where each
run of adjacent chunks begins and how many are in that run.  For
example, given chunks A B C D E F, if A is adjacent to B, but not
to C, and C, D, E and F are all adjacent,
adjacencyRunStart[0] == 0; adjacencyRunLength[0] == 2
adjacencyRunStart[1] == 2; adjacencyRunLength[1] == 4
Track the longest run of chunks found
Track the longest run of chunks found
Try merging adjacent chunks to come up with better sized chunks for
outlining.  This algorithm is not optimal, but it should be
reasonably fast.  Consider an example like this, where four chunks
of the sizes specified in brackets are adjacent.  The best way of
combining these chunks would be to merge the first pair and merge
the last three to form two chunks, but the algorithm will merge the
three in the middle instead, leaving three chunks in all.
[25000] [25000] [20000] [1000] [20000]
Start by trying to merge the maximum number of adjacent chunks, and
work down from there.
Look at each run of adjacent chunks
Within the current run of adjacent chunks, look at all
"subruns" of length numToMerge, until we run out or find
a subrun that can be merged.
Find out how big the subrun is
If the current subrun is small enough to outline,
merge it, and split the remaining chunks in the run
Adjust the length of the current run of adjacent
chunks to end at the newly merged chunk...
and any chunks that follow the newly merged chunk
in the current run of adjacent chunks form another
new run of adjacent chunks
Make a final pass for any chunk that wasn't merged with a sibling
and include it in the list of chunks after merging.
Special handling for initialization methods.  No other methods can
include the less than and greater than characters in their names,
so we munge the names here.
Loop until the original method comes in under the JVM limit or
the loop was unable to outline any more methods
Get all the best candidates for outlining, and sort them in
ascending order of size
Loop over the candidates for outlining, from the largest to the
smallest and outline them one at a time, until the loop has
outlined all or the original method comes in under the JVM
limit on the size of a method.
Check the size of the method now
Outlining failed to reduce the size of the current method
sufficiently.  Throw an internal error.
We're not equipped to deal with exception handlers yet.  Bail out!
Create new outlined method with signature:
CopyLocals is an object that is used to copy-in/copy-out local
variables that are used by the outlined method.   Only locals whose
value is potentially set or referenced outside the range of the
chunk that is being outlined will be represented in CopyLocals.  The
type of the variable for copying local variables is actually
generated to be unique - it is not named CopyLocals.
The outlined method never needs to be referenced outside of this
class, and will never be overridden, so we mark it private final.
Create class for copying local variables to the outlined method.
The fields the class will need to contain will be determined as the
code in the outlineable chunk is examined.
Number of fields in the copy class
The handle for the instruction after the last one to be outlined.
Note that this should never end up being null.  An outlineable chunk
won't contain a RETURN instruction or other branch out of the chunk,
and the JVM specification prohibits code in a method from just
"falling off the end" so this should always point to a valid handle.
InstructionLists for copying values into and out of an instance of
oldMethCoypInIL  - from locals in old method into an instance
of the CopyLocals class (oldMethCopyInIL)
oldMethCopyOutIL - from CopyLocals back into locals in the old
newMethCopyInIL  - from CopyLocals into locals in the new
newMethCopyOutIL - from locals in new method into the instance
of the CopyLocals class
Allocate instance of class in which we'll copy in or copy out locals
other two are used for references to fields in the CopyLocals object
Generate code to invoke the new outlined method, and place the code
Used to keep track of the first in a sequence of
Used to keep track of the last instruction that was copied
Keeps track of the mapping from instruction handles in the old
method to instruction handles in the outlined method.  Only need
to track instructions that are targeted by something else in the
Keeps track of the mapping from local variables in the old method
to local variables in the outlined method.
Pass 1: Make copies of all instructions, append them to the new list
and associate old instruction references with the new ones, i.e.,
a 1:1 mapping.  The special marker instructions are not copied.
Also, identify local variables whose values need to be copied into or
out of the new outlined method, and builds up targetMap and
localVarMap as described above.  The code identifies those local
variables first so that they can have fixed slots in the stack
frame for the outlined method assigned them ahead of all those
variables that don't need to exist for the entirety of the outlined
MarkerInstructions are not copied, so if something else targets
one, the targetMap will point to the nearest copied sibling
InstructionHandle:  for an OutlineableChunkEnd, the nearest
preceding sibling; for an OutlineableChunkStart, the nearest
Copy the instruction and append it to the outlined method's
Use clone for shallow copy
For any instruction that touches a local variable,
check whether the local variable's value needs to be
copied into or out of the outlined method.  If so,
generate the code to perform the necessary copying, and
use localVarMap to map the variable in the original
method to the variable in the new method.
Has the code already mapped this local variable to a
local in the new method?
Determine whether the local variable needs to be
copied into or out of the outlined by checking
whether the range of instructions in which the
variable is accessible is outside the range of
instructions in the outlineable chunk.
Special case a chunk start offset of zero:  a local
variable live at that position must be a method
parameter, so the code doesn't need to check whether
the variable is live before that point; being live
at offset zero is sufficient to know that the value
must be copied in to the outlined method.
For any variable that needs to be copied into or out
of the outlined method, create a field in the
CopyLocals class, and generate the necessary code for
copying the value.
Record the mapping from the old local to the new
Generate code for the old method to store the
value of the local into the correct field in
CopyLocals prior to invocation of the
If the end of the live range of the old
variable was in the middle of the outlined
chunk.  Make the load of its value the new
end of its range.
Generate code for start of the outlined
method to copy the value from a field in
CopyLocals to the new local in the outlined
Generate code for the end of the outlined
method to copy the value from the new local
variable into a field in CopyLocals
Generate code to copy the value from a field
in CopyLocals into a local in the original
method following invocation of the outlined
If the start of the live range of the old
variable was in the middle of the outlined
chunk.  Make this store into it the new start
of its range.
If this is the first instruction copied following a sequence
of OutlineableChunkStart instructions, indicate that the
sequence of old instruction all map to this newly created
Pass 2: Walk old and new instruction lists, updating branch targets
and local variable references in the new list
i == old instruction; c == copied instruction
New target must be in targetMap
Handle LOOKUPSWITCH or TABLESWITCH which may have many
Update all targets
For any instruction that touches a local variable,
map the location of the variable in the original
method to its location in the new method.
Create new variable based on old variable - use same
name and type, but we will let the variable be active
for the entire outlined method.
The old variable's live range was wholly contained in
the outlined chunk.  There should no longer be stores
of values into it or loads of its value, so we can just
mark its live range as the reference to the outlined
If the old instruction marks the end of the range of a local
variable, make sure that any slots on the stack reserved for
local variables are made available for reuse by calling
If the current instruction in the original list was a marker,
it wasn't copied, so don't advance through the list of copied
POP the reference to the CopyLocals object from the stack
Now that the generation of the outlined code is complete, update
the old local variables with new start and end ranges, as required.
Assemble the instruction lists so that the old method invokes the
new outlined method
Insert the copying code into the outlined method
Discard instructions in outlineable chunk from old method
If there were still references to old instructions lingering,
clean those up.  The only instructions targetting the deleted
instructions should have been part of the chunk that was just
deleted, except that instructions might branch to the start of
the outlined chunk; similarly, all the live ranges of local
variables should have been adjusted, except for unreferenced
In the case of any lingering variable references,
just make the live range point to the outlined
function reference.  Such variables should be unused
Make a copy for the new method of all exceptions that might be thrown
Need to look for any branch target offsets that exceed the range
If any branch instructions needed widening, recompute the size
of the byte code for the method
Loop through all the instructions, finding those that would be
affected by inserting new instructions in the InstructionList, and
calculating the maximum amount by which the relative offset between
two instructions could possibly change.
In part this loop duplicates code in
org.apache.bcel.generic.InstructionList.setPosition(), which does
this to determine whether to use 16-bit or 32-bit offsets for GOTO
and JSR instructions.  Ideally, that method would do the same for
conditional branch instructions, but it doesn't, so we duplicate the
Instructions that may have 16-bit or 32-bit branch targets.
The size of the branch offset might increase by two bytes.
Instructions that contain padding for alignment purposes
Up to three bytes of padding might be needed.  For greater
accuracy, we should be able to discount any padding already
added to these instructions by InstructionList.setPosition(),
their APIs do not expose that information.
Instructions that might be rewritten by this method as a
conditional branch followed by an unconditional branch.
The unconditional branch would require five bytes.
Now that the maximum number of bytes by which the method might grow
has been determined, look for conditional branches to see which
might possibly exceed the 16-bit relative offset.
Consider the worst case scenario in which the conditional
branch and its target are separated by all the instructions
in the method that might increase in size.  If that results
in a relative offset that cannot be represented as a 32-bit
signed quantity, rewrite the instruction as described above.
Invert the logic of the IF instruction, and append
that to the InstructionList following the original IF
Append an unconditional branch to the target of the
original IF instruction after the new IF instruction
If the original IF was the last instruction in
InstructionList, add a new no-op to act as the target
of the new IF
Make the new IF instruction branch around the GOTO
If anything still "points" to the old IF instruction,
make adjustments to refer to either the new IF or GOTO
Ideally, one should simply be able to use
InstructionTargeter.updateTarget to change
references to the old IF instruction to the new
IF instruction.  However, if a LocalVariableGen
indicated the old IF marked the end of the range
in which the IF variable is in use, the live
range of the variable must extend to include the
newly created GOTO instruction.  The need for
this sort of specific knowledge of an
implementor of the InstructionTargeter interface
makes the code more fragile.  Future implementors
of the interface might have similar requirements
which wouldn't be accommodated seemlessly.
This can never happen - we updated the list of
instructions that target the deleted instruction
prior to deleting it.
Adjust the pointer in the InstructionList to point after
the newly inserted IF instruction
Indicate that this method rewrote at least one IF
Did this method rewrite any IF instructions?
get only a single node as anchor to fetch the owner document
we output all Attrs which are available
included and inclusive
included and not inclusive
excluded and inclusive
excluded and not inclusive
Locator2Impl.java - extended LocatorImpl
Public Domain: no warranty.
$Id: Locator2Impl.java,v 1.2 2004/11/03 22:49:08 jsuttor Exp $
Locator2 method implementations
Adjust to proper size
Fits in one byte?
Applies for LDC_W
Create vector to hold int[] elements, each element being one range
parsed out of members.
Run state machine over members.
Before first integer in first group
In first integer in a group
After first integer in a group
Before second integer in a group
In second integer in a group
After second integer in a group
Before first integer in second or later group
Finish off the state machine.
Before first integer in first group
In first integer in a group
After first integer in a group
In second integer in a group
After second integer in a group
Before second integer in a group
Before first integer in second or later group
Return canonical array form.
Make sure range is non-null.
Stick range at the back of the vector.
Work towards the front of the vector to integrate the new range
with the existing ranges.
Get lower and upper bounds of the two ranges being compared.
The coalesced range is from the smaller lower bound to
the larger upper bound.
Create vector to hold int[] elements, each element being one range
parsed out of members.
Process all integer groups in members.
Get lower and upper bounds of the range.
Verify valid bounds.
Accumulate the range.
Return canonical array form.
Do a linear search to find the range that contains x, if any.
Do a linear search to find the range that contains x, if any.
SAX error handler.
No warranty; no copyright -- use this as you will.
$Id: ErrorHandler.java,v 1.2 2004/11/03 22:44:52 jsuttor Exp $
end of ErrorHandler.java
Message will be strange if mxbean is null but it is not
supposed to be.
add default recognized properties
configure DTD pipeline
configure XML document pipeline: insert after DTDValidator and
before XML Schema validator
we don't have to worry about fSchemaValidator being null, since
super.configurePipeline() instantiated it if the feature was set
Otherwise, insert after the last component in the pipeline
configure XML 1.1. DTD pipeline
configure XML document pipeline: insert after DTDValidator and
before XML Schema validator
we don't have to worry about fSchemaValidator being null, since
super.configurePipeline() instantiated it if the feature was set
Otherwise, insert after the last component in the pipeline
check if both reference the same object
/ Watch the values in getObjectForLayer()
Hashtable to store layer values for non-JComponent components
Container Override methods
New methods for managing layers
/ MAKE SURE THIS AND setLayer(Component c, int layer, int position)  are SYNCED
/ MAKE SURE THIS AND putLayer(JComponent c, int layer) are SYNCED
/ Short circut the counting when we have them all
/ Short circut the counting when we have them all
layer is greater than any current layer
[ ASSERT(layer > highestLayer()) ]
layer requested is lower than any current layer
[ ASSERT(layer < lowestLayer()) ]
put it on the bottom of the stack
In the case of a single layer entry handle the degenerative cases
If we are adding to the bottom, return the last element
Otherwise make sure the requested position falls in the
Otherwise return the end of the layer
The global LogManager object
'props' is assigned within a lock but accessed without it.
Declaring it volatile makes sure that another thread will not
be able to see a partially constructed 'props' object.
(seeing a partially constructed 'props' object can result in
NPE being thrown in Hashtable.get(), because it leaves the door
open for props.getProperties() to be called before the construcor
of Hashtable is actually completed).
The map of the registered listeners. The map value is the registration
count to allow for cases where the same listener is registered many times.
LoggerContext for system loggers and user loggers
non final field - make it volatile to make sure that other threads
will see the new value once ensureLogManagerInitialized() has finished
Have we done the primordial reading of the configuration file?
(Must be done after a suitable amount of java.lang.System
initialization has been done)
Have we initialized global (root) handlers yet?
This gets set to false in readConfiguration
True if JVM death is imminent and the exit hook has been called.
This private class is used as a shutdown hook.
It does a "reset" to close all open handlers.
This is to ensure the LogManager.<clinit> is completed
before synchronized block. Otherwise deadlocks are possible.
If the global handlers haven't been initialized yet, we
don't want to initialize them just so we can close them!
Note that death is imminent.
Do a reset to close all active handlers.
Add a shutdown hook to close the global handlers.
If the VM is already shutting down,
We do not need to register shutdownHook.
These permission will be checked in the LogManager constructor,
in order to register the Cleaner() thread as a shutdown hook.
Check them here to avoid the penalty of constructing the object
we don't want to do this twice, and we don't want to do
this on private manager instances.
Maybe another thread has called ensureLogManagerInitialized()
before us and is still executing it. If so we will block until
the log manager has finished initialized, then acquire the monitor,
notice that initializationDone is now true and return.
Otherwise - we have come here first! We will acquire the monitor,
see that initializationDone is still false, and perform the
If initializedCalled is true it means that we're already in
the process of initializing the LogManager in this thread.
There has been a recursive call to ensureLogManagerInitialized().
If isRecursiveInitialization is true it means that we're
already in the process of initializing the LogManager in
this thread. There has been a recursive call to
ensureLogManagerInitialized(). We should not proceed as
it would lead to infinite recursion.
If initializationDone is true then it means the manager
has finished initializing; just return: we're done.
Calling addLogger below will in turn call requiresDefaultLogger()
which will call ensureLogManagerInitialized().
We use initializedCalled to break the recursion.
Create and retain Logger for the root of the namespace.
Adding the global Logger.
Do not call Logger.getGlobal() here as this might trigger
subtle inter-dependency issues.
Make sure the global logger will be registered in the
If System.in/out/err are null, it's a good
indication that we're still in the
Platform loggers begin to delegate to java.util.logging.Logger
increment the registration count if already registered
remove from map if registration count is 1, otherwise
just decrement its count
LoggerContext maps from AppContext
Returns the LoggerContext for the user code (i.e. application or AppContext).
Loggers are isolated from each AppContext.
for each applet, it has its own LoggerContext isolated from others
find the AppContext of the applet code
will be null if we are in the main app context.
Create a new LoggerContext for the applet.
for standalone app, return userContext
The system context.
Find or create a specified logger instance. If a logger has
already been created with the given name it is returned.
Otherwise a new logger instance is created and registered
in the LogManager global namespace.
This method will always return a non-null Logger object.
Synchronization is not required here. All synchronization for
adding a new Logger object is handled by addLogger().
This method must delegate to the LogManager implementation to
add a new Logger or return the one that has been added previously
as a LogManager subclass may override the addLogger, getLogger,
readConfiguration, and other methods.
only allocate the new logger once
We successfully added the new Logger that we
created above so return it without refetching.
We didn't add the new Logger that we created above
because another thread added a Logger with the same
name after our null check above and before our call
to addLogger(). We have to refetch the Logger because
addLogger() returns a boolean instead of the Logger
reference itself. However, if the thread that created
the other Logger is not holding a strong reference to
the other Logger, then it is possible for the other
Logger to be GC'ed after we saw it in addLogger() and
before we can refetch it. If it has been GC'ed then
we'll just loop around and try again.
Add a system logger in the system context's namespace
Add the system logger to the LogManager's namespace if not exist
so that there is only one single logger of the given name.
System loggers are visible to applications unless a logger of
the same name has been added.
First attempt to call addLogger instead of getLogger
This would avoid potential bug in custom LogManager.getLogger
implementation that adds a logger if does not exist
successfully added the new system logger
LogManager will set the sysLogger's handlers via LogManager.addLogger method.
if logger already exists but handlers not set
LoggerContext maintains the logger namespace per context.
The default LogManager implementation has one system context and user
context.  The system context is used to maintain the namespace for
all system loggers and is queried by the system code.  If a system logger
doesn't exist in the user context, it'll also be added to the user context.
The user context is queried by the user code and all other loggers are
added in the user context.
Table of named Loggers that maps names to Loggers.
Tree of named Loggers
Tells whether default loggers are required in this context.
If true, the default loggers will be lazily added.
This context's LogManager.
This context owner's root logger, which if not null, and if
the context requires default loggers, will be added to the context
The global logger, which if not null, and if
the context requires default loggers, will be added to the context
avoids initialization cycles.
a LogManager subclass may have its own implementation to add and
get a Logger.  So delegate to the LogManager to do the work.
Due to subtle deadlock issues getUserContext() no longer
Therefore - we need to add the default loggers later on.
Checks that the context is properly initialized
This is necessary before calling e.g. find(name)
Ensure that the root and global loggers are set.
ensure that this context is properly initialized before
looking for loggers.
Hashtable holds stale weak reference
to a logger which has been GC-ed.
This method is called before adding a logger to the
'logger' is the context that will be added.
This method will ensure that the defaults loggers are added
before adding 'logger'.
Used for lazy addition of root logger and global logger
to a LoggerContext.
This check is simple sanity: we do not want that this
method be called for anything else than Logger.global
the case where we have a non null logger which is neither
Logger.global nor manager.rootLogger indicates a serious
issue - as ensureDefaultLogger should never be called
with any other loggers than one of these two (or null - if
e.g manager.rootLogger is not yet initialized)...
Adds the logger if it's not already there.
It is important to prevent addLocalLogger to
call ensureAllDefaultLoggers when we're in the process
off adding one of those default loggers - as this would
immediately cause a stack overflow.
Therefore we must pass addDefaultLoggersIfNeeded=false,
even if requiresDefaultLoggers is true.
no need to add default loggers if it's not required
Add a logger to this context.  This method will only set its level
and process parent loggers.  It doesn't set its handlers.
addDefaultLoggersIfNeeded serves to break recursion when adding
default loggers. If we're adding one of the default loggers
(we're being called from ensureDefaultLogger()) then
addDefaultLoggersIfNeeded will be false: we don't want to
call ensureAllDefaultLoggers again.
Note: addDefaultLoggersIfNeeded can also be false when
requiresDefaultLoggers is false - since calling
ensureAllDefaultLoggers would have no effect in this case.
It's possible that the Logger was GC'ed after a
drainLoggerRefQueueBounded() call above so allow
a new one to be registered.
We already have a registered logger with the given name.
We're adding a new logger.
Note that we are creating a weak reference here.
Apply any initial level defined for the new logger, unless
the logger's level is already initialized
instantiation of the handler is done in the LogManager.addLogger
implementation as a handler class may be only visible to LogManager
subclass for the custom log manager case
Find the new node and its parent.
Walk over the children and tell them we are their new parent.
new LogNode is ready so tell the LoggerWeakRef about it
ensure that this context is properly initialized before
returning logger names.
If logger.getUseParentHandlers() returns 'true' and any of the logger's
parents have levels or handlers defined, make sure they are instantiated.
This pname has a level/handlers definition.
Make sure it exists.
Gets a node in our tree of logger nodes.
If necessary, create it.
Add a system logger in the system context's namespace as well as
in the LogManager's namespace if not exist so that there is only
one single logger of the given name.  System loggers are visible
to applications unless a logger of the same name has been added.
only allocate the new system logger once
We successfully added the new Logger that we
created above so return it without refetching.
We didn't add the new Logger that we created above
because another thread added a Logger with the same
name after our null check above and before our call
to addLogger(). We have to refetch the Logger because
addLogger() returns a boolean instead of the Logger
reference itself. However, if the thread that created
the other Logger is not holding a strong reference to
the other Logger, then it is possible for the other
Logger to be GC'ed after we saw it in addLogger() and
before we can refetch it. If it has been GC'ed then
we'll just loop around and try again.
Add new per logger handlers.
We need to raise privilege here. All our decisions will
be made based on the logging configuration, which can
only be modified by trusted code.
Check if there is a property defining the
this handler's level.
Probably a bad level. Drop through.
Add this Handler to the logger
loggerRefQueue holds LoggerWeakRef objects for Logger objects
that have been GC'ed.
Package-level inner class.
Helper class for managing WeakReferences to Logger objects.
- has weak references to all named Loggers
- namedLoggers keeps the LoggerWeakRef objects for the named
Loggers around until we can deal with the book keeping for
the named Logger that is being GC'ed.
- has a weak reference to a named Logger
- the LogNode will also keep the LoggerWeakRef objects for
the named Loggers around; currently LogNodes never go away.
- has a weak reference to each direct child Logger; this
includes anonymous and named Loggers
- anonymous Loggers are always children of the rootLogger
which is a strong reference; rootLogger.kids keeps the
LoggerWeakRef objects for the anonymous Loggers around
until we can deal with the book keeping.
for namedLoggers cleanup
for loggerRef cleanup
for kids cleanup
avoid calling dispose twice
save for namedLoggers cleanup
dispose of this LoggerWeakRef object
Avoid calling dispose twice. When a Logger is gc'ed, its
LoggerWeakRef will be enqueued.
However, a new logger of the same name may be added (or looked
up) before the queue is drained. When that happens, dispose()
will be called by addLocalLogger() or findLogger().
Later when the queue is drained, dispose() will be called again
for the same LoggerWeakRef. Marking LoggerWeakRef as disposed
avoids processing the data twice (even though the code should
now be reentrant).
Note to maintainers:
Be careful not to call any method that tries to acquire
another lock from within this block - as this would surely
lead to deadlocks, given that dispose() can be called by
multiple threads, and from within different synchronized
n.loggerRef can only be safely modified from within
a lock on LoggerContext. removeLoggerRef is already
synchronized on LoggerContext so calling
n.context.removeLoggerRef from within this lock is safe.
if we have a LogNode, then we were a named Logger
so clear namedLoggers weak ref to us
clear our ref to the Logger's name
LogNode may have been reused - so only clear
LogNode.loggerRef if LogNode.loggerRef == this
clear LogNode's weak ref to us
clear our ref to LogNode
this LoggerWeakRef has or had a parent Logger
the parent Logger is still there so clear the
parent Logger's weak ref to us
clear our weak ref to the parent Logger
set the node field to the specified value
set the parentRef field to the specified value
Drain some Logger objects that have been GC'ed.
drainLoggerRefQueueBounded() is called by addLogger() below
and by Logger.getAnonymousLogger(String) so we'll drain up to
MAX_ITERATIONS GC'ed Loggers for every Logger we add.
On a WinXP VMware client, a MAX_ITERATIONS value of 400 gives
us about a 50/50 mix in increased weak ref counts versus
decreased weak ref counts in the AnonLoggerWeakRefLeak test.
Here are stats for cleaning up sets of 400 anonymous Loggers:
- test duration 1 minute
- sample size of 125 sets of 400
- average: 1.99 ms
- minimum: 0.57 ms
- maximum: 25.3 ms
The same config gives us a better decreased weak ref count
than increased weak ref count in the LoggerWeakRefLeak test.
Here are stats for cleaning up sets of 400 named Loggers:
- test duration 2 minutes
- sample size of 506 sets of 400
- average: 0.57 ms
- minimum: 0.02 ms
- maximum: 10.9 ms
haven't finished loading LogManager yet
a Logger object has been GC'ed so clean it up
Do we have a per logger handler too?
Note: this will add a 200ms penalty
Private method to set a level on a logger.
If necessary, we raise privilege before doing the call.
There is no security manager, so things are easy.
There is a security manager.  Raise privilege before
Private method to set a parent on a logger.
If necessary, we raise privilege before doing the setParent call.
There is no security manager, so things are easy.
There is a security manager.  Raise privilege before
if a configuration class is specified, load it and use it.
Instantiate the named class.  It is its constructor's
responsibility to initialize the logging configuration, by
calling readConfiguration(InputStream) with a suitable stream.
keep going and useful config file.
Since we are doing a reset we no longer want to initialize
the global handlers, if they haven't been initialized yet.
Private method to reset an individual target logger.
Close all the Logger's handlers.
Problems closing a handler?  Keep going...
This is the root logger.
get a list of whitespace separated classnames from a property.
Load the properties
Instantiate new configuration objects.
Set levels on any pre-existing loggers, based on the new properties.
Notify any interested parties that our properties have changed.
We first take a copy of the listener map so that we aren't holding any
locks when calling the listeners.
Note that we need to reinitialize global handles when
they are first referenced.
Package private method to get a String property.
If the property is not defined we return the given
Package private method to get an integer property.
If the property is not defined or cannot be parsed
we return the given default value.
Package private method to get a boolean property.
If the property is not defined or cannot be parsed
we return the given default value.
Package private method to get a Level property.
If the property is not defined or cannot be parsed
we return the given default value.
Package private method to get a filter property.
We return an instance of the class named by the "name"
property. If the property is not defined or has problems
we return the defaultValue.
We got one of a variety of exceptions in creating the
class or creating an instance.
We got an exception.  Return the defaultValue.
Package private method to get a formatter property.
We return an instance of the class named by the "name"
property. If the property is not defined or has problems
we return the defaultValue.
We got one of a variety of exceptions in creating the
class or creating an instance.
We got an exception.  Return the defaultValue.
Private method to load the global handlers.
We do the real work lazily, when the global handlers
are first used.
The VM is shutting down and our exit hook has been called.
Avoid allocating global handlers.
Nested class to represent a node in our tree of named loggers.
Recursive method to walk the tree below a node and set
a new parent logger.
We use a subclass of Logger for the root logger, so
that we only instantiate the global handlers when they
are first needed.
We do not call the protected Logger two args constructor here,
to avoid calling LogManager.getLogManager() from within the
Make sure that the global handlers have been instantiated.
Private method to be called when the configuration has
changed to apply any level settings to any pre-existing loggers.
Not a level definition.
same as ISO:
DAY_OF_WEEK, DAY_OF_MONTH, EPOCH_DAY, MONTH_OF_YEAR, PROLEPTIC_MONTH, YEAR
calendar specific fields
DAY_OF_YEAR, YEAR_OF_ERA, ERA
getLong() validates for supported fields
YEAR, PROLEPTIC_MONTH and others are same as ISO
for javadoc and covariant return type
override for performance
override for performance
override for performance
JapaneseChronology is implicit in the JAPANESE_DATE_TYPE
This file was generated AUTOMATICALLY from a template file Fri Jul 21 22:00:53 PDT 2017
map the offset overflow chars
map the titlecase chars with both a 1:M uppercase map
and a lowercase map
default mapChar is already set, so no
need to redo it here.
map chars with overflow offsets
map char that have both a 1:1 and 1:M map
ch must have a 1:M case mapping, but we
can't handle it here. Return ch.
since mapChar is already set, no need
to redo it here.
There is a titlecase equivalent.  Perform further checks:
The character does not have an uppercase equivalent, so it must
already be uppercase; so add 1 to get the titlecase form.
The character does not have a lowercase equivalent, so it must
already be lowercase; so subtract 1 to get the titlecase form.
The character has both an uppercase equivalent and a lowercase
equivalent, so it must itself be a titlecase form; return it.
This character has no titlecase equivalent but it does have an
uppercase equivalent, so use that (subtract the signed case offset).
Java supradecimal digit
TAMIL NUMBER ONE HUNDRED
TAMIL NUMBER ONE THOUSAND
ETHIOPIC NUMBER FORTY
ETHIOPIC NUMBER FIFTY
ETHIOPIC NUMBER SIXTY
ETHIOPIC NUMBER SEVENTY
ETHIOPIC NUMBER EIGHTY
ETHIOPIC NUMBER NINETY
ETHIOPIC NUMBER HUNDRED
ETHIOPIC NUMBER TEN THOUSAND
FRACTION NUMERATOR ONE
ROMAN NUMERAL FIFTY
ROMAN NUMERAL ONE HUNDRED
ROMAN NUMERAL FIVE HUNDRED
ROMAN NUMERAL ONE THOUSAND
SMALL ROMAN NUMERAL FIFTY
SMALL ROMAN NUMERAL ONE HUNDRED
SMALL ROMAN NUMERAL FIVE HUNDRED
SMALL ROMAN NUMERAL ONE THOUSAND
ROMAN NUMERAL ONE THOUSAND C D
ROMAN NUMERAL FIVE THOUSAND
ROMAN NUMERAL TEN THOUSAND
CIRCLED NUMBER THIRTY THREE
CIRCLED NUMBER THIRTY FOUR
CIRCLED NUMBER THIRTY FIVE
CIRCLED NUMBER THIRTY SIX
CIRCLED NUMBER THIRTY SEVEN
CIRCLED NUMBER THIRTY EIGHT
CIRCLED NUMBER THIRTY NINE
CIRCLED NUMBER FORTY
CIRCLED NUMBER FORTY ONE
CIRCLED NUMBER FORTY TWO
CIRCLED NUMBER FORTY THREE
CIRCLED NUMBER FORTY FOUR
CIRCLED NUMBER FORTY FIVE
CIRCLED NUMBER FORTY SIX
CIRCLED NUMBER FORTY SEVEN
CIRCLED NUMBER FORTY EIGHT
CIRCLED NUMBER FORTY NINE
CIRCLED NUMBER FIFTY
MALAYALAM NUMBER ONE HUNDRED
MALAYALAM NUMBER ONE THOUSAND
ROMAN NUMERAL FIFTY EARLY FORM
ROMAN NUMERAL FIFTY THOUSAND
ROMAN NUMERAL ONE HUNDRED THOUSAND
This is the only char with LRE
This is the only char with RLE
This is the only char with PDF
This is the only char with LRO
This is the only char with RLO
map overflow characters
invariant: top > current >= bottom && ch >= CharacterData.charMap[bottom][0]
The following tables and code generated using:
java GenerateCharacter -plane 0 -template c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/jdk/make/data/characterdata/CharacterData00.java.template -spec c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/jdk/make/data/unicodedata/UnicodeData.txt -specialcasing c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/jdk/make/data/unicodedata/SpecialCasing.txt -proplist c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/jdk/make/data/unicodedata/PropList.txt -o c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u144/9417/build/windows-amd64/jdk/gensrc/java/lang/CharacterData00.java -string -usecharforbyte 11 4 1
The X table has 2048 entries for a total of 4096 bytes.
The Y table has 5664 entries for a total of 11328 bytes.
The A table has 930 entries for a total of 3720 bytes.
The B table has 930 entries for a total of 1860 bytes.
In all, the character property tables require 19144 bytes.
THIS CODE WAS AUTOMATICALLY CREATED BY GenerateCharacter:
Message keys used by the serializer
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The localname is the portion after the optional colon; the message indicates
that there is a problem with that part of the QNAME.
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The prefix is the portion before the optional colon; the message indicates
that there is a problem with that part of the QNAME.
A thread used to execute jobs
protected or private variables
Used to ensure that each spun class name is unique
For dumping generated classes to disk, for debugging purposes
See context values in AbstractValidatingLambdaMetafactory
Name of type containing implementation "CC"
Name of implementation method "impl"
Type descriptor for implementation methods "(I)Ljava/lang/String;"
class for implementaion method return type "Ljava/lang/String;"
Generated class constructor type "(CC)void"
ASM class writer
Generated names for the constructor arguments
Type descriptors for the constructor arguments
Generated name for the generated class "X$$Lambda$1"
The lambda implementing inner class constructor is private, set
it accessible (by us) before creating the constant sole instance
Assure no duplicate interfaces (ClassFormatError)
Generate final fields to be filled in by constructor
Forward the SAM method
Forward the bridges
Define the generated class in this VM.
If requested, dump out to a file for debugging purposes
createDirectories may need it
Maxs computed by ClassWriter.COMPUTE_MAXS, these arguments ignored
Maxs computed by ClassWriter.COMPUTE_MAXS, these arguments ignored
Invoke the method we want to forward to
Convert the return value (if any) and return it
Note: if adapting from non-void to void, the 'return'
instruction will pop the unneeded result
Maxs computed by ClassWriter.COMPUTE_MAXS,these arguments ignored
Find the maximum bit depth across all channels
Ensure bitDepth is between 1 and 16
Check number of bands, alpha
Fix 4464413: PNGTransparency reg-test was failing
because for IndexColorModels that have alpha,
numBands == 1 && hasAlpha == true, thus causing
the check below to fail and return false.
Methods for use only by StateEngineImpl.
coords array is big enough for holding:
coordinates returned from currentSegment (6)
two subdivided quadratic curves (2+4+4=10)
0-1 horizontal splitting parameters
2 parametric equation derivative coefficients
three subdivided cubic curves (2+6+6+6=20)
0-2 horizontal splitting parameters
3 parametric equation derivative coefficients
One might be able to prove that this is impossible...
First Order0 "moveto"
First point is always an order 0 curve (moveto)
REMIND: A *much* simpler operation should be possible...
Should be able to do a curve-wise comparison since all Areas
should evaluate their curves in the same top-down order.
REMIND: A simpler operation can be performed for some types
REMIND: Which is better, EVEN_ODD or NON_ZERO?
The paths calculated could be classified either way.
Need to finish off junction between curves
this.loader must not be null, or the newProxyInstance call
read and discard the repository ID
write the repository ID
format string for printing the log record
A new ORB started server registers itself with the Activator
Install a particular kind of endpoint
list active servers
If the server is not running, start it up.
If the server is running, shut it down
currently running, this method will activate it.
list all registered ORBs for a server
After this hook completes, the server may still be running.
serialVersionUID is not constant
Serialization compatibility stuff:
Two serial forms are supported in this class. The selected form depends
on system property "jmx.serial.form":
- "1.0" for JMX 1.0
- any other value for JMX 1.1 and higher
Serial version for old serial form
Serial version for new serial form
OK: exception means no compat with 1.0, too bad
Get the class of the object
check input arguments
gradient center/focal point is the center of the bounding box,
radius is set to 1.0, and then we set a scale transform
to achieve an elliptical gradient defined by the bounding box
avoid modifying the user's transform...
incorporate the gradient transform
Background color for unselected tabs that don't have an explicitly
Whether or not we're using ocean. This is cached as it is used
extensively during painting.
Selected border color for ocean.
last tab in run
not the first tab in the last run
the first tab in the last run
last tab in run
not the first tab in the last run
the first tab in the last run
paint highlight in the gap on tab behind this one
on the left end (where they all line up)
first tab in run but not first tab in last run
tab in front of selected tab
tab in front of normal tab
last tab in run
If it's the second to last row.
is the right edge of the last tab to the right
of the left edge of the current tab?
is the left edge of the last tab to the left
of the right edge of the current tab?
fill in gap for all other rows except last row
Check each tab in the row that is 'on top' of this row
Check to see if this tab is over the gap
Paint part of the tab above
last tab in run
not the first tab in the last run
the first tab in the last run
paint highlight in the gap on tab behind this one
on the left end (where they all line up)
first tab in run but not first tab in last run
tab in front of selected tab
tab in front of normal tab
last tab in run
Paint part of the tab above
Paint the background for the tab area
last tab in run
last tab in run
Draw unbroken line if tabs are not on TOP, OR
selected tab is not in run adjacent to content, OR
selected tab is not visible (SCROLL_TAB_LAYOUT)
Break line to show visual connection to selected tab
Draw unbroken line if tabs are not on BOTTOM, OR
selected tab is not in run adjacent to content, OR
selected tab is not visible (SCROLL_TAB_LAYOUT)
Break line to show visual connection to selected tab
Draw unbroken line if tabs are not on LEFT, OR
selected tab is not in run adjacent to content, OR
selected tab is not visible (SCROLL_TAB_LAYOUT)
Break line to show visual connection to selected tab
Draw unbroken line if tabs are not on RIGHT, OR
selected tab is not in run adjacent to content, OR
selected tab is not visible (SCROLL_TAB_LAYOUT)
Break line to show visual connection to selected tab
Tab runs laid out vertically should overlap
at least as much as the largest slant
Don't rotate runs!
Don't pad last run
Only normalize the runs for top & bottom;  normalizing
doesn't look right for Metal's vertical tabs
because the last run isn't padded and it looks odd to have
fat tabs in the first vertical runs, but slimmer ones in the
last (this effect isn't noticeable for horizontal tabs).
Don't rotate runs!
Don't pad selected tab
Shortcut for literal strings
If the content is literal text, call comment(char[],int,int) or
comment(String), as appropriate.  Otherwise, use a
StringValueHandler to gather the textual content of the xsl:comment
and call comment(String) with the result.
Save the current handler base on the stack
first arg to "comment" call
Get the translet's StringValueHandler
translate contents with substituted handler
get String out of the handler
Restore old handler base from stack
Slow but space conservative.
Basic type or reference
Using two strings so that package renaming doesn't change it
Running on Java SE 5
TODO: This is only used in EmbeddedFrame, and should probably be moved
into an EmbeddedFramePeer which would extend FramePeer
TODO: This is only used in EmbeddedFrame, and should probably be moved
into an EmbeddedFramePeer which would extend FramePeer
override for Javadoc
Check for null parameter
Check for non-RoleUnresolved objects
Build the List<RoleUnresolved>
Offset by the margins so that pref/min/max return the
Offset by the margins so that pref/min/max return the
check for percentage span
bound the span to the percentage specified
assign the offset and span for the child
can't make the child this wide, align it
make it the target width, or as small as it can get.
Reset the painter
Get the width/height
-- This file was mechanically generated: Do not edit! --
These fields are declared here rather than in Heap-X-Buffer in order to
reduce the number of virtual method invocations needed to access these
values, which is especially costly when coding small buffers.
Non-null only for heap buffers
Valid only for heap buffers
Creates a new buffer with the given mark, position, limit, capacity,
backing array, and array offset
Creates a new buffer with the given mark, position, limit, and capacity
-- Singleton get/put methods --
-- Bulk get operations --
-- Bulk put operations --
-- Other stuff --
-- Other char stuff --
-- Other byte stuff: Access to binary data --
Don't draw anything...
For each array:
point = (x + v0 * w + v1 * arcWidth,
length of a binary type is the number of bytes
Create an LdapName object from a string distinguished name.
This is only necessary for the pi.clientrequestinfo test.
It tests that request ids are different.
Rather than rewrite the test, just fake it.
REVISIT - use registry
Called when client making an invocation.
End of file.
Creating the model this way is a bit simplistic, but
I believe that it is the the most common usage of this
component - it's what people will expect.
documented with set/getOrientation()
documented with is/setBorderPainted()
PENDING: specify that string not painted when in indeterminate mode?
or just leave that to the L&F?
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
PENDING(???) setting the same model to multiple bars is broken; listeners
TIGER - 4422362
Type-specific CORBA::Object operations
Create the model
inner class AccessibleJButton
There may be duplicate prefixes in the list so we
first transfer them to a set to ensure uniqueness.
extend the array, if necessary
Create a copy, don't share the array
ignore factory information
these types are not passed back to peer
event type cannot be consumed
These fields may receive context content if this was relative URL
This field has already been parsed
FIX: should not assume query if opaque
Strip off the query part
Parse the authority part if any
more than one '@' in authority. This is not server based
If the host is surrounded by [ and ] then its an IPv6
literal address as specified in RFC2732
port can be null according to RFC2396
port can be null according to RFC2396
If the authority is defined then the path is defined by the
spec only; See RFC 2396 Section 5.2.4.
Parse the file path if any
Remove embedded /./
Remove embedded /../ if possible
Remove trailing .. if possible
Remove starting .
Remove trailing .
Generate the protocol part.
Generate the host part.
Generate the file part.
Generate the port part.
Generate the ref part.
Compare the protocols.
Compare the files.
Compare the ports.
Compare the hosts.
if we have internet address for both, compare them
else, if both have host names, compare them
pre-compute length of StringBuffer
ensure that no one can reset the protocol on a given URL.
All NEO service contexts must be in the range
NEO_FIRST_SERVICE_CONTEXT + NUM_NEO_SERVICE_CONTEXTS - 1
Tagged Components Ids
Used by AS 7 for IIOP failover.
Used by AS 8.1 for Request Partioning
TaggedComponentId for Java serialization tagged component.
Service Context Ids
Used by AS 7 for IIOP failover.
All Sun policies are allocated using the SUNVMCID, which is also
used for minor codes.  This allows 12 bits of offset, so
the largest legal Sun policy is SUNVMCID.value + 4095.
These are the subcontract IDs for various qualities of
Persistent SCIDs have the second bit as 1.
SCIDs less than FIRST_POA_SCID are JavaIDL SCIDs.
Constants for ORB properties **************************************************************
All ORB properties must follow the following rules:
1. Property names must start with either
ORG_OMG_CORBA_PREFIX or SUN_PREFIX.
2. Property names must have unique suffixes after the last ".".
3. Property names must have "ORB" as the first 3 letters
in their suffix.
4. proprietary property names should have a subsystem
where appropriate after the prefix.
org.omg.CORBA properties must be defined by OMG standards
The well known org.omg.CORBA.ORBClass and
org.omg.CORBA.ORBSingletonClass are not included here
since they occur in org.omg.CORBA.ORB.
All of our proprietary properties must start with com.sun.CORBA
This property is provided for backward compatibility reasons
Property for setting use of repository Ids during serialization.
NOTE: This is an internal property.  It should never be set by
a user.  That is the reason it has spaces in its name - to make it
harder to use.
giop related properties - default settings in decimal form
object key used for target addressing
iop profile used for target addressing
ior used for target addressing
accept all target addressing dispositions (default)
CORBA formal 00-11-03 sections 15.4.2.2, 15.4.3.2, 15.4.6.2
state that the GIOP 1.2 RequestMessage, ReplyMessage, and
LocateReply message bodies must begin on 8 byte boundaries.
The GIOP 1.2 fragments must be divisible by 8.  We generalize this
to GIOP 1.1 fragments, as well.
connection management properties
Request partitioning maximum and minimum thread pool id constants.
transport read tcp timeout property, colon separated property
with syntax <initial time to wait:max read giop header time to
wait: max read message time to wait:backoff factor>
initial time to wait in milliseconds if a transport
tcp read returns 0 bytes
max time to spend in cumulative waits in milliseconds
if a transport tcp read returns 0 bytes
max time to spend in cumulative waits in milliseconds
if a transport tcp read of GIOP header returns 0 bytes
A backoff percentage used to compute the next amount of time to
wait on a subsequent transport tcp read of 0 bytes
"Socket" | "SocketChannel"
Note: Connections accepted by SocketChannel will be SocketChannel.
Applicable if using SocketChannel and using select thread.
Applicable on client-side. "Socket" | "SocketChannel"
Applicable if using SocketChannel and using select thread
Used to disable the use of direct byte buffers.  This enables much easier
debugging, because the contents of a direct byte buffer cannot be
viewed in most (all?) debuggers.
POA related policies
Server Properties; e.g. when properties passed to ORB activated
This one is an exception, but it may be externally visible
Necessary for package renaming to work correctly
Property for enabling ORB's use of Java serialization.
Constants for ORB prefixes **************************************************************
Constants for NameService properties ************************************
defines the default GIOP minor version to be 0.
Constants for INS properties ********************************************
GIOP Version number for validation of INS URL format addresses
Subcontract's differentiation using the TRANSIENT and PERSISTENT
Name Service Property.
Constants for ORBD properties ****************************************************************
These properties are never passed on ORB init: they are only passed to ORBD.
If RI is starting the NameService then they would indicate that by
passing the RI flag. That would start a Persistent Port to listen to
***************** Constants for Logging ****************
Constants for initial references *************************************************************
A large Number to make sure that other ServerIds doesn't collide
with NameServer Persistent Server Id
New for Portable Interceptors
Constants for ORBD DB ***********************************************************************
Constants for ThreadPool ********************************************************************
Default value for when inactive threads in the pool can stop running (ms)
Default name of the threadpool
Default name of the workqueue
Constants for minor code bases **************************************************************
This is the value that pre-Merlin Sun ORBs incorrectly used.  We preserve this
here for backwards compatibility, but note that the current ORB must never
create a BAD_PARAM system exception with this minor code.
Code Set related *******************************************************
If we don't always send the code set context, there's a possibility
of failure when fragments of a smaller request are interleved with
those of a first request with other large service contexts.
Use byte order markers in streams when applicable?  This won't apply to
GIOP 1.1 due to limitations in the CDR encoding.
Use byte order markers in encapsulations when applicable?
The CHAR_CODESETS and WCHAR_CODESETS allow the user to override the default
connection code sets.  The value should be a comma separated list of OSF
registry numbers.  The first number in the list will be the native code
Number can be specified as hex if preceded by 0x, otherwise they are
interpreted as decimal.
Code sets that we accept currently (see core/OSFCodeSetRegistry):
ISO8859-1 (Latin-1)     0x00010001
ISO646 (ASCII)          0x00010020
Note:  The ORB will let you assign any of the above values to
either of the following properties, but the above assignments
are the only ones that won't get you into trouble.
Constants to make stream format version code easier to read
Reusable clip shape object
Ignore bad value
Cache frame geometries
These don't seem to apply here, but the Galaxy theme uses them. Not sure why.
System property may not be set so skip null directories.
Set userHome here because we need the privilege
Note: this is a small file (< 1024 bytes) so it's not worth
starting an XML parser or even to use a buffered reader.
Pending: verify character encoding spec for gconf
OK to just ignore. We'll use a fallback theme.
OK to just ignore. We'll use a fallback theme.
Assume all rgb values are shades of gray
Leave room for three characters in the title.
Get colors from child nodes
skip right paren
For each array:
point = (x + v0 * w + v1 * arcWidth,
Don't draw anything...
Add one for each corner that has a curve
Maps servants to POAs for deactivating servants when unexportObject is called.
Maintained by POAs activate_object and deactivate_object.
Implementation of ObjectAdapterFactory interface
It is important to copy the list of POAManagers first because
pm.deactivate removes itself from poaManagers!
Special methods used to manipulate global POA related state
We delay the evaluation of makeRootPOA until
a call to resolve_initial_references( "RootPOA" ).
The Future guarantees that makeRootPOA is only called once.
See if we are trying to getRootPOA while shutting down the ORB.
if null, ltr
x,y pairs for components in visual order
if null, ltr
if null, ltr
if null, 0
built on demand in getMetrics
first, we need to check for graphic components on the TOP or BOTTOM baselines.  So
we perform the work that used to be in getMetrics here.
ascent + descent must not be less than this value
walk through EGA's
we now know enough to compute the locs, but we need the final loc
for the advance before we can create the metrics object
we have top or bottom baselines, so expand the baselines array
full offsets are needed by CoreMetrics.effectiveBaselineOffset
adjust because of italics
1) compute the area of overlap - min effective ascent and min effective descent
2) compute the x positions along italic angle of ascent and descent for left and right
3) compute maximum left - right, adjust right position by this value
this is a crude form of kerning between textcomponents
note glyphvectors preposition glyphs based on offset,
so tl doesn't need to adjust glyphvector position
no italic adjustment for x, but still need to compute y
do we want italic padding at the right of the line?
locs[locs.length - 1] = 0;  final offset is always back on baseline
ok, build fMetrics since we have the final advance
build path if we need it
if we have a matching frc, set it to null so we don't have to test it
for each component
only cache integral locations with the default frc, this is a bit strict
couldn't use cache, or didn't have it, so compute
all glyphvectors with no decorations, no layout path
draw and test
charPos is relative to the component - adjust for
dlf: get baseRot from font for now???
no extra info yet, bidi determines run and line direction
!!! For now, let's assign runs of text with both fonts and graphic attributes
a null rotation (e.g. the baseline rotation goes away when a graphic
no extra info yet, bidi determines run and line direction
all characters outside the justification range must be in the base direction
of the layout, otherwise justification makes no sense.
get the actual justification delta
generate an array of GlyphJustificationInfo records to pass to
the justifier.  Array is visually ordered.
get positions that each component will be using
get justification infos
records are visually ordered, and contiguous, so start and end are
simply the places where we didn't fetch records
invoke justifier on the records
apply justification deltas
only make two passes
return the sum of the advances of text between the logical start and limit
name of the special signature alg
name of the equivalent cipher alg
all the services we need to lookup for compatibility with Cipher
try services until we find an Spi or a working Signature subclass
must be a subclass of Signature, disable dynamic selection
pre-initialize with values for our SignatureSpi implementations
must be a CipherSpi, which we can wrap with the CipherAdapter
Signature extends SignatureSpi
so it is a "real" Spi if it is an
instance of SignatureSpi but not Signature
something is wrong, assume not an SPI
exception compatibility with existing code
exception compatibility with existing code
return an implementation for NONEwithRSA, which is a special case
because of the Cipher.RSA/ECB/PKCS1Padding compatibility wrapper
try Signature first
throw Signature style exception message to avoid confusion,
but append Cipher exception as cause
empty, overridden in Delegate
If the certificate is of type X509Certificate,
we should check whether it has a Key Usage
extension marked as critical.
Check whether the cert has a key usage extension
marked as a critical extension.
The OID for KeyUsage extension is 2.5.29.15.
keyUsageInfo[0] is for digitalSignature.
The provider implementation (delegate)
filled in once the provider is selected
lock for mutex during provider selection
next service to try in provider selection
null once provider is selected
remaining services to try in provider selection
null once provider is selected
no lock needed
used with delayed provider selection
Because 'algorithm' and 'provider' are private
members of our supertype, we must perform a cast to
must be NONEwithRSA
max number of debug warnings to print from chooseFirstProvider()
not needed any more
if provider says it does not support this key, ignore it
if instance is not a SignatureSpi, ignore it
NoSuchAlgorithmException from newInstance()
InvalidKeyException from init()
RuntimeException (ProviderException) from init()
no working provider found, fail
adapter for RSA/ECB/PKCS1Padding ciphers
e.g. wrong public key used
return false rather than throwing exception
JAXP spec is ambiguous about what really happens in this case,
so work defensively
if the result object contains something strange,
it is not a user problem, but it is a JAXB provider's problem.
That's why we throw a runtime exception.
override for Javadoc
SAX default implementation for AttributeList.
No warranty; no copyright -- use this as you will.
$Id: AttributeListImpl.java,v 1.2 2004/11/03 22:53:08 jsuttor Exp $
Methods specific to this class.
Implementation of org.xml.sax.AttributeList
end of AttributeListImpl.java
Visibility guaranteed by final field guarantees
Returned cached type if available
Find nearest closure to add a variable reference
way up in the tree
Attempt to get the cached variable type
If that does not work we must force a type-check (this is normally
only needed for globals in included/imported stylesheets
If in a top-level element, create dependency to the referenced var
Return the type of the referenced variable
To support bidirectional text, we build a more heavyweight
representation of the field.
this shouldn't happen, should probably throw in this case.
Justification is done in adjustAllocation(), so disable
ParagraphView's justification handling by doing nothing here.
horizontally align the interior
adjust the allocation to match the bounded range.
--- View methods -------------------------------------------
End of file.
private constructor defined to "hide" the default public constructor
PUBLIC STATIC METHODS
PRIVATE STATIC METHODS
overflow caught later
override for Javadoc
override for Javadoc
inline TemporalAccessor.super.query(query) as an optimization
non-JDK classes are not permitted to make this optimization
added for Nimbus LAF
whether to tile indeterminate painting
the width of each tile
minimal visible bar size
Glow around the bar foreground
handle scaling for sizeVarients for special case components. The
key "JComponent.sizeVariant" scales for large/small/mini
components are based on Apples LAF
if tiling and indeterminate, then paint the progress bar foreground a
bit wider than it should be. Shift as needed to ensure that there is
an animated effect
paint each tile horizontally
paint each tile vertically
Calculate the position for the text.
Progress bar isn't wide enough for the font.  Don't paint it.
Paint the text.
Calculate the bounds for the text.
Progress bar isn't tall enough for the font.  Don't paint it.
Paint the text.
adjust the height if necessary to make room for the string
adjust the width if necessary to make room for the string
make sure the width is big enough for the string
make sure the height is big enough for the string
handle scaling for sizeVarients for special case components. The
key "JComponent.sizeVariant" scales for large/small/mini
components are based on Apples LAF
Common UI methods
Type-specific CORBA::Object operations
REVISIT: create a unit test for this class.
End ITERATOR state
listOfContactInfos is null when used by the legacy
socket factory.  In that case this iterator is NOT used.
List is immutable so no need to synchronize access.
REVISIT: Implement as internal closure iterator which would
wraps sticky or default.  Then hasNext and next just call
We hold onto the last in case we get an addressing
disposition retry.  Then we use it again.
We also hold onto it for the sticky manager.
retry from root ior
The normal operation for a standard iterator is to throw
ConcurrentModificationException whenever the underlying collection
changes.  This is implemented by keeping a modification counter (the
timestamp may fail because the granularity is too coarse).
Essentially what you need to do is whenever the iterator fails this
way, go back to ContactInfoList and get a new iterator.
Need to update CorbaClientRequestDispatchImpl to catch and use
If we report the exception in _request (i.e., beginRequest
we cannot throw RemarshalException to the stub because _request
does not declare that exception.
To keep the two-level dispatching (first level chooses ContactInfo,
second level is specific to that ContactInfo/EPT) we need to
ensure that the request dispatchers get their iterator from the
InvocationStack (i.e., ThreadLocal). That way if the list iterator
needs a complete update it happens right here.
End of file.
Use Quicksort on small arrays
Check if the array is nearly sorted
Check special cases
Implementation note: variable "right" is increased by 1.
The last run contains one element
The array is already sorted
Determine alternation base for merge
Use or create temporary array b for merging
temp array; alternates with a
array offsets from 'left'
space needed for b
Use insertion sort on tiny arrays
Inexpensive approximation of length / 7
Sort these elements using insertion sort
The index of the first element of center part
The index before the first element of right part
Move a[k] to left part
Move a[k] to right part
a[great] <= pivot2
pivot1 <= a[great] <= pivot2
Swap pivots into their final positions
Sort left and right parts recursively, excluding known pivots
Move a[k] to left part
Move a[k] to right part
a[great] < pivot2
pivot1 < a[great] < pivot2
Sort center part recursively
Partitioning with one pivot
Move a[k] to left part
a[k] > pivot - Move a[k] to right part
a[great] <= pivot
a[great] == pivot
Use Quicksort on small arrays
Check if the array is nearly sorted
Check special cases
Implementation note: variable "right" is increased by 1.
The last run contains one element
The array is already sorted
Determine alternation base for merge
Use or create temporary array b for merging
temp array; alternates with a
array offsets from 'left'
space needed for b
Use insertion sort on tiny arrays
Inexpensive approximation of length / 7
Sort these elements using insertion sort
The index of the first element of center part
The index before the first element of right part
Move a[k] to left part
Move a[k] to right part
a[great] <= pivot2
pivot1 <= a[great] <= pivot2
Swap pivots into their final positions
Sort left and right parts recursively, excluding known pivots
Move a[k] to left part
Move a[k] to right part
a[great] < pivot2
pivot1 < a[great] < pivot2
Sort center part recursively
Partitioning with one pivot
Move a[k] to left part
a[k] > pivot - Move a[k] to right part
a[great] <= pivot
a[great] == pivot
Use counting sort on large arrays
Use Dual-Pivot Quicksort on small arrays
Use Quicksort on small arrays
Check if the array is nearly sorted
Check special cases
Implementation note: variable "right" is increased by 1.
The last run contains one element
The array is already sorted
Determine alternation base for merge
Use or create temporary array b for merging
temp array; alternates with a
array offsets from 'left'
space needed for b
Use insertion sort on tiny arrays
Inexpensive approximation of length / 7
Sort these elements using insertion sort
The index of the first element of center part
The index before the first element of right part
Move a[k] to left part
Move a[k] to right part
a[great] <= pivot2
pivot1 <= a[great] <= pivot2
Swap pivots into their final positions
Sort left and right parts recursively, excluding known pivots
Move a[k] to left part
Move a[k] to right part
a[great] < pivot2
pivot1 < a[great] < pivot2
Sort center part recursively
Partitioning with one pivot
Move a[k] to left part
a[k] > pivot - Move a[k] to right part
a[great] <= pivot
a[great] == pivot
Use counting sort on large arrays
Use Dual-Pivot Quicksort on small arrays
Use Quicksort on small arrays
Check if the array is nearly sorted
Check special cases
Implementation note: variable "right" is increased by 1.
The last run contains one element
The array is already sorted
Determine alternation base for merge
Use or create temporary array b for merging
temp array; alternates with a
array offsets from 'left'
space needed for b
Use insertion sort on tiny arrays
Inexpensive approximation of length / 7
Sort these elements using insertion sort
The index of the first element of center part
The index before the first element of right part
Move a[k] to left part
Move a[k] to right part
a[great] <= pivot2
pivot1 <= a[great] <= pivot2
Swap pivots into their final positions
Sort left and right parts recursively, excluding known pivots
Move a[k] to left part
Move a[k] to right part
a[great] < pivot2
pivot1 < a[great] < pivot2
Sort center part recursively
Partitioning with one pivot
Move a[k] to left part
a[k] > pivot - Move a[k] to right part
a[great] <= pivot
a[great] == pivot
Use counting sort on large arrays
Use insertion sort on small arrays
a[k] is NaN
ak is -0.0f
Use Quicksort on small arrays
Check if the array is nearly sorted
Check special cases
Implementation note: variable "right" is increased by 1.
The last run contains one element
The array is already sorted
Determine alternation base for merge
Use or create temporary array b for merging
temp array; alternates with a
array offsets from 'left'
space needed for b
Use insertion sort on tiny arrays
Inexpensive approximation of length / 7
Sort these elements using insertion sort
The index of the first element of center part
The index before the first element of right part
Move a[k] to left part
Move a[k] to right part
a[great] <= pivot2
pivot1 <= a[great] <= pivot2
Swap pivots into their final positions
Sort left and right parts recursively, excluding known pivots
Move a[k] to left part
Move a[k] to right part
a[great] < pivot2
pivot1 < a[great] < pivot2
Sort center part recursively
Partitioning with one pivot
Move a[k] to left part
a[k] > pivot - Move a[k] to right part
a[great] <= pivot
a[great] == pivot
a[k] is NaN
ak is -0.0d
Use Quicksort on small arrays
Check if the array is nearly sorted
Check special cases
Implementation note: variable "right" is increased by 1.
The last run contains one element
The array is already sorted
Determine alternation base for merge
Use or create temporary array b for merging
temp array; alternates with a
array offsets from 'left'
space needed for b
Use insertion sort on tiny arrays
Inexpensive approximation of length / 7
Sort these elements using insertion sort
The index of the first element of center part
The index before the first element of right part
Move a[k] to left part
Move a[k] to right part
a[great] <= pivot2
pivot1 <= a[great] <= pivot2
Swap pivots into their final positions
Sort left and right parts recursively, excluding known pivots
Move a[k] to left part
Move a[k] to right part
a[great] < pivot2
pivot1 < a[great] < pivot2
Sort center part recursively
Partitioning with one pivot
Move a[k] to left part
a[k] > pivot - Move a[k] to right part
a[great] <= pivot
a[great] == pivot
REVISIT.  Can the type be something that is
non-primitive yet not a value_box, value, or objref?
If so, should use ObjectStreamClass or throw
Set FVD name
Set FVD id _REVISIT_ : Manglings
Set FVD is_abstract
Set FVD is_custom
Set FVD defined_in _REVISIT_ : Manglings
Set FVD version
Skip FVD operations - N/A
Skip FVD attributed - N/A
Set FVD members
Maps classes to repositoryIDs strings. This is used to detect recursive types.
Stores all types created for resolving indirect types at the end.
Skip FVD initializers - N/A
Skip FVD supported_interfaces
Skip FVD abstract_base_values - N/A
Set FVD base_value
Set FVD type
Note : fields come out of ObjectStreamClass in correct order for
writing.  So, we will create the same order in the members array.
_REVISIT_ : Manglings
_REVISIT_ : Manglings
_REVISIT_ : IDLType implementation missing
When using serialPersistentFields, the class may
no longer have an actual Field that corresponds
to one of the items.  The Java to IDL spec
ptc-00-01-06 1.3.5.6 says that the IDL field
should be private in this case.
members[i].type = orb.get_primitive_tc(TCKind.tk_value_box); 11638
end for loop
Maps classes to repositoryIDs strings. This is used to detect recursive types.
Stores all types created for resolving indirect types at the end.
This wrapper method is the protection against infinite recursion.
cache the rep id BEFORE creating a new typecode.
so that recursive tc can look up the rep id.
Maintains a stack of key-value pairs. Compares elements using == operator.
Arrays - may recurse for multi-dimensional arrays
REVISIT truncatable and abstract?
_REVISIT_ Not sure if this is right.
bug fix # 2838, cast to reals if both are result tree fragments
If one is of reference type, then convert the other too
bug fix # 2838
Ensure that the node-set is the left argument
Promote nodes to node sets
Promote integer to doubles to have fewer compares
Promote result-trees to strings
In the node-boolean case, convert node to boolean first
Lookup the table of primops to find the best match
Call compare() from the BasisLibrary
TODO: optimize if one of the args is 0
must be backpatched
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of PasswordFieldPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of PasswordFieldPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
The value of the cookie itself.
NAME= ... "$Name" style is reserved
value of NAME
Attributes encoded in the header's cookie fields.
Comment=VALUE ... describes cookie's use
CommentURL="http URL" ... describes cookie's use
Discard ... discard cookie unconditionally
Domain=VALUE ... domain that sees cookie
Max-Age=VALUE ... cookies auto-expire
Path=VALUE ... URLs that see the cookie
Port[="portlist"] ... the port cookie may be returned to
Secure ... e.g. use SSL
HttpOnly ... i.e. not accessible to scripts
Version=1 ... RFC 2965 style
The original header this cookie was consructed from, if it was
constructed by parsing a header, otherwise null.
Hold the creation time (in seconds) of the http cookie for later
Since the positive and zero max-age have their meanings,
this value serves as a hint as 'not specify max-age'
date formats used by Netscape's cookie draft
as well as formats seen on various sites
constant strings represent set-cookie header token
Private version of parse() that will store the original header used to
create the cookie, in the cookie itself. This can be useful for filtering
Set-Cookie[2] headers, using the internal parsing logic defined in this
if header start with set-cookie or set-cookie2, strip it off
The Netscape cookie may have a comma in its expires attribute, while
the comma is the delimiter in rfc 2965/2109 cookie header string.
so the parse logic is slightly different
Netscape draft cookie
if header string contains more than one cookie,
it'll separate them with comma
if not specify max-age, this cookie should be
discarded when user agent is to be closed, but
it is not expired.
if there's no embedded dot in domain and domain is not .local
if the host name contains no dot and the domain name
is .local or host.local
if the host name and the domain name are just string-compare euqal
need to check H & D component
if domain is actually .host
One http cookie equals to another cookie (RFC 2965 sec. 3.3.3) if:
1. they come from same domain (case-insensitive),
2. have same name (case-insensitive),
3. and have same path (case-sensitive).
Note -- disabled for now to allow full Netscape compatibility
from RFC 2068, token special case characters
deliberately includes space
it's cookie's name
no "=" in name-value pair; it's an error
remaining name-value pairs are cookie's attributes
assign attribute to cookie
Just ignore bogus version, it will default to 0 or 1
strip off the surrounding "-sign if there's any
Ignore the attribute as per RFC 2965
2-digit years following the standard set
out it rfc 6265
Ignore, try the next date format
only netscape cookie using 'expires'
version is mandatory for rfc 2965/2109 cookie
rfc 2965/2109 use 'max-age'
only rfc 2965 cookie starts with 'set-cookie2'
it is comma and not surrounding by double-quotes
make sure required attribute(s) have been set
call copy from the DOM 'library'
We want the whole tree, so we start with the root node
reinstantiate Signature object to work around bug in JDK
this shouldn't occur, but if it does, restore previous
A given point in the raster should take on the same color as its
projection onto the gradient vector.
Thus, we want the projection of the current position vector
onto the gradient vector, then normalized with respect to the
length of the gradient vector, giving a value which can be mapped
into the range 0-1.
currentVector dot gradientVector / length(gradientVector)
normalized = projection / length(gradientVector)
change in x from start to end
change in y from start to end
total distance squared
avoid repeated calculations by doing these divides once
incremental change along gradient for +x
incremental change along gradient for +y
constant, incorporates the translation components from the matrix
current value for row gradients
used to end iteration on rows
constant which can be pulled out of the inner loop
for every row
initialize current value to be start
for every pixel in this row
get the color
incremental change in g
change in off from row to row
rowlimit is width + offset
Required by parent CDROutputStream
See EncapsOutputStream, the only one that uses the
non-pooled ByteBuffers, for additional info.
Needed by request and reply messages for GIOP versions >= 1.2 only.
Required by IIOPOutputStream and other subclasses
Type-specific CORBA::Object operations
should not happen
Too bad, we'll say no for now.
Implementation Note: No state is kept except the data above
(fWhatToShow, fNodeFilter, fCurrentNode, fRoot) such that
setters could be created for these data values and the
implementation will still work.
get the lastChild of result.
if there is a lastChild which passes filters return it.
otherwise return the previous sibling.
otherwise return null.
return parent's 1st sibling.
end , return null
if (accept == NodeFilter.SKIP_NODE)  and REJECT too.
if (accept == NodeFilter.REJECT_NODE)
if (accept == NodeFilter.REJECT_NODE)
if (accept == NodeFilter.REJECT_NODE)
if (accept == NodeFilter.REJECT_NODE)
What to show has failed. See above excerpt from spec.
Equivalent to FILTER_SKIP.
do nothing for now
Ignore if a lexical handler has not been set
time to fire off comment event
Redefined in SAXXMLOutput
Redefined in SAXXMLOutput
fire off the start element event
we are not overwriting an existing LexicalHandler, and _saxHandler
is also implements LexicalHandler, so lets use it
fire off the start element event
fire off the start element event
remember the current node
Get the node's value as a String and use that String as if
it were an input character notification.
Contains rep. ids as keys to FullValueDescriptions
Private ORBSingleton used when we need an ORB while not
having a delegate set.
backward compatability so that appropriate rep-id calculations
can take place
this needs to be transient to prevent serialization during
Operation to obtain the IR from the sending context
Operations to obtain a URL to the implementation code
default to using the current ORB version in case the
vhandler is not set
Util.getCodebase may return null which would
cause a BAD_PARAM exception.
the same information
default to using the current ORB version in case the
vhandler is not set
default to using the current ORB version in case the
vhandler is not set
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of ComboBoxTextFieldPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of ComboBoxTextFieldPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of TabbedPaneTabPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of TabbedPaneTabPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
set the source of this handler
return the source from which this handler derives its events
set content model source
get content model source
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of ComboBoxArrowButtonPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of ComboBoxArrowButtonPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
Registry of singleton profile objects for specific color spaces
defined in the ColorSpace class (e.g. CS_sRGB), see
getInstance(int cspace) factory method.
Future versions may choose to write profile data for new
predefined color spaces as well, if any will be introduced,
so that old versions that don't recognize the new CS name
may fall back to constructing profile from the data.
getData will activate deferred profile if necessary
Temporary storage used by readObject to store resolved profile
(obtained with getInstance) for readResolve to return.
ColorSpace.CS_* constant if known
-- This file was mechanically generated: Do not edit! --
DynAnyFactory interface methods
Returns the most derived DynAny type based on the Anys TypeCode.
Returns the most derived DynAny type based on the TypeCode.
Needed for org.omg.CORBA.Object
HTML 4.0 loose DTD
HTML 4.0 strict DTD
From "John Ky" <hand@syd.speednet.com.au
Transitional Document Type Definition ()
From "John Ky" <hand@syd.speednet.com.au
HTML 4.0, section 16.5
Netscape 4 extension
Netscape 4 extension
NOW FOR ATTRIBUTE INFORMATION . . .
Netscape 4 extension
Attribution to: "Voytenko, Dimitry" <DVoytenko@SECTORBASE.COM>
HTML 4.0, section 16.5
Netscape 4 extension
Netscape 4 extension
The nowrap attribute of a tr element is both
a Netscape and Internet-Explorer extension
clean up any pending things first
if this element has a namespace then treat it like XML
getElemDesc2(name) is faster than getElemDesc(name)
deal with indentation issues first
save any attributes for later processing
an optimization for elements which are expected
to be empty.
This is the <HEAD> element, do some special processing
deal with any pending issues
if the element has a namespace, treat it like XML, not HTML
deal with any indentation issues
the start-tag open when this method was called,
so we need to process it now.
the starting tag was still open when we received this endElement() call
so we need to process any gathered attributes NOW, before they go away.
clear attributes object for re-use with next element
As per Dave/Paul recommendation 12/06/2000
clean up because the element has ended
fire off the end element event
a quick exit if the HTML element had no children.
This block of code can be removed if the corresponding block of code
in startElement() also labeled with "OPTIMIZE-EMPTY" is also removed
some more clean because the element has ended.
Two calls to single-char write may NOT
be more efficient than one to string-write...
A URI is always in an "escaped" form, since escaping or unescaping a
completed URI might change its semantics.  Normally, the only time
escape encodings can safely be made is when the URI is being created
from its component parts; each component may have its own set of
characters that are reserved, so only the mechanism responsible for
generating or interpreting that component can determine whether or
not escaping a character will change its semantics. Likewise, a URI
must be separated into its components before the escaped characters
within those components can be safely decoded.
...So we do our best to do limited escaping of the URL, without
causing damage.  If the URL is already properly escaped, in theory, this
function should not change the string value.
Encode UTF16 to UTF8.
Reference is Unicode, A Primer, by Tony Graham.
Note that Kay doesn't escape 0x20...
if(ch == 0x20)  Not sure about this... -sb
Clear low 6 bits before rotate, put high 4 bits in low byte,
and set two high bits.
First 6 bits, + high bit
I'm sure this can be done in 3 instructions, but I choose
to try and do it exactly like it is done in the book, at least
until we are sure this is totally clean.  I don't think performance
is a big issue with this particular function, though I could be
wrong.  Also, the stuff below clearly does more masking than
it needs to do.
Clear high 6 bits.
Middle 4 bits (wwww) + 1
"Note that the value of wwww from the high surrogate bit pattern
is incremented to make the uuuuu bit pattern in the scalar value
so the surrogate pair don't address the BMP."
next 4 bits
low 2 bits
Get low surrogate character.
Clear high 6 bits.
put the middle 4 bits into the bottom of yyyyyy (byte 3)
bottom 6 bits.
top 3 bits of uuuuu
top 4 bits
middle 6 bits
First 6 bits, + high bit
In this character range we have first written out any previously accumulated
"clean" characters, then processed the current more complicated character,
which may have incremented "i".
We now we reset the next possible clean character.
Since http:www.ietf.org/rfc/rfc2396.txt refers to the URI grammar as
not allowing quotes in the URI proper syntax, nor in the fragment
identifier, we believe that it's OK to double escape quotes.
If the character is a '%' number number, try to avoid double-escaping.
There is a question if this is legal behavior.
Dmitri Ilyin: to check if '%' number number is invalid. It must be checked if %xx is a sign, that would be encoded
The encoded signes are in Hex form. So %xx my be in form %3C that is "<" sign. I will try to change here a little.
if( ((i+2) < len) && isASCIIDigit(stringArray[i+1]) && isASCIIDigit(stringArray[i+2]) )
We are no longer escaping '%'
Mike Kay encodes this as &#34;, so he may know something I don't?
we have to escape this, I guess.
We have written out any clean characters, then the escaped '%' and now we
We now we reset the next possible clean character.
HTML 4.01 reads, "Authors should use "&amp;" (ASCII decimal 38)
instead of "&" to avoid confusion with the beginning of a character
reference (entity reference open delimiter).
no processing for this character, just count how
many characters in a row that we have that need no processing
are there any clean characters at the end of the array
that we haven't processed yet?
if the whole string can be written out as-is do so
otherwise write out the clean chars at the end of the
a little optimization for 1 clean character
(we could have let the previous if(...) handle them all)
no escaping in this case, as specified in 15.2
no escaping in this case, as specified in 15.2
two input characters processed
this increments by one and the for()
loop itself increments by another one.
The next is kind of a hack to keep from escaping in the case
of Shift_JIS and the like.
no escaping in this case
end of for()
are there any clean characters at the end of the array
that we haven't processed yet?
if the whole string can be written out as-is do so
otherwise write out the clean chars at the end of the
a little optimization for 1 clean character
(we could have let the previous if(...) handle them all)
With m_ispreserve just set true it looks like shouldIndent()
will always return false, so drop any possible indentation.
time to generate characters event
Process any pending starDocument and startElement first.
Use a fairly nasty hack to tell if the next node is supposed to be
writer.write(data + ">");  different from XML
different from XML
different from XML
Always output a newline char if not inside of an
element. The whitespace is not significant in that
now generate the PI event
finish processing attributes, time to fire off the start element event
clear attributes object for re-use with next element
Should have been warned in init, I guess...
hack for XSLTC with finding URI for default namespace
the elements URI is not known yet, and it
doesn't have a prefix, and we are currently
setting the uri for prefix "", so we have
the uri for the element... lets remember it
The internal DTD subset is not serialized by the ToHTMLStream serializer
The internal DTD subset is not serialized by the ToHTMLStream serializer
The internal DTD subset is not serialized by the ToHTMLStream serializer
The internal DTD subset is not serialized by the ToHTMLStream serializer
"flags" has indicated that the characters
'>'  '<'   '&'  and '"' are not in the value and
m_htmlcharInfo has recorded that there are no other
entities in the range 0 to 127 so we write out the
The internal DTD subset is not serialized by the ToHTMLStream serializer
make the biggest buffer ever needed in get(String)
put this value into the tree only with a lower case key
put this value into the tree with a case insensitive key
optimize the look up based on the number of chars
case 0 looks silly, but the generated bytecode runs
faster for lookup of elements of length 2 with this in
and a fair bit faster.  Don't know why.
comment out case 2 because the default is faster
case 2 :
if (ch0 < ALPHA_SIZE && ch1 < ALPHA_SIZE)
if (node != null)
if (ch1 < ALPHA_SIZE)
if (node != null)
A thread-safe way to loop over the characters
the key is not 7-bit ASCII so we won't find it here
copy some fields from the existing Trie into this one.
get a buffer just big enough to hold the longest key in the table.
optimize the look up based on the number of chars
case 0 looks silly, but the generated bytecode runs
faster for lookup of elements of length 2 with this in
and a fair bit faster.  Don't know why.
the key is not 7-bit ASCII so we won't find it here
-- This file was mechanically generated: Do not edit! --
Cached unsafe-access object
Cached array base offset
Cached unaligned-access capability
Base address, used in all indexing calculations
NOTE: moved up to Buffer.java for speed in JNI GetDirectBufferAddress
An object attached to this buffer. If this buffer is a view of another
buffer then we use this field to keep a reference to that buffer to
ensure that its memory isn't freed before we are done with it.
For duplicates and slices
-- This file was mechanically generated: Do not edit! --
enforce limit == capacity
XMLReaderAdapter.java - adapt an SAX2 XMLReader to a SAX1 Parser
Written by David Megginson
NO WARRANTY!  This class is in the public domain.
$Id: XMLReaderAdapter.java,v 1.3 2004/11/03 22:53:09 jsuttor Exp $
Implementation of org.xml.sax.Parser.
NO OP: it's just extra information, and we can ignore it
Implementation of org.xml.sax.ContentHandler.
end of XMLReaderAdapter.java
See notes in CDROutputStream
WARNING: Must compute real alignment after calling
checkBlockLength since it may move the position
Some other ORBs may have found a way to send 1.1
fragments which put alignment bytes at the end
of a fragment
We must recalculate the alignment after a possible
fragmentation since the new bbwi.position() (after the header)
may require a different alignment.
This can be overridden....
Save the size of the current buffer for
possible fragmentOffset calculation
By this point we should be guaranteed to have
a new fragment whose header has already been
unmarshalled.  bbwi.position() should point to the
end of the header.
Clear the flag
In GIOP 1.1, interoperability with wchar is limited
to 2 byte fixed width encodings.  CORBA formal 99-10-07 15.3.1.6.
WARNING:  For UTF-16, this means that there can be no
byte order marker, so it must default to big endian!
Because of the alignAndCheck, we should be guaranteed
2 bytes of real data.
Did the provided bytes convert to more than one
character?  This may come up as more unicode values are
assigned, and a single 16 bit Java char isn't enough.
Better to use strings for i18n purposes.
In GIOP 1.1, interoperability with wchar is limited
to 2 byte fixed width encodings.  CORBA formal 99-10-07 15.3.1.6.
Workaround for ORBs which send string lengths of
zero to mean empty string.
IMPORTANT: Do not replace 'new String("")' with "", it may result
in a Serialization bug (See serialization.zerolengthstring) and
bug id: 4728756 for details
Don't include the two byte null for the
following computations.  Remember that since we're limited
to a 2 byte fixed width code set, the "length" was the
number of such 2 byte code points plus a 2 byte null.
Skip over the 2 byte null
-- This file was mechanically generated: Do not edit! --
enforce limit == capacity
Sep 14, 2000:
Fixed serializer to report IO exception directly, instead at
the end of document processing.
Reported by Patrick Higgins <phiggins@transzap.com>
Aug 21, 2000:
Fixed bug in startDocument not calling prepare.
Reported by Mikael Staldal <d96-mst-ingen-reklam@d.kth.se>
Aug 21, 2000:
Added ability to omit DOCTYPE declaration.
Sep 1, 2000:
If no output format is provided the serializer now defaults
to ISO-8859-1 encoding. Reported by Mikael Staldal
for users to override XHTMLNamespace if need be.
Set  value for alternate XHTML namespace.
SAX content handler serializing methods
If this is the root element handle it differently.
If the first root element in the document, serialize
the document's DOCTYPE. Space preserving defaults
to that of the output format.
For any other element, if first in parent, then
close parent's opening tag and use the parnet's
Indent this element on a new line if the first
content of the parent element or immediately
following an element.
Do not change the current element state yet.
This only happens in endElement().
As per SAX2, the namespace URI is an empty string if the element has no
namespace URI, or namespaces is turned off. The check against null protects
against broken SAX implementations, so I've left it there. - mrglavas
SAX2: rawName (QName) could be empty string if
namespace-prefixes property is false.
XHTML: element names are lower case, DOM will be different
For each attribute serialize it's name and value as one part,
separated with a space so the element can be broken on
XHTML: print empty string for null values.
HTML: Empty values print as attribute name, no value.
HTML: URI attributes will print unescaped
The prefixes map uses the URI value as key.
and prefix name as value
Now it's time to enter a new element state
with the tag name and space preserving.
We still do not change the curent element state.
Prevents line breaks inside A/TD
Handle SCRIPT and STYLE specifically by changing the
state of the current element to CDATA (XHTML) or
XHTML: Print contents as CDATA section
HTML: Print contents unescaped
Works much like content() with additions for closing
an element. Note the different checks for the closed
element's state and the parent element's state.
Must leave CData section first
XHTML: element names are lower case, DOM will be different
This element is not empty and that last content was
another element, so print a line break before that
last element and this element's closing tag.
[keith] Provided this is not an anchor.
HTML: some elements do not print closing tag (e.g. LI)
Must leave CData section first (Illegal in HTML, but still)
Leave the element state and update that of the parent
(if we're not root) to not empty and after element.
Temporary hack to prevent line breaks inside A/TD
SAX document handler serializing methods
HTML: no CDATA section
If this is the root element handle it differently.
If the first root element in the document, serialize
the document's DOCTYPE. Space preserving defaults
to that of the output format.
For any other element, if first in parent, then
close parent's opening tag and use the parnet's
Indent this element on a new line if the first
content of the parent element or immediately
following an element.
Do not change the current element state yet.
This only happens in endElement().
XHTML: element names are lower case, DOM will be different
For each attribute serialize it's name and value as one part,
separated with a space so the element can be broken on
XHTML: print empty string for null values.
HTML: Empty values print as attribute name, no value.
HTML: URI attributes will print unescaped
Now it's time to enter a new element state
with the tag name and space preserving.
We still do not change the curent element state.
Prevents line breaks inside A/TD
Handle SCRIPT and STYLE specifically by changing the
state of the current element to CDATA (XHTML) or
XHTML: Print contents as CDATA section
HTML: Print contents unescaped
Generic node serializing methods methods
Not supported in HTML/XHTML, but we still have to switch
out of DTD mode.
If the public and system identifiers were not specified
in the output format, use the appropriate ones for HTML
XHTML: If public identifier and system identifier
specified, print them, else print just system identifier
HTML: If public identifier specified, print it with
system identifier, if specified.
XHTML requires that all element names are lower case, so the
root on the DOCTYPE must be 'html'. - mrglavas
Always serialize these, even if not te first root element.
If this is the root element handle it differently.
If the first root element in the document, serialize
the document's DOCTYPE. Space preserving defaults
to that of the output format.
For any other element, if first in parent, then
close parent's opening tag and use the parnet's
Indent this element on a new line if the first
content of the parent element or immediately
following an element.
Do not change the current element state yet.
This only happens in endElement().
XHTML: element names are lower case, DOM will be different
Lookup the element's attribute, but only print specified
attributes. (Unspecified attributes are derived from the DTD.
For each attribute print it's name and value as one part,
separated with a space so the element can be broken on
XHTML: print empty string for null values.
HTML: Empty values print as attribute name, no value.
HTML: URI attributes will print unescaped
If element has children, or if element is not an empty tag,
serialize an opening tag.
Enter an element state, and serialize the children
one by one. Finally, end the element.
Prevents line breaks inside A/TD
Handle SCRIPT and STYLE specifically by changing the
state of the current element to CDATA (XHTML) or
XHTML: Print contents as CDATA section
HTML: Print contents unescaped
XHTML: Close empty tag with ' />' so it's XML and HTML compatible.
HTML: Empty tags are defined as such in DTD no in document.
After element but parent element is no longer empty.
HTML: no CDATA section
XXX  Apparently Netscape doesn't like if we escape the URI
using %nn, so we leave it as is, just remove any quotes.
check for default provider to avoid loading of installed providers
try to find provider
Don't skip the decimal, it causes wierd behavior
toString isn't localized, so that using +/- should work
store a datatype error: error code plus the arguments
report an error
The start element event
The end element event
The empty element event
Note, synchronization achieved via invocations of other StringBuffer methods
after narrowing of s to specific type
Ditto for toStringCache clearing
Note, synchronization achieved via invocation of StringBuffer insert(int, String)
after conversion of b to String by super class method
Ditto for toStringCache clearing
Note, synchronization achieved via invocation of StringBuffer insert(int, String)
after conversion of i to String by super class method
Ditto for toStringCache clearing
Note, synchronization achieved via invocation of StringBuffer insert(int, String)
after conversion of l to String by super class method
Ditto for toStringCache clearing
Note, synchronization achieved via invocation of StringBuffer insert(int, String)
after conversion of f to String by super class method
Ditto for toStringCache clearing
Note, synchronization achieved via invocation of StringBuffer insert(int, String)
after conversion of d to String by super class method
Ditto for toStringCache clearing
Note, synchronization achieved via invocations of other StringBuffer methods
Note, synchronization achieved via invocations of other StringBuffer methods
We are using StringValueExp here to be consistent with other queries,
although we should actually either use a simple string (the classname)
or a ValueExp - which would allow more complex queries - like for
instance evaluating the class name from an AttributeValueExp.
As it stands - using StringValueExp instead of a simple constant string
doesn't serve any useful purpose besides offering a consistent
look & feel.
Get the class name value
Should not happen - unless someone wrongly implemented
Test whether the MBean is an instance of that class.
BEGIN: Keys needed for exception messages of  JAXP 1.3 XPath API implementation
END: Keys needed for exception messages of  JAXP 1.3 XPath API implementation
Note to translators:  A relative location path is a form of XPath expression.
The message indicates that such an expression was expected following the
characters '/' or '', but was not found.
Note to translators:  A location path is a form of XPath expression.
The message indicates that syntactically such an expression was expected,but
the characters specified by the substitution text were encountered instead.
Note to translators:  A location path is a form of XPath expression.
The message indicates that syntactically such a subexpression was expected,
but no more characters were found in the expression.
Note to translators:  A location step is part of an XPath expression.
The message indicates that syntactically such an expression was expected
following the specified characters.
Note to translators:  A node test is part of an XPath expression that is
used to test for particular kinds of nodes.  In this case, a node test that
consists of an NCName followed by a colon and an asterisk or that consists
of a QName was expected, but was not found.
Note to translators:  A step pattern is part of an XPath expression.
The message indicates that syntactically such an expression was expected,
but the specified character was found in the expression instead.
Note to translators: A relative path pattern is part of an XPath expression.
The message indicates that syntactically such an expression was expected,
but was not found.
Note to translators:  The substitution text is the name of a data type.  The
message indicates that a value of a particular type could not be converted
to a value of type boolean.
Note to translators: Do not translate ANY_UNORDERED_NODE_TYPE and
Note to translators: Do not translate UNORDERED_NODE_SNAPSHOT_TYPE and
Note to translators: This message indicates that the document being operated
upon changed, so the iterator object that was being used to traverse the
document has now become invalid.
Note to translators:  The substitution text is the name of a data type.  The
message indicates that a value of a particular type could not be converted
to a value of type string.
Note to translators: Do not translate snapshotItem,
UNORDERED_NODE_SNAPSHOT_TYPE and ORDERED_NODE_SNAPSHOT_TYPE.
Note to translators:  XPathEvaluator is a Java interface name.  An
XPathEvaluator is created with respect to a particular XML document, and in
this case the expression represented by this object was being evaluated with
respect to a context node from a different document.
Note to translators:  The XPath expression cannot be evaluated with respect
to this type of node.
BEGIN:  Definitions of error keys used  in exception messages of  JAXP 1.3 XPath API implementation
END:  Definitions of error keys used  in exception messages of  JAXP 1.3 XPath API implementation
Other miscellaneous text used inside the code...
================= INFRASTRUCTURE ======================
An action that does nothing at all.
optimize FSM here if desired.  For example,
we could choose different strategies for implementing
the state transition function based on the distribution
of values for states and input labels.
This method is present only for debugging.
innerDoIt does the actual transition.
Use the currentState defaults if
set, otherwise use the state engine default.
The state engine default never changes the state
Locals needed for performing the state transition, once we determine
the required transition.
Do until no guard has deferred.
clear this after each deferral!
Search for a guard that is not DISABLED.
All DISABLED means use defaults.
ga has the next state and action.
Perform the state transition.  Pre and post actions are only
performed if the state changes (see UML hidden transitions).
Note that action may be null in a transition, which simply
means that no action is needed.  Note that action.doIt may
throw an exception, in which case the exception is
propagated after making sure that the transition is properly
end of StateEngineImpl.java
also catches illegal null name
makeMap will catch the case where the name is empty
Optimize the case where exactly one Descriptor is non-Empty
and it is immutable - we can just return it.
clone the primitive array, could use an 8-way if/else here
Note: this Javadoc is copied from javax.management.Descriptor
due to 6369229.
Note: this Javadoc is copied from javax.management.Descriptor
due to 6369229.
Object factory methods
Algorithm factory methods
NOTE: we could check for 0 (i.e., CSIv2) but, for a
non-CSIv2-configured client ORB talking to a CSIv2 configured
server ORB you might end up with an empty contact info list
which would then report a failure which would not be as
instructive as leaving a ContactInfo with a 0 port in the list.
End of file.
cf. Throwable(Throwable cause) constructor.
System Properties corresponding to ACCESS_EXTERNAL_* properties
all access keyword
Implementation limits: corresponding System Properties of the above
Implementation limits: API properties
legacy System Properties
Constants: DOM Level 3 feature ids
REVISIT: this feature seems to have no effect for Xerces
DOM Level 3 features defined in Core:
Load and Save
XML version constants
XML version constants
DOM related constants
Constant to enable Schema 1.1 support
whether the type being parsed is a S4S built-in type.
return qualified name of simpleType or empty string if error occured
General Attribute Checking
if it's a global type without a name, return null
don't add global components without name to the grammar
also add it to extended map
General Attribute Checking
get name and final values
Generate a unique name for the anonymous type by concatenating together the
names of parent nodes
The name is quite good for debugging/error purposes, but we may want to
revisit how this is done for performance reasons (LM).
derivation type: restriction/list/union
nothing should follow this element
General Attribute Checking: get base/item/member types
check content (annotation?, ...)
get base type from "base" attribute
if its the built-in type, return null from here
get types from "memberTypes" attribute
for each qname in the list
get the type decl
if it's a union, expand it
check if there is a child "simpleType"
it's an error for both "base" and "simpleType" to appear
traverse this child to get the base type
get the next element
traverse this child to get the member type
if it's a union, expand it
get the next element
it's an error if neither "base/itemType" nor "simpleType" appears
it's an error if "memberTypes" is empty and no "simpleType" appears
error finding "base" or error traversing "simpleType".
don't need to report an error, since some error has been reported.
error finding "memberTypes" or error traversing "simpleType".
don't need to report an error, since some error has been reported.
item type of list types can't have list content
create the simple type based on the "base" type
now traverse facets, if it's derived by restriction
Recreate the type, ignoring the facets
no element should appear after this point
return the new type
@param: elm - top element
@param: baseTypeStr - type (base/itemType/memberTypes)
@param: baseRefContext:  whether the caller is using this type as a base for restriction, union or list
return XSSimpleType available for the baseTypeStr, null if not found or disallowed.
also throws an error if the base type won't allow itself to be used in this context.
REVISIT: can this code be re-used?
if it's a complex type, or if its restriction of anySimpleType
if the base type is anySimpleType and the current type is
a S4S built-in type, return null. (not an error).
check whethe the type denoted by the name and namespace is a S4S
built-in type. update fIsBuiltIn at the same time.
find if a datatype validator is a list or has list datatype member.
Yes, so make sure it is connected and converted
to a stub (if needed)...
null means DTD
Instantiate a SAXParser directly and not through SAX so that we use the right ClassLoader
JAXP "namespaceAware" == SAX Namespaces feature
Note: there is a compatibility problem here with default values:
JAXP default is false while SAX 2 default is true!
SAX "namespaces" and "namespace-prefixes" features should not
both be false.  We make them opposite for backward compatibility
since JAXP 1.0 apps may want to receive xmlns* attributes.
Avoid setting the XInclude processing feature if the value is false.
This will keep the configuration from throwing an exception if it
does not support XInclude.
Set application's features, followed by validation features.
If validating, provide a default ErrorHandler that prints
validation errors with a warning telling the user to set an
Get the Schema object from the factory
Xerces2 AbstractSAXParser implements SAX1 Parser
This should never happen. We only store recognized
features and properties in the hash maps. For now
just ignore it.
TODO: Add localized error message.
If the property is not supported
re-throw the exception if the value is true.
If the property is not supported
re-throw the exception if the value is true.
TODO: Add localized error message.
TODO: Add localized error message.
JAXP 1.2 support
The spec says if a schema is given via SAXParserFactory
the JAXP 1.2 properties shouldn't be allowed.
None of the properties will take effect till the setValidating(true) has been called
this will allow the parser not to emit DTD-related
errors, as the spec demands
REVISIT: It would be nice if we could format this message
using a user specified locale as we do in the underlying
XMLReader -- mrglavas
The spec says if a schema is given via SAXParserFactory
the JAXP 1.2 properties shouldn't be allowed.
check if the property is managed by security manager
check if the property is managed by security property manager
fall back to the existing property manager
TODO: Add localized error message.
JAXP 1.2 support
This should never be thrown from the schema validator.
This should never be thrown from the schema validator.
This should never be thrown from the schema validator.
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of InternalFrameTitlePanePainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of InternalFrameTitlePanePainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
to be substituted for jdk1.1.x
Re-declares methods that are in class MBeanParameterInfo of JMX 1.0
(these will be removed when MBeanParameterInfo is made a parent interface of this interface)
Now declares methods that are specific to open MBeans
(almost) empty switch, or just default
Swap instructions, too
Offload comparator-based version for sake of performance
type (and possibly null) check
split comparator and comparable paths
Put clone into "virgin" state (except for comparator)
Initialize clone with our mappings
NavigableMap API methods
View class support
deleted entries are replaced by their successors
Abstract methods defined in ascending vs descending classes
These relay to the appropriate absolute versions
deleted entries are replaced by their successors
Implement minimal Spliterator as KeySpliterator backup
If strictly internal, copy successor's element to p and then make p
point to successor.
p has 2 children
Start fixup at replacement node, if it exists.
Link replacement to parent
Null out links so they are OK to use by fixAfterDeletion.
return if we are the only node.
No children. Use self as phantom replacement and unlink.
Write out the Comparator and any hidden stuff
Write out size (number of Mappings)
Write out keys and values (alternating)
Read in the Comparator and any hidden stuff
Read in size
extract key and/or value from iterator or stream
color nodes in non-full bottommost level red
traverser; initially first node in range
one past last, or null
0: top, -1: is a left split, +1: right
size estimate (exact only for top-level)
for CME checks
e not already past s
e not already past s
e not already past s
e not already past s
Adapt or create a key-based comparator
[GIOPHeader(12) + requestID(4)] bytes
Used for mark / reset operations.
Note: at this point, the buffer position is zero. The setIndex()
method call can be used to set a desired read index.
Called from read_octet or read_long or read_ulong method.
check if size < [ GIOPHeader(12) + requestID(4)] bytes
markedItemQ.addLast(Byte.valueOf(value));  only in JDK 1.5
check if size < [ GIOPHeader(12) + requestID(4)] bytes
Use big endian (network byte order). This is fixed.
Both the writer and reader use the same byte order.
Cannot happen. All direct reads are contained
within the first 16 bytes.
read off the typecode
REVISIT We could avoid this try-catch if we could peek the typecode
kind off this stream and see if it is a tk_value.
Looking at the code we know that for tk_value the Any.read_value()
below ignores the tc argument anyway (except for the kind field).
But still we would need to make sure that the whole typecode,
including encapsulations, is read off.
We can be sure that the whole typecode encapsulation has been
read off the value of the any.
We don't need an implementation for this method, since principal
is absent in GIOP version 1.2 or above.
Each octet contains (up to) two decimal digits. If the fixed type has
an odd number of decimal digits, then the representation
begins with the first (most significant) digit.
Otherwise, this first half-octet is all zero, and the first digit
is in the second half-octet.
The sign configuration, in the last half-octet of the representation,
is 0xD for negative numbers and 0xC for positive and zero values.
positive number or zero
In any case, we must first read the IOR.
Could not create stubFactory, so use null.
XXX stubFactory handling is still too complex:
Can we resolve the stubFactory question once in
a single place?
clz is an interface class
REVISIT - should we make these throw UnsupportedOperationExceptions?
Right now, they'll go up to the java.io versions!
public int read(byte b[], int off, int len) throws IOException
Nested mark disallowed.
Further, mark is not supported until first 16 bytes are read.
This should return false so that outside users (people using the JDK)
don't have any guarantees that mark/reset will work in their
custom marshaling code.  This is necessary since they could do things
like expect obj1a == obj1b in the following code:
Needed by AnyImpl and ServiceContexts
Set the buffer position.
Set mark related data.
Used exclusively by the dup() method.
Used exclusively by the dup() method.
Needed by TCUtility
digits isn't really needed here
Needed by TypeCodeImpl
Needed by request and reply messages for GIOP versions >= 1.2 only.
no-op. We don't care about body alignment while using
Java serialization. What the GIOP spec states does not apply here.
Needed by IIOPInputStream and other subclasses
this is redundant, since buffer size was already specified
as part of the init call. So, ignore.
For every 16 bytes, there is one line
of output.  First, the hex output of
the 16 bytes with each byte separated
by a space.
Add any extra spaces to align the
text column in case we didn't end
Now output the ASCII equivalents.  Non-ASCII
characters are shown as periods.
Common UI methods
normal IPv6 address
Perform native initialization
normal IPv6 address
typically should not happen, but it may be that
the machine being used for deserialization has
the same interface name but without IPv6 configured.
Check that our invariants are satisfied
create an appropriate policy mediator based on the policies.
Note that the policies object has already been validated before
this call, so it can only contain valid combinations of POA policies.
Returns GraphicsConfiguration instance that toFind belongs to or null
if drawing point is set to a point beyond visible screen area (e.g.
Take into account screen insets, decrease viewport
Just to be paranoid
we do not adjust x/y when using awt.Window tips
Fit as much of the tooltip on screen as possible
add keylistener here to trigger tip for access
ensure tooltip shows only in proper place
A component in an unactive internal frame is sent two
mouseEntered events, make sure we don't end up adding
ourselves an extra time.
if we get an exit and have a heavy window
we need to check if it if overlapping the inside component
insideComponent may be removed after tooltip is made visible
insideComponent may have been hidden (e.g. in a menu)
Lazily lookup the values from within insideTimerAction
Returns: 0 no adjust
-1 can't fit
>0 adjust value by amount returned
fix internal frame size bug: 4139087 - 4159012
no check for awt.Frame since we use Heavy tips
Returns:  0 no adjust
>0 adjust by value return
Return the number of pixels over the edge we are extending.
If we are over the edge the ToolTipManager can adjust.
REMIND: what if the Tooltip is just too big to fit at all - we currently will just clip
System.out.println("width b.x/b.width: " + b.x + "/" + b.width +
showing we unshow
put a focuschange listener on to bring the tip down
Shown tooltip will be hidden
SAX parser interface.
No warranty; no copyright -- use this as you will.
$Id: Parser.java,v 1.2 2004/11/03 22:55:32 jsuttor Exp $
end of Parser.java
no need to implement Enumeration since this is only for internal use
List<NamedWeakReference<Class | Object>>
reload class if weak ref cleared
Instantiate Class to get factory
replace Class object or null
substitute missing glyph width
PENDING(prinz) this needs to be fixed to
insert to the given position.
treat as text/plain
PENDING(prinz) this needs to be fixed to
use the given document range.
treat as text/plain
We use a String constant here, rather than calling
DatatypeFactory.class.getName() - in order to make javadoc
generate a See Also: Constant Field Value link.
We use new String() here to prevent javadoc from generating
a See Also: Constant Field Value link.
years may not be set
months may not be set
days may not be set
hours may not be set
minutes may not be set
seconds may not be set
lexicalRepresentation must be non-null
test lexicalRepresentation against spec regex
lexicalRepresentation must be non-null
test lexicalRepresentation against spec regex
create a Duration that only has sign, year & month
Duration is immutable, so need to create a new Duration
implementations may override this method in a more efficient way
year may be undefined
millisecond may be undefined
millisecond must be >= 0 millisecond <= 1000
millisecond may be undefined
millisecond must be >= 0 millisecond <= 1000
Get object factories list from environment properties or
provider resource file.
Try each factory until one succeeds
private objects to cache the locale and resource bundle
memorize the most-recent locale
CatalogResolver.java - A SAX EntityResolver/JAXP URI Resolver
Ideally this method would not attempt to open the
InputStream, but there is a bug (in Xerces, at least)
that causes the parser to mistakenly open the wrong
system identifier if the returned InputSource does
not have a byteStream.
It could be argued that we still shouldn't do this here,
but since the purpose of calling the entityResolver is
almost certainly to open the input stream, it seems to
do little harm.
try to make an absolute URI from the current base
don't bother if the absBase isn't different!
has more labels, or keep the trailing dot as at present
has more labels, or keep the trailing dot as at present
ACE Prefix is "xn--"
single instance of nameprep
should never reach here
to suppress the default zero-argument constructor
toASCII operation; should only apply to a single label
Check if the string contains code points outside the ASCII range 0..0x7c.
perform the nameprep operation; flag ALLOW_UNASSIGNED is used here
step 8, move forward to check the smallest number of the code points
the length must be inside 1..63
Verify the absence of non-LDH ASCII code points
0..0x2c, 0x2e..0x2f, 0x3a..0x40, 0x5b..0x60, 0x7b..0x7f
Verify the absence of leading and trailing hyphen
If all code points are inside 0..0x7f, skip to step 8
verify the sequence does not begin with ACE prefix
encode the sequence with punycode
prepend the ACE prefix
the length must be inside 1..63
toUnicode operation; should only apply to a single label
find out if all the codepoints in input are ASCII
perform the nameprep operation; flag ALLOW_UNASSIGNED is used here
toUnicode never fails; if any step fails, return the input string
verify ACE Prefix
Remove the ACE Prefix
Decode using punycode
return output of step 5
just return the input
LDH stands for "letter/digit/hyphen", with characters restricted to the
26-letter Latin alphabet <A-Z a-z>, the digits <0-9>, and the hyphen
Non LDH refers to characters in the ASCII range, but which are not
letters, digits or the hypen.
non-LDH = 0..0x2C, 0x2E..0x2F, 0x3A..0x40, 0x5B..0x60, 0x7B..0x7F
or if there is no dots, return the length of input string
dots might be: \u002E (full stop), \u3002 (ideographic full stop), \uFF0E (fullwidth full stop),
and \uFF61 (halfwidth ideographic full stop).
to check if a string is a root label, ".".
to check if a character is a label separator, i.e. a dot character.
to check if a string only contains US-ASCII code point
to check if a string starts with ACE-prefix
Box-orientation constant used to specify locations in a box.
Compass-direction constants used to specify a position.
These constants specify a horizontal or
vertical orientation. For example, they are
used by scrollbars and sliders.
Constants for orientation support, since some languages are
left-to-right oriented and some are right-to-left oriented.
This orientation is currently used by buttons and labels.
Insure that its one of the types we require
Store the nodes and init any data that needs it
Package, final methods
Package, inherited methods
If its an alternation, then if either child is nullable then
this node is nullable. If its a concatenation, then both of
them have to be nullable.
Protected, inherited methods
Its the the union of the first positions of our children.
If our left child is nullable, then its the union of our
children's first positions. Else is our left child's first
Its the the union of the first positions of our children.
If our right child is nullable, then its the union of our
children's last positions. Else is our right child's last
Private data members
These are the references to the two nodes that are on either
side of this binary operation.
Convert Exception to corresponding Error
is field undefined?
Following two dates compare to EQUALS since in different timezones.
2000-01-15T12:00:00-05:00 == 2000-01-15T13:00:00-04:00
Must ensure both instances generate same hashcode by normalizing
this to UTC timezone.
The offset value to 0-based index from the era value.
i.e., getValue() + ERA_OFFSET == 0-based index
the number of defined JapaneseEra constants.
There could be an extra era defined in its configuration.
array for the singleton JapaneseEra instances
the first day of the era
override as super would return range from 0 to 1
Make sure that we can invoke a method from a normally
inaccessible package, as this reflective class must always
be able to invoke a non-public method.
mex should never be null, as null cannot be thrown
This is not a user thrown exception from the
method call, so don't copy it.  This is either
an error or a reflective invoke exception.
read and discard the repository ID
write the repository ID
End of file.
Currently implemented as a singleton, since it's hardcoded
REVISIT: Forbid serialization of PSVI DOM until
we support object serialization of grammars -- mrglavas
perform tasks that iterate over the children while
preventing the collection from changing.
propagate a preferenceChanged, using the
probably want to change this to be more exact.
remove the replaced state records
insert the state records for the new children
notify that the size changed
the newly inserted children don't have a valid
offset so the child locator needs to be messaged
that the child prior to the new children has
--- View methods ------------------------------------
size was being changed on the child, no need to
queue work for it.
mark all of the ChildState instances as needing to
resize the child, and queue up work to fix them.
along the major axis the value is ignored
unless the estimatedMajorSpan property is
nothing is known about the children yet
nothing is known about the children yet
forward to the child view, and make sure we don't
interact with the layout thread by synchronizing
on the child state.
child index to forward to
locate the child view and it's allocation so that
we can forward to it.  Make sure the layout thread
doesn't change anything by trying to flush changes
to the parent while the GUI thread is trying to
find the child and it's allocation.
forward to the child view, and make sure we don't
interact with the layout thread by synchronizing
on the child state.
--- variables -----------------------------------------
done painting intersection
offsets need to be updated
should only get here on the first time display.
roll offset calculations forward
no changes prior to the needed offset
this should be a binary search
Make sure that lastAlloc also contains childAlloc,
this will be false if haven't yet flushed changes.
nothing to do
this may overwrite anothers threads cached
value for actively changing... but that just
means it won't use the cache if there is an
setting the child size on the minor axis
may have caused it to change it's preference
along the major axis.
make it the target width, or as small as it can get.
can't make the child this wide, align it
X+ -> XX*
X? -> X|
used to detect if the last - was escaped.
Don't use 'cotinue' for this loop.
single-range | from-to-range | subtraction
\ + c
Exit this loop
if not shorthands...
if regex = '[-]' then invalid
Here is no '-'.
Is this '-' is a from-to token??
c '-' ']' -> '-' is a single-range.
if - is at the last position of the group
LINE FEED U+000A
CRRIAGE RETURN U+000D
HORIZONTAL TABULATION U+0009
return actucal char
correct pos to array index
internally Blobs are stored as arrays.
increment pos, and i
increment pos only
correct to array indexing
this shouldn't happen, since we are Cloneable
Note: this check to see if it is an instance of Serializable
is for backwards compatibiity
the actual value is chosen because ## is not a valid
sequence in xs:anyURI.
array of object
Copyright (c) 1995-96 by Cisco Systems, Inc.
Now extract the ids
should never happen. VM bug.
First handle the case where oid is expressed as 1.2.3.4
if we are here, it means we have something to resolve..
Ok assume there is a variable name to resolve ...
just parse the element.
state of each entry
get the string needed to make the activation command
create a HashMap with capacity 255
Since all methods are synchronized, we don't need any
additional synchronization mechanisms
compute the activation command
add path to the java vm
add any arguments to the server Java VM
add ORB properties
we need to pass in the verify flag, so that the server is not
launched, when we try to validate its definition during registration
into the RepositoryImpl
add classpath to the server
add server class name and arguments
Add the debug flag, if any
find if the ORB is already registered, then throw an exception
store all listener ports and their types
put this set of listener ports in the HashMap associated
with the orbId
_REVISIT_, If the state is not equal to ACTIVATED then it is a bug
need to log that error, once the Logging framework is in place
shutdown the server
call the uninstall
what kind of exception should be thrown
If the State in the ServerTableEntry is RUNNING and the
Process was shut down abnormally, The method will change the
server state as De-Activated.
Clear the PortInformation as it is old
Move the state to De-Activated, So that the next
call to this server will re-activate.
get an entry corresponding to orbId
return the port corresponding to the endpointType
have everything in the table
get an entry corresponding to orbId
return the port corresponding to the endpointType
no element in HashMap corresponding to ORBid found
have everything in the table
The following flags correspond to characteristics on Spliterator
and the values MUST be equal.
The following Spliterator characteristics are not currently used but a
gap in the bit set is deliberately retained to enable corresponding
stream flags ifwhen required without modification to other flag values.
4, 0x00000100 NONNULL(4, ...
5, 0x00000400 IMMUTABLE(5, ...
6, 0x00001000 CONCURRENT(6, ...
7, 0x00004000 SUBSIZED(7, ...
The following 4 flags are currently undefined and a free for any further
The following flags are specific to streams and operations
The following 2 flags are currently undefined and a free for any further
stream flags if/when required
Two bits per flag
0x01 or 0x10 nibbles are transformed to 0x11
0x00 nibbles remain unchanged
Then all the bits are flipped
Then the result is logically or'ed with the operation flags.
By flipping the nibbles 0x11 become 0x00 and 0x01 become 0x10
Shift left 1 to restore set flags and mask off anything other than the set flags
Do not propagate the SORTED characteristic if it does not correspond
to a natural sort order
construct an IDREF datatype validator
Check if is valid key-[81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*
the type of component stored here: complex or simple type
first get the number of components for all types
then copy all types to an temporary array
then copy either simple or complex types to fArray,
depending on which kind is required
only return it if it matches the required type
serialVersionUID is not constant
Serialization compatibility stuff:
Two serial forms are supported in this class. The selected form depends
on system property "jmx.serial.form":
- "1.0" for JMX 1.0
- any other value for JMX 1.1 and higher
Serial version for old serial form
Serial version for new serial form
Serializable fields in old serial form
Serializable fields in new serial form
Actual serial version and serial form
OK: No compat with 1.0
END Serialization compatibility stuff
create default descriptor
create default descriptor
New serial form ignores extra field "currClass"
Serializes this instance in the old serial form
Serializes this instance in the new serial form
First try to call the delegate implementation class's
"Object get_interface_def(..)" method (will work for JDK1.2 ORBs).
Else call the delegate implementation class's
"InterfaceDef get_interface(..)" method using reflection
(will work for pre-JDK1.2 ORBs).
If the ORB's delegate class does not implement
"Object get_interface_def(..)", this will call
get_interface_def(..) on portable.Delegate.
Call "InterfaceDef get_interface(..)" method using reflection.
Enable secure processing feature by default
only W3C XML Schema 1.0 is supported
this will let the loader store parsed Grammars into the pool.
this should have been reported to users already.
this hasn't been reported, so do so now.
and we must throw it.
Clear reference to grammar pool.
Select Schema implementation based on grammar count.
Use a Schema that uses the system id as the equality source.
in secure mode, let _useServicesMechanism be determined by the constructor
check if the property is managed by security manager
check if the property is managed by security property manager
fall back to the existing property manager
since there are no vectors of int, we have to use arrays.
We allocate them in chunks of 10 elements so we don't have to allocate all the time.
field holding the text
fields holding run attribute information
run attributes are organized by run
current size of the arrays
actual number of runs, <= runArraySize
start index for each run
vector of attribute keys for each run
parallel vector of attribute values for each run
Build the String contents
Determine the runs, creating a new run when the attributes
If performance is critical, this constructor should be
implemented here rather than invoking the constructor for a
subrange. We can avoid some range checking in the loops.
Validate the given subrange
Copy the given string
Select attribute keys to be taken care of
Get and set attribute runs for each attribute name. Need to
scan from the top of the text so that we can discard any
Annotation that is no longer applied to a subset text segment.
if the run is beyond the given (subset) range, we
don't need to process further.
attribute is applied to any subrange
make sure we have run attribute data vectors
break up runs if necessary
make sure we have run attribute data vectors
break up runs if necessary
use temporary variables so things remain consistent in case of an exception
assume initial run starting at index 0
ensure there's a run break at offset, return the index of the run
search for the run index where this offset should be
if the offset is at a run start already, we're done
we'll have to break up a run
first, make sure we have enough space in our arrays
make copies of the attribute information of the old run that the new one used to be part of
use temporary variables so things remain consistent in case of an exception
now actually break up the run
add the attribute attribute/value to all runs where beginRunIndex <= runIndex < endRunIndex
index of key and value in our vectors; assume we don't have an entry yet
check whether we have an entry already
create new entry
update existing entry
all (with the exception of length) reading operations are private,
since AttributedString instances are accessed through iterators.
length is package private so that CharacterIteratorFieldDelegate can
access it without creating an AttributedCharacterIterator.
gets an attribute value, but returns an annotation only if it's range does not extend outside the range beginIndex..endIndex
need to check whether the annotation's range extends outside the iterator's range
annotation's range starts before iterator's range
annotation's range ends after iterator's range
annotation's range is subrange of iterator's range,
so we can return the value
returns whether all specified attributes have equal values in the runs with the given indices
returns whether the two objects are either both null or equal
the iterator class associated with this string class
note on synchronization:
we don't synchronize on the iterator, assuming that an iterator is only used in one thread.
we do synchronize access to the AttributedString however, since it's more likely to be shared between threads.
start and end index for our iteration
attributes that our client is interested in
the current index for our iteration
invariant: beginIndex <= currentIndex <= endIndex
information about the run that includes currentIndex
Object methods. See documentation in that class.
CharacterIterator methods. See documentation in that interface.
AttributedCharacterIterator methods. See documentation in that interface.
??? would be nice to return null, but current spec doesn't allow it
returning Hashtable saves AttributeMap from dealing with emptiness
??? This should screen out attribute keys that aren't relevant to the client
??? would be nice to return null, but current spec doesn't allow it
returning HashSet saves us from dealing with emptiness
??? should try to create this only once, then update if necessary,
and give callers read-only view
internally used methods
set the current index, update information about the current run if necessary,
return the character at the current index
update the information about the current run
the map class associated with this string class, giving access to the attributes of one run
the max index / the max value of XSObject type
multi value facet
number of grammars/namespaces stored here
all target namespaces
all schema grammar objects (for each namespace)
a map from namespace to schema grammar
a map from element declaration to its substitution group
store a certain kind of components from all namespaces
store a certain kind of components from one namespace
a string list of all the target namespaces.
store all annotations
whether there is any IDC in this XSModel
copy namespaces/grammars from the array to our arrays
If a schema for the schema namespace isn't included, include it here.
and recursively get all imported grammars, add them to our arrays
get the grammar
for each imported grammar
check whether this grammar is already in the list
if it's not, add it to the list
ensure the capacity of the arrays
establish the mapping from namespace to grammars
update the idc field
build substitution groups
get all hashtables from all namespaces for this type of components
for complex/simple types, create a special implementation,
which take specific types out of the hash table
try to find the grammar
get the hashtable for this type of components
for complex/simple types, create a special implementation,
which take specific types out of the hash table
do this in two passes to avoid inaccurate array size
Single instance used by JViewport.
Need to wrap the uri in an Attribute node so that we can
Pass to the resource resolvers
Lets see if there are any transforms
retrieve the cipher text
Required for AbstractSet
obj must be a Node
Required for AbstractSet
Required for AbstractSet
Clear every node
This visits every node in the graph exactly once.  A
visitor is allowed to modify the graph during the
Repeat the traversal until every node has been visited.  Since
it takes one pass to determine whether or not each node has
already been visited, this loop always runs at least once.
Copy entries to array to avoid concurrent modification
problem with iterator if the visitor is updating the graph.
Visit each node in the graph that has not already been visited.
If any node is visited in this pass, we must run at least one more
Make sure the child is in the graph so it can be
visited later if necessary.
Mark the child as a non-root, since a child is never a root.
Default is using 24 bits per pixel.
Raw data can only handle bytes, everything greater must be ASCII.
for images with BandedSampleModel we can not work
with raster directly and must use writePixels()
we can work with raster directly only in case of
BGR component order.
In any other case we must use writePixels()
BugId 4892214: we can not work with raster directly
if image have different color order than RGB.
We should use writePixels() for such images.
we will use getPixels() to extract pixel data for writePixels()
Please note that getPixels() provides rgb bands order.
XXX: check more
Number of bytes that a scanline for the image written out will have.
we should use 32bpp images in case of BI_BITFIELD
compression to avoid color conversion artefacts
Setting this flag to false ensures that generic
writePixels() will be used to store image data
it is unlikely, but if it happens, we should throw
an exception related to unsupported image format
prepare info for writePixels procedure
handle BI_RGB compression
Cannot be written as a Palette image. So write out as
24 bit image.
Grey scale images
actual writing of image data
Calculate padding for each scanline
FileHeader is 14 bytes, BitmapHeader is 40 bytes,
add palette size and that is where the data will begin
write masks for red, green and blue components.
Writing of actual image data
Buffer for up to 8 rows of pixels
Also create a buffer to hold one line of the data
to be written to the file, so we can use array writes.
prepare embedded buffer
update the file/image Size
Get the pixels
byte[] bdata =
pixel data is provided here in RGB order
Write the RLE EOF marker and
update the file/image Size
Partially filled last byte, if any
Put the last pixel of odd-length lines in the 4 MSBs
Since BMP needs BGR format
Case where IndexColorModel had > 256 colors.
We have two possibilities here:
1. we are writing the indexed image with bitfields
compression (this covers also the case of BYTE_BINARY)
=> use icm to get actual RGB color values.
2. we are writing the gray-scaled image with BI_BITFIELDS
=> just replicate the level of gray to color components.
Write out the padding
/ Check if there was an existing Absolute Run
/ Absolute Encoding for less than 3
/ treated as regular encoding
/ Do not include the last element since it will
/ be inclued in the next encoding/run
/ Only 255 values permitted
/ If there was an existing run
padding since 255 elts is not even
Write the run
write the Absolute Run
Check if there was an existing Absolute Run
we need to exclude  last 2 elts, similarity of
which caused to enter this part of the code
if # of elts is odd - read the last element
Padding to word align absolute encoding
/ Only EOF required now
odd runlength and the run ends here
runCount wont be > 254 since 256/255 case will
be taken care of in above code.
If end of scanline
/ Only EOF required now
Check for existing run
only 255 elements
Padding for word align
since it will fit into 127 bytes
Handle the End of scanline for the last 2 4bits
reserved1 and reserved2
offset to image data
size of header
number of planes
Bits Per Pixel
only 4bpp images can be encoded as BI_RLE4
only 8bpp images can be encoded as BI_RLE8
The total argument turns out to be a bad idea since the
total of all the children can overflow the integer used to
hold the total.  The total must therefore be calculated and
stored in long variables.
---- determine what we have to work with ----
---- make the adjustments ----
lay out with offsets increasing from 0
lay out with offsets decreasing from the end of the allocation
---- determine what we have to work with ----
---- make the adjustments ----
lay out with offsets increasing from 0
lay out with offsets decreasing from the end of the allocation
This method was used by the JTable - which now uses a different technique.
if( priority > 0 )
This should wait until the transformThread is considered not alive.
shouldn't happen: we're passing in null caps
shouldn't happen: we're passing in null caps
Overridden in subclasses
Traverse all templates
Get the next template
Add this template to a test sequence if it has a pattern
Patterns on type id() and key() are special since they do not have
any kernel node type (it can be anything as long as the node is in
the id's or key's index).
Alternative patterns are broken up and re-processed recursively
Finally we have a pattern that can be added to a test sequence!
id() and key()-type patterns do not have a kernel type
Otherwise get the kernel pattern from the LPP
kernel pattern is the last (maybe only) Step
Make sure the array of pattern groups is long enough
Find the vector to put this pattern into
Complete test sequence for "text()" with "child::node()"
Complete test sequence for "*" with "child::node()"
Complete test sequence for "pi()" with "child::node()"
Complete test sequence for "comment()" with "child::node()"
Complete test sequence for "@*" with "attribute::node()"
Complete test sequence for user-defined types
If an attribute then copy "@*" to its test sequence
And also copy "attribute::node()" to its test sequence
If an element then copy "*" to its test sequence
And also copy "child::node()" to its test sequence
doesn't matter what is 'put', only key matters
Initialize the types and names arrays for the NamedMethodGenerator.
For simple named templates, the signature of the generated method
is not fixed. It depends on the number of parameters declared in the
!!! TODO templates both named and matched
else trivial TestSeq
Append switch() statement - namespace test dispatch loop
Initialize targets for namespace() switch statement
Add test sequences for known namespace types
Return "null" if no test sequences were compiled
Append first code in applyTemplates() - get type of current node
Create the applyTemplates() method
Insert an extra NOP just to keep "current" from appearing as if it
has a value before the start of the loop.
Create a local variable to hold the current node
Create the "body" instruction list that will eventually hold the
code for the entire method (other ILs will be appended).
Create an instruction list that contains the default next-node
The body of this code can get very large - large than can be handled
by a single IFNE(body.getStart()) instruction - need workaround:
applyTemplates() ends here!
Live range of "current" ends at end of loop
Compile default handling of elements (traverse children)
Compile default handling of text/attribute nodes (output text)
Distinguish attribute/element/namespace tests for further processing
Initialize isAttribute[] and isNamespace[] arrays
Compile all templates - regardless of pattern type
Handle template with explicit "*" pattern
Handle template with explicit "@*" pattern
Do tests for id() and key() patterns first
If there is a match on node() we need to replace ihElem
and ihText if the priority of node() is higher
Compare priorities of node() and "*"
Compare priorities of node() and text()
Handle templates with "ns:*" pattern
Handle templates with "ns:@*" pattern
Handle templates with "ns:elem" or "ns:@attr" pattern
Jump straight to namespace tests ?
Test first, then jump to namespace tests
Handle pattern with match on root node - default: traverse children
Handle pattern with match on root node - default: traverse children
Handle any pattern with match on text nodes - default: output text
This DOM-type is not in use - default: process next node
Match unknown element in DOM - default: check for namespace match
Match unknown attribute in DOM - default: check for namespace match
Match on processing instruction - default: process next node
Match on comments - default: process next node
This DOM-type is not in use - default: process next node
This DOM-type is not in use - default: process next node
This DOM-type is not in use - default: process next node
This DOM-type is not in use - default: process next node
This DOM-type is not in use - default: process next node
This DOM-type is not in use - default: process next node
Now compile test sequences for various match patterns:
Jump straight to namespace tests ?
Match on node type
Append first code in applyTemplates() - get type of current node
Append switch() statement - main dispatch loop in applyTemplates()
Append all the "case:" statements
Append the actual template code
Append NS:* node tests (if any)
Append NS:@* node tests (if any)
Append default action for element and root nodes
Append default action for text and attribute nodes
putting together constituent instruction lists
fall through to ilLoop
Compile method(s) for <xsl:apply-imports/> for this mode
Clear some datastructures
IMPORTANT: Save orignal & complete set of templates!!!!
Gather templates that are within the scope of this import
Process all patterns from those templates
Create the applyTemplates() method
Create the local variable to hold the current node
Create the "body" instruction list that will eventually hold the
code for the entire method (other ILs will be appended).
Create an instruction list that contains the default next-node
Compile default handling of elements (traverse children)
Compile default handling of text/attribute nodes (output text)
Distinguish attribute/element/namespace tests for further processing
Compile all templates - regardless of pattern type
Handle template with explicit "*" pattern
Handle template with explicit "@*" pattern
Do tests for id() and key() patterns first
If there is a match on node() we need to replace ihElem
and ihText if the priority of node() is higher
Compare priorities of node() and "*"
Compare priorities of node() and text()
Handle templates with "ns:*" pattern
Handle templates with "ns:@*" pattern
Handle templates with "ns:elem" or "ns:@attr" pattern
Jump straight to namespace tests ?
Test first, then jump to namespace tests
Handle pattern with match on root node - default: traverse children
Handle pattern with match on root node - default: traverse children
%HZ%:  Was ihLoop in XSLTC_DTM branch
Handle any pattern with match on text nodes - default: loop
This DOM-type is not in use - default: process next node
Match unknown element in DOM - default: check for namespace match
Match unknown attribute in DOM - default: check for namespace match
Match on processing instruction - default: loop
Match on comments - default: process next node
This DOM-type is not in use - default: process next node
This DOM-type is not in use - default: process next node
This DOM-type is not in use - default: process next node
This DOM-type is not in use - default: process next node
This DOM-type is not in use - default: process next node
This DOM-type is not in use - default: process next node
Now compile test sequences for various match patterns:
Jump straight to namespace tests ?
Match on node type
Append first code in applyTemplates() - get type of current node
Append switch() statement - main dispatch loop in applyTemplates()
Append all the "case:" statements
Append the actual template code
Append NS:* node tests (if any)
Append NS:@* node tests (if any)
Append default action for element and root nodes
Append default action for text and attribute nodes
putting together constituent instruction lists
Mark the end of the live range for the "current" variable
fall through to ilLoop
Restore original (complete) set of templates for this transformation
LoadInstruction, POP => (removed)
changed to lower case - changing to all lower case although only the instruction with capital I
is creating a problem in the Turkish locale
TODO: move target down into the list
ILOAD_N, ILOAD_N, SWAP, ISTORE_N => ILOAD_N
changed to lower case - changing to all lower case although only the instruction with capital I
is creating a problem in the Turkish locale
TODO: move target down into the list
LoadInstruction_N, LoadInstruction_M, SWAP => LoadInstruction_M, LoadInstruction_N
changed to lower case - changing to all lower case although only the instruction with capital I
is creating a problem in the Turkish locale
TODO: move target down into the list
ALOAD_N ALOAD_N => ALOAD_N DUP
changed to lower case - changing to all lower case although only the instruction with capital I
is creating a problem in the Turkish locale
TODO: move target down into the list
ISSUE: this class depends on nothing in AWT -- move to java.util?
Go up the tree until the nodes are at the same level
Move up the tree until we find a common ancestor.  Since we know
that both nodes are at the same level, we won't cross paths
unknowingly (if there is a common ancestor, both nodes hit it in
the same iteration).
only need to check one -- they're at the
same level so if one is null, the other is
No children, so look for nextSibling
order matters not
shallow copy -- the new node has no parent or children
Won't happen because we implement Cloneable
Save the userObject, if its Serializable.
PENDING: don't really need a vector
End of class PreorderEnumeration
End of class PostorderEnumeration
PENDING: don't really need a vector
A simple queue with a linked list data structure.
null if empty
null if end
End of class Queue
End of class BreadthFirstEnumeration
End of class PathBetweenNodesEnumeration
End of class DefaultMutableTreeNode
Fixed date of January 1, 1970 (Gregorian)
Useful millisecond constants.  Although ONE_DAY and ONE_WEEK can fit
into ints, they must be longs in order to prevent arithmetic overflow
when performing (bug 4173516).
ZONE_OFFSET (UNIX compatibility)
DST_OFFSET (historical least maximum)
DST_OFFSET (double summer time)
Proclaim serialization compatibility with JDK 1.1
Reference to the sun.util.calendar.Gregorian instance (singleton).
Reference to the JulianCalendar instance (singleton), set as needed. See
JulianCalendar eras. See getJulianCalendarSystem().
The default value of gregorianCutover.
Set AM_PM and HOUR here to set their stamp values before
setting HOUR_OF_DAY (6178071).
If hourOfDay is a valid PM hour, set the correct PM values
so that it won't throw an exception in case it's set to
The default value for AM_PM is AM.
We don't care any out of range value here for leniency.
The stamp values of AM_PM and HOUR must be COMPUTED. (6440854)
should be changed to set() when this constructor is made
Before changing the cutover date, make sure to have the
time of this calendar.
To provide the "pure" Julian calendar as advertised.
Strictly speaking, the last millisecond should be a
Gregorian date. However, the API doc specifies that setting
the cutover date to Long.MAX_VALUE will make this calendar
a pure Julian calendar. (See 4167995)
Set the cutover year (in the Gregorian year numbering)
The field values are no longer valid under the new
If the given year is the Gregorian cutover year, we need to
determine which calendar system to be applied to February in the year.
If amount == 0, do nothing even the given field is out of
range. This is tested by JCK.
Sync the time and calendar fields.
year <= 0
if year == 0, you get 1 BCE.
era == BCE
year <= 0
if year == 0, you get 1 CE
year <= 0
if year == 0, you get 1 BCE
era == BCE
year <= 0
if year == 0, you get 1 CE
month < 0
Handle the time fields here. Convert the given
amount to milliseconds and call setTimeInMillis.
hours to minutes
minutes to seconds
seconds to milliseconds
Handle week, day and AM_PM fields which involves
time zone offset change adjustment. Convert the
given amount to the number of days.
synonym of DATE
Convert the amount to the number of days (delta)
and +12 or -12 hours (timeOfDay).
The time fields don't require time zone offset change
The rest of the fields (week, day or AM_PM fields)
require time zone offset (both GMT and DST) change
Translate the current time to the fixed date and time
of the day.
fd is the expected fixed date after the calculation
If the time zone offset has changed, then adjust the difference.
If the adjustment has changed the date, then take
the previous one.
If amount == 0, do nothing even the given field is out of
range. This is tested by JCK.
Sync the time and calendar fields.
These fields are handled simply, since they have fixed minima
and maxima.  The field DAY_OF_MONTH is almost as simple.  Other
fields are complicated, since the range within they must roll
varies depending on the date.
12 or 24 hours
The day might have changed, which could happen if
the daylight saving time transition brings it to
the next day, although it's very unlikely. But we
have to make sure not to change the larger fields.
Time zone offset and/or daylight saving might have changed.
Rolling the month involves both pinning the final value to [0, 11]
and adjusting the DAY_OF_MONTH if necessary.  We only adjust the
DAY_OF_MONTH if, after updating the MONTH field, it is illegal.
E.g., <jan31>.roll(MONTH, 1) -> <feb28> or <feb29>.
Keep the day of month in the range.  We don't want to spill over
into the next month; e.g., we don't want jan31 + 1 mo -> feb31 ->
We need to take care of different lengths in
year and month due to the cutover.
If the new value is in between min and max
(exclusive), then we can use the value.
Make sure that the min week has the current DAY_OF_WEEK
in the calendar year
Make sure the same thing for the max week
When WEEK_OF_YEAR and YEAR are out of sync,
adjust woy and amount to stay in the calendar year.
Handle cutover here.
Make sure that the min week has the current DAY_OF_WEEK
Make sure the same thing for the max week
value: the new WEEK_OF_YEAR which must be converted
to month and day of month.
dow: relative day of week from first day of week
fixed date of the first day (usually 1) of the month
actual month length
the first day of week of the month.
if the week has enough days to form a week, the
week starts from the previous month.
value: the new WEEK_OF_MONTH value
nfd: fixed date of the rolled date
Unlike WEEK_OF_YEAR, we need to change day of week if the
nfd is out of the month.
If we are in the cutover year, convert nfd to
its calendar date and use dayOfMonth.
Cutover year handling
It may not be a regular month. Convert the date and range to
the relative values, perform the roll, and
convert the result back to the rolled date.
Handle cutover here.
If the week of year is in the same year, we can
just change DAY_OF_WEEK.
We need to handle it in a different way around year
boundaries and in the cutover year. Note that
changing era and year values violates the roll
rule: not changing larger calendar fields...
after normalized, min should be 1.
Cutover year handling
On or after Gregorian 200-3-1, Julian and Gregorian
calendar dates are the same or Gregorian dates are
larger (i.e., there is a "gap") after 300-3-1.
There might be "overlapping" dates.
January 1 of the next year may or may not exist.
Handle cutover year.
Convert the fixed date to its calendar date.
Handle cutover year.
January 1 of the next year may or may not exist.
Get the day of week of January 1 of the year
Normalize the day of week with the firstDayOfWeek value
# of days in the first week
Cutover year handling
may be in the Gregorian cutover month
Let a cloned GregorianCalendar take care of the cutover cases.
Calculate the millisecond offset from the beginning
of the year of this calendar and adjust the max
year value if we are beyond the limit in the max
To share the zone by CalendarDates
To share the zone by CalendarDates
implicitly calls complete()
Fast path for the Gregorian calendar years that are never
affected by the Julian-Gregorian transition
General (slow) path
Quickly check the possibility of year adjustments before
cloning this GregorianCalendar.
Create a clone to work on the calculation
Use GMT so that intermediate date calculations won't
affect the time of day fields.
Go to the first day of the year, which is usually January 1.
Get the first day of the first day-of-week in the year.
To avoid changing the time of day fields by date
calculations, use a clone with the GMT time zone.
to avoid throwing an IllegalArgumentException in
non-lenient, set WEEK_OF_YEAR internally
Use the 2nd week for calculating the max of WEEK_OF_YEAR
Time => Fields computation
Determine which calendar fields need to be computed.
We have to call computTime in case calsys == null in
order to set calsys and cdate. (6263644)
After computing all the fields, set the field state to `COMPUTED'.
By computing time and zoneOffset separately, we can take
the wider range of time+zoneOffset than the previous
Handle Gregorian dates.
See if we can use gdate to avoid date calculation.
Handle Julian calendar dates.
Always set the ERA and YEAR values.
Set the basic date fields.
Assume AM == 0
If we are in the cutover year, we need some special handling.
Need to take care of the "missing" days.
We need to find out where we are. The cutover
gap could even be more than one year.  (One
year difference in ~48667 years.)
The spec is to calculate WEEK_OF_YEAR in the
ISO8601-style. This creates problems, though.
If the date belongs to the last week of the
previous year, use the week number of "12/31" of
the "previous" year. Again, if the previous year is
the Gregorian cutover year, we need to take care of
it.  Usually the previous day of January 1 is
December 31, which is not always true in
The first days forms a week in which the date is included.
In case the gap is more than one year.
The first days forms a week in which the date is included.
We can always use `gcal' since Julian and Gregorian are the
same thing for this calculation.
In non-lenient mode, perform brief checking of calendar
fields which have been set externally. Through this
checking, the field values are stored in originalFields[]
to see if any of them are normalized later.
Quick validation for any out of range values
Let the super class determine which calendar fields to be
used to calculate the time.
The year defaults to the epoch start. We don't check
fieldMask for YEAR because YEAR is a mandatory field to
determine the date.
Even in lenient mode we disallow ERA values other than CE & BCE.
(The same normalization rule as add()/roll() could be
applied here in lenient mode. But this checking is kept
unchanged for compatibility as of 1.5.)
If year is 0 or negative, we need to set the ERA value later.
Calculate the time of day. We rely on the convention that
an UNSET field has 0.
The default value of AM_PM is 0 which designates AM.
Convert the time of day to the number of days and the
millisecond offset from midnight.
Calculate the fixed date since January 1, 1 (Gregorian).
Now we have to determine which calendar date it is.
If the date is relative from the beginning of the year
The date is in an "overlapping" period. No way
to disambiguate it. Determine it using the
previous date calculation.
The date is in a "missing" period.
Take the Julian date for compatibility, which
will produce a Gregorian date.
millis represents local wall-clock time in milliseconds.
Compute the time zone offset and DST offset.  There are two potential
ambiguities here.  We'll assume a 2:00 am (wall time) switchover time
for discussion purposes here.
1. The transition into DST.  Here, a designated time of 2:00 am - 2:59 am
can be in standard or in DST depending.  However, 2:00 am is an invalid
representation (the representation jumps from 1:59:59 am Std to 3:00:00 am DST).
We assume standard time.
2. The transition out of DST.  Here, a designated time of 1:00 am - 1:59 am
can be in standard or DST.  Both are valid representations (the rep
jumps from 1:59:59 DST to 1:00:00 Std).
Again, we assume standard time.
We use the TimeZone object, unless the user has explicitly set the ZONE_OFFSET
or DST_OFFSET fields; then we use those fields.
Adjust the time zone offset values to get the UTC time.
Set this calendar's time in milliseconds
Restore the original field values
No need to check if MONTH has been set (no isSet(MONTH)
call) since its unset value happens to be JANUARY (0).
If the month is out of range, adjust it into range
Get the fixed date since Jan 1, 1 (Gregorian). We are on
the first day of either `month' or January in 'year'.
We are on the first day of the month. Just add the
offset if DAY_OF_MONTH is set. If the isSet call
returns false, that means DAY_OF_MONTH has been
selected just because of the selected
combination. We don't need to add any since the
default value is the 1st.
To avoid underflow with DAY_OF_MONTH-1, add
DAY_OF_MONTH, then subtract 1.
If we have enough days in the first week, then
move to the previous week.
In lenient mode, we treat days of the previous
months as a part of the specified
WEEK_OF_MONTH. See 4633646.
We are basing this on the day-of-week-in-month.  The only
trickiness occurs if the day-of-week-in-month is
Go to the first day of the next week of
the specified week boundary.
Then, get the day of week date on or before the last date.
January 1 of the year doesn't exist.  Use
gregorianCutoverDate as the first day of the
We are on the first day of the year.
Add the offset, then subtract 1. (Make sure to avoid underflow.)
If we have enough days in the first week, then move
to the previous week.
Create a clone and normalize the calendar fields
Dates before the cutover date don't exist
in the same (Gregorian) year. So, no
January 1 exists in the year. Use the
cutover date as the first day of the year.
January 1 of the normalized year should exist.
The cutover happened on January 1.
The cutover happened sometime during the year.
The cutover happened in the month.
The "gap" fits in the same month.
Use the cutover date as the first day of the month.
The cutover happened before the month.
Note that the identity string is dependent on 3 variables:
- the name of the subclass of Key
- the identityHashCode of the subclass of Key
- the integer key of the Key
It is theoretically possible for 2 distinct keys to collide
along all 3 of those attributes in the context of multiple
class loaders, but that occurrence will be extremely rare and
we account for that possibility below in the recordIdentity
method by slightly relaxing our uniqueness guarantees if we
end up in that situation.
Note that this system can fail in a mostly harmless
way.  If we end up generating the same identity
String for 2 different classes (a very rare case)
then we correctly avoid throwing the exception above,
but we are about to drop through to a statement that
will replace the entry for the old Key subclass with
an entry for the new Key subclass.  At that time the
old subclass will be vulnerable to someone generating
a duplicate Key instance for it.  We could bail out
of the method here and let the old identity keep its
record in the map, but we are more likely to see a
duplicate key go by for the new class than the old
one since the new one is probably still in the
initialization stage.  In either case, the probability
of loading 2 classes in the same VM with the same name
and identityHashCode should be nearly impossible.
Note: Use a weak reference to avoid holding on to extra
objects and classes after they should be unloaded.
## javac bug?
Funnel each key/value pair through our protected put method
this shouldn't happen, since we are Cloneable
retrieve Algorithm Attribute from ds:Transform
are we already registered?
are we already registered?
give it to the current document
AttributesImpl.java - default implementation of Attributes.
Written by David Megginson
NO WARRANTY!  This class is in the public domain.
$Id: AttributesImpl.java,v 1.2 2004/11/03 22:53:08 jsuttor Exp $
Implementation of org.xml.sax.Attributes.
end of AttributesImpl.java
Debug.java - Print debug messages
Because nodes are added in document order,
duplicates can be eliminated easily at this stage.
Clear _nodes array
Get the mapping table for the document containing the context node
Split argument to id function into XML whitespace separated tokens
If input was from W3C DOM, use DOM's getElementById to do
Did we find the context node in the set of nodes?
Didn't find the context node in the set of nodes returned by id
Get the mapping table for the document containing the context node
Check whether the context node is present in the set of nodes
returned by the key function
The particular key name identifies no nodes in this document
If a MultiDOM, ensure _enhancedDOM is correctly set
so that getElementById() works in lookupNodes below
Get mapping from key values/IDs to DTM nodes for this document
For id function, tokenize argument as whitespace separated
list of values and look up nodes identified by each ID.
Does the ID map to any node in the document?
If input was from W3C DOM, use DOM's getElementById to do
If we found any nodes, merge them into the cumulative
For key function, map key value to nodes
If the arugment to the function is a node set, set the
context node on it.
If at most one key value or at most one string argument to id
resulted in nodes being returned, use the IntegerArray
stored at _nodes directly.  This relies on the fact that the
IntegerArray never includes duplicate nodes and is always stored
in document order.
All nodes retrieved are in the same document
Is the argument not a node set?
Look up nodes returned for the single string argument
For each node in the node set argument, get the string value
and look up the nodes returned by key or id for that string
value.  If at most one string value has nodes associated,
the nodes will be stored in _nodes; otherwise, the nodes
will be placed in a heap.
If nodes are stored in _nodes, take advantage of the fact that
there are no duplicates.  Otherwise, fall back to the base heap
implementaiton and hope it does a good job with this.
If nodes are stored in _nodes, take advantage of the fact that
there are no duplicates and they are stored in document order.
Otherwise, fall back to the base heap implementation to do a
good job with this.
Common UI methods
And update the last divider location.
Update the JSplitPane on the screen
Update the JSplitPane on the screen
Update the JSplitPane on the screen
Update the JSplitPane on the screen
Accessibility support
FIXME: [[[WDW - Should also add BUSY if this implements
Adjustable at some point.  If this happens, we probably
should also add actions.]]]
TIGER - 4422535
inner class AccessibleJSplitPane
read and discard the repository ID
write the repository ID
NOTE:  This implementation is here solely because we can't add new
abstract methods to an existing class.  There is almost ALWAYS a
better, faster way to do this.
NOTE: This implementation probably is wrong for most situations
because it fails to take into account the possibility that a
CharacterIterator passed to setText() may not have a begin offset
of 0.  But since the abstract BreakIterator doesn't have that
knowledge, it assumes the begin offset is 0.  If you subclass
BreakIterator, copy the SimpleTextBoundary implementation of this
function into your subclass.  [This should have been abstract at
this level, but it's too late to fix that now.]
raises exception on error
The code below reads the reply body in some cases
SYSTEM_EXCEPTION & LOCATION_FORWARD
do nothing. The client stub will read the exception from body.
Note, this writes only the header information. SystemException or
IOR may be written afterwards into the reply mesg body.
start the content model: did not see any children
convinient method: when error occurs, to find a matching decl
from the candidate elements.
we only try to look for a matching decl if we have not seen
this element yet.
found the decl, mark this element as "seen".
couldn't find the decl, change to error state.
If <all> has minOccurs of zero and there are
no children to validate, it is trivially valid
if one element is required, but not present, then error
check whether there is conflict between any two leaves
REVISIT: do we want to report all errors? or just one?
we only try to look for a matching decl if we have not seen
this element yet.
REMIND: remove when filtering is done at lower level
skip value for unrecognized key
To be fully implemented in a future release
To be fully implemented in a future release
To be fully implemented in a future release
To be fully implemented in a future release
To be fully implemented in a future release
To be fully implemented in a future release
To be fully implemented in a future release
Fields, i.e., variables of class
methods defined in the class
attributes defined in the class
Generated in memory
Allowed for backward compatibility
Get source file name if available
May be zero -> class is java.lang.Object
Debugging ... on/off
Get path separator either / or \ usually
End of file.
currently we have a broken situation where if a developer
takes the border from a JComboBox and sets it on a JTextField
then the codepath will eventually lead back to this method
but pass in a JTextField instead of JComboBox! In case this
happens, we just return the normal synth state for the component
instead of doing anything special
for editable combos the editor component has the focus not the
combo box its self, so we should make the combo paint focused
when its editor has focus
end UI Initialization
begin ComponentUI Implementation
Fix for 4238829: should lay out the JPanel.
SynthComboBoxRenderer should have installed Name while constructor is working.
The setName invocation in the SynthComboBoxRenderer() constructor doesn't work
because of the opaque property is installed in the constructor based on the
component name (see GTKStyle.isOpaque())
The renderer component should inherit the enabled and
orientation state of its parent combobox.  This is
especially needed for GTK comboboxes, where the
ListCellRenderer's state determines the visual state
of the combobox.
repaint whole combo on focus gain
repaint whole combo on focus loss
bug! see 26869
-- Begin Closure interface --------------------
Only one reference per variable
-- End Closure interface ----------------------
Parse the select expression (node string value if no expression)
Get the sort order; default is 'ascending'
Get the sort data type; default is text
bug! see 26869
Get the case order; default is language dependant
If the sort data-type is not set we use the natural data-type
of the data we will sort
bug! see 26869
Backwards branches are prohibited if an uninitialized object is
on the stack by section 4.9.4 of the JVM Specification, 2nd Ed.
We don't know whether this code might contain backwards branches
so we mustn't create the new object until after we've created
the suspect arguments to its constructor.  Instead we calculate
the values of the arguments to the constructor first, store them
in temporary variables, create the object and reload the
arguments from the temporaries to avoid the problem.
Get the current node iterator
Compile the code for the NodeSortRecord producing class and pass
that as the last argument to the SortingIterator constructor.
Backwards branches are prohibited if an uninitialized object is
on the stack by section 4.9.4 of the JVM Specification, 2nd Ed.
We don't know whether this code might contain backwards branches
so we mustn't create the new object until after we've created
the suspect arguments to its constructor.  Instead we calculate
the values of the arguments to the constructor first, store them
in temporary variables, create the object and reload the
arguments from the temporaries to avoid the problem.
Compile code that initializes the static _sortOrder
Initialize closure variables in sortRecordFactory
Discard duplicate variable references
Store variable in new closure
Add a new instance variable for each var in closure
Discard duplicate variable references
Define a constructor for this class
Push all parameters onto the stack and called super.<init>()
Override the definition of makeNodeSortRecord()
Initialize closure in record class
Get field from factory class
Put field in record class
This generates a new class for handling this specific sort
Add a new instance variable for each var in closure
Set the name of the inner class in this sort object
Discard duplicate variable references
Call the constructor in the NodeSortRecord superclass
Values needed for the switch statement
Compile switch statement only if the key has multiple levels
Put the parameter to the swtich statement on the stack
Append the switch statement here later on
Append all the cases for the switch statment
Compile def. target for switch statement if key has multiple levels
Append the default target - it will _NEVER_ be reached
does this permission have a wildcard at the end?
the name without the wildcard on the end
is this permission the old-style exitVM permission (pre JDK 1.6)?
Is wildcard or ends with ".*"?
one wildcard can imply another
make sure ap.path is longer so a.b.* doesn't imply a.b
a non-wildcard can't imply a wildcard
init is called to initialize the rest of the values.
make sure we only add new BasicPermissions of the same class
Also check null for compatibility with deserialized form from
adding first permission
No sync on all_allowed; staleness OK
random subclasses of BasicPermission do not imply each other
short circuit if the "*" Permission was added
Check for full match first. Then work our way up the
path looking for matches on a.b..*
we have a direct hit!
work our way up the tree...
we don't have to check for "*" as it was already checked
at the top (all_allowed), so we just return false
Convert Iterator of Map values into an Enumeration
Need to maintain serialization interoperability with earlier releases,
which had the serializable field:
Don't call out.defaultWriteObject()
Copy perms into a Hashtable
Write out serializable fields
Don't call defaultReadObject()
Read in serialized fields
writeObject writes a Hashtable<String, Permission> for the
permissions key, so this cast is safe, unless the data is corrupt.
At this point the AST is already built and we should be able to
find any declared global variable or parameter
If in a top-level element, create dependency to the referenced var
read and discard the repository ID
write the repository ID
name server database directory
create the ORB Object
set up the database directory
create the persistent name service
add root naming context to initial naming
wait for invocations
Instance variables components and names above are kept in sync
with these two arrays at all times.
We can be sure that typeCode is of kind tk_struct
Initialize components lazily, on demand.
This is an optimization in case the user is only interested in storing Anys.
We can be sure that typeCode is of kind tk_struct
For DynAnyComplex, the operation sets the current position to -1
for empty exceptions and to zero for all other TypeCodes.
The members (if any) are (recursively) initialized to their default values.
DynAny interface methods
_REVISIT_ Overridden to provide more efficient copying.
Copies all the internal representations which is faster than reconstructing them.
Creates references to the parameter instead of copying it.
We know that this is of kind tk_struct
_REVISIT_ More info
_REVISIT_ More info
Creates the appropriate subtype without copying the Any
_REVISIT_ More info
Creates references to the parameter instead of copying it.
We know that this is of kind tk_struct
_REVISIT_ More info
_REVISIT_ More info
_REVISIT_ More info
Initializes components, names, nameValuePairs and nameDynAnyPairs representation
from the Any representation
This typeCode is of kind tk_struct.
Creates the appropriate subtype without copying the Any
System.out.println("Created DynAny for " + memberName +
Initializes components, names, nameValuePairs and nameDynAnyPairs representation
from the internal TypeCode information with default values
This is not done recursively, only one level.
More levels are initialized lazily, on demand.
This typeCode is of kind tk_struct.
System.out.println("Created DynAny for " + memberName +
get a hold of the default initialized Any without copying
It is probably right not to destroy the released component DynAnys.
Some other DynAny or a user variable might still hold onto them
and if not then the garbage collector will take care of it.
may be laziliy initialized
right, left spliterators
As there can only ever be one autoscroller active these fields are
static. The Timer is recreated as necessary to target the appropriate
The public API, all methods are cover methods for an instance method
Methods mirror the public static API
-- This file was mechanically generated: Do not edit! --
This should return a Class definition if using TrAX
This code is only run when the native API is used
Old NodeSortRecordFactory constructor had no lang or case_order
arguments.  Provide default values in that case for binary
Set up array of zero-length strings as default values
of lang and case_order
WeakReference's aren't serializable.
The Component's that reference an Action do so through a strong
reference, so that there is no need to check for serialized.
Check to see whether any old buttons have
been enqueued for GC.  If so, look up their
PCL instance and remove it from its Action.
Will only happen if serialized and real target was null
no need to sync in the future
---- variables -----------------------------------
--- gap management -------------------------------
Move gap to end of block.
Move gap to beginning of block.
The gap is properly inside the target block.
No data movement necessary, simply move both gap pointers.
Expand the array if the gap is too small.
Pre-shift the gap, to reduce total movement.
Copy array items to new end of array.
Move gap up, move data down.
Move gap down, move data up.
==== Constructors ====
NodeSetDTM will call this, and so it's not a good thing to throw
an assertion here.
If root is DTM.NULL, then something's wrong with the context
not resetting the iterator on purpose!!!
If the cache is on, and the node has already been found, then
just return from the list.
There is a cache
The node is in the cache, so just return it.
We have exhausted the iterator, and if there is a cache
it must have all nodes in it by now, so let the cache
know that it is complete.
getVector().RemoveAllNoClear();   Is this good?
though may be surprising if it also has an iterator!
This should never happen
Keep our superclass informed of the current NodeVector
Nodes from the iterator are cached
All of the nodes from the iterator are cached
so just return the number of nodes in the cache
If this NodeSequence wraps a mutable nodeset, then
m_last will not reflect the size of the nodeset if
it has been mutated...
In making this clone of an iterator we are making
another NodeSequence object it has a reference
to the same IteratorCache object as the original
so we need to remember that more than one
NodeSequence object shares the cache.
In making this clone of an iterator we are making
another NodeSequence object it has a reference
to the same IteratorCache object as the original
so we need to remember that more than one
NodeSequence object shares the cache.
can't be sure?
This needs to do a binary search, but a binary search
is somewhat tough because the sequence test involves
Duplicate, suppress insert
end addNodeInDocOrder(Vector v, Object obj)
Keep our superclass informed of the current NodeVector
... if we don't the smoketest fails (don't know why).
A copy of the code of what SetVector() would do.
Keep our superclass informed of the current NodeVector
current index, modified on advance/split
For efficiency, especially in executors with limited
parallelism, check to see if previously submitted tasks are
done before submitting more of them. This interleaving
plus the exception mechanics account for messiness of main
Record exceptions so that if we fail to obtain any
result, we can throw the last exception we got.
Start one task for sure; the rest incrementally
Interleave time checks and calls to execute in case
executor doesn't have any/much parallelism.
need to implement for JSR204
Character <= 0xff (basic latin) is handled by internal fast-path
to avoid initializing large tables.
Note: performance of this "fast-path" code may be sub-optimal
in negative cases for some accessors due to complicated ranges.
Should revisit after optimization of table initialization.
eliminate loops in case of the boot
ClassLoader returning itself as a parent
REVISIT - This should go in an abstract class called
BufferManagerReadBase which should implement
BufferManagerRead. Then, this class should extend
REVISIT - should we consider throwing an exception similar to what's
done for underflow()???
Mark and reset handler -------------------------
This will never happen
Nothing to close and cleanup.
real implementation is in sun.awt.im.InputContext
real implementation is in sun.awt.im.InputContext
real implementation is in sun.awt.im.InputContext
real implementation is in sun.awt.im.InputContext
real implementation is in sun.awt.im.InputContext
real implementation is in sun.awt.im.InputContext
real implementation is in sun.awt.im.InputContext
real implementation is in sun.awt.im.InputContext
real implementation is in sun.awt.im.InputContext
real implementation is in sun.awt.im.InputContext
real implementation is in sun.awt.im.InputContext
real implementation is in sun.awt.im.InputContext
Use getHostString() to avoid reverse lookups
No Authentication required. We're done then!
GSSName name = manager.createName("SERVICE:socks@"+server,
GSSContext context = manager.createContext(name, null, null,
send the output token if generated
if (i == len)
/* RFC 1961 states that if Context initialisation fails the connection
MUST be closed */
This is the general case
server is not null only when the socket was created with a
specified proxy in which case it does bypass the ProxySelector
Use getHostString() to avoid reverse lookups
This shouldn't happen
Use getHostString() to avoid reverse lookups
Connects to the SOCKS server
Worked, let's get outta here
Ooops, let's notify the ProxySelector
Will continue the while loop and try the next proxy
Connects to the SOCKS server
cmdIn & cmdOut were initialized during the privilegedConnect() call
SOCKS Protocol version 4 doesn't know how to deal with
DOMAIN type of addresses (unresolved addresses here)
This is SOCKS V5
Maybe it's not a V5 sever after all
Let's try V4 before we give up
SOCKS Protocol version 4 doesn't know how to deal with
DOMAIN type of addresses (unresolved addresses here)
this is a client socket, not a server socket, don't
call the SOCKS proxy for a bind!
Connects to the SOCKS server
This is the general case
server is not null only when the socket was created with a
specified proxy in which case it does bypass the ProxySelector
Use getHostString() to avoid reverse lookups
This shouldn't happen
Use getHostString() to avoid reverse lookups
Connects to the SOCKS server
Ooops, let's notify the ProxySelector
Will continue the while loop and try the next proxy
Maybe it's not a V5 sever after all
Let's try V4 before we give up
We're OK. Let's issue the BIND command.
Not a Socks ServerSocket.
Sends the "SOCKS BIND" request.
Need to do that so that the socket won't be closed
when the ServerSocket is closed by the user.
It kinds of detaches the Socket because it is now
BEGIN   Package Private methods ... to be made public later
END     Package Private methods ... to be made public later
other fields are bit-copied
get resource bundle data
Avoid potential recursions
different for Arabic,etc.
string representation new since 1.6
Try to obtain the currency used in the locale's country.
Check for empty country string separately because it's a valid
country ID for Locale (and used for the C locale), but not a valid
ISO 3166 country code, and exceptions are expensive.
use default values below for compatibility
Currently the monetary decimal separator is the same as the
standard decimal separator for all locales that we support.
If that changes, add a new entry to NumberElements.
didn't have locale; use root locale
didn't have exponentialSeparator. Create one using exponential
Field new in JDK 1.1.6
Field new in JDK 1.1.6
Field new in JDK 1.6
currency; only the ISO code is serialized.
Proclaim JDK 1.1 FCS compatibility
The internal serial version which says which version was written
- 0 (default) for version up to JDK 1.1.5
- 1 for version from JDK 1.1.6, which includes two new fields:
monetarySeparator and exponential.
- 2 for version from J2SE 1.4, which includes locale field.
- 3 for version from J2SE 1.6, which includes exponentialSeparator field.
If the Stub is not connected to an ORB, BAD_OPERATION exception
will be raised by the code below.
no need to call init() because of calls to hashCode() below
hashCodes being the same does not mean equality. The stubs still
could be pointing to different IORs. So, do a literal comparison.
Apparently the ONLY way to do this (other than using private
reflection)  toString, because it is not possible to directly
access the StubDelegateImpl from the Stub.
These message should be read from a locale-specific resource bundle
These properties are not used directly, but are kept as
private members to avoid being GC'd.
Set the flag which determines which version of Windows should
be rendered. This flag only need to be set once.
if version <= 4.0 then the classic LAF should be loaded.
Using the fonts set by the user can potentially cause
performance and compatibility issues, so allow this feature
to be switched off either at runtime or programmatically
XXX - there are probably a lot of redundant values that could be removed.
ie. Take a look at RadioButtonBorder, etc...
XXX - some of these doens't seem to be used
Set the flag which determines which version of Windows should
be rendered. This flag only need to be set once.
if version <= 4.0 then the classic LAF should be loaded.
The following four lines were commented out as part of bug 4991597
This code *is* correct, however it differs from WindowsXP and is, apparently
a Windows XP bug. Until Windows fixes this bug, we shall also exhibit the same
Object ReadOnlyTextBackground = new XPColorValue(Part.EP_EDITTEXT, State.READONLY, Prop.FILLCOLOR,
Object DisabledTextBackground = new XPColorValue(Part.EP_EDITTEXT, State.DISABLED, Prop.FILLCOLOR,
These desktop properties are not used directly, but are needed to
trigger realoading of UI's.
this key defines which of the various cues to render
Overridden from BasicL&F. This L&F should play all sounds
all the time. The infrastructure decides what to play.
This is disabled until sound bugs can be resolved.
Button.foreground, Button.shadow, Button.darkShadow,
Button.disabledForground, and Button.disabledShadow are only
used for Windows Classic. Windows XP will use colors
from the current visual style.
W2K keyboard navigation hidding.
margin is 2 all the way around, BasicBorders.RadioButtonBorder
(checkbox uses RadioButtonBorder) is 2 all the way around too.
The constructor takes one arg: an array of UIDefaults.LazyValue
representing the icons
Internal Frame Auditory Cue Mappings
Menu Item Auditory Cue Mapping
indicates that keyboard navigation won't skip disabled menu items
margin is 2 all the way around, BasicBorders.RadioButtonBorder
is 2 all the way around too.
Option Pane Auditory Cue Mappings
These bindings are only enabled when there is a default
button set on the rootpane.
cell text color
cell background color
grid line color
header text color
use default bg from XP styles
or white bg otherwise
When a desktop property change is detected, these classes must be
reinitialized in the defaults table to ensure the classes reference
the updated desktop property values (colors mostly)
For focus rectangle for cells and trees.
Toggle flag for drawing the mnemonic state
Flag which indicates that the Win98/Win2k/WinME features
should be disabled.
Do not hide mnemonics if the UI defaults do not support this
Do not hide mnemonics if the UI defaults do not support this
Runnable appears to block until completed playing, hence
start up another thread to handle playing.
This desktop property is needed to trigger reloading the icon.
It is kept in member variable to avoid GC.
4950968: Workaround to mimic the way Windows maps the default
font size of 6 pts to the smallest available bitmap font size.
This happens mostly on Win 98/Me & NT.
A constant that lets you specify null when using XP styles.
This call adds a property change listener for the property,
which triggers a call to updateUI(). The value returned
is not interesting here.
Make sure property change listener is readded each time
Windows LayoutStyle.  From:
Windows doesn't spec this
Fall through to related.
Between text labels and their associated controls (for
example, text boxes and list boxes): 3
NOTE: We're not honoring:
'Text label beside a button 3 down from the top of
the button,' but I suspect that is an attempt to
enforce a baseline layout which will be handled
separately.  In order to enforce this we would need
this API to return a more complicated type (Insets,
or something else).
Between related controls: 4
Between unrelated controls: 7
This calculation comes from:
The -1 comes from experimentation.
if the component has a HI_RES_DISABLED_ICON_CLIENT_KEY
client property set to Boolean.TRUE, then use the new
hi res algorithm for creating the disabled icon (used
in particular by the WindowsFileChooserUI class)
find the average of red, green, and blue
pull out the alpha channel
calc the average
turn back into rgb
Fallback value is never used because of the configureValue method doesn't return null
check whether URI is already registered
check whether URI is already registered
needs to validate for ID attribute normalization
index either points to the discriminator or the named member is it exists.
The currently active member, which is of the same type as the discriminator.
We can be sure that typeCode is of kind tk_union
We can be sure that typeCode is of kind tk_union
Sets the current position to zero.
The discriminator value is set to a value consistent with the first named member
of the union. That member is activated and (recursively) initialized to its default value.
We can be sure that memberCount() > 0 according to the IDL language spec
Necessary to guarantee OBJECT_NOT_EXIST in member()
DynAny interface methods
_REVISIT_ More efficient copy operation
DynUnion interface methods
Sets the discriminator of the DynUnion to the specified value.
If the TypeCode of the parameter is not equivalent
to the TypeCode of the unions discriminator, the operation raises TypeMismatch.
Setting the discriminator to a value that is consistent with the currently
active union member does not affect the currently active member.
Setting the discriminator to a value that is inconsistent with the currently
active member deactivates the member and activates the member that is consistent
with the new discriminator value (if there is a member for that value)
by initializing the member to its default value.
If the discriminator value indicates a non-existent union member
this operation sets the current position to 0
(has_no_active_member returns true in this case).
Otherwise the current position is set to 1 (has_no_active_member returns false and
component_count returns 2 in this case).
_REVISIT_ Could possibly optimize here if we don't need to initialize components
Sets the discriminator to a value that is consistent with the value
of the default case of a union; it sets the current position to
zero and causes component_count to return 2.
Calling set_to_default_member on a union that does not have an explicit
default case raises TypeMismatch.
Sets the discriminator to a value that does not correspond
to any of the unions case labels.
It sets the current position to zero and causes component_count to return 1.
Calling set_to_no_active_member on a union that has an explicit default case
or on a union that uses the entire range of discriminator values
for explicit case labels raises TypeMismatch.
_REVISIT_ How does one check for "entire range of discriminator values"?
erase the discriminators value so that it does not correspond
to any of the unions case labels
Necessary to guarantee OBJECT_NOT_EXIST in member()
Returns true if the union has no active member
(that is, the unions value consists solely of its discriminator because the
discriminator has a value that is not listed as an explicit case label).
Calling this operation on a union that has a default case returns false.
Calling this operation on a union that uses the entire range of discriminator
values for explicit case labels returns false.
_REVISIT_ How does one check for "entire range of discriminator values"?
Returns the currently active member.
If the union has no active member, the operation raises InvalidValue.
Note that the returned reference remains valid only for as long
as the currently active member does not change.
Using the returned reference beyond the life time
of the currently active member raises OBJECT_NOT_EXIST.
Returns the name of the currently active member.
If the unions TypeCode does not contain a member name for the currently active member,
the operation returns an empty string.
Calling member_name on a union without an active member raises InvalidValue.
Returns the TCKind value of the TypeCode of the currently active member.
If the union has no active member, the operation raises InvalidValue.
Wrap single node path in a node set
Create new StepIterator
Backwards branches are prohibited if an uninitialized object is
on the stack by section 4.9.4 of the JVM Specification, 2nd Ed.
We don't know whether this code might contain backwards branches,
so we mustn't create the new object until after we've created
the suspect arguments to its constructor.  Instead we calculate
the values of the arguments to the constructor first, store them
in temporary variables, create the object and reload the
arguments from the temporaries to avoid the problem.
Recursively compile 2 iterators
Initialize StepIterator with iterators from the stack
This is a special case for the * path with or without predicates
------------------------- JDBC 4.1 -----------------------------------
Note: empty strings as paramete names are now outlawed.
The .equals("") is for compatibility with current JVM
behavior.  It may be removed at some point.
Package-private accessor to the real name field.
no caching for now
Only annotations on classes are inherited, for all other
objects getDeclaredAnnotation is the same as
Only annotations on classes are inherited, for all other
objects getDeclaredAnnotations is the same as
this field is necessary because JComponent.ui is transient
when layerUI is serializable
filter out all unaccepted events
REVISIT: we are losing the type information in DOM during serialization
Support for DOM Level 3 renameNode method.
Note: This only deals with part of the pb. It is expected to be
called after the Attr has been detached for one thing.
CoreDocumentImpl does all the work.
create a real text node as child if we don't have one yet
REVISIT: should an attribute that is not in the tree return
take care of case where there are kids
Need to break the association w/ original kids
Cloning an Attribute always clones its children,
since they represent its value, no matter whether this
is a deep clone or not
Can no longer just discard the kids; they may have
event listeners waiting for them to disconnect.
create an actual text node as our child so
that we can use it in the event
simply discard children if any
remove ref from first child to last child
then remove ref to current value
Create and add the new one, generating only non-aggregate events
(There are no listeners on the new Text, but there may be
capture/bubble listeners on the Attr.
Note that aggregate events are NOT dispatched here,
since we need to combine the remove and insert.
if there are any event handlers create a real node
directly store the string
if we have an owner, ownerNode is our ownerElement, otherwise it's
our ownerDocument and we don't have an ownerElement
if we have an owner, ownerNode is our ownerElement, otherwise it's
our ownerDocument and we don't have an ownerElement
No need to normalize if already normalized or
if value is kept as a String.
If kid is a text node, we need to check for one of two
1) There is an adjacent text node
2) There is no adjacent text node, but kid is
an empty text node.
If an adjacent text node, merge it with kid
Don't advance; there might be another.
If kid is empty, remove it
JKESS: KNOWN ISSUE HERE
last child is stored as the previous sibling of first child
store lastChild as previous sibling of first child
Tail-call; optimizer should be able to do good things with.
SLOW BUT SAFE: We could insert the whole subtree without
juggling so many next/previous pointers. (Wipe out the
parent's child-list, patch the parent pointers, set the
ends of the list.) But we know some subclasses have special-
case behavior they add to insertBefore(), so we don't risk it.
This approch also takes fewer bytecodes.
NOTE: If one of the children is not a legal child of this
node, throw HIERARCHY_REQUEST_ERR before _any_ of the children
have been transferred. (Alternative behaviors would be to
reparent up to the first failure point or reparent all those
which are acceptable to the target node, neither of which is
as robust. PR-DOM-0818 isn't entirely clear on which it
No need to check kids for right-document; if they weren't,
they wouldn't be kids of that DocFrag.
stupid case that must be handled as a no-op triggering events...
refChild must be a child of this node (or null)
Prevent cycles in the tree
newChild cannot be ancestor of this Node,
and actually cannot be this
make sure we have a node and not a string
Convert to internal type, to avoid repeated casting
Convert to internal type, to avoid repeated casting
Attach before and after
Note: firstChild.previousSibling == lastChild!!
this our first and only child
this is an append
this is an insert
at the head of the list
somewhere in the middle
Tail-call, should be optimizable
we don't have any child per say so it can't be one of them!
Patch linked list around oldChild
Note: lastChild == firstChild.previousSibling
oldInternal == firstChild
removing first child
next line is: firstChild = oldInternal.nextSibling
removing last child
removing some other child in the middle
Save previous sibling for normalization checking.
Remove oldInternal's references to tree
If Mutation Events are being generated, this operation might
throw aggregate events twice when modifying an Attr -- once
on insertion and once on removal. DOM Level 2 does not specify
this as either desirable or undesirable, but hints that
aggregations should be issued only once per user request.
Recursively set kids
By default just change the flag to avoid calling this method again
See if insertion caused this node to be unnormalized.
If an adjacent sibling of the new child is a text node,
flag this node as unnormalized.
If the new child is not normalized,
then this node is inherently not normalized.
See if removal caused this node to be unnormalized.
If the adjacent siblings of the removed child were both text nodes,
flag this node as unnormalized.
perform default deseralization
hardset synchildren - so we don't try to sync -
it does not make any sense to try to synchildren when we just
The following is an optimization of:
The following is an optimization of:
Terminal evaluation methods
If the last intermediate operation is stateful then
evaluate directly to avoid an extra collection step
Set the depth of this, last, pipeline stage to zero to slice the
pipeline such that this operation will not be included in the
upstream slice and upstream operations will not be included
in this slice
Primitive specialization use co-variant overrides, hence is not final
Get the source spliterator of the pipeline
Adapt the source spliterator, evaluating each stateful op
in the pipeline up to and including this pipeline stage.
The depth and flags of each pipeline stage are adjusted accordingly.
Clear the short circuit flag for next pipeline stage
This stage encapsulates short-circuiting, the next
stage may not have any short-circuit operations, and
if so spliterator.forEachRemaining should be used
Inject or clear SIZED on the source pipeline stage
based on the stage's spliterator
Apply flags from the terminal operation to last pipeline stage
Shape-specific abstract methods, implemented by XxxPipeline classes
Op-specific abstract methods, implemented by the operation class
Accessor methods (LocateRequestMessage interface)
this will raise a MARSHAL exception upon errors.
A reference to the main stylesheet parser object.
A reference to an external XMLReader (SAX parser) passed to us
A reference to an external SourceLoader (for use with include/import)
A reference to the stylesheet being compiled.
Counters used by various classes to generate unique names.
Name index tables
Next available element type
Index of all registered QNames
Map of all registered elements
Map of all registered attributes
Namespace index tables
Next available namespace type
Index of all registered namespaces
Map of all registered namespaces
Map of all registered namespace prefixes
All literal text in the stylesheet
These define the various methods for outputting the translet
Compiler options (passed from command line or XSLTC client)
Check if the function is not loaded already
Return loaded class
Open input stream from URL and wrap inside InputSource
Open input stream from URL and wrap inside InputSource
We have nothing else!!!
The systemId may not be set, so we'll have to check the URL
Set the translet class name if not already set
Ensure we have a non-empty class name at this point
default translet name
Get the root node of the abstract syntax tree
Compile the translet - this is where the work is done!
Create a Stylesheet element from the root node
Create AST under the Stylesheet element (parse & type-check)
Generate the bytecodes and output the translet class(es)
Class synchronization is needed for BCEL
reset this here to be sure it is not re-used
Get the number of stylesheets (ie. URLs) in the vector
Return straight away if the vector is empty
Special handling needed if the URL count is one, becuase the
_className global must not be reset if it was set explicitly
Traverse all elements in the vector and compile
reset, so that new name will be computed
Register element (full QName)
namespace::ext2:ped2 will be made empty in TypedNamespaceIterator
create the manifest
dump() closes it's output stream
Character data could take up to three-times as much space when
written to the class file as UTF-8.  The maximum size for a
constant is 65535/3.  If we exceed that,
(We really should use some "bin packing".)
Initializing the Character Flag Array
Code generated by: XMLCharGenerator.
Fill 3 of value (byte) 49
Fill 6 of value (byte) 49
Fill 2 of value (byte) -71
Fill 10 of value (byte) -71
Fill 2 of value (byte) 49
Fill 26 of value (byte) -3
Fill 2 of value (byte) 33
Fill 26 of value (byte) -3
Fill 60 of value (byte) 33
Fill 8 of value (byte) 33
Fill 23 of value (byte) -19
Fill 31 of value (byte) -19
Fill 58 of value (byte) -19
Fill 2 of value (byte) 33
Fill 11 of value (byte) -19
Fill 2 of value (byte) 33
Fill 8 of value (byte) -19
Fill 53 of value (byte) -19
Fill 68 of value (byte) -19
Fill 9 of value (byte) 33
Fill 36 of value (byte) -19
Fill 3 of value (byte) 33
Fill 2 of value (byte) -19
Fill 4 of value (byte) 33
Fill 30 of value (byte) -19
Fill 56 of value (byte) 33
Fill 89 of value (byte) -19
Fill 18 of value (byte) 33
Fill 7 of value (byte) -19
Fill 14 of value (byte) 33
Fill 2 of value (byte) -87
Fill 46 of value (byte) 33
Fill 70 of value (byte) -87
Fill 26 of value (byte) 33
Fill 2 of value (byte) -87
Fill 36 of value (byte) 33
Fill 3 of value (byte) -19
Fill 20 of value (byte) -19
Fill 44 of value (byte) -19
Fill 7 of value (byte) -19
Fill 3 of value (byte) 33
Fill 18 of value (byte) -19
Fill 13 of value (byte) 33
Fill 12 of value (byte) -19
Fill 66 of value (byte) -19
Fill 12 of value (byte) -19
Fill 36 of value (byte) -19
Fill 4 of value (byte) -87
Fill 9 of value (byte) 33
Fill 53 of value (byte) -19
Fill 2 of value (byte) 33
Fill 2 of value (byte) -19
Fill 2 of value (byte) 33
Fill 2 of value (byte) -19
Fill 3 of value (byte) 33
Fill 28 of value (byte) -19
Fill 2 of value (byte) 33
Fill 8 of value (byte) -19
Fill 2 of value (byte) 33
Fill 2 of value (byte) -19
Fill 55 of value (byte) 33
Fill 38 of value (byte) -19
Fill 2 of value (byte) 33
Fill 7 of value (byte) 33
Fill 38 of value (byte) -19
Fill 10 of value (byte) 33
Fill 17 of value (byte) -87
Fill 23 of value (byte) -87
Fill 3 of value (byte) -87
Fill 2 of value (byte) -87
Fill 11 of value (byte) 33
Fill 27 of value (byte) -19
Fill 5 of value (byte) 33
Fill 3 of value (byte) -19
Fill 46 of value (byte) 33
Fill 26 of value (byte) -19
Fill 5 of value (byte) 33
Fill 10 of value (byte) -19
Fill 8 of value (byte) -87
Fill 13 of value (byte) 33
Fill 10 of value (byte) -87
Fill 6 of value (byte) 33
Fill 71 of value (byte) -19
Fill 2 of value (byte) 33
Fill 5 of value (byte) -19
Fill 15 of value (byte) -19
Fill 4 of value (byte) -19
Fill 15 of value (byte) -87
Fill 2 of value (byte) -19
Fill 2 of value (byte) -87
Fill 4 of value (byte) -87
Fill 2 of value (byte) 33
Fill 10 of value (byte) -87
Fill 519 of value (byte) 33
Fill 3 of value (byte) -87
Fill 53 of value (byte) -19
Fill 2 of value (byte) 33
Fill 16 of value (byte) -87
Fill 3 of value (byte) 33
Fill 4 of value (byte) -87
Fill 3 of value (byte) 33
Fill 10 of value (byte) -19
Fill 2 of value (byte) -87
Fill 2 of value (byte) 33
Fill 10 of value (byte) -87
Fill 17 of value (byte) 33
Fill 3 of value (byte) -87
Fill 8 of value (byte) -19
Fill 2 of value (byte) 33
Fill 2 of value (byte) -19
Fill 2 of value (byte) 33
Fill 22 of value (byte) -19
Fill 7 of value (byte) -19
Fill 3 of value (byte) 33
Fill 4 of value (byte) -19
Fill 2 of value (byte) 33
Fill 7 of value (byte) -87
Fill 2 of value (byte) 33
Fill 2 of value (byte) -87
Fill 2 of value (byte) 33
Fill 3 of value (byte) -87
Fill 9 of value (byte) 33
Fill 4 of value (byte) 33
Fill 2 of value (byte) -19
Fill 3 of value (byte) -19
Fill 2 of value (byte) -87
Fill 2 of value (byte) 33
Fill 10 of value (byte) -87
Fill 2 of value (byte) -19
Fill 16 of value (byte) 33
Fill 2 of value (byte) 33
Fill 6 of value (byte) -19
Fill 4 of value (byte) 33
Fill 2 of value (byte) -19
Fill 2 of value (byte) 33
Fill 22 of value (byte) -19
Fill 7 of value (byte) -19
Fill 2 of value (byte) -19
Fill 2 of value (byte) -19
Fill 2 of value (byte) -19
Fill 2 of value (byte) 33
Fill 5 of value (byte) -87
Fill 4 of value (byte) 33
Fill 2 of value (byte) -87
Fill 2 of value (byte) 33
Fill 3 of value (byte) -87
Fill 11 of value (byte) 33
Fill 4 of value (byte) -19
Fill 7 of value (byte) 33
Fill 12 of value (byte) -87
Fill 3 of value (byte) -19
Fill 12 of value (byte) 33
Fill 3 of value (byte) -87
Fill 7 of value (byte) -19
Fill 3 of value (byte) -19
Fill 22 of value (byte) -19
Fill 7 of value (byte) -19
Fill 2 of value (byte) -19
Fill 5 of value (byte) -19
Fill 2 of value (byte) 33
Fill 8 of value (byte) -87
Fill 3 of value (byte) -87
Fill 3 of value (byte) -87
Fill 18 of value (byte) 33
Fill 5 of value (byte) 33
Fill 10 of value (byte) -87
Fill 17 of value (byte) 33
Fill 3 of value (byte) -87
Fill 8 of value (byte) -19
Fill 2 of value (byte) 33
Fill 2 of value (byte) -19
Fill 2 of value (byte) 33
Fill 22 of value (byte) -19
Fill 7 of value (byte) -19
Fill 2 of value (byte) -19
Fill 2 of value (byte) 33
Fill 4 of value (byte) -19
Fill 2 of value (byte) 33
Fill 6 of value (byte) -87
Fill 3 of value (byte) 33
Fill 2 of value (byte) -87
Fill 2 of value (byte) 33
Fill 3 of value (byte) -87
Fill 8 of value (byte) 33
Fill 2 of value (byte) -87
Fill 4 of value (byte) 33
Fill 2 of value (byte) -19
Fill 3 of value (byte) -19
Fill 4 of value (byte) 33
Fill 10 of value (byte) -87
Fill 18 of value (byte) 33
Fill 2 of value (byte) -87
Fill 6 of value (byte) -19
Fill 3 of value (byte) 33
Fill 3 of value (byte) -19
Fill 4 of value (byte) -19
Fill 3 of value (byte) 33
Fill 2 of value (byte) -19
Fill 2 of value (byte) -19
Fill 3 of value (byte) 33
Fill 2 of value (byte) -19
Fill 3 of value (byte) 33
Fill 3 of value (byte) -19
Fill 3 of value (byte) 33
Fill 8 of value (byte) -19
Fill 3 of value (byte) -19
Fill 4 of value (byte) 33
Fill 5 of value (byte) -87
Fill 3 of value (byte) 33
Fill 3 of value (byte) -87
Fill 4 of value (byte) -87
Fill 9 of value (byte) 33
Fill 15 of value (byte) 33
Fill 9 of value (byte) -87
Fill 17 of value (byte) 33
Fill 3 of value (byte) -87
Fill 8 of value (byte) -19
Fill 3 of value (byte) -19
Fill 23 of value (byte) -19
Fill 10 of value (byte) -19
Fill 5 of value (byte) -19
Fill 4 of value (byte) 33
Fill 7 of value (byte) -87
Fill 3 of value (byte) -87
Fill 4 of value (byte) -87
Fill 7 of value (byte) 33
Fill 2 of value (byte) -87
Fill 9 of value (byte) 33
Fill 2 of value (byte) -19
Fill 4 of value (byte) 33
Fill 10 of value (byte) -87
Fill 18 of value (byte) 33
Fill 2 of value (byte) -87
Fill 8 of value (byte) -19
Fill 3 of value (byte) -19
Fill 23 of value (byte) -19
Fill 10 of value (byte) -19
Fill 5 of value (byte) -19
Fill 4 of value (byte) 33
Fill 7 of value (byte) -87
Fill 3 of value (byte) -87
Fill 4 of value (byte) -87
Fill 7 of value (byte) 33
Fill 2 of value (byte) -87
Fill 7 of value (byte) 33
Fill 2 of value (byte) -19
Fill 4 of value (byte) 33
Fill 10 of value (byte) -87
Fill 18 of value (byte) 33
Fill 2 of value (byte) -87
Fill 8 of value (byte) -19
Fill 3 of value (byte) -19
Fill 23 of value (byte) -19
Fill 16 of value (byte) -19
Fill 4 of value (byte) 33
Fill 6 of value (byte) -87
Fill 2 of value (byte) 33
Fill 3 of value (byte) -87
Fill 4 of value (byte) -87
Fill 9 of value (byte) 33
Fill 8 of value (byte) 33
Fill 2 of value (byte) -19
Fill 4 of value (byte) 33
Fill 10 of value (byte) -87
Fill 145 of value (byte) 33
Fill 46 of value (byte) -19
Fill 2 of value (byte) -19
Fill 7 of value (byte) -87
Fill 5 of value (byte) 33
Fill 6 of value (byte) -19
Fill 9 of value (byte) -87
Fill 10 of value (byte) -87
Fill 39 of value (byte) 33
Fill 2 of value (byte) -19
Fill 2 of value (byte) 33
Fill 2 of value (byte) -19
Fill 2 of value (byte) 33
Fill 6 of value (byte) 33
Fill 4 of value (byte) -19
Fill 7 of value (byte) -19
Fill 3 of value (byte) -19
Fill 2 of value (byte) 33
Fill 2 of value (byte) -19
Fill 2 of value (byte) -19
Fill 2 of value (byte) -19
Fill 6 of value (byte) -87
Fill 2 of value (byte) -87
Fill 2 of value (byte) 33
Fill 5 of value (byte) -19
Fill 6 of value (byte) -87
Fill 2 of value (byte) 33
Fill 10 of value (byte) -87
Fill 62 of value (byte) 33
Fill 2 of value (byte) -87
Fill 6 of value (byte) 33
Fill 10 of value (byte) -87
Fill 11 of value (byte) 33
Fill 4 of value (byte) 33
Fill 2 of value (byte) -87
Fill 8 of value (byte) -19
Fill 33 of value (byte) -19
Fill 7 of value (byte) 33
Fill 20 of value (byte) -87
Fill 6 of value (byte) -87
Fill 4 of value (byte) 33
Fill 6 of value (byte) -87
Fill 21 of value (byte) -87
Fill 3 of value (byte) 33
Fill 7 of value (byte) -87
Fill 230 of value (byte) 33
Fill 38 of value (byte) -19
Fill 10 of value (byte) 33
Fill 39 of value (byte) -19
Fill 9 of value (byte) 33
Fill 2 of value (byte) -19
Fill 3 of value (byte) -19
Fill 2 of value (byte) -19
Fill 5 of value (byte) -19
Fill 41 of value (byte) 33
Fill 11 of value (byte) 33
Fill 3 of value (byte) 33
Fill 2 of value (byte) -19
Fill 3 of value (byte) 33
Fill 5 of value (byte) 33
Fill 3 of value (byte) -19
Fill 3 of value (byte) 33
Fill 2 of value (byte) -19
Fill 3 of value (byte) 33
Fill 2 of value (byte) -19
Fill 40 of value (byte) 33
Fill 9 of value (byte) 33
Fill 2 of value (byte) 33
Fill 2 of value (byte) 33
Fill 2 of value (byte) -19
Fill 7 of value (byte) 33
Fill 2 of value (byte) -19
Fill 7 of value (byte) -19
Fill 40 of value (byte) 33
Fill 4 of value (byte) 33
Fill 8 of value (byte) 33
Fill 3078 of value (byte) 33
Fill 156 of value (byte) -19
Fill 4 of value (byte) 33
Fill 90 of value (byte) -19
Fill 6 of value (byte) 33
Fill 22 of value (byte) -19
Fill 2 of value (byte) 33
Fill 6 of value (byte) -19
Fill 2 of value (byte) 33
Fill 38 of value (byte) -19
Fill 2 of value (byte) 33
Fill 6 of value (byte) -19
Fill 2 of value (byte) 33
Fill 8 of value (byte) -19
Fill 31 of value (byte) -19
Fill 2 of value (byte) 33
Fill 53 of value (byte) -19
Fill 7 of value (byte) -19
Fill 3 of value (byte) 33
Fill 3 of value (byte) -19
Fill 7 of value (byte) -19
Fill 3 of value (byte) 33
Fill 4 of value (byte) -19
Fill 2 of value (byte) 33
Fill 6 of value (byte) -19
Fill 4 of value (byte) 33
Fill 13 of value (byte) -19
Fill 5 of value (byte) 33
Fill 3 of value (byte) -19
Fill 7 of value (byte) -19
Fill 211 of value (byte) 33
Fill 13 of value (byte) -87
Fill 4 of value (byte) 33
Fill 68 of value (byte) 33
Fill 3 of value (byte) 33
Fill 2 of value (byte) -19
Fill 2 of value (byte) 33
Fill 81 of value (byte) 33
Fill 3 of value (byte) -19
Fill 3714 of value (byte) 33
Fill 25 of value (byte) 33
Fill 9 of value (byte) -19
Fill 6 of value (byte) -87
Fill 5 of value (byte) -87
Fill 11 of value (byte) 33
Fill 84 of value (byte) -19
Fill 4 of value (byte) 33
Fill 2 of value (byte) -87
Fill 2 of value (byte) 33
Fill 2 of value (byte) -87
Fill 2 of value (byte) 33
Fill 90 of value (byte) -19
Fill 3 of value (byte) -87
Fill 6 of value (byte) 33
Fill 40 of value (byte) -19
Fill 7379 of value (byte) 33
Fill 20902 of value (byte) -19
Fill 3162 of value (byte) 33
Fill 11172 of value (byte) -19
Fill 92 of value (byte) 33
Fill 8190 of value (byte) 33
Public static methods
SNMP Runtime imports
This method will generate a SnmpStatusException
if `depth' is out of bounds.
This method will generate a SnmpStatusException
if `depth' is out of bounds.
SNMP Runtime import
The translation table is easy in this case ...
we need to allocate a new SnmpVarBind. Otherwise the first
sub request will modify the list...
Always call with V2. So the merge of the responses will
May be we should control the position ...
if ((elmt != null) &&  (elmt.value == null) &&
(version == snmpVersionTwo))
else if ((val == null) && (version == snmpVersionTwo))
Now we need to take the smallest oid ...
Take the smallest (lexicographically)
Must compare agent used for reply
Take the deeper within the reply
This iterator matches all kinds of nodes
Find the next storage with at least one element and return its Iterator
Calculate the hash value here because it's always used.
do not synchronize this method - see 4071298
do not synchronize this method - see 4071298
for compatibility, check for old user.region property
region can be of form country, country_variant, or _variant
This may just append '_'
Get the localized patterns for formatting a list, and use
them to format the list.
Get the localized patterns for formatting a display name.
The display name consists of a main name, followed by qualifiers.
Typically, the format is "MainName (Qualifier, Qualifier)" but this
depends on what pattern is stored in the display locale.
The main name is the language, or if there is no language, the script,
then if no script, the country. If there is no language/script/country
(an anomalous situation) then the display name is simply the variant's
The first one in the main name
Others are qualifiers
Create an array whose first element is the number of remaining
elements.  This serves as a selector into a ChoiceFormat pattern from
the resource.  The second and third elements are the main name and
the qualifier; if there are no qualifiers, the third element is
unused by the format pattern.
We could also just call formatList() and have it handle the empty
list case, but this is more efficient, and we want it to be
efficient since all the language-only locales will not have any
If we cannot get the message format pattern, then we use a simple
hard-coded pattern.  This should not occur in practice unless the
installation is missing some core files (FormatData etc.).
================= privates =====================================
Split the variant name into tokens separated by '_'.
For each variant token, lookup the display name.  If
not found, use the variant name itself.
If we have no list patterns, compose the list in a simple,
Compose the list down to three elements if necessary
Rebuild the argument list with the list length as the first element
Format it using the pattern in the resource
Use the given format to compose the first two elements into one
Form a new list one element shorter
Duplicate of sun.util.locale.UnicodeLocaleExtension.isKey in order to
avoid its class loading.
place holder just for backward support
we accept both the old and the new ISO codes for the languages whose ISO
codes have changed, but we always store the OLD code, for backward compatibility
Special cases for backward compatibility support
ja_JP_JP -> u-ca-japanese (calendar = japanese)
th_TH_TH -> u-nu-thai (numbersystem = thai)
Do syntax check.
ALPHA / DIGIT
These message should be read from a locale-specific resource bundle
parse will throw IAE if logLevel is invalid
W2K Feature: Check to see if the Underscore should be rendered.
to work around an apparent bug in Windows, use the pushbutton
color for disabled toolbar buttons if the disabled color is the
same as the enabled color
only draw shadow if developer hasn't changed the foreground color
and if the current style has text shadows.
Skip the component ID: we just wrote it out above
eventually we could have some logic to supply a default name
for mxbeanLookup and objectName
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of DesktopIconPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of DesktopIconPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
* Set the location where this expression was built from.
* @param locator the location where this expression was built from, may be
public void setSourceLocator(SourceLocator locator)
For now, the current node is already pushed.
For now, the current node is already pushed.
TO DO: Need to get stylesheet Locator from here.
=============== ExpressionNode methods ================
=============== SourceLocator methods ================
remaining imports are for Javadoc
add default recognized features
NOTE: These shouldn't really be here but since the XML Schema
validator is constructed dynamically, its recognized
features might not have been set and it would cause a
not-recognized exception to be thrown. -Ac
set state for default features
add default recognized properties
NOTE: These shouldn't really be here but since the XML Schema
validator is constructed dynamically, its recognized
properties might not have been set and it would cause a
not-recognized exception to be thrown. -Ac
If schema validator was not in the pipeline insert it.
add schema component
add schema message formatter
features and properties
Lets the user turn Schema validation support on/off.
activate full schema checking
Feature identifier: expose schema normalized value
Feature identifier: send element default value via characters()
An alias in fact, but saves lots of casts
List of reusable handles
Generics and annotations support
generic info repository; lazily initialized
Accessor for factory
create scope and factory
Accessor for generic info repository
lazily initialize repository if necessary
create and cache generic info repository
return cached repository
For sharing of ConstructorAccessors. This branching structure
is currently only two levels deep (i.e., one root Constructor
and potentially many Constructor objects pointing to it.)
If this branching structure would ever contain cycles, deadlocks can
occur in annotation code.
This routine enables sharing of ConstructorAccessor objects
among Constructor objects which refer to the same underlying
method in the VM. (All of this contortion is only necessary
because of the "accessibility" bit in AccessibleObject,
which implicitly requires that new java.lang.reflect
objects be fabricated for each reflective call on Class
Might as well eagerly propagate this if already present
NOTE that there is no synchronization used here. It is correct
(though not efficient) to generate more than one
ConstructorAccessor for a given Constructor. However, avoiding
synchronization will probably make the implementation more
First check to see if one has been created yet, and take it
Otherwise fabricate one and propagate it up to the root
Returns ConstructorAccessor for this Constructor object, not
looking up the chain to the root
Sets the ConstructorAccessor for this Constructor object and
(recursively) its root
Can't do reliable parameter counting
Check for the enclosing instance parameter for
non-static member classes
Comparison and hashing
Appends the default realm if it is missing
A ServicePermission with a principal in the deduced realm and
any action must be granted if no realm is provided by caller.
Swallow the actual exception to hide info
Inherits javadocs from Object
Type-specific CORBA::Object operations
End of file.
Remember: the encoder does backward encoding
bugId 4641696 : RuntimeExceptions must be transformed in
Modifying the model
Querying the model
Required SERVICE_CONTEXT_ID and getId definitions
Content model compositors
These message should be read from a locale-specific resource bundle
Proclaim serial compatibility with 1.1 FCS
Check for "''" indicating a literal quote
clean up last one
choose based upon which has less precision
approximate that by choosing the closest one to an integer.
could do better, but it's not worth it.
Append choiceFormats[i], using quotes if there are special characters.
Single quotes themselves must be escaped in either case.
find the number
same as number < choiceLimits, except catchs NaN
return either a formatted number, or a string
find the best number (defined as the one with the longest parse)
for primitives or immutables, shallow clone is enough
enough for reasonable distribution
OpenMBeanAttributeInfoSupport and this class are very similar
but can't easily be refactored because there's no multiple inheritance.
The best we can do for refactoring is to put a bunch of static methods
in OpenMBeanAttributeInfoSupport and import them here.
to be constructed unmodifiable
As this instance is immutable, these two values need only
be calculated once.
As this instance is immutable, these two values
need only be calculated once.
Construct parent's state
Initialize this instance's specific state
replace null by empty
We already converted the array into an unmodifiable Set
in the descriptor.
This noise allows us to avoid "unchecked" warnings without
having to suppress them explicitly.
Special case for ArrayType and TabularType
[JF] TODO: clone it so that it cannot be altered,
[JF] TODO: if we decide to support defaultValue as an array itself.
[JF] As of today (oct 2000) it is not supported so
defaultValue is null for arrays. Nothing to do.
Special case for ArrayType and TabularType
[JF] TODO: clone values so that they cannot be altered,
[JF] TODO: if we decide to support LegalValues as an array itself.
[JF] As of today (oct 2000) it is not supported so
legalValues is null for arrays. Nothing to do.
Returns our legalValues Set (set was constructed unmodifiable)
Note: only comparable values have a minValue, so that's not
the case of arrays and tabulars (always null).
Note: only comparable values have a maxValue, so that's not
the case of arrays and tabulars (always null).
compiler bug? should be able to omit class name here
also below in toString and hashCode
Calculate the hash code value if it has not yet been done
(ie 1st call to hashCode())
return always the same hash code for this instance (immutable)
Calculate the string value if it has not yet been done (ie
1st call to toString())
return always the same string representation for this
wait for time to change
If system time has gone backwards increase
original by 1ms to maintain uniqueness
This check was already here.  So, for now, I will not add it to the validation
that is done when the validate parameter is true.
This check was already here.  So, for now, I will not add it to the validation
that is done when the validate parameter is true.
This check was already here.  So, for now, I will not add it to the validation
that is done when the validate parameter is true.
Do we want this?
Do we want this?
TODO: error or warning...
Note: this may have any value, so
calculations must be done in longs
All 18-digit base ten strings fit into a long; not all 19-digit
Cache of common small BigDecimal values.
Cache of zero scaled by 0 - 15
Half of Long.MIN_VALUE & Long.MAX_VALUE.
protect against huge length.
This is the primary string to BigDecimal constructor; all
incoming strings end up here; it uses explicit (inline)
parsing for speed and generates at most one intermediate
(temporary) object (a char[] array) for non-compact case.
Use locals for all fields values until completion
record precision value
record scale value
the compact value in long
the inflated value in BigInteger
use array bounds checking to handle too-long, len == 0,
bad offset, etc.
handle the sign
leading minus means negative
leading + allowed
should now be at numeric part of the significand
true when there is a '.'
integer significand array & idx is the index to it. The array
is ONLY used when we can't use a compact representation.
First compact case, we need not to preserve the character
and we can just compute the value in place.
else digit is a redundant leading zero
prec unchanged if preceded by 0s
else digit is a redundant leading zero
prec unchanged if preceded by 0s
Next test is required for backwards compatibility
[saves a test]
no digits found
Adjust scale if exp is not zero.
had significant exponent
therefore, this subtract cannot overflow
First compact case, we need not to preserve the character
and we can just compute the value in place.
else c must be a redundant leading zero
prec unchanged if preceded by 0s
Next test is required for backwards compatibility
[saves a test]
here when no characters left
no digits found
Adjust scale if exp is not zero.
had significant exponent
Remove leading zeros from precision (digits count)
no exponent digits
skip leading zeros in the exponent
too many nonzero exponent digits
c now holds first digit of exponent
not a digit
that was final character
Translate the double into sign, exponent and significand, according
to the formulae in JLS, Section 20.10.22.
At this point, val == sign * significand * 2**exponent.
i.e., significand is even
Calculate intVal and scale
(exponent > 0)
Negative scales are now allowed
drop can't be more than 18
drop can't be more than 18
Static Factory Methods
Reminder: a zero double returns '0.0', so we cannot fastpath
to use the constant ZERO.  This might be important enough to
justify a factory approach, a cache, or a few private
If either number is zero then the other number, rounded and
scaled if necessary, is used as the result.
result.scale < preferredScale
can achieve target scale
scales differ; alignment needed
lhs is big; augend is small
lhs is small; augend is big
big and small disjoint
small digits not visible
Since addition is symmetric, preserving input order in
returned operands doesn't matter
Pair of subtrahend values given before pair of
values from this BigDecimal to avoid need for
method overloading on the specialized add method
share the special rounding code in add()
Calculate preferred scale
divide(BigDecimal, mc) tries to adjust the quotient to
the desired one by removing trailing zeros; since the
exact divide method does not have an explicit digit
limit, we can add zeros too.
Now calculate the answer.  We use the existing
divide-and-round method, but as this rounds to scale we have
to normalize the values here to achieve the desired result.
For x/y we first handle y=0 and x=0, and then normalize x and
y to give x' and y' with the following constraints:
(a) 0.1 <= x' < 1
(b)  x' <= y' < 10*x'
Dividing x'/y' with the required scale set to mc.precision then
will give a result in the range 0.1 to 1 rounded to exactly
the right number of digits (except in the case of a result of
1.000... which can arise when x=y, or when rounding overflows
The 1.000... case will reduce properly to 1.
Calculate preferred scale
much faster when this << divisor
Perform a divide with enough digits to round to a correct
integer value; then remove any fractional digits
pad with zeros if necessary
Calculate preferred scale
If the quotient is the full integer value,
|dividend-product| < |divisor|.
we use the identity  x = i * y + r to determine r
No need to calculate pow(n) if result will over/underflow.
Don't attempt to support "supernormal" numbers.
x**0 == 1 in X3.274
magnitude of n
length of n in digits
ready to carry out power calculation...
set once we've seen a 1-bit
for each bit [top bit ignored]
shift left 1 bit
top bit is set
OK, we're off
that was the last bit
else (!seenbit) no point in squaring ONE
if negative n, calculate the reciprocal using working precision
round to final precision and strip zeros
no rounding please
zero can have any scale
newScale < oldScale -- drop some digits
Can't predict the precision due to the effect of rounding.
newScale < oldScale -- drop some digits
Can't predict the precision due to the effect of rounding.
Decimal Point Motion Operations
Cannot use movePointRight(-n) in case of n==Integer.MIN_VALUE
Cannot use movePointLeft(-n) in case of n==Integer.MIN_VALUE
Quick path for equal scale and non-inflated case.
Match scales, avoid unnecessary inflation
Avoid matching scales if the (adjusted) exponents differ
The cases sdiff <= Integer.MIN_VALUE intentionally fall through.
sdiff > 0
The cases sdiff > Integer.MAX_VALUE intentionally fall through.
No decimal point
force to an integer, quietly
round to an integer, with Exception if decimal part non-0
If more than 19 digits in integer part it cannot possibly fit
[OK for negative scale too]
Fastpath zero and < 1.0 numbers (the latter can be very slow
to round if very small)
round to an integer, with Exception if decimal part non-0
need to check carefully
will check decimal part
will check decimal part
will check decimal part
Don't have too guard against
Math.abs(MIN_VALUE) because of outer check
Somewhat inefficient, but guaranteed to work.
Don't have too guard against
Math.abs(MIN_VALUE) because of outer check
Somewhat inefficient, but guaranteed to work.
Private class to build a string representation for BigDecimal object.
"StringBuilderHelper" is constructed as a thread local variable so it is
thread safe. The StringBuilder field acts as a buffer to hold the temporary
representation of BigDecimal. The cmpCharArray holds all the characters for
the compact representation of BigDecimal (except for '-' sign' if it is
negative) if its intCompact field is not INFLATED. It is shared by all
calls to toString() and its variants in that particular thread.
Placeholder for BigDecimal string
character array to place the intCompact
All non negative longs can be made to fit into 19 character array.
since we start from the least significant digit, charPos points to
the last character in cmpCharArray.
Get 2 digits/iteration using longs until quotient fits into an int
Get 2 digits/iteration using ints when i2 >= 100
zero scale is trivial
currency fast path
offset is the starting index for coeff array
Get the significand as an absolute value
Construct a buffer, with sufficient capacity for all cases.
If E-notation is needed, length will be: +1 if negative, +1
if '.' needed, +2 for "E+", + up to 10 for adjusted exponent.
Otherwise it could have +1 if negative, plus leading "0.00000"
prefix '-' if negative
count of padding zeros
E-notation is needed
more to come
[adjusted was negative]
now a multiple of 3
exponent is a multiple of three
significand all in integer
may need some zeros, too
[!sci could have made 0]
force sign for positive
The following comparison and the above synchronized statement is
to prevent multiple threads from expanding the same array.
Based on the following facts:
2. the following store is a volatile store.
the newly created array elements can be safely published.
0 / 10^0
1 / 10^1
2 / 10^2
3 / 10^3
4 / 10^4
5 / 10^5
6 / 10^6
7 / 10^7
8 / 10^8
9 / 10^9
10 / 10^10
11 / 10^11
12 / 10^12
13 / 10^13
14 / 10^14
15 / 10^15
16 / 10^16
17 / 10^17
18 / 10^18
Read in all fields
validate possibly bad fields
[all values of scale are now allowed]
Must inflate to maintain compatible serial form.
Could reset intVal back to null if it has to be set.
must screen for 0, might as well 10
if r >= length, must have max possible digits for long
drop can't be more than 18
drop can't be more than 18
drop can't be more than 18
store quotient in long
store remainder in long
store quotient in long
store remainder in long
Away from zero
Some kind of half-way rounding
We're closer to higher digit
We're closer to lower digit
2 * r can't fit into long
record remainder is zero or not
store quotient & remainder in long
Descend into mutables for faster remainder checks
record remainder is zero or not
store quotient & remainder in long
Descend into mutables for faster remainder checks
2 * r can't fit into long
record remainder is zero or not
Descend into mutables for faster remainder checks
record remainder is zero or not
Descend into mutables for faster remainder checks
odd number cannot end in 0
odd number cannot end in 0
See "Hacker's Delight" section 2-12 for explanation of
the overflow test.
same sign test
can't overflow here!
satisfy constraint (b)
[that is, divisor *= 10]
assert newScale >= xscale
assert newScale >= yscale
abs(scaledX) <= abs(ys)
result is "scaledX * 10^msp / ys"
abs(scaleX)== abs(ys) => result will be scaled 10^mcp + correct sign
abs(scaledX) < abs(ys)
doRound, here, only affects 1000000000 case.
satisfy constraint (b)
[that is, divisor *= 10]
In order to find out whether the divide generates the exact result,
we avoid calling the above divide method. 'quotient' holds the
return BigDecimal object whose scale will be set to 'scl'.
assert newScale >= yscale
doRound, here, only affects 1000000000 case.
Normalize dividend & divisor so that both fall into [0.1, 0.999...]
satisfy constraint (b)
[that is, divisor *= 10]
In order to find out whether the divide generates the exact result,
we avoid calling the above divide method. 'quotient' holds the
return BigDecimal object whose scale will be set to 'scl'.
assert newScale >= yscale
doRound, here, only affects 1000000000 case.
Normalize dividend & divisor so that both fall into [0.1, 0.999...]
satisfy constraint (b)
[that is, divisor *= 10]
In order to find out whether the divide generates the exact result,
we avoid calling the above divide method. 'quotient' holds the
return BigDecimal object whose scale will be set to 'scl'.
doRound, here, only affects 1000000000 case.
Normalize dividend & divisor so that both fall into [0.1, 0.999...]
satisfy constraint (b)
[that is, divisor *= 10]
In order to find out whether the divide generates the exact result,
we avoid calling the above divide method. 'quotient' holds the
return BigDecimal object whose scale will be set to 'scl'.
doRound, here, only affects 1000000000 case.
multiply dividend0 * dividend1
Number base (32 bits).
result (which is positive and unsigned here)
can't fit into long due to sign bit is used for value
Approximate the quotient and remainder
Correct the approximation
n - q*d == r && 0 <= r < d, hence we're done.
Compare Normalize dividend & divisor so that both fall into [0.1, 0.999...]
assert xs!=0 && ys!=0
sdiff > 0
Compare Normalize dividend & divisor so that both fall into [0.1, 0.999...]
assert "ys can't be represented as long"
Compare Normalize dividend & divisor so that both fall into [0.1, 0.999...]
sdiff >= 0
attempt to do it in 128 bits
multiply dividend0 * dividend1
0x8AC7230489E80000L  = unsigned 2^19
Adjust exponent to create subnormal double, then
replace subnormal double exponent with subnormal float
double string will be the same as float string
Check for NaN based on values of bit fields, maximum
exponent and nonzero significand.
Neither val is NaN, thisVal is smaller
Neither val is NaN, thisVal is larger
Cannot use floatToRawIntBits because of possibility of NaNs.
Values are equal
(-0.0, 0.0) or (!NaN, NaN)
(0.0, -0.0) or (NaN, !NaN)
If a META-INF entry is not MF or block or SF, they should
be normal entries. According to 2 above, no more block or
SF will appear. Let's doneWithMeta.
be liberal in what you accept. If the name starts with ./, remove
it as we internally canonicalize it with out the ./.
be liberal in what you accept. If the name starts with /, remove
it as we internally canonicalize it with out the /.
only set the jev object for entries that have a signature
(either verified or not)
don't compute the digest for this entry
add to sigFileData in case future blocks need it
check pending blocks, we can now process
anyone waiting for this .SF file
now we are parsing a signature block file
see if we have already parsed an external .SF file
put this block on queue for later processing
since we don't have the .SF bytes yet
ignore and treat as unsigned
ignore and treat as unsigned
ignore and treat as unsigned
ignore and treat as unsigned
Convert into a Certificate[]
MANIFEST.MF is always treated as signed and verified,
move its signers from sigFileSigners to verifiedSigners.
Extended JavaUtilJarAccess CodeSource API Support
Any map entries left?
true if file is part of the signature mechanism itself
check input parameters
copy the points...
avoid modifying the user's transform...
incorporate the gradient transform
faster to use the basic GradientPaintContext for this
REVISIT: make sure no memory leaks in client/server request/reply maps.
REVISIT: normalize requestHeader, replyHeader, messageHeader.
Note: in some cases (e.g., a reply message) this message
mediator will only be used for dispatch.  Then the original
request side mediator will take over.
REVISIT: probably move logic in outputObject to here.
REVISIT - need separate field?
Case: first a location forward, then a marshaling
exception (e.g., non-serializable object).  Only
send cancel once.
REVISIT: we could attempt to send a final incomplete
fragment in this case.
Find the typecode for the exception
Since we dont have the actual user exception
class, the spec says we have to create an
UnknownUserException and put it in the
must be a truly unknown exception
A null msg should never happen. But, we'll be
defensive just in case.
REVISIT: ContactInfo/Acceptor output object factories
just use this.  Maybe need to distinguish:
then do getStreamFormatVersionForRequest/ForReply here.
NOTE: The request service contexts may indicate the max.
Defaults to 1 for GIOP 1.2 or less, 2 for
GIOP 1.3 or higher.
Used by server side.
REVISIT: should look up in orb registry.
Note: relies on side-effect of setting mediator output field.
REVISIT - cast - need interface
Note: relies on side-effect of setting mediator output field.
REVISIT - cast - need interface
Didn't have the max stream format version tagged
REVISIT - This could be a separate implementation object looked
up in a registry.  However it needs some state in the message
mediator so combine for now.
REVISIT - this should be handled internally.
Leader/Follower when using reader thread.
When this thread is done working it will go back in pool.
First unregister current registration.
Have another thread become the reader.
When using reader thread then wen this thread is
done working it will continue reading.
NOTE: VERY IMPORTANT:
Only participate in select after getting to the point
that proper serialization of fragments is ensured.
IMPORTANT: To avoid bug (4953599), we force the Thread that does the NIO select
to also do the enable/disable of Ops using SelectionKey.interestOps(Ops of Interest).
Otherwise, the SelectionKey.interestOps(Ops of Interest) may block indefinitely in
REVISIT: refactor createInputObject (and createMessageMediator)
into base PlugInFactory.  Get via connection (either ContactInfo
This will end up using the MessageMediator associated with
the original request instead of the current mediator (which
need to be constructed to hold the dispatchBuffer and connection).
This handles message types for which we don't create classes.
REVISIT: this is identical to 1_0 except for fragment part.
NOTE: in the old code this used to be done conditionally:
Now we always put it in. We take it out when
the response is done.
This must happen now so if a header is fragmented the stream
may be found.
Note: This *MUST* come after putting stream in above map
since the header may be fragmented and you do not want to
start reading again until the map above is set.
inputObject.unmarshalHeader();  done in subcontract.
REVISIT: this should be done by waiting thread.
More fragments are coming to complete this reply, so keep
a reference to the InputStream so we can add the fragments
In 1.1, we can't assume that we have the request ID in the
first fragment.  Thus, another thread is used
to be the reader while this thread unmarshals
the extended header and wakes up the client thread.
REVISIT - error handling.
This must be done now.
Not fragmented, therefore we know the request
ID is here.  Thus, we can unmarshal the extended header
and wake up the client thread without using a third
thread as above.
REVISIT - error handling during unmarshal.
This must be done now to get the request id.
We know that the request ID is in the first fragment
REVISIT Put in subcontract.
Fragmented LocateReplies are not allowed in 1.1.
No need to put in client reply map - already there.
If no input stream available, then discard the fragment.
This can happen:
1. if a fragment message is received prior to receiving
the original request/reply message. Very unlikely.
2. if a fragment message is received after the
reply has been sent (early replies)
Note: In the case of early replies, the fragments received
during the request processing (which are never unmarshaled),
will eventually be discarded by the GC.
need to release dispatchByteBuffer to pool if
we are discarding
NOTE: This *must* come after queing the fragment
when using the selector to ensure fragments stay in order.
Note:  We know it's a 1.2 fragment, we have the data, but
we need the IIOPInputStream instance to unmarshal the
request ID... but we need the request ID to get the
IIOPInputStream instance. So we peek at the raw bytes.
See 1.1 comments.
need to release dispatchByteBuffer to pool if
we are discarding
REVISIT: but if it is a server don't you have to remove the
stream from the map?
NOTE: This *must* come after queing the fragment
when using the selector to ensure fragments stay in order.
REVISIT: Move these two to subcontract.
REVISIT: move this to subcontract (but both client and server need it).
The GIOP version of CancelRequest does not matter, since
CancelRequest_1_0 could be sent to cancel a request which
has a different GIOP version.
we do not support bi-directional giop yet, ignore.
Try to get hold of the InputStream buffer.
In the case of 1.0 requests there is no way to get hold of
InputStream. Try out the 1.1 and 1.2 cases.
was the request 1.2 ?
was the request 1.1 ?
XXX log this!
either the request was 1.0
or an early reply has already been sent
or request processing is over
or its a spurious CancelRequest
A spurious 1.1 CancelRequest has been received.
XXX log this!
XXX log this
this means that
1. the 1.1 requests' requestId has not been received
i.e., a CancelRequest was received even before the
1.1 request was received. The spec disallows this.
2. or the 1.1 request has a requestId 0.
It is a little tricky to distinguish these two. So, be
conservative and do not cancel the request. Downside is that
1.1 requests with requestId of 0 will never be cancelled.
Any mediator obtained here should only ever be for a GIOP
At this point we have a valid message mediator that contains
a valid requestId.
at this point we have chosen a request to be cancelled. But we
do not know if the target object's method has been invoked or not.
Request input stream being available simply means that the request
processing is not over yet. simply set the abort flag in the
BMRS and hope that the worker thread would notice it (this can
happen only if the request stream is being unmarshalled and the
target's method has not been invoked yet). This guarantees
that the requests which have been dispatched to the
target's method will never be cancelled.
REVISIT - this makes hcks sendTwoObjects fail
REVISIT - type and location
REVISIT - can be null for TRANSIENT below.
release NIO ByteBuffers to ByteBufferPool
Given what close() does, this catch shouldn't ever happen.
See CDRInput/OutputObject.close() for more info.
It also won't result in a Corba error if an IOException happens.
Does nothing if already unmarshaled.
This is necessary so mediator can act as ResponseHandler
and pass necessary info to response constructors located
in the subcontract.
REVISIT - same class right now.
REVISIT: Should we catch SystemExceptions?
create a response containing the expected target
no need to send reply
REVISIT If exception is not OBJECT_NOT_EXIST, it should
have a different reply
This handles OBJECT_NOT_EXIST exceptions thrown in
the subcontract or obj manager. Send back UNKNOWN_OBJECT.
outputObject.setMessage(reply);  REVISIT - not necessary
locate msgs 1.0 & 1.1 :=> grow,
1.2 :=> stream
If we haven't unmarshaled the header, we probably don't
have enough information to even send back a reply.
Cannot do this check.  When target addressing disposition does
not match (during header unmarshaling) it throws an exception
to be handled here.
REVISIT - catch and ignore RequestCanceledException.
REVISIT - should we close connection?
User code (e.g., postinvoke, interceptors) may change
the exception, so we end up back here.
Report the changed exception.
Reporting an exception response causes the
poa current stack, the interceptor stacks, etc.
to be balanced.  It also notifies interceptors
that the request was cancelled.
NOTE: We do not trap ThreadDeath above Throwable.
There is no reason to stop the thread.  It is
just a worker thread.  The ORB never throws
ThreadDeath.  Client code may (e.g., in ServantManagers,
interceptors, or servants) but that should not
effect the ORB threads.  So it is just handled
If user code throws a non-SystemException report it generically.
Respond with expected target addressing disposition.
REVISIT: via acceptor factory.
REVISIT: via acceptor factory.
REVISIT: ignore service contexts during framework transition.
They are set in SubcontractResponseHandler to the wrong connection.
Then they would be set again here and a duplicate contexts
REVISIT - same as above
NOTE: This service context container gets augmented in
It is possible that fragments of response have already been
sent.  Then an error may occur (e.g. marshaling error like
non serializable object).  In that case it is too late
to send the exception.  We just return the existing fragmented
stream here.  This will cause an incomplete last fragment
to be sent.  Then the other side will get a marshaling error
when attempting to unmarshal.
REVISIT: Impl - make interface method to do the following.
REVISIT: need to think about messageMediator containing correct
pointer to output object.
Only do this if interceptors have been initialized on this request
and have not completed their lifecycle (otherwise the info stack
may be empty or have a different request's entry on top).
REVISIT: not necessary in framework now?
Inform Portable Interceptors of the SystemException.  This is
required to be done here because the ending interception point
is called in the when creating the response below
but we do not currently write the SystemException into the
response until after the ending point is called.
NOTE: We MUST add the service context before creating
the response since service contexts are written to the
stream when the response object is created.
NOTE: From here on, it is too late to add more service contexts.
They have already been serialized to the stream (and maybe fragments
NOTE: you must flush or baos will be empty.
REVISIT - IOR arg is ignored.
REVISIT - these should be invoked from subcontract.
REVISIT = do not use null.
REVISIT - not necessary?
NOTE: The mediator holds onto output object so return value
not really necessary.
Run ServantLocator::postinvoke.  This may cause a SystemException
which will throw out of the constructor and return later
to construct a reply for that exception.  The internal logic
of returnServant makes sure that postinvoke is only called once.
REVISIT: instead of instanceof, put method on all orbs.
This flag is to deal with BootstrapServer use of reply streams,
with ServerRequestDispatcher's use of reply streams, etc.
It is possible to get marshaling errors in the skeleton after
postinvoke has completed.  We must set this to false so that
when the error exception reply is constructed we don't try
to incorrectly access poa current (which will be the wrong
one or an empty stack.
Invoke server request ending interception points (send_*):
Note: this may end up with a SystemException or an internal
Note this will be executed even if a ForwardRequest or
SystemException is thrown by a Portable Interceptors ending
point since we end up in this constructor again anyway.
See createSystemExceptionResponse for why this is necesary.
Once you get here then the final reply is available (i.e.,
postinvoke and interceptors have completed.
NOTE : We only want to send the runtime context the first time
send ORBVersion servicecontext as part of the Reply
REVISIT - this method should be migrated to orbutil.ORBUtility
since all locations that release ByteBuffers use
very similar logic and debug information.
End of file.
Merge the relation targets if the key exists
Peek in the input buffer without changing the internal state
If end of buffer, can't disambiguate :(
Can't disambiguate, so return as symbol
Return symbol if next token is '::' or '('
Disable Nagle's algorithm (i.e., always send immediately).
Disable Nagle's algorithm (i.e., always send immediately).
End of file.
$$kk: 03.04.99: josh bloch recommends getting rid of this:
what can you really do with a set of untyped controls??
$$kk: 03.05.99: i am putting this back in.  for one thing,
you can check the length and know whether you should keep
default - SET TO 0???
Ideally this would return the size from the layout manager,
but that could result in the layed out size being different from
the dividerSize, which may break developers as well as
Paint the border.
Look and feel doesn't want to support one touch buttons, bail.
Fill the background first ...
... then draw the arrow.
Little trick to make the
arrows of equal size
Don't want the button to participate in focus traversable.
Fill the background first ...
... then draw the arrow.
Don't want the button to participate in focus traversable.
Don't allow dragging.
End of BasicSplitPaneDivider.DragController
Don't allow dragging.
End of BasicSplitPaneDividier.VerticalDragController
NOTE: This isn't really used, refer to
BasicSplitPaneDivider.getPreferredSize for the reason.
I leave it in hopes of having this used at some point.
End of class BasicSplitPaneDivider.DividerLayout
We use the location from the UI directly, as the location the
JSplitPane itself maintains is not necessarly correct.
We do this in case the dividers notion of the location
differs from the real location.
End of class BasicSplitPaneDivider.LeftActionListener
Make a (shallow) copy of the environment.
builder must return non-null factory
use reference if possible
if reference identifies a factory, use exclusively
No factory found, so return original refInfo.
Will reach this point if factory class is not in
class path and reference does not contain a URL for it
if reference has no factory, check for addresses
ignore name & attrs params; not used in URL factory
try using any specified factories
Try each factory until one succeeds
Get list of state factories
no factories to try; just return originals
Try each factory until one succeeds
CatalogManager.java - Access CatalogManager.properties
Note that we don't setDebug() here; we do that lazily. Either the
user will set it explicitly, or we'll do it automagically if they
read from the propertyFile for some other reason. That way, there's
no attempt to read from the file before the caller has had a chance
to avoid it.
there's no reason to give this warning more than once
This is a bit of a hack. After we've successfully read the properties,
use them to set the default debug level, if the user hasn't already set
the default debug level.
This is a bit of a hack. After we've successfully got the verbosity,
we have to use it to set the default debug level,
if the user hasn't already set the default debug level.
-- This file was mechanically generated: Do not edit! --
layout the text and icon
try to create instance of Xalan factory...
GTM: NB: 'debug' should change to something more unique...
GTM: NB: 'debug' should change to something more unique...
feature name cannot be null
all done processing feature
All supported features should be listed here
feature name cannot be null
Inefficient, but it really does not matter in a function like this
-- This file was mechanically generated: Do not edit! --
these declarations are here as documentation
eliminate loops in case of the boot
ClassLoader returning itself as a parent
Ensure that we either set both of these or neither
clone because byte arrays are modifiable
First, ensure that the name parses
Snapshot set and parse it
If everything went OK, make the changes
Ensure that we either set both of these or neither
called from CertPathHelper
set names to non-null dummy value
this breaks getPathToNames()
clone because byte arrays are modifiable
First, ensure that the name parses
Copy the Lists and Collection
Check the contents of the Lists and clone any byte arrays
See javadoc for parameter "names".
Copied from sun.security.x509.KeyUsageExtension
(without calling the superclass)
not able to retrieve notAfter value
not able to retrieve notBefore value
Safe casts assuming clone() works correctly
Must clone these because addPathToName et al. modify them
Old actions forward to an instance of this.
The distance that the track is from the side of the control
ComponentUI Interface Implementation methods
This figures out where the labels, ticks, track, and thumb are.
use default if missing so that BasicSliderUI can be used in other
LAFs like Nimbus
Assume uniform labels.
NOTE: BasicSpinner really provides for CENTER_OFFSET, but
the default min/pref size is smaller than it should be
so that getBaseline() doesn't implement the contract
for CENTER_OFFSET as defined in Component.
If it's not on a tick, change the value
This is the fix for the bug #6401380
used to center sliders added using BorderLayout.CENTER (bug 4275631)
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
Register Slider as an image observer. It allows to catch notifications about
image changes (e.g. gif animation)
Used exclusively by setThumbLocation()
Property Change Handler
/ Model Listener Class
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
/ Track Listener Class
We should recalculate geometry just before
calculation of the thumb movement direction.
It is important for the case, when JSlider
is a cell editor in JTable. See 6348946.
Clicked in the Thumb area?
changed this class to public to avoid bogus IllegalAccessException
bug in InternetExplorer browser.  It was protected.  Work around
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Actions. If you need to add
new functionality add it to the Actions, but make sure this
class calls into the Actions.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Actions. If you need to add
new functionality add it to the Actions, but make sure this
class calls into the Actions.
MIN or MAX
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of ScrollBarTrackPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of ScrollBarTrackPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
-- This file was mechanically generated: Do not edit! --
these declarations are here as documentation
Private method to configure a ConsoleHandler from LogManager
properties and/or default values as specified in the class
doing a setEncoding with null should always work.
This can only be set at static initialization time (no sync necessary).
Same code as in PortableRemoteObject. Can not be shared because they
are in different packages and the visibility needs to be package for
security reasons. If you know a better solution how to share this code
then remove it from PortableRemoteObject. Also in Stub.java
ignore, then try RMIClassLoader
check that a serialization permission has been
set to allow the loading of the Util delegate
which provides access to custom ValueHandler
must be restartable
must be restartable
Set start node for left-hand iterator...
... and get start node for right-hand iterator from left-hand,
with special case for * path - see ParentLocationPath
Special case for * path - see ParentLocationPath
Try to get another node from the right-hand iterator
If not, get the next starting point from left-hand iterator...
...and pass it on to the right-hand iterator
check WBMP "header"
while WBMP reader does not support ext WBMP headers
check image dimension
We can't verify that amount of data in the stream
corresponds to image dimension because we do not know
the length of the data stream.
Assuming that wbmp image are used for mobile devices,
let's introduce an upper limit for image dimension.
In case if exact amount of raster data is unknown,
let's reject images with dimension above the limit.
Common UI methods
Set the fragment's "more fragments" bit to true, put it in the
queue, and allocate a new bbwi.
Set the fragment's moreFragments field to true
Enqueue the previous fragment
Create a new bbwi
XREVISIT - Downcast
Now we must marshal in the fragment header/GIOP header
REVISIT - we can optimize this by not creating the fragment message
XREVISIT - Downcast
Send all fragments
Enqueue the last fragment
With the collect strategy, we must lock the connection
while fragments are being sent.  This is so that there are
no interleved fragments in GIOP 1.1.
Note that this thread must not call writeLock again in any
of its send methods!
Get a reference to ByteBufferPool so that the ByteBufferWithInfo
ByteBuffer can be released to the ByteBufferPool
Release ByteBufferWithInfo's ByteBuffer back to the pool
print address of ByteBuffer being released
iterate thru queue and release any ByteBufferWithInfo's
ByteBuffer that may be remaining on the queue to the
print address of ByteBuffer being released
If this is ever changed in isAssignmentCompatible()
This is not explicitely stated, but clear. Isn't it?
TODO: Check if this is still valid or find a way to dynamically find out which
interfaces arrays implement. However, as of the JVM specification edition 2, there
are at least two different pages where assignment compatibility is defined and
on one of them "interfaces implemented by arrays" is exchanged with "'Cloneable' or
TODO: Is there a proof of OBJECT being the direct ancestor of every ArrayType?
TODO: The above line is correct comparing to the vmspec2. But one could
make class file verification a bit stronger here by using the notion of
superinterfaces or even castability or assignment compatibility.
this and t are ObjectTypes, see above.
Huh? Did you ask for Type.OBJECT's superclass??
TODO: Is there a proof of OBJECT being the direct ancestor of every ArrayType?
TODO: The above line is correct comparing to the vmspec2. But one could
make class file verification a bit stronger here by using the notion of
superinterfaces or even castability or assignment compatibility.
this and t are ObjectTypes, see above.
Huh? Did you ask for Type.OBJECT's superclass??
Common UI methods
if the parent is null then propogate down the view tree
in FlowView.java view might be referenced
from two super-views as a child. see logicalView
-1 is a reserved value, see the code below
YECK! Ideally, the x location from the magic caret position
would be passed in.
Assume extends left to right.
If it spans lines, force it to be the width of the view.
don't consider the element changes they
are for a view further down.
don't consider the element changes they
are for a view further down.
don't consider the element changes they
are for a view further down.
PENDING(prinz) this is a temporary implementation
forward to any view not in the forwarding hole
formed by added elements (i.e. they will be updated
Event beyond our offsets. We may have represented this, that is
the remove may have removed one of our child Elements that
represented this, so, we should forward to last element.
If v is at a boundary, forward the event to the previous
Do nothing by default. Should be overridden in subclasses, if any.
should damage more intelligently
static argument available for viewToModel calls since only
one thread at a time may call this method.
Didn't fit, force to heavy.
Check if the parent component is an option pane.  If so we need to
force a heavy weight popup in order to have event dispatching work
The recycled popup can't serve us well
dispose it and create new one
Set window name. We need this in BasicPopupMenuUI
to identify focusable popup window.
If the Window isn't visible, we don't cache it as we
likely won't ever get a windowClosed event to clean up.
We also don't cache DefaultFrames as this indicates
there wasn't a valid Window parent, and thus we don't
know when to clean up.
Clean up if the Window is closed
Force the content to be added to the layered pane, otherwise
we'll get an exception when adding to the RootPaneContainer.
If we have GraphicsConfiguration use it
to get screen bounds
If we don't have GraphicsConfiguration use primary screen
Take insets into account
Try to find a JLayeredPane and Window to add
Continue, so that if there is a higher JRootPane, we'll
pick it up.
Painting code stops at Applets, we don't want
to add to a Component above an Applet otherwise
you'll never see it painted.
Set the visibility to false before adding to workaround a
bug in Solaris in which the Popup gets added at the wrong
location, which will result in a mouseExit, which will then
result in the ToolTip being removed.
NOTE: this uses setOpaque vs LookAndFeel.installProperty as
there is NO reason for the RootPane not to be opaque. For
painting to work the contentPane must be opaque, therefor the
RootPane can also be opaque.
This implements SwingHeavyWeight so that repaints on it
are processed by the RepaintManager and SwingPaintEventDispatcher.
Check for null parameter
Check for non-Role objects
Build the List<Role>
Revisit [cebro] Localize message
Revisit [cebro] Localize message
Draw the separation
These constants are not used in JDK code
Center text vertically.
Try posting event, unless there's a SecurityManager.
Leave room for three characters in the title.
SystemMenuBar forces the icon to be 16x16 or less.
Take into account the border insets if any.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
This action is currently undefined
whether to show the menu
This action is currently undefined
Resize to 16x16 if necessary.
End Title Pane Class
end of State.java
REVISIT: only local element and attribute are different from others.
it's possible to have either name or ref. all the others
are only allowed to have one of name or ref, or neither of them.
we'd better move such checking to the traverser.
constants to return
used to store the map from element name to attribute list
for 14 global elements
for 39 local elememnts
used to initialize fEleAttrsMap
step 1: all possible data types
DT_??? >= 0 : validate using a validator, which is initialized staticly
DT_??? <  0 : validate directly, which is done in "validate()"
used to store extra datatype validators
step 5: register all datatype validators for new types
xpath = a subset of XPath expression
xpath = a subset of XPath expression
step 2: all possible attributes for all elements
step 3: store all these attributes in an array
step 4: for each element, make a list of possible attributes
for element "attribute" - global
default = string
fixed = string
id = ID
name = NCName
type = QName
for element "attribute" - local name
default = string
fixed = string
form = (qualified | unqualified)
id = ID
name = NCName
type = QName
use = (optional | prohibited | required) : optional
for element "attribute" - local ref
default = string
fixed = string
id = ID
ref = QName
use = (optional | prohibited | required) : optional
for element "element" - global
abstract = boolean : false
block = (#all | List of (extension | restriction | substitution))
default = string
final = (#all | List of (extension | restriction))
fixed = string
id = ID
name = NCName
nillable = boolean : false
substitutionGroup = QName
type = QName
for element "element" - local name
block = (#all | List of (extension | restriction | substitution))
default = string
fixed = string
form = (qualified | unqualified)
id = ID
maxOccurs = (nonNegativeInteger | unbounded)  : 1
minOccurs = nonNegativeInteger : 1
name = NCName
nillable = boolean : false
type = QName
for element "element" - local ref
id = ID
maxOccurs = (nonNegativeInteger | unbounded)  : 1
minOccurs = nonNegativeInteger : 1
ref = QName
for element "complexType" - global
abstract = boolean : false
block = (#all | List of (extension | restriction))
final = (#all | List of (extension | restriction))
id = ID
mixed = boolean : false
name = NCName
for element "notation" - global
id = ID
name = NCName
public = A public identifier, per ISO 8879
system = anyURI
for element "complexType" - local
id = ID
mixed = boolean : false
for element "simpleContent" - local
id = ID
for element "restriction" - local
base = QName
id = ID
for element "extension" - local
base = QName
id = ID
for element "attributeGroup" - local ref
id = ID
ref = QName
for element "anyAttribute" - local
id = ID
namespace = ((##any | ##other) | List of (anyURI | (##targetNamespace | ##local)) )  : ##any
processContents = (lax | skip | strict) : strict
for element "complexContent" - local
id = ID
mixed = boolean
for element "attributeGroup" - global
id = ID
name = NCName
for element "group" - global
id = ID
name = NCName
for element "group" - local ref
id = ID
maxOccurs = (nonNegativeInteger | unbounded)  : 1
minOccurs = nonNegativeInteger : 1
ref = QName
for element "all" - local
id = ID
maxOccurs = 1 : 1
minOccurs = (0 | 1) : 1
for element "choice" - local
id = ID
maxOccurs = (nonNegativeInteger | unbounded)  : 1
minOccurs = nonNegativeInteger : 1
for element "sequence" - local
for element "any" - local
id = ID
maxOccurs = (nonNegativeInteger | unbounded)  : 1
minOccurs = nonNegativeInteger : 1
namespace = ((##any | ##other) | List of (anyURI | (##targetNamespace | ##local)) )  : ##any
processContents = (lax | skip | strict) : strict
for element "unique" - local
id = ID
name = NCName
for element "key" - local
for element "keyref" - local
id = ID
name = NCName
refer = QName
for element "selector" - local
id = ID
xpath = a subset of XPath expression
for element "field" - local
id = ID
xpath = a subset of XPath expression
for element "annotation" - global
id = ID
for element "annotation" - local
for element "appinfo" - local
source = anyURI
for element "documentation" - local
source = anyURI
xml:lang = language
for element "simpleType" - global
final = (#all | List of (list | union | restriction))
id = ID
name = NCName
for element "simpleType" - local
final = (#all | List of (list | union | restriction))
id = ID
for element "restriction" - local
already registered for complexType
for element "list" - local
id = ID
itemType = QName
for element "union" - local
id = ID
memberTypes = List of QName
for element "schema" - global
attributeFormDefault = (qualified | unqualified) : unqualified
blockDefault = (#all | List of (extension | restriction | substitution))  : ''
elementFormDefault = (qualified | unqualified) : unqualified
finalDefault = (#all | List of (extension | restriction | list | union))  : ''
id = ID
targetNamespace = anyURI
version = token
xml:lang = language
for element "include" - global
id = ID
schemaLocation = anyURI
for element "redefine" - global
for element "import" - global
id = ID
namespace = anyURI
schemaLocation = anyURI
for element "length" - local
id = ID
value = nonNegativeInteger
fixed = boolean : false
for element "minLength" - local
for element "maxLength" - local
for element "fractionDigits" - local
for element "totalDigits" - local
id = ID
value = positiveInteger
fixed = boolean : false
for element "pattern" - local
id = ID
value = string
for element "enumeration" - local
id = ID
value = anySimpleType
for element "whiteSpace" - local
id = ID
value = preserve | replace | collapse
fixed = boolean : false
for element "maxInclusive" - local
id = ID
value = anySimpleType
fixed = boolean : false
for element "maxExclusive" - local
for element "minInclusive" - local
for element "minExclusive" - local
used to resolver namespace prefixes
used to store symbols.
used to store the mapping from processed element to attributes
temprory vector, used to hold the namespace list
whether this attribute appeared in the current element
constructor. Sets fErrorReproter and get datatype validators
get all attributes
REVISIT: only local element and attribute are different from others.
it's possible to have either name or ref. all the others
are only allowed to have one of name or ref, or neither of them.
we'd better move such checking to the traverser.
get desired attribute list of this element
should never gets here.
when this method is called, the call already knows that
the element can appear.
clear the "seen" flag.
traverse all attributes
get the attribute name/value
we don't want to add namespace declarations to the non-schema attributes
Both <schema> and <documentation> may have an xml:lang attribute.
Set the URI for this attribute to null so that we process it
like any other schema attribute.
for attributes with namespace prefix
attributes with schema namespace are not allowed
and not allowed on "document" and "appInfo"
these are usually small
for attributes from other namespace
store them in a list, and TRY to validate them after
schema traversal (because it's "lax")
REVISIT:  actually use this some day...
check whether this attribute is allowed
we've seen this attribute
check the value against the datatype
no checking on string needs to be done here.
no checking on xpath needs to be done here.
xpath values are validated in xpath parser
kludge to handle chameleon includes/redefines...
For "enumeration", and type is possible to be a QName, we need
to return namespace context for later QName resolution.
apply default values
if the attribute didn't apprear, and
if the attribute is optional with default value, apply it
Check that minOccurs isn't greater than maxOccurs.
maxOccurLimit is only check in secure mode
The maxOccurs restriction no longer applies to elements
and wildcards in a sequence in which they are the only
particle. These are now validated using a constant
space algorithm. The restriction still applies to all
Determine if constant-space algorithm can be applied
Revisit :: IMO this is not right place to check
reset max values in case processing continues on error
To validate these types, we don't actually need to normalize the
strings. We only need to remove the whitespace from both ends.
In some special cases (list types), StringTokenizer can correctly
process the un-normalized whitespace.
block = (#all | List of (extension | restriction | substitution))
block = (#all | List of (extension | restriction))
final = (#all | List of (extension | restriction))
REVISIT: if #all, then make the result the combination of
would this be a problem?
the reason doing so is that when final/blockFinal on <schema>
is #all, it's not always the same as the conbination of those
values allowed by final/blockFinal.
for example, finalDefault="#all" is not always the same as
if finalDefault="#all", final on any simple type would be
"extension restriction list union".
final = (#all | List of (list | union | restriction))
choice = SchemaSymbols.RESTRICTION|SchemaSymbols.LIST|
REVISIT: if #all, then make the result the combination of
would this be a problem?
same reason as above DT_BLOCK1/DT_FINAL
finalDefault = (#all | List of (extension | restriction | list | union))
choice = SchemaSymbols.RESTRICTION|SchemaSymbols.LIST|
REVISIT: if #all, then make the result the combination of
would this be a problem?
same reason as above DT_BLOCK1/DT_FINAL
form = (qualified | unqualified)
maxOccurs = (nonNegativeInteger | unbounded)
maxOccurs = 1
memberTypes = List of QName
kludge to handle chameleon includes/redefines...
minOccurs = (0 | 1)
namespace = ((##any | ##other) | List of (anyURI | (##targetNamespace | ##local)) )
we have found namespace URI here
need to add it to the symbol table
check for duplicate namespaces in the list
convert the vector to an array
processContents = (lax | skip | strict)
use = (optional | prohibited | required)
value = preserve | replace | collapse
validate attriubtes from non-schema namespaces
REVISIT: why we store the attributes in this way? why not just a list
REVISIT: pass the proper element node to reportSchemaError
for all attributes
get name, uri, localpart
find associated grammar
and get the datatype validator, if there is one
get all values appeared with this attribute name
for each of the values
and validate it using the XSSimpleType
REVISIT: what would be the proper validation context?
guess we need to save that in the vectors too.
normalize the string according to the whiteSpace facet
when it's replace, just replace #x9, #xa, #xd by #x20
when it's collapse
append real characters, so we passed leading ws
for whitespaces, we skip all following ws
if it's not a leading or tailing ws, then append a space
the following part implements an attribute-value-array pool.
when checkAttribute is called, it calls getAvailableArray to get
an array from the pool; when the caller is done with the array,
it calls returnAttrArray to return that array to the pool.
initial size of the array pool. 10 is big enough
the incremental size of the array pool
the array pool
used to clear the returned array
I think System.arrayCopy is more efficient than setting 35 fields to null
current position of the array pool (# of arrays not returned)
get the next available array
if no array left in the pool, increase the pool size
initialize each *new* array
get the next available one
clear it from the pool. this is for GC: if a caller forget to
return the array, we want that array to be GCed.
to make sure that one array is not returned twice, we use
the last entry to indicate whether an array is already returned
now set it to false.
return an array back to the pool
pop the namespace context
3. the array is of wrong size; 4. the array is already returned
then we can't accept this array to be returned
mark this array as returned
better clear nonschema vector
and put it into the pool
push the namespace context
search for new namespace bindings
name of the attribute
index of the datatype validator
whether it's optional, and has default value
the default value of this attribute
As this instance is immutable,
these two values need only be calculated once.
may throw an ArrayStoreException
check parameters that should not be null or empty
(unfortunately it is not done in superclass :-( ! )
may throw an ArrayStoreException
if obj is null, return false
if obj is not a OpenMBeanConstructorInfo, return false
Now, really test for equality between this
OpenMBeanConstructorInfo implementation and the other:
their Name should be equal
their Signatures should be equal
All tests for equality were successfull
Calculate the hash code value if it has not yet been done
(ie 1st call to hashCode())
return always the same hash code for this instance (immutable)
Calculate the string value if it has not yet been done (ie
1st call to toString())
return always the same string representation for this
types of particles
type of the particle
term of the particle
for PARTICLE_ELEMENT : the element decl
for PARTICLE_WILDCARD: the wildcard decl
for PARTICLE_MODELGROUP: the model group
minimum occurrence of this particle
maximum occurrence of this particle
clone this decl
whether this particle contains nothing
Create a delegate and stick it in the servant.
This delegate is needed during dispatch for the ObjectImpl._orb()
method to work.
This new servant delegate no longer needs the id for
read and discard the repository ID
write the repository ID
create the SecurityManager property:
As per the spec, 100% is the same as *
hence the mapping.
extend spec if we have more children than specified
in ROWS or COLS attribute
allocate the absolute's first, they have
then deal with percents.
allocate remainingSpace to relative
There are no relative columns and the space has been
under- or overallocated.  In this case, turn all the
percentage and pixel specified columns to percentage
columns based on the ratio of their pixel count to the
total "virtual" size. (In the case of percentage columns,
the pixel count would equal the specified percentage
of the screen size.
This action is in accordance with the HTML
4.0 spec (see section 8.3, the end of the discussion of
the FRAMESET tag).  The precedence of percentage and pixel
specified columns is unclear (spec seems to indicate that
they share priority, however, unspecified what happens when
addendum is that we behave similar to netscape in that specified
widths have precedance over percentage widths...
ok we know what our total space is, and we know how large each
column should be relative to each other... therefore we can use
that relative information to deduce their percentages of a whole
and then scale them appropriately for the correct size
this is for just in case there is something left over.. if there is we just
add it one pixel at a time to the frames in order.. We shouldn't really ever get
here and if we do it shouldn't be with more than 1 pixel, maybe two.
just in case there are more pixels than frames...should never happen..
Add this check for JDK consistency for empty strings.
we have to check whether we can read, write,
and delete cache files.
So, compose cache file path and check it.
Ensure category is present
Ensure category is present
Ensure category is present
Deregister the spi in this case, but only as
Perform mark/reset as a defensive measure
even though plug-ins are supposed to take
care of it.
method returns an array of Strings
Ensure category is present
Ensure category is present
Ensure category is present
Ensure category is present
Deregister the spi in this case, but only as a writerSpi
Ensure category is present
Ensure category is present
Ensure category is present
Ensure category is present
Deregister the spi in this case, but only as a writerSpi
Ensure category is present
Deregister the spi in this case, but only as a readerSpi
Ensure category is present
Ensure category is present
remove old panels
remove from hierarchy
removed all panels and added none
one panel case
moving from single to multiple
note the properties listed here can currently be used by people
providing runtimes to hint what fonts are good.  For example the bold
dialog font looks bad on a Mac, so Apple could use this property to
hint at a good font.
However, we don't promise to support these forever.  We may move
to getting these from the swing.properties file, or elsewhere.
Only access the boldMetal key if a look and feel has
been loaded, otherwise we'll trigger loading the look
menu and window are mapped to controlFont
While passing null may seem bad, we don't actually use
the table and looking it up is rather expensive.
This is the only information we can provide in a pipeline.
getLong() reduces chances of exceptions in toString()
Short cuts to constant pool
Get names from constant pool
only calculate on head
* Set the list of predicate expressions for this pattern step.
* @param predicates List of expression objects.
public void setPredicates(Expression[] predicates)
TODO: should keep throw sax exception...
TODO: should keep throw sax exception...
Type-specific CORBA::Object operations
form integral number of 6-bit groups
remove white spaces
should be divisible by four
if found "no data" just return null
if found "no data" just return null
Check if they are PAD characters
Two PAD e.g. 3c[Pad][Pad]
last 4 bits should be zero
One PAD  e.g. 3cQ[Pad]
last 2 bits should be zero
an error  like "3c[Pad]r", "3cdX", "3cXd", "3cXX" where X is non data
No PAD e.g 3cQl
count characters that's not whitespace
The quadratic parabola has degenerated to a line.
The line has degenerated to a constant.
From Numerical Recipes, 5.6, Quadratic and Cubic Equations
If d < 0.0, then there are no roots
For accuracy, calculate one root using:
(-b +/- d) / 2a
and the other using:
2c / (-b +/- d)
Choose the sign of the +/- so that b+d gets larger in magnitude
We already tested a for being 0 above
Trivially reject non-existant rectangles
Trivially accept if either endpoint is inside the rectangle
(not on its border since it may end there and not go inside)
Record where they lie with respect to the rectangle.
-1 => left, 0 => inside, 1 => right
Trivially reject if all points are entirely to one side of
All points left
All points above
All points right
All points below
Test for endpoints on the edge where either the segment
or the curve is headed "inwards" from them
Note: These tests are a superset of the fast endpoint tests
above and thus repeat those tests, but take more time
and cover more cases
First endpoint on border with either edge moving inside
Second endpoint on border with either edge moving inside
Trivially accept if endpoints span directly across the rectangle
We now know that both endpoints are outside the rectangle
but the 3 points are not all on one side of the rectangle.
Therefore the curve cannot be contained inside the rectangle,
but the rectangle might be contained inside the curve, or
the curve might intersect the boundary of the rectangle.
Both Y coordinates for the closing segment are above or
below the rectangle which means that we can only intersect
if the curve crosses the top (or bottom) of the rectangle
in more than one place and if those crossing locations
span the horizontal range of the rectangle.
Y ranges overlap.  Now we examine the X ranges
Both X coordinates for the closing segment are left of
or right of the rectangle which means that we can only
intersect if the curve crosses the left (or right) edge
of the rectangle in more than one place and if those
crossing locations span the vertical range of the rectangle.
The X and Y ranges of the endpoints overlap the X and Y
ranges of the rectangle, now find out how the endpoint
line segment intersects the Y range of the rectangle
If the part of the line segment that intersects the Y range
of the rectangle crosses it horizontally - trivially accept
Now we know that both the X and Y ranges intersect and that
the endpoint line segment does not directly cross the rectangle.
We can almost treat this case like one of the cases above
where both endpoints are to one side, except that we will
only get one intersection of the curve with the vertical
side of the rectangle.  This is because the endpoint segment
accounts for the other intersection.
(Remember there is overlap in both the X and Y ranges which
means that the segment must cross at least one vertical edge
of the rectangle - in particular, the "near vertical side" -
leaving only one intersection for the curve.)
Now we calculate the y tags of the two intersections on the
"near vertical side" of the rectangle.  We will have one with
the endpoint segment, and one with the curve.  If those two
vertical intersections overlap the Y range of the rectangle,
we have an intersection.  Otherwise, we don't.
c1tag = vertical intersection class of the endpoint segment
Choose the y tag of the endpoint that was not on the same
side of the rectangle as the subsegment calculated above.
Note that we can "steal" the existing Y tag of that endpoint
since it will be provably the same as the vertical intersection.
c2tag = vertical intersection class of the curve
We have to calculate this one the straightforward way.
Note that the c2tag can still tell us which vertical edge
to test against.
Note: We should be able to assert(num == 2); since the
X range "crosses" (not touches) the vertical boundary,
but we pass num to evalQuadratic for completeness.
Note: We can assert(num evals == 1); since one of the
2 crossings will be out of the [0,1] range.
Finally, we have an intersection if the two crossings
overlap the Y range of the rectangle.
Assertion: Quadratic curves closed by connecting their
endpoints are always convex.
this shouldn't happen, since we are Cloneable
??? may not be used anymore
<relation id> -> <RelationSupport object/ObjectName>
depending if the relation has been created using createRelation()
method (so internally handled) or is an MBean added as a relation by the
<relation id> -> <relation type name>
<relation MBean Object Name> -> <relation id>
<relation type name> -> <RelationType object>
<relation type name> -> ArrayList of <relation id>
to list all the relations of a given type
<ObjectName> -> HashMap
the value HashMap mapping:
<relation id> -> ArrayList of <role name>
to track where a given MBean is referenced.
Flag to indicate if, when a notification is received for the
unregistration of an MBean referenced in a relation, if an immediate
"purge" of the relations (look for the relations no
longer valid) has to be performed , or if that will be performed only
when the purgeRelations method will be explicitly called.
true is immediate purge.
Internal counter to provide sequence numbers for notifications sent by:
- the Relation Service
- a relation handled by the Relation Service
ObjectName used to register the Relation Service in the MBean Server
MBean Server where the Relation Service is registered
Filter registered in the MBean Server with the Relation Service to be
informed of referenced MBean deregistrations
List of unregistration notifications received (storage used if purge
of relations when unregistering a referenced MBean is not immediate but
on user request)
MBean Server not set by preRegister(): relation service not
Pre-registration: retrieves its ObjectName and MBean Server
No exception thrown.
Post-registration: does nothing
Pre-unregistration: does nothing
Post-unregistration: does nothing
Relation type handling
Can throw an InvalidRelationTypeException
Checks the role infos
Can throw InvalidRelationTypeException
Can throw a RelationTypeNotFoundException
Can throw a RelationTypeNotFoundException
Can throw a RoleInfoNotFoundException
Can throw RelationServiceNotRegisteredException
Checks if the relation type to be removed exists
Can throw a RelationTypeNotFoundException
Retrieves the relation ids for relations of that type
Note: take a copy of the list as it is a part of a map that
will be updated by removeRelation() below.
Removes the relation type from all maps
Removes all relations of that type
Note: will remove it from myRelId2RelTypeMap :)
Can throw RelationServiceNotRegisteredException (detected
Shall not throw a RelationNotFoundException
Can throw RelationServiceNotRegisteredException
Creates RelationSupport object
Can throw InvalidRoleValueException
Adds relation object as a relation into the Relation Service
Can throw RoleNotFoundException, InvalidRelationId,
Cannot throw MBeanException
Can throw RelationServiceNotRegisteredException
Checks that the relation MBean implements the Relation interface.
It will also check that the provided ObjectName corresponds to a
registered MBean (else will throw an InstanceNotFoundException)
Checks there is a relation id in the relation MBean (its uniqueness
is checked in addRelationInt())
Can throw InstanceNotFoundException (but detected above)
No MBeanException as no exception raised by this method, and no
Checks that the Relation Service where the relation MBean is
expected to be added is the current one
Can throw InstanceNotFoundException (but detected above)
No MBeanException as no exception raised by this method, no
Checks that a relation type has been specified for the relation
Can throw InstanceNotFoundException (but detected above)
No MBeanException as no exception raised by this method, no
Retrieves all roles without considering read mode
Can throw InstanceNotFoundException (but detected above)
No MBeanException as no exception raised by this method, no
Can throw RoleNotFoundException, InvalidRelationIdException,
Adds relation MBean ObjectName in map
Updates flag to specify that the relation is managed by the Relation
This flag and setter are inherited from RelationSupport and not parts
of the Relation interface, so may be not supported.
OK : The flag is not supported.
Updates listener information to received notification for
unregistration of this MBean
Can throw RelationNotFoundException
Can throw RelationNotFoundException
Can throw a RelationTypeNotFoundException
Can throw a RoleInfoNotFoundException to be transformed into
returned value RoleStatus.NO_ROLE_WITH_NAME
Can throw a RelationTypeNotFoundException
Can throw RelationNotFoundException
Can throw a RelationNotFoundException
Can throw RelationNotFoundException
Can throw RelationServiceNotRegisteredException
Verifies the relation has been added in the Relation Service
Can throw a RelationNotFoundException
Note: no need to test if oldValue not null before cloning,
List of ObjectNames of new referenced MBeans
Checks if this ObjectName was already present in old value
Note: use copy (oldRoleValue) instead of original
oldValue to speed up, as oldRoleValue is decreased
by removing unchanged references :)
New reference to an ObjectName
Stores this reference into map
Returns true if new reference, false if MBean already
Adds it into list of new reference
MBean was already referenced in old value
Removes it from old value (local list) to ignore it when
looking for remove MBean references
List of ObjectNames of MBeans no longer referenced
Each ObjectName remaining in oldRoleValue is an ObjectName no longer
referenced in new value
Removes MBean reference from map
Returns true if the MBean is no longer referenced in any
Adds it into list of references to be removed
To avoid having one listener per ObjectName of referenced MBean,
and to increase performances, there is only one listener recording
all ObjectNames of interest
Can throw RelationServiceNotRegisteredException
Checks there is a relation with this id
Can throw RelationNotFoundException
Removes it from listener filter
Can throw a RelationServiceNotRegisteredException
Sends a notification
Note: has to be done FIRST as needs the relation to be still in the
No RelationNotFoundException as checked above
Revisit [cebro] Handle CIM "Delete" and "IfDeleted" qualifiers:
deleting the relation can mean to delete referenced MBeans. In
that case, MBeans to be unregistered are put in a list sent along
with the notification below
Can throw a RelationNotFoundException (but detected above)
Removes the relation from various internal maps
- MBean reference map
Retrieves the MBeans referenced in this relation
Note: here we cannot use removeMBeanReference() because it would
require to know the MBeans referenced in the relation. For
that it would be necessary to call 'getReferencedMBeans()'
on the relation itself. Ok if it is an internal one, but if
it is an MBean, it is possible it is already unregistered, so
not available through the MBean Server.
List of MBeans no longer referenced in any relation, to be
removed fom the map
Retrieves relations where the MBean is referenced
MBean no longer referenced
Note: do not remove it here because pointed by the
Cleans MBean reference map by removing MBeans no longer
- Relation id to object map
- ObjectName to relation id map
Relation id to relation type name map
First retrieves the relation type name
- Relation type name to relation id map
Can be null if called from removeRelationType()
No other relation of that type
Can throw RelationServiceNotRegisteredException
Revisit [cebro] Handle the CIM "Delete" and "IfDeleted" qualifier:
if the unregistered MBean has the "IfDeleted" qualifier,
possible that the relation itself or other referenced MBeans
have to be removed (then a notification would have to be sent
to inform that they should be unregistered.
Clones the list of notifications to be able to still receive new
notifications while proceeding those ones
Updates the listener filter to avoid receiving notifications for
those MBeans again
Makes also a local "myRefedMBeanObjName2RelIdsMap" map, mapping
ObjectName -> relId -> roles, to remove the MBean from the global
List of references to be removed from the listener filter
Map including ObjectNames for unregistered MBeans, with
referencing relation ids and roles
Adds the unregsitered MBean in the list of references to
remove from the listener filter
Retrieves the associated map of relation ids and roles
Updates the listener
Can throw RelationServiceNotRegisteredException
Retrieves the relations where the MBean is referenced
List of relation ids where the unregistered MBean is
List of roles of the relation where the MBean is
Checks if the relation has to be removed or not,
regarding expected minimum role cardinality and current
number of references after removal of the current one
If the relation is kept, calls
handleMBeanUnregistration() callback of the relation to
Can throw RelationServiceNotRegisteredException
Shall not throw RelationNotFoundException,
Retrieves the relations referencing the MBean
Relation Ids where the MBean is referenced
List of relation ids of interest regarding the selected
Considers all relations
Considers only the relation ids for relations of given
Retrieves its relation type
Now looks at the roles where the MBean is expected to be
Retrieves list of role names where the MBean is
All roles to be considered
Note: no need to test if list not null before
cloning, MUST be not null else bug :(
Filters only the relations where the MBean is
referenced in  given role
Retrieves the map <relation id> -> <role names> for those
Retrieves ObjectNames of MBeans referenced in this relation
Shall not throw a RelationNotFoundException if incorrect status
of maps :(
For each MBean associated to given one in a relation, adds the
association <ObjectName> -> <relation id> into result map
Sees if this MBean is already associated to the given
one in another relation
Can throw RelationTypeNotFoundException
Can throw RelationServiceNotRegisteredException
Can throw a RelationNotFoundException
Can throw RoleNotFoundException
Can throw MBeanException wrapping a RoleNotFoundException:
throw wrapped exception
Shall not throw InstanceNotFoundException or ReflectionException
Can throw RelationServiceNotRegisteredException
Can throw a RelationNotFoundException
OK : This is an array of java.lang.String
so this should never happen...
Shall not throw InstanceNotFoundException, ReflectionException
Can throw a RelationNotFoundException
Shall not throw any Exception
Can throw a RelationNotFoundException
Can throw RoleNotFoundException
Can throw MBeanException wrapping RoleNotFoundException:
throw wrapped exception
Shall not throw InstanceNotFoundException or ReflectionException
Can throw RelationServiceNotRegisteredException
Can throw a RelationNotFoundException
Can throw RoleNotFoundException,
Shall not throw RelationTypeNotFoundException
(as relation exists in the RS, its relation type is known)
Can throw MBeanException wrapping RoleNotFoundException,
Shall not MBeanException wrapping an MBeanException wrapping
RelationTypeNotFoundException, or ReflectionException, or
Can throw RelationServiceNotRegisteredException
Can throw a RelationNotFoundException
Can throw RelationServiceNotRegisteredException
Shall not throw RelationTypeNotFoundException (as relation is
known, its relation type exists)
Shall not throw InstanceNotFoundException or an MBeanException
Can throw a RelationNotFoundException
Can throw a RelationNotFoundException
Note: use a flag to block access to
myRefedMBeanObjName2RelIdsMap only for a quick access
Unregistration of a referenced MBean
Can throw RelationServiceNotRegisteredException
but assume that will be fine :)
Note: do both tests as a relation can be an MBean and be
itself referenced in another relation :)
Unregistration of a relation MBean
Can throw RelationTypeNotFoundException,
Shall not throw RelationTypeNotFoundException or
Adds given object as a relation type.
-param relationTypeObj  relation type object
-exception IllegalArgumentException  if null parameter
-exception InvalidRelationTypeException  if there is already a relation
type with that name
Checks that there is not already a relation type with that name
existing in the Relation Service
Can throw a RelationTypeNotFoundException (in fact should ;)
OK : The RelationType could not be found.
Adds the relation type
Retrieves relation type with given name
-param relationTypeName  expected name of a relation type created in the
-return RelationType object corresponding to given name
-exception IllegalArgumentException  if null parameter
-exception RelationTypeNotFoundException  if no relation type for that
name created in Relation Service
No null relation type accepted, so can use get()
Retrieves relation corresponding to given relation id.
- a RelationSupport object if the relation is internal
- the ObjectName of the corresponding MBean
-param relationId  expected relation id
-return RelationSupport object or ObjectName of relation with given id
-exception IllegalArgumentException  if null parameter
-exception RelationNotFoundException  if no relation for that
relation id created in Relation Service
No null relation  accepted, so can use get()
Adds a new MBean reference (reference to an ObjectName) in the
referenced MBean map (myRefedMBeanObjName2RelIdsMap).
-param objectName  ObjectName of new referenced MBean
-param relationId  relation id of the relation where the MBean is
-param roleName  name of the role where the MBean is referenced
- true  if the MBean was not referenced before, so really a new
- false else
-exception IllegalArgumentException  if null parameter
Checks if the MBean was already referenced
No null value allowed, use get() directly
MBean not referenced in any relation yet
List of roles where the MBean is referenced in given
Map of relations where the MBean is referenced
MBean already referenced in at least another relation
Checks if already referenced in another role in current
MBean not referenced in current relation
List of roles where the MBean is referenced in given
Adds new reference done in current relation
MBean already referenced in current relation in another
Adds new reference done
Removes an obsolete MBean reference (reference to an ObjectName) in
the referenced MBean map (myRefedMBeanObjName2RelIdsMap).
-param objectName  ObjectName of MBean no longer referenced
-param relationId  relation id of the relation where the MBean was
-param roleName  name of the role where the MBean was referenced
-param allRolesFlag  flag, if true removes reference to MBean for all
roles in the relation, not only for the one above
- true  if the MBean is no longer reference in any relation
- false else
-exception IllegalArgumentException  if null parameter
Retrieves the set of relations (designed via their relation ids)
where the MBean is referenced
Note that it is possible that the MBean has already been removed
from the internal map: this is the case when the MBean is
unregistered, the role is updated, then we arrive here.
The MBean is no longer referenced
Now retrieves the roles of current relation where the MBean
Removes obsolete reference to role
Checks if there is still at least one role in current relation
where the MBean is referenced
MBean no longer referenced in current relation: removes
Checks if the MBean is still referenced in at least on relation
MBean no longer referenced in any relation: removes entry
Updates the listener registered to the MBean Server to be informed of
referenced MBean deregistrations
-param newRefList  ArrayList of ObjectNames for new references done
to MBeans (can be null)
-param obsoleteRefList  ArrayList of ObjectNames for obsolete references
to MBeans (can be null)
-exception RelationServiceNotRegisteredException  if the Relation
Service is not registered in the MBean Server.
Nothing to do :)
Can throw RelationServiceNotRegisteredException
Initialize it to be able to synchronise it :)
Enables ObjectNames in newRefList
Disables ObjectNames in obsoleteRefList
The Relation Service was already registered as a
Shall not throw InstanceNotFoundException (as the
MBean Server Delegate is expected to exist) or
ListenerNotFoundException (as it has been checked above
that the Relation Service is registered)
Adds Relation Service with current filter
Can throw InstanceNotFoundException if the Relation
Service is not registered, to be transformed into
Assume that there will not be any InstanceNotFoundException
for the MBean Server Delegate :)
Adds a relation (being either a RelationSupport object or an MBean
referenced using its ObjectName) in the Relation Service.
Will send a notification RelationNotification with type:
- RelationNotification.RELATION_BASIC_CREATION for internal relation
- RelationNotification.RELATION_MBEAN_CREATION for an MBean being added
as a relation.
-param relationBaseFlag  flag true if the relation is a RelationSupport
object, false if it is an MBean
-param relationObj  RelationSupport object (if relation is internal)
-param relationObjName  ObjectName of the MBean to be added as a relation
(only for the relation MBean)
-param relationId  relation identifier, to uniquely identify the relation
inside the Relation Service
-param relationTypeName  name of the relation type (has to be created
in the Relation Service)
-param roleList  role list to initialize roles of the relation
(can be null)
-exception IllegalArgumentException  if null paramater
-exception RelationServiceNotRegisteredException  if the Relation
Service is not registered in the MBean Server
-exception RoleNotFoundException  if a value is provided for a role
that does not exist in the relation type
-exception InvalidRelationIdException  if relation id already used
-exception RelationTypeNotFoundException  if relation type not known in
-exception InvalidRoleValueException if:
- the same role name is used for two different roles
- the number of referenced MBeans in given value is less than
expected minimum degree
- the number of referenced MBeans in provided value exceeds expected
- one referenced MBean in the value is not an Object of the MBean
class expected for that role
- an MBean provided for that role does not exist
Can throw RelationServiceNotRegisteredException
Checks if there is already a relation with given id
Can throw a RelationNotFoundException (in fact should :)
There is already a relation with that id
OK : The Relation could not be found.
Retrieves the relation type
Can throw RelationTypeNotFoundException
Checks that each provided role conforms to its role info provided in
the relation type
First retrieves a local list of the role infos of the relation type
to see which roles have not been initialized
Note: no need to test if list not null before cloning, not allowed
to have an empty relation type.
Retrieves corresponding role info
Can throw a RoleInfoNotFoundException to be converted into a
Checks that role conforms to role info,
A problem has occurred: throws appropriate exception
Removes role info for that list from list of role infos for
roles to be defaulted
Note: no need to check if != -1, MUST be there :)
Initializes roles not initialized by roleList
Can throw InvalidRoleValueException
Creation of relation successfull!!!!
Updates internal maps
Relation id to object map
Note: do not clone relation object, created by us :)
Relation id to relation type name map
Relation type to relation id map
Referenced MBean to relation id map
Only role list parameter used, as default initialization of roles
done automatically in initializeMissingRoles() sets each
uninitialized role to an empty value.
Creates a dummy empty ArrayList of ObjectNames to be the old
role value :)
Will not throw a RelationNotFoundException (as the RelId2Obj map
has been updated above) so catch it :)
OK : The Relation could not be found.
Sends a notification for relation creation
Will not throw RelationNotFoundException so catch it :)
OK : The Relation could not be found.
Checks that given role conforms to given role info.
-param chkType  type of check:
- 1: read, just check read access
- 2: write, check value and write access if writeChkFlag
-param roleName  role name
-param roleValue  role value
-param roleInfo  corresponding role info
-param writeChkFlag  boolean to specify a current write access and
to check it
-return Integer with value:
- 0: ok
-exception IllegalArgumentException  if null parameter
Checks read access if required
End of check :)
Checks write access if required
Checks minimum cardinality
Checks maximum cardinality
Verifies that each referenced MBean is registered in the MBean
Server and that it is an instance of the class specified in the
role info, or of a subclass of it
Note that here again this is under the assumption that
referenced MBeans, relation MBeans and the Relation Service are
registered in the same MBean Server.
Checks it is registered
Checks if it is of the correct class
Can throw an InstanceNotFoundException, if MBean not registered
Initializes roles associated to given role infos to default value (empty
ArrayList of ObjectNames) in given relation.
It will succeed for every role except if the role info has a minimum
cardinality greater than 0. In that case, an InvalidRoleValueException
will be raised.
-param relationBaseFlag  flag true if the relation is a RelationSupport
object, false if it is an MBean
-param relationObj  RelationSupport object (if relation is internal)
-param relationObjName  ObjectName of the MBean to be added as a relation
(only for the relation MBean)
-param relationId  relation id
-param relationTypeName  name of the relation type (has to be created
in the Relation Service)
-param roleInfoList  list of role infos for roles to be defaulted
-exception IllegalArgumentException  if null paramater
-exception RelationServiceNotRegisteredException  if the Relation
Service is not registered in the MBean Server
-exception InvalidRoleValueException  if role must have a non-empty
Revisit [cebro] Handle CIM qualifiers as REQUIRED to detect roles which
should have been initialized by the user
Can throw RelationServiceNotRegisteredException
For each role info (corresponding to a role not initialized by the
role list provided by the user), try to set in the relation a role
with an empty list of ObjectNames.
A check is performed to verify that the role can be set to an
empty value, according to its minimum cardinality
Creates an empty value
Creates a role
Can throw InvalidRoleValueException
Will not throw RoleNotFoundException (role to be
initialized), or RelationNotFoundException, or
Relation is an MBean
Use standard setRole()
Can throw MBeanException wrapping
InvalidRoleValueException. Returns the target exception to
Will not throw MBeanException (wrapping
RoleNotFoundException or MBeanException) or
InstanceNotFoundException, or ReflectionException
Again here the assumption is that the Relation Service and
the relation MBeans are registered in the same MBean Server.
Throws an exception corresponding to a given problem type
-param pbType  possible problem, defined in RoleUnresolved
-param roleName  role name
-exception IllegalArgumentException  if null parameter
-exception RoleNotFoundException  for problems:
-exception InvalidRoleValueException  for problems:
Exception type: 1 = RoleNotFoundException
2 = InvalidRoleValueException
No default as we must have been in one of those cases
Sends a notification of given type, with given parameters
-param intNtfType  integer to represent notification type:
- 1 : create
- 2 : update
- 3 : delete
-param message  human-readable message
-param relationId  relation id of the created/updated/deleted relation
-param unregMBeanList  list of ObjectNames of referenced MBeans
expected to be unregistered due to relation removal (only for removal,
due to CIM qualifiers, can be null)
-param roleName  role name
-param roleNewValue  role new value (ArrayList of ObjectNames)
-param oldValue  old role value (ArrayList of ObjectNames)
-exception IllegalArgument  if null parameter
-exception RelationNotFoundException  if no relation for given id
Relation type name
Note: do not use getRelationTypeName() as if it is a relation MBean
it is already unregistered.
ObjectName (for a relation MBean)
Can also throw a RelationNotFoundException, but detected above
Creation or removal
Checks, for the unregistration of an MBean referenced in the roles given
in parameter, if the relation has to be removed or not, regarding
expected minimum role cardinality and current number of
references in each role after removal of the current one.
If the relation is kept, calls handleMBeanUnregistration() callback of
the relation to update it.
-param relationId  relation id
-param objectName  ObjectName of the unregistered MBean
-param roleNameList  list of names of roles where the unregistered
MBean is referenced.
-exception IllegalArgumentException  if null parameter
-exception RelationServiceNotRegisteredException  if the Relation
Service is not registered in the MBean Server
-exception RelationNotFoundException  if unknown relation id
-exception RoleNotFoundException  if one role given as parameter does
not exist in the relation
Can throw RelationServiceNotRegisteredException
Retrieves the relation type name of the relation
Can throw RelationNotFoundException
Retrieves the relation
Can throw RelationNotFoundException, but already detected above
Flag to specify if the relation has to be deleted
Retrieves number of MBeans currently referenced in role
BEWARE! Do not use getRole() as role may be not readable
Can throw RelationNotFoundException (but already checked),
Retrieves new number of element in role
Retrieves role info for that role
Shall not throw RelationTypeNotFoundException or
Checks with expected minimum number of elements
The relation has to be deleted
Removes the relation
Updates each role in the relation using
BEWARE: this roleNameList list MUST BE A COPY of a role name
list for a referenced MBean in a relation, NOT a
reference to an original one part of the
myRefedMBeanObjName2RelIdsMap!!!! Because each role
which name is in that list will be updated (potentially
using setRole(). So the Relation Service will update the
myRefedMBeanObjName2RelIdsMap to refelect the new role
Can throw RoleNotFoundException (but already checked)
Shall not throw
InvalidRoleValueException (value was correct, removing
one reference shall not invalidate it, else detected
Shall not throw InstanceNotFoundException, or
MBeanException (wrapping RoleNotFoundException or
MBeanException or InvalidRoleValueException) or
A collection of DOMString values
GETTERS AND SETTERS
Message keys used by the serializer
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The localname is the portion after the optional colon; the message indicates
that there is a problem with that part of the QNAME.
Note to translators:  A QNAME has the syntactic form [NCName:]NCName
The prefix is the portion before the optional colon; the message indicates
that there is a problem with that part of the QNAME.
synchronizeData will initialize attributes
Support for DOM Level 3 renameNode method.
Note: This only deals with part of the pb. CoreDocumentImpl
does all the work.
Replicate NamedNodeMap rather than sharing it.
Absolute base URI is computed according to
XML Base (http:www.w3.org/TR/xmlbase/#granularity)
1. The base URI specified by an xml:base attribute on the element,
if one exists
attribute value is always empty string
This may be a relative URI.
Make any parentURI into a URI object to use with the URI(URI, String) constructor
This should never happen: parent should have checked the URI and returned null if invalid.
2.the base URI of the element's parent element within the
document or external entity, if one exists
3. the base URI of the document entity or external entity
containing the element
ownerNode serves as a parent or as document
base URI of parent element is not null
return valid absolute base URI
No need to normalize if already normalized.
If kid is a text node, we need to check for one of two
1) There is an adjacent text node
2) There is no adjacent text node, but kid is
an empty text node.
If an adjacent text node, merge it with kid
Don't advance; there might be another.
If kid is empty, remove it
Otherwise it might be an Element, which is handled recursively
We must also normalize all of the attributes
changed() will have occurred when the removeChild() was done,
so does not have to be reissued.
This will throw INUSE if necessary
DOM2: Namespace methods
REVISIT: this is not efficient, we are creating twice the same
strings for prefix and localName.
Note: we can't just change the name of the attribute. Names have to be in sorted
order in the attributes vector because a binary search is used to locate them.
If the new name has a different prefix, the list may become unsorted.
Maybe it would be better to resort the list, but the simplest
fix seems to be to remove the old attribute and re-insert it.
-- Norman.Walsh@Sun.COM, 2 Feb 2007
This case may happen if user calls:
This case is not defined by the DOM spec, we choose
to create a new attribute in this case and remove an old one from the tree
note this might cause events to be propagated or user data to be lost
This will throw INUSE if necessary
DOM Level 1 Node
if namespace uri is empty string, set it to 'null'
no need to sync in the future
we don't want to generate any event for this so turn them off
set mutation events flag back to its original value
support for DOM Level 3 renameNode method
End of file.
End of file.
Space between the border and the component's edge
Space between the border and text
Horizontal inset of text that is left or right justified
REMIND(aim): remove all or some of these set methods?
-- This file was mechanically generated: Do not edit! --
Cached unsafe-access object
Cached array base offset
Cached unaligned-access capability
Base address, used in all indexing calculations
NOTE: moved up to Buffer.java for speed in JNI GetDirectBufferAddress
An object attached to this buffer. If this buffer is a view of another
buffer then we use this field to keep a reference to that buffer to
ensure that its memory isn't freed before we are done with it.
Round up to page boundary
Invoked to construct a direct ByteBuffer referring to the block of
memory. A given arbitrary object may also be attached to the buffer.
Invoked only by JNI: NewDirectByteBuffer(void*, long)
For memory-mapped buffers -- invoked by FileChannelImpl via reflection
For duplicates and slices
IHR: Visited on 2006-11-17
Added a boolean return value to particleValidRestriction (it was a void function)
to help the checkRecurseLax to know when expansion has happened and no order is required
This assumes that the names are never null.
if derived is anyType, then it's valid only if base is anyType too
if derived is anySimpleType, then it's valid only if the base
if derived is simple type
if base is complex type
if base is anyType, change base to anySimpleType,
otherwise, not valid
if derived is anySimpleType, then it's valid only if the base
if base is complex type
if base is anyType, change base to anySimpleType,
otherwise, not valid
if derived is anyType, then it's valid only if base is anyType too
1 They are the same type definition.
2 All of the following must be true:
2.2 One of the following must be true:
2.2.1 D's base type definition is B.
2.2.2 D's base type definition is not the simple ur-type definition and is validly derived from B given the subset, as defined by this constraint.
2.1 B and D must be the same type definition.
2 One of the following must be true:
2.3 All of the following must be true:
2.3.2 The appropriate case among the following must be true:
if base is complex type
if base is anyType, change base to anySimpleType,
otherwise, not valid
For a string to be a valid default with respect to a type definition the appropriate case among the following must be true:
1 If the type definition is a simple type definition, then the string must be valid with respect to that definition as defined by String Valid (3.14.4).
2 If the type definition is a complex type definition, then all of the following must be true:
2.2 The appropriate case among the following must be true:
get the simple type declaration, and validate
complex type with mixed. to make sure that we store correct
information in vinfo and return the correct value, we use
"string" type for validation
validate the original lexical rep, and set the actual value
validate the canonical lexical rep
get all grammars, and put all substitution group information
in the substitution group handler
before worrying about complexTypes, let's get
groups redefined by restriction out of the way.
can't be a restriction!
for each complex type, check the 3 constraints.
types need to be checked
to hold the errors
REVISIT: do we want to report all errors? or just one?
whether only do UPA checking
if do all checkings, how many need to be checked again.
i: grammar; j: type; k: error
for all grammars
get whether to skip EDC, and types need to be checked
for each type
if we've already full-checked this grammar, then
skip the EDC constraint
1. Element Decl Consistent
2. Particle Derivation
get the content model and check UPA
now report all errors
REVISIT: do we want to report all errors? or just one?
if we are doing all checkings, and this one needs further
checking, store it in the type array.
clear errors for the next type.
REVISIT: do we want to report all errors? or just one?
we've done with the types in this grammar. if we are checking
all constraints, need to trim type array to a proper size:
only contain those need further checking.
and mark this grammar that it only needs UPA checking.
check for elements in the tree with the same name and namespace
Check for subsitution groups.
How can we avoid this concat?  LM.
just add it in
If this is the same check element, we're O.K.
Types are not the same
Check that a given particle is a valid restriction of a base particle.
Returns a boolean indicating if there has been expansion of substitution group
in the bParticle.
With this information the checkRecurseLax function knows when is
to keep the order and when to ignore it.
By default there has been no expansion
Check for empty particles.   If either base or derived particle is empty,
(and the other isn't) it's an error.
Do setup prior to invoking the Particle (Restriction) cases.
- removing pointless occurrences for groups, and retrieving a vector of
- turning top-level elements with substitution groups into CHOICE groups.
Handle pointless groups for the derived particle
Find a group, starting with this particle, with more than 1 child.   There
may be none, and the particle of interest trivially becomes an element or
Particle has been replaced.   Retrieve new type info.
Fill in a vector with the children of the particle, removing any
pointless model groups in the process.
For elements which are the heads of substitution groups, treat as CHOICE
Check for subsitution groups.   Treat any element that has a
subsitution group as a choice.   Fill in the children vector with the
members of the substitution group
Now, set the type to be CHOICE.  The "group" will have the same
occurrence information as the original particle.
Fill in the vector of children
Set the handler to null, to indicate that we've finished handling
substitution groups for this particle.
Handle pointless groups for the base particle
Find a group, starting with this particle, with more than 1 child.   There
may be none, and the particle of interest trivially becomes an element or
Particle has been replaced.   Retrieve new type info.
Fill in a vector with the children of the particle, removing any
pointless model groups in the process.
Check for subsitution groups.   Treat any element that has a
subsitution group as a choice.   Fill in the children vector with the
members of the substitution group
Now, set the type to be CHOICE
Set the handler to null, to indicate that we've finished handling
substitution groups for this particle.
if we are here expansion of bParticle happened
O.K. - Figure out which particle derivation rule applies and call it
Treat the element as if it were in a group of the same type
as the base Particle
Treat the element as if it were in a group of the same type
as the base Particle
Check that the names are the same
Check occurrence range
Check for consistent fixed values
derived one has to have a fixed value
get simple type
if there is no simple type, then compare based on string
Check identity constraints
Check for disallowed substitutions
Check that the derived element's type is derived from the base's.
check Occurrence ranges
check wildcard allows namespace of element
check Occurrence ranges
check wildcard subset
check Occurrence ranges
Check that each member of the group is a valid restriction of the wildcard
REVISIT: should we really just ignore original cause of this error?
how can we report it?
check Occurrence ranges
Now, see if there are some elements in the base we didn't match up
check Occurrence ranges
didn't find a match.  Detect an error
Now, see if there are some elements in the base we didn't match up
check Occurrence ranges
IHR: go back one element on b list because the next element may match
this as well.
didn't find a match.  Detect an error
See if the sequence group is a valid restriction of the choice
Here is an example of a valid restriction:
check Occurrence ranges
didn't find a match.  Detect an error
to check whether two element overlap, as defined in constraint UPA
if the two element have the same name and namespace,
or if there is an element decl in element1's substitution group,
who has the same name/namespace with element2
or if there is an element decl in element2's substitution group,
who has the same name/namespace with element1
to check whether an element overlaps with a wildcard,
as defined in constraint UPA
if the wildcard allows the element
or if the wildcard allows any element in the substitution group
if the intersection of the two wildcard is not empty list
call one of the above methods according to the type of decls
-- This file was mechanically generated: Do not edit! --
the Identity constraint we're the matcher for.  Only
used for selectors!
verify that an attribute is not selected
NOTE: We have to prefix the selector XPath with "./" in
order to handle selectors such as "." that select
the element container because the fields could be
relative to that element. -Ac
Unless xpath starts with a descendant node -Achille Fokoue
... or a '.' or a '/' - NG
And we also need to prefix exprs to the right of | with ./ - NG
activate the fields, if selector is matched
this trick is needed to allow the RetrievalMethodResolver to eat a
ds:RSAKeyValue directly (without KeyValue)
helper class for deferred invocations
do the actual invocation
for the asynchronous case, note that the response has been
update local boolean indicator
notify any client waiting on a 'get_response'
End of EditableView
this draws the MenuBar border
The width of the border
Returns true if the associated component has focus.
The size of the bounding box for Motif frame corners.
Returns true if the associated internal frame has focus.
inner 3D border
inner 3D border
black drop shadow  __|
inner 3D border
black drop shadow  __|
Space between the border and text
Space for the separator under the title
-- This file was mechanically generated: Do not edit! --
enforce limit == capacity
Note the use of max value rather than minimum value here.
See the opening preamble on arithmetic with springs.
No need to check for UNSET as
Integer.MIN_VALUE == -Integer.MIN_VALUE.
We will be doing arithmetic with the results of this call,
so if a returned value is Integer.MAX_VALUE we will get
arithmetic overflow. Truncate such values.
Use the instance variables of the StaticSpring superclass to
cache values that have already been calculated.
Remove these, they're not used often and can be created using minus -
as per these implementations.
drop through to ZoneRulesProvider
invalid ZoneRegion is not important to this method
this is here for serialization Javadoc
$Id: JAXPPrefixResolver.java,v 1.1.2.1 2005/08/01 01:30:18 jeffsuttor Exp $
--- EditorKit methods ---------------------------
remove references to current document so it can be collected.
EditorKit might not have installed the StyledDocument yet.
record current character attributes.
If nothing is selected, get the attributes from the character
before the start of the selection, otherwise get the attributes
from the character element at the start of the selection.
Get the attributes from the character at the selection
if in a different paragrah!
New document will have changed selection to 0,0.
---- default ViewFactory implementation ---------------------
default to text display
--- Action implementations ---------------------------------
See if we are in a JTextComponent.
Need to support:
default_outside_border: Insets when default.
interior_focus: Indicates if focus should appear inside border, or
focus-line-width: Integer giving size of focus border
focus-padding: Integer giving padding between border and focus
NOTE: this is called for JCheckBox too
NOTE: this is called for JCheckBoxMenuItem too
Does not call into ENGINE for better performance
Paint the default indicator
Render the box.
Toolbar buttons should only have their background painted
in the PRESSED, SELECTED, or MOUSE_OVER states.
Otherwise, always paint the button's background, unless
the user has overridden it and we're in the ENABLED state.
Does not call into ENGINE for better performance
This is called for both MENU and MENU_ITEM
Note that we don't call paintCachedImage() here.  Since the
progress bar foreground is painted differently for each value
it would be wasteful to try to cache an image for each state,
so instead we simply avoid caching in this case.
don't bother caching the image
For regular/menu separators, we simply subtract out the insets.
For focused sliders, we paint focus rect outside the bounds passed.
Need to adjust for that.
The ubuntulooks engine paints slider troughs differently depending
on the current slider value and its component orientation.
not used for sliders; any value will work
Note that we don't call paintCachedImage() here.  Since some
engines (e.g. ubuntulooks) paint the slider background
differently for any given slider value, it would be wasteful
to try to cache an image for each state, so instead we simply
avoid caching in this case.
don't bother caching the image
This is handled in paintTextFieldBackground
Does not call into ENGINE for better performance
NOTE: Combobox and Label, Password and FormattedTextField calls this
Text is odd in that it uses the TEXT_BACKGROUND vs BACKGROUND.
Does not call into ENGINE for better performance
Note: the scrollbar insets already include the "trough-border",
which is needed to position the scrollbar buttons properly.
But when we render, we need to take the trough border out
of the equation so that we paint the entire area covered by
the trough border and the scrollbar content itself.
The clearlooks engine paints scrollbar thumbs differently
depending on the current scroll value (specifically, it will avoid
rendering a certain line when the thumb is at the starting or
ending position).  Therefore, we normalize the current value to
the range [0,100] here and then pass it down to setRangeValue()
so that the native widget is configured appropriately.  Note that
there are really only four values that matter (min, middle, max,
or fill) so we restrict to one of those four values to avoid
blowing out the image cache.
In this case, the thumb fills the entire track, so it is
touching both ends at the same time
Somewhere in between
the string arg should alternate based on row being painted,
but we currently don't pass that in.
As far as I can tell, these don't call into the ENGINE.
As far as I can tell, these don't call into the ENGINE.
Also note that you don't want this to call into the ENGINE
as if it where to paint a background JViewport wouldn't scroll
All icon painting methods are called from under GTK_LOCK
The orientation parameter passed down by Synth refers to the
orientation of the toolbar, but the one we pass to GTK refers
to the orientation of the handle.  Therefore, we need to swap
the value here: horizontal toolbars have vertical handles, and
Refer to GTKLookAndFeel for details on this.
TitledBorder implementation for GTK L&F
keySet, may be empty but is never null, typ. a tiny array
boolean isRegistered, protected by key set
regLock, lock object to prevent duplicate registrations
boolean isBlocking, protected by regLock
create all built-in types
TODO: move specific 1.0 DV implementation from base
-- This file was mechanically generated: Do not edit! --
enforce limit == capacity
The original URL may have been redirected - this
sets it to whatever URL/codebase we ended up getting
Parse the document
Return list of parsed MLets
Access rights of parsed class
Names of implemented interfaces
collection of constants
class fields, i.e., its variables
methods defined in the class
attributes defined in the class
Loaded from zip file
Not a very clean solution ...
Is already a data stream
Check magic tag of class file
Get compiler version
Read constant pool entries
Get class information
Get interface information, i.e., implemented interfaces
Read class fields, i.e., the variables of the class
Read class methods, i.e., the functions in the class
Read class attributes
Check for unknown variables
for(int i=0; i < u.length; i++)
Everything should have been read now
Read everything of interest, so close the file
Return the information we have gathered in a new object
Set the fragment's moreFragments field to true
Reuse the old buffer
REVISIT - need to account for case when needed > available
even after fragmenting.  This is the large array case, so
the caller should retry when it runs out of space.
Now we must marshal in the fragment header/GIOP header
REVISIT - we can optimize this by not creating the fragment message
REVISIT: need an ORB
Send the fragment
Sends the last fragment
See JLS sections 8.1.1, 8.3.1, 8.4.3, 8.8.3, and 9.1.1.
java.lang.reflect.Modifier includes INTERFACE, but that's a VMism.
Must adjust _startNode if self is included
Portable Interceptor initialization.
This locking is done so that multiple connections are not created
for the same endpoint
7046238 - Synchronization on a single monitor for contactInfo parameters
with identical hashCode(), so we lock on same monitor for equal parameters
(which can refer to equal (in terms of equals()) but not the same objects)
REVISIT: this part similar to marshalingComplete below.
this part similar to Remarshal in this method below
Do not do connection reclaim here since the connections
are marked in use by registerWaiter() call and since this
call happens later do it after that.
NOTE: Thread data so we can get the mediator in release reply
in order to remove the waiter in CorbaConnection.
We cannot depend on obtaining information in releaseReply
via its InputStream argument since, on certain errors
(e.g., client marshaling errors), the stream may be null.
Likewise for releaseReply "self".
NOTE: This must be done before initializing the message since
that may start sending fragments which may end up in "early"
replies or client marshaling exceptions.
NOTE: Not necessary for oneways, but useful for debugging.
This must be done BEFORE message initialization since fragments
may be sent at that time.
Do connection reclaim now
This MUST come before message is initialized so
service contexts may be added by PI because
initial fragments may be sent during message initialization.
NOTE: We get here because an interceptor raised ForwardRequest
and updated the IOR/Iterator.  Since we have a fresh iterator
hasNext should succeed.
REVISIT: We should feed ALL interceptor exceptions to
iterator.reportException so it can determine if it wants
to retry.  Right now, SystemExceptions will flow to the
This assumes that interceptors update
ContactInfoList outside of subcontract.
Want to move that update to here.
Fix for 6763340: Complete the first attempt before starting another.
Bug 6382377: must not lose exception in PI
Must run interceptor end point before retrying.
NOTE: Interceptor ending point will run in releaseReply.
We know for sure now that we've sent a message.
So OK to not send initial again.
NOTE: not necessary to set MessageMediator for PI.
It already has it.
Process the response.
Invoke Portable Interceptors with receive_other
Now that we have the service contexts processed and the
correct ORBVersion set, we must finish initializing the stream.
REVISIT - need interface for this operation.
Invoke Portable Interceptors with receive_exception:
If PI did not change the exception, throw a
exception = null is to maintain symmetry with
Otherwise, throw the exception PI wants thrown.
No retry, so see if was unknown.
Invoke Portable Interceptors with receive_exception:
It was not a comm failure nor unknown.
This is the general case.
Invoke Portable Interceptors with receive_exception:
Note: We should never need to execute this line, but
we should assert in case exception is null somehow.
This return will be ignored - already unmarshaled above.
NOTE: Expects iterator to update target IOR
Invoke Portable Interceptors with receive_other:
If PI did not change exception, throw Remarshal, else
throw the exception PI wants thrown.
KMC: GenericPOAClientSC did not check exception != null
Set the desired target addressing disposition.
Invoke Portable Interceptors with receive_other:
For consistency with corresponding code in GenericPOAClientSC:
If PI did not change exception, throw Remarshal, else
throw the exception PI wants thrown.
KMC: GenericPOAClientSC did not include exception != null check
Invoke Portable Interceptors with receive_reply:
Remember: not thrown if exception is null.
Filters the given exception into a SystemException or a
RemarshalException and throws it.  Assumes the given exception is
of one of these two types.  This is a utility method for
the above invoke code which must do this numerous times.
If the exception is null, no exception is thrown.
Note that this code is duplicated in GenericPOAClientSC.java
REVISIT - unify with PI handling
NOTE - We must unregister the waiter NOW for this request
since the retry will result in a new request id.  Therefore
the old request id would be lost and we would have a memory
leak in the responseWaitingRoom.
The messageMediator may be null if COMM_FAILURE before
it is created.
Add the RMI-IIOP max stream format version
service context to every request.  Once we have GIOP 1.3,
we could skip it since we now support version 2, but
probably safer to always send it.
ORBVersion servicecontext needs to be sent
NOTE : We only want to send the runtime context the first time
Do not do c.setPostInitialContexts() here.
If a client interceptor send_request does a ForwardRequest
which ends up using the same connection then the service
context would not be sent.
no service context available, return gracefully.
set the codebase returned by the server
see if the version subcontract is present, if yes, then set
Note: the inputObject may be null if an error occurs
in request or before _invoke returns.
Note: self may be null also (e.g., compiler generates null in stub).
Release any outstanding NIO ByteBuffers to the ByteBufferPool
XREVISIT NOTE - Assumes unregistering the waiter for
location forwards has already happened somewhere else.
The code below is only going to unregister the final successful
NOTE: In the case of a recursive stack of endRequests in a
finally block (because of Remarshal) only the first call to
unregisterWaiter will remove the waiter.  The rest will be
Invoke Portable Interceptors cleanup.  This is done to handle
exceptions during stream marshaling.  More generally, exceptions
that occur in the ORB after send_request (which includes
after returning from _request) before _invoke:
REVISIT: Early replies?
See CDRInput/OutputObject.close() for more info.
This won't result in a Corba error if an IOException happens.
XXX This seems to be a broken double checked locking idiom: FIX IT!
conn.getCodeSetContext() is null when no other requests have
been made on this connection to trigger code set negotation.
Double checking.  Don't let any other
threads use this connection until the
code sets are straight.
This only looks at the first code set component.  If
there can be multiple locations with multiple code sets,
this requires more work.
Didn't have a code set component.  The default will
be to use ISO8859-1 for char data and throw an
exception if wchar data is used.
Get the native and conversion code sets the
server specified in its IOR
Perform the negotiation between this ORB's code sets and
the ones from the IOR
REVISIT.  OMG issue 3318 concerning sending the code set
service context more than once was deemed too much for the
RTF.  Here's our strategy for the moment:
Send it on every request (necessary in cases of fragmentation
with multithreaded clients or when the first thing on a
connection is a LocateRequest).  Provide an ORB property
to disable multiple sends.
Note that the connection is null in the local case and no
service context is included.  We use the ORB provided
Also, there will be no negotiation or service context
in GIOP 1.0.  ISO8859-1 is used for char/string, and
wchar/wstring are illegal.
Get the negotiated code sets (if any) out of the connection
Either we shouldn't send the code set service context, or
for some reason, the connection doesn't have its code sets.
Perhaps the server didn't include them in the IOR.  Uses
ISO8859-1 for char and makes wchar/wstring illegal.
REVISIT - need interface for mark/reset
End of file.
If it's a Xerces DOM store type information for attributes, set idness, etc..
write type information to this attribute
Add default/fixed attributes
If it's a Xerces DOM store type information for attributes, set idness, etc..
write type information to this attribute
Write type information to this element
State values that determine which methods are allowed.
get_effective_policy, manager_id, and adapter_state are valid unless STATE_DONE
add_component, and add_component_to_profile are valid.
adapter_template, and R/W to current_factory are valid
No methods are valid in this state
The current state of this object
The ObjectAdapter associated with this IORInfo object.
At this point, the iortemp must contain only a single
IIOPProfileTemplate.  This is a restriction of our
implementation.  Also, note the the ObjectReferenceTemplate
is called when a certain POA is created in a certain ORB
in a certain server, so the server_id, orb_id, and
poa_id operations must be well-defined no matter what
kind of implementation is used: e.g., if a POA creates
IORs with multiple profiles, they must still all agree
about this information.  Thus, we are justified in
extracting the single IIOPProfileTemplate to create
an ObjectReferenceTemplate here.
Convert the given IOP::TaggedComponent into the appropriate
type for the TaggedProfileTemplate
Iterate through TaggedProfileTemplates and add the given tagged
component to the appropriate one(s).
If no profile was found with the given id, throw a BAD_PARAM:
(See orbos/00-08-06, section 21.5.3.3.)
REVISIT: add minor codes!
Flags defining possible monitor errors.
Stop the Monitor.
GETTERS AND SETTERS
Check that the specified object is not already contained.
Add the specified object in the list.
Update legacy protected stuff.
Check for null object.
Remove the specified object from the list.
Update legacy protected stuff.
Update alreadyNotified array.
Reset the complex type attribute information
such that it is recalculated again.
Reschedule the scheduler task if the monitor is active.
Reset the complex type attribute information
such that it is recalculated again.
Cache the AccessControlContext of the Monitor.start() caller.
The monitor tasks will be executed within this context.
Start the scheduler.
Cancel the scheduler task associated with the
scheduler and its associated monitor task.
Reset the AccessControlContext.
Reset the complex type attribute information
such that it is recalculated again.
Check for "ObservedAttribute" replacement.
This could happen if a thread A called setObservedAttribute()
while other thread B was in the middle of the monitor() method
and received the old observed attribute value.
Look up MBeanInfo if needed
Check for complex type attribute
Check that neither the observed object nor the
observed attribute are null.  If the observed
object or observed attribute is null, this means
that the monitor started before a complete
initialization and nothing is done.
Check that the observed object is registered in the
MBean server and that the observed attribute
belongs to the observed object.
Check if the monitor has been stopped.
Check if the observed attribute has been changed.
Avoid race condition where mbs.getAttribute() succeeded but
another thread replaced the observed attribute meanwhile.
Avoid setting computed derived gauge on erroneous attribute.
Derive a Comparable object from the ObservedAttribute value
if the type of the ObservedAttribute value is a complex type.
Check that the observed attribute type is supported by this
Check that threshold type is supported by this monitor.
Let someone subclassing the monitor to perform additional
monitor consistency checks and report errors if necessary.
If no errors were found then clear all error flags and
let the monitor decide if a notification must be sent.
Clear all already notified flags.
Get derived gauge from comparable value.
Check if an alarm must be fired.
Notify monitor errors
Notify monitor alarms
Find out if there's already an existing executor for the calling
thread and reuse it. Otherwise, create a new one and store it in
the executors map. If there is a SecurityManager, the group of
System.getSecurityManager() is used, else the group of the thread
instantiating this MonitorTask, i.e. the group of the thread that
ResolvingXMLReader.java - An XMLReader that performs catalog resolution
The certificate type
The provider implementation
Disallow external from creating one of these.
Don't use bootstrap class loader directly!
skip this URL
make the biggest buffer ever needed in get(String)
put this value into the tree with a case insensitive key
optimize the look up based on the number of chars
case 0 looks silly, but the generated bytecode runs
faster for lookup of elements of length 2 with this in
and a fair bit faster.  Don't know why.
comment out case 2 because the default is faster
case 2 :
if (ch0 < ALPHA_SIZE && ch1 < ALPHA_SIZE)
if (node != null)
if (ch1 < ALPHA_SIZE)
if (node != null)
copy string into array
the key is not 7-bit ASCII so we won't find it here
Following are the possible return values from getObscuredState.
bit 10 is free
Search parents for its popup
Reached toplevel, break and return null
We enable key events on all JComponents so that accessibility
bindings will work everywhere. This is a partial fix to BugID
aaText shouldn't persist between look and feels, reset it.
clean UIClientPropertyKeys from client properties
If we are only to paint to a specific child, determine
Enable painting of heavyweights in non-opaque windows.
The component is either lightweight, or
heavyweight in a non-opaque window
Will ocassionaly happen in 1.2, especially when printing.
paint forcing use of the double buffer.  This is used for historical
reasons: JViewport, when scrolling, previously directly invoked paint
while turning off double buffering at the RepaintManager level, this
codes simulates that.
Can't reuse border insets because the Border interface
can't be enhanced.
super.getInsets() always returns an Insets object with
all of its value zeroed.  No need for a new object here.
Push any new KeyStrokes to the KeyboardManager.
Remove any old ones.
Updated the registered Hashtable.
Hasn't been created yet.
Hasn't been created yet.
Hasn't been created yet.
Hasn't been created.
foreground already bound in AWT1.2
background already bound in AWT1.2
font already bound in AWT1.2
REMIND(bcb) choosing the default value is more complicated
This gives the key event listeners a crack at the event
give the component itself a crack at the event
Get the KeyStroke
in this case a keystroke made of an extended key code has a priority.
Do we have a key binding for e?
If we have a binding by an extended code, use it.
If not, check for regular code binding.
This is done so that the children of a JInternalFrame are
given precedence for WHEN_IN_FOCUSED_WINDOW bindings before
other components WHEN_IN_FOCUSED_WINDOW bindings. This also gives
more precedence to the WHEN_IN_FOCUSED_WINDOW bindings of the
JInternalFrame's children vs the
WHEN_ANCESTOR_OF_FOCUSED_COMPONENT bindings of the parents.
maybe generalize from JInternalFrame (like isFocusCycleRoot).
We don't want to do the drags when the mouse moves if we're
autoscrolling.  It makes it feel spastic.
Inner classes can't get at this method from a super class
This will be non-null if actionListener is an Action.
This keeps the old semantics where
registerKeyboardAction(null) would essentialy remove
the binding. We don't remove the binding from the
InputMap as that would still allow parent InputMaps
bindings to be accessed.
We don't allow any values to be added.
Does nothing, our enabledness is determiend from our asociated
This class is used by the KeyboardState class to provide a single
instance that can be stored in the AppContext.
Get the array of key codes from the AppContext.
We are forced to process VK_PRINTSCREEN separately because
the Windows doesn't generate the key pressed event for
printscreen and it block the processing of key release
event for printscreen.
Not a known KeyEvent type, bail.
We're currently calling into the InputVerifier
for this component, so allow the focus change.
We're already in the InputVerifier for
currentSource. By resetting the currentSource
we ensure that if the InputVerifier for
currentSource does a requestFocus, we don't
try and run the InputVerifier again.
inner class AccessibleFocusHandler
fallback to the client name property
fallback to the titled border if it exists
fallback to the label labeling us if it exists
fallback to the client description property
fallback to the tool tip text if it exists
Just in case the subclass overrode the
getToolTipText method and actually
requires a MouseEvent.
[[[FIXME:  WDW - we probably should require this
method to take a MouseEvent and just pass it on
to getToolTipText.  The swing-feedback traffic
leads me to believe getToolTipText might change,
though, so I was hesitant to make this change at
fallback to the label labeling us if it exists
Try to get the linked label's mnemonic if it exists
inner class AccessibleJComponent
Both the value and ArrayTable are null, implying we don't
have to do anything.
old == new == null
Invoked from putClientProperty.  This is provided for subclasses
XXX This method is implemented as a workaround to a JLS issue with ambiguous
methods. This should be removed once 4758654 is resolved.
AncestorListeners are handled by the AncestorNotifier
VetoableChangeListeners are handled by VetoableChangeSupport
PropertyChangeListeners are handled by PropertyChangeSupport
This isn't strictly correct.  The event shouldn't be
fired until *after* the parent is set to null.  But
we only get notified before that happens
Note: We don't bother invalidating here as once added
to a valid parent invalidate will be invoked (addImpl
invokes addNotify which will invoke invalidate on the
new Component). Also, if we do add a check to isValid
here it can potentially be called before the constructor
which was causing some people grief.
To avoid a flood of Runnables when constructing GUIs off
the EDT, a flag is maintained as to whether or not
a Runnable has been scheduled.
parent Container's up to Window or Applet. First container is
the direct parent. Note that in testing it was faster to
alloc a new Vector vs keeping a stack of them around, and gc
seemed to have a minimal effect on this.
Children of c may overlap, three possible cases for the
. Completely obscured by an opaque sibling, in which
case there is no need to paint.
. Partially obscured by a sibling: need to start
painting from c.
. Otherwise we aren't obscured and thus don't need to
start painting from parent.
Get rid of any buffer since we draw from here and
we might draw something larger
look to see if the parent (and therefor this component)
is double buffered
if we aren't on top, include the parent's clip
If the clip width or height is negative, don't bother painting
Notify the Components that are going to be painted of the
child component to paint to.
Reset the painting child for the parent components.
Called from paintImmediately (RepaintManager) to fill
Called from paint() (AWT) to repair damage
These functions must be static so that they can be called from
subclasses inside the package, but whose inheritance hierarhcy includes
classes outside of the package below JComponent (e.g., JTextArea).
Read back the client properties.
should beef this up a bit
The compiled program
The compiled RE 'program' instruction buffer
The amount of the program buffer currently in use
Input state for compiling regular expression
Length of the pattern string
Current input index into ac
Total number of paren pairs
No flags (nothing special)
True if node is potentially null
True if top level expr
Special types of 'escapes'
Escape complexity mask
Escape is really a backreference
Escape isn't really a true character
Escape represents a whole class of characters
Maximum number of bracket pairs
Number of bracket sets
Minimum number of matches
Additional optional matches
Lookup table for POSIX character class names
Start off with a generous, yet reasonable, initial size
Get current program length
If the current length + n more is too much
Double the size of the program array until n more will fit
Allocate new program array and move data into it
Make room for character
Make room for a new node
Move everything from insertAt to the end down nodeSize elements
Traverse the chain until the next offset is 0
while the 'node' is not the last in the chain
and the 'node' is not the last in the program.
if the node we are supposed to point to is in the chain then
point to the end of the program instead.
Michael McCallum <gholam@xtra.co.nz>
FIXME:  This is a _hack_ to stop infinite programs.
I believe that the implementation of the reluctant matches is wrong but
have not worked out a better way yet.
if we have reached the end of the program then dont set the pointTo.
im not sure if this will break any thing but passes all the tests.
Point the last node in the chain to pointTo.
Make room for a new node
Add new node at end
Return index of new node
Allocate bracket stacks if not already done
Initialize to invalid values
trick the tricky
Initialize to invalid values
Next char must be a digit
If out of input, fail
If end of expr, optional limit is 0
If out of input, fail
Next char must be a digit
Get max number
Optional repetitions must be >= 0
Must have close brace
Escape shouldn't occur as last character in string!
Switch on character after backslash
Exact required hex digits for escape type
Parse up to hexDigits characters from input
If it's a hexadecimal digit (0-9)
Compute new value
If it's a hexadecimal letter (a-f)
Compute new value
If it's not a valid digit or hex letter, the escape must be invalid
because hexDigits of input have not been absorbed yet.
An octal escape starts with a 0 or has two digits in a row
Handle \nnn octal escapes
It's actually a backreference (\[1-9]), not an escape
Simple quoting of a character
Check for bad calling or empty class
Check for unterminated or empty class
Check for POSIX character class
POSIX character classes are denoted with lowercase ASCII strings
Should be a ":]" to terminate the POSIX character class
Get character class
Select the POSIX class id
Move past colon and right bracket
Return new POSIX character class node
Try to build a class.  Create OP_ANYOF node
Parse class declaration
Switch on character
Escape always advances the stream
Word boundaries and backrefs not allowed in a character class!
Classes can't be an endpoint of a range
Handle specific type of class (some are ok)
Make last char invalid (can't be a range start)
Escape is simple so treat as a simple char
Start a range if one isn't already started
If no last character, start of range is 0
Premature end of range. define up to Character.MAX_VALUE
Handle simple character simpleChar
if we are defining a range make it now
Actually create a range if the range is ok
We are done defining the range
If simple character and not start of range, include it
Shouldn't be out of input
Absorb the ']' end of class marker
Emit character class definition
Create a string node
Length of atom
Loop while we've got input
Is there a next char?
If the next 'char' is an escape, look past the whole escape
Switch on next char
If the next character is a closure operator and our atom is non-empty, the
current character should bind to the closure operator rather than the atom
Switch on current char
We should have an atom by now
No atom before closure
Get the escaped character (advances input automatically)
Check if it's a simple escape (as opposed to, say, a backreference)
Not a simple escape, so backup to where we were before the escape.
Add escaped char to atom
Add normal character to atom
This "shouldn't" happen
Emit the atom length into the program
Don't forget, escape() advances the input stream!
Switch on escaped character
We had a simple escape and we want to have it end up in
an atom, so we back up and fall though to the default handling
Everything above either fails or returns.
If it wasn't one of the above, it must be the start of an atom.
Values to pass by reference to terminal()
Get terminal symbol
Or in flags from terminal symbol
Advance input, set NODE_NULLABLE flag and do sanity checks
The current node can be null
Eat closure character
Don't allow blantant stupidity
If the next character is a '?', make the closure non-greedy (reluctant)
Actually do the closure now
We look for our bracket in the list
Process min first
Rewind stream and run it through again - more matchers coming
Bug #1030: No optinal matches - no need to rewind
Drop through now and closure expression.
More optional matchers - 'play it again sam!'
Bug #1030: We are done - this one is last and optional
Drop through to optionally close
Rollback terminal - neither min nor opt matchers present
X? is compiled as (X|)
branch before X
inserted branch to option
which is OP_NOTHING
point (second) branch to OP_NOTHING
point the end of X to OP_NOTHING node
branch before X
end of X points to an option
the start again
the other option is
a new branch
is added to the end of X
one option is to go back to the start
the other option
Add end after closured subexpr
Actually do the closure now
Point to the expr after the closure
Get each possibly closured piece and concat
Get new node
If there's a chain, append to the end
Chain starts at current
If we don't run loop, make a nothing node
Set nullable flag for this branch
Create open paren node unless we were called from the top level (which has no parens)
if its a cluster ( rather than a proper subexpression ie with backrefs )
Create a branch node
Loop through branches
Create an ending node (either a close paren or an OP_END)
Append the ending node to the ret nodelist
Hook the ends of each branch to the end node
while the next node o
If branch, make the end of the branch's operand chain point to the end node.
Return the node list
Initialize variables for compilation
Save pattern in instance variable
Precompute pattern length for speed
Set parsing index to the first character
Set emitted instruction count to zero
Set paren level to 1 (the implicit outer parens)
No bracketed closures yet
Initialize pass by reference flags value
Should be at end of input
Return the result
Capacity of current range arrays
Number of range array elements in use
Return if no elements left or index is out of range
Move elements down
One less element now
Loop through ranges
Min-max is subsumed by minRange[i]-maxRange[i]
Min-max subsumes minRange[i]-maxRange[i]
Min is in the range, but max is outside
Max is in the range, but min is outside
Must not overlap any other ranges
Loop through ranges
minRange[i]-maxRange[i] is subsumed by min-max
min-max is subsumed by minRange[i]-maxRange[i]
minRange is in the range, but maxRange is outside
maxRange is in the range, but minRange is outside
access needs this
ComponentUI Interface Implementation methods
Enable the content pane to inherit background color from its
parent by setting its background color to null.
Set the ActionMap's parent to the Auditory Feedback Action Map
Provide a FocusListener to listen for a WINDOW_LOST_FOCUS event,
so that a resize can be cancelled if the focus is lost while resizing
when an Alt-Tab, modal dialog popup, iconify, dispose, or remove
of the internal frame occurs.
Cancel a resize in progress by calling finishMouseReleased().
PENDING(hania): Why are these WHEN_IN_FOCUSED_WINDOWs? Shouldn't
they be WHEN_ANCESTOR_OF_FOCUSED_COMPONENT?
Also, no longer registering on the desktopicon, the previous
action did nothing.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
Internal Frame Auditory Cue Activation
delegate to desktop manager
Internal Frame Auditory Cue Activation
delegate to desktop manager
Internal Frame Auditory Cue Activation
This method seems to regularly get called after an
internal frame is iconified. Don't play this sound then.
delegate to desktop manager
Internal Frame Auditory Cue Activation
delegate to desktop manager
Internal Frame Auditory Cue Activation
This method seems to regularly get called after an
internal frame is maximized. Don't play this sound then.
delegate to desktop manager
/ Border Listener Class
_x & _y are the mousePressed location in absolute coordinate system
__x & __y are the mousePressed location in source view's coordinate system
Factor out finishMouseReleased() from mouseReleased(), so that
it can be called by cancelResize() without passing it a null
Remove the WindowFocusListener for handling a
WINDOW_LOST_FOCUS event with a cancelResize().
Set discardRelease to true, so that only a mousePressed()
which sets it to false, will allow entry to the above code
for finishing a resize.
Add the WindowFocusListener for handling a
WINDOW_LOST_FOCUS event with a cancelResize().
(STEVE) Yucky work around for bug ID 4106552
Handle a MOVE
don't allow moving of frames if maximixed or left mouse
button was not used.
Make sure we stay in-bounds
/ End BorderListener Class
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
NOTE: This class exists only for backward compatibility. All
its functionality has been moved into Handler. If you need to add
new functionality add it to the Handler, but make sure this
class calls into the Handler.
Cancel a resize which may be in progress, when a
WINDOW_LOST_FOCUS event occurs, which may be
caused by an Alt-Tab or a modal dialog popup.
Get the JInternalFrame's parent container size
Resize the internal frame if it is maximized and relocate
the associated icon as well.
Relocate the icon base on the new parent bounds.
Update the new parent bounds for next resize.
Validate the component tree for this container.
The minimum size of the internal frame only takes into
account the title pane since you are allowed to resize
the frames to the point where just the title pane is visible.
Cancel a resize in progress if the internal frame
gets a setClosed(true) or dispose().
Cancel a resize in progress, if the internal frame
gets a remove(), removeNotify() or setIcon(true).
If no current, conversion is a top-level
push root node
Reset this iterator
Check that the function was passed exactly two arguments
The first argument must be a String, or cast to a String
The second argument must also be a String, or cast to a String
Listeners that this UI attaches to the JList
Following ivars are used if the list is laying out horizontally
Shrink renderer to preferred size. This is mostly used on Windows
where selection is only shown around the file name, instead of
across the whole list cell.
Determine how many columns we need to paint
And then how many rows in this columnn
Not valid, bail!
Empty out the renderer pane, allowing renderers to be gc'ed.
fix for 6711072 some LAFs like Nimbus do not provide this
UIManager key and we should not through a NPE here because of it
JList actually has much more complex behavior here.
If rowHeight != -1 the rowHeight is either the max of all cell
heights (layout orientation != VERTICAL), or is variable depending
upon the cell.  We assume a default size.
We could theoretically query the real renderer, but that would
not work for an empty model and the results may vary with
default TransferHandler doesn't support drop
so we don't want drop handling
Determine the max of the renderer heights.
The number of rows is either determined by the visible row
count, or by the height of the list.
Because HORIZONTAL_WRAP flows differently, the
rowsPerColumn needs to be adjusted.
add the lead item to the selection without changing lead or anchor
toggle the selected state of the lead item and move the anchor to it
extend the selection to the lead item
move the anchor to the lead and ensure only that item is selected
discontinuous selection actions are only enabled for
this is done to restore the anchor and lead
apply for horizontal scrolling: the step for next
page index is number of visible columns
this is necessary for right-to-left orientation only
go to the first visible cell
if lead is the first visible cell (or above it)
adjust the visible rect up
go one cell down if first visible cell doesn't fit
into adjasted visible rectangle
if index isn't less then lead
try to go to cell previous to lead
go to the last completely visible cell
go up one cell if last visible cell doesn't fit
into visible rectangle
if lead is the last completely visible index
(or below it) adjust the visible rect down
go one cell up if last visible cell doesn't fit
into adjasted visible rectangle
if index isn't greater then lead
try to go to cell next after lead
CHANGE_LEAD is only valid with multiple interval selection
IMPORTANT - This needs to happen before the index is changed.
This is because JFileChooser, which uses JList, also scrolls
the selected item into view. If that happens first, then
this method becomes a no-op.
casting should be safe since the action is only enabled
right for left-to-right
left for right-to-left
adjust width to fit into visible rectangle
adjust height to fit into visible rectangle
there's only one item so we should select it
Won't change the selection.
there's only one item so we should select it
Nothing to select
Subsequent same key presses move the keyboard focus to the next
object that starts with the same letter.
Whether or not the mouse press (which is being considered as part
of a drag sequence) also caused the selection change to be fully
different behavior if drag is enabled
if we have a valid row and this is a drag initiating event
do nothing for control - will be handled on release
or when drag starts
clicking on something that's already selected
and need to make it the lead now
could be a drag initiating event - don't grab focus
When drag is enabled mouse drags won't change the selection
in the list, so we only set the isAdjusting flag when it's
If shift is down in multi-select, we should do nothing.
For single select or non-shift-click, clear the selection
4835633.  Dragging onto a File should not select it.
remove the last newline
read and discard the repository ID
write the repository ID
Repository ID cache
Write end flag
Beginning with the resolution to interop issue 3526,
only enclosing chunked valuetypes are taken into account
when computing the nesting level.  However, we still need
the old computation around for interoperability with our
In block marker
Last end tag position
Repository ID handlers
Code set converters (created when first needed)
REVISIT - This should be re-factored so that including whether
to use pool byte buffers or not doesn't need to be known.
ORB must not be null.  See CDROutputStream constructor.
Micro-benchmarks show ByteBuffer.get(int) out perform the bulk
ByteBuffer.get(byte[], offset, length).
Called by Request and Reply message. Valid for GIOP versions >= 1.2 only.
Illegal for GIOP versions < 1.2.
No-op for GIOP 1.0
No-op for GIOP 1.0
Default implementation of grow.  Subclassers may override this.
Always grow the single buffer. This needs to delegate
fragmentation policy for IIOP 1.1.
No such type in java
The 'if' stmt is commented out since we need the alignAndReserve to
be called, particularly when the first body byte is written,
to induce header padding to align the body on a 8-octet boundary,
for GIOP versions 1.2 and above. Refer to internalWriteOctetArray()
method that also has a similar change.
if (bbwi.position() + 1 > bbwi.buflen)
REVISIT - Should just use ByteBuffer.put(byte) and let it
increment the ByteBuffer position. This is true
for all write operations in this file.
CORBA formal 99-10-07 15.3.1.6: "In the case of multi-byte encodings
of characters, a single instance of the char type may only
hold one octet of any multi-byte character encoding."
These wchar methods are only used when talking to
legacy ORBs, now.
Don't allow transmission of wchar/wstring data with
foreign ORBs since it's against the spec.
If it's one of our legacy ORBs, do what they did:
A string is encoded as an unsigned CORBA long for the
number of bytes to follow (including a terminating null).
There is only one octet per character in the string.
Write the null ending
Don't allow transmission of wchar/wstring data with
foreign ORBs since it's against the spec.
When talking to our legacy ORBs, do what they did:
This will only have an effect if we're already chunking
Write the null ending
This will only have an effect if we're already chunking
Performs no checks and doesn't tamper with chunking
This flag forces the alignAndReserve method to be called the
first time an octet is written. This is necessary to ensure
that the body is aligned on an 8-octet boundary. Note the 'if'
condition inside the 'while' loop below. Also, refer to the
write_octet() method that has a similar change.
This will only have an effect if we're already chunking
This will only have an effect if we're already chunking
IDL to Java formal 01-06-06 1.21.4.2
------------ RMI related methods --------------------------
Assume value type.
Is it a CORBA.Object?
Write our flag...
Now write out the object...
Write WStringValue's repository ID
Add indirection for object to indirection table
Write Value chunk
Write end tag
Write repository ID
Add indirection for object to indirection table
Write Value chunk
Write end tag
_REVISIT_ could check to see whether chunking really needed
Get rep id
Write rep id
Add indirection for object to indirection table
Write Value chunk
Write end tag
Allow the ValueHandler to call writeReplace on
the Serializable (if the method is present)
Write null tag and return
Write rep. id
Add indirection for object to indirection table
Write Value chunk
Write end tag
Handle null references
Write null tag and return
Handle shared references
Handle IDL Value types
RMI-IIOP value type
Check to see if we need to start another block for a
possible outer value
Handle null references
Write null tag and return
Handle shared references
Add indirection for object to indirection table
Write Value chunk
Write end tag
Add indirection for object to indirection table
Write Value chunk
no need to test for custom on the non-chunked path
Write end tag
Check to see if we need to start another block for a
possible outer value
Move inBlock=true to after write_long since write_long might
trigger grow which will lead to erroneous behavior with a
Save space in the buffer for block size
Has to happen after write_long since write_long could
trigger grow which is overridden by supper classes to
depend on inBlock.
Remember where to put the size of the endblock less 4
Utility method which will hopefully decrease chunking complexity
by allowing us to end_block and update chunk lengths without
calling alignAndReserve.  Otherwise, it's possible to get into
recursive scenarios which lose the chunking state.
Test to see if the block was of zero length
If so, remove the block instead of ending it
(This can happen if the last field written
in a value was another value)
Need to assert that blockSizeIndex == bbwi.position()?  REVISIT
------------ End RMI related methods --------------------------
This will only have an effect if we're already chunking
This will only have an effect if we're already chunking
This will only have an effect if we're already chunking
This will only have an effect if we're already chunking
This will only have an effect if we're already chunking
This will only have an effect if we're already chunking
This will only have an effect if we're already chunking
This will only have an effect if we're already chunking
This will only have an effect if we're already chunking
This will only have an effect if we're already chunking
This will only have an effect if we're already chunking
This will only have an effect if we're already chunking
This will only have an effect if we're already chunking
This will only have an effect if we're already chunking
This will only have an effect if we're already chunking
This will only have an effect if we're already chunking
CDROutputStream state management.
Micro-benchmarks are showing a loop of ByteBuffer.get(int) is
faster than ByteBuffer.get(byte[], offset, length)
Micro-benchmarks are showing a loop of ByteBuffer.get(int) is
faster than ByteBuffer.get(byte[], offset, length)
Use an indirection if available
Write it as a string.  Note that we have already done the
special case conversion of non-Latin-1 characters to escaped
Latin-1 sequences in RepositoryId.
It's not a good idea to cache them now that we can have
multiple code sets.
Add indirection for id to indirection table
Handles end tag compaction...
We are exactly at the same position and index as the
end of the last end tag.  Thus, we can back up over it
and compact the tags.
Special case in which we're at the beginning of a new
fragment, but the position is the same.  We can't back up,
so we just write the new end tag without compaction.  This
occurs when a value ends and calls start_block to open a
continuation chunk, but it's called at the very end of
Remember the last index and position.  These are only used when chunking.
Increment the nesting level
Write Value chunk
Write end tag
Pre-Merlin/J2EE 1.3 ORBs wrote the repository ID
and codebase strings in the wrong order.  This handles
Casts and returns an Object as a Serializable
This is required for JDK 1.1 only to avoid VerifyErrors when
passing arrays as Serializable
private java.io.Serializable make_serializable(java.lang.Object object)
_REVISIT_ could check to see whether chunking really needed
Write rep. id
Write Value chunk
Write the IDLEntity using reflection
getDeclaredMethod requires RuntimePermission accessDeclaredMembers
if a different class loader is used (even though the javadoc says otherwise)
this gets caught below
Write end tag
This will stay a custom add-on until the java-rtf issue is resolved.
Then it should be declared in org.omg.CORBA.portable.OutputStream.
Pads the string representation of bigDecimal with zeros to fit the given
digits and scale before it gets written to the stream.
Get rid of the sign
Determine integer and fraction parts
Pad both parts with zeros as necessary
This string contains no sign or dot
This method should be remove by the java-rtf issue.
Right now the scale and digits information of the type code is lost.
This string might contain sign and/or dot
The string may contain a sign and dot
Each octet contains (up to) two decimal digits
First calculate the length of the string without optional sign and dot
If the fixed type has an odd number of decimal digits,
then the representation begins with the first (most significant) digit.
Otherwise, this first half-octet is all zero, and the first digit
is in the second half-octet.
The sign configuration, in the last half-octet of the representation,
is 0xD for negative numbers and 0xC for positive and zero values
For every 16 bytes, there is one line
of output.  First, the hex output of
the 16 bytes with each byte separated
by a space.
Add any extra spaces to align the
text column in case we didn't end
Now output the ASCII equivalents.  Non-ASCII
characters are shown as periods.
Must ensure that there are no chunks between the tag
and the actual indirection value.  This isn't talked about
in the spec, but seems to cause headaches in our code.
At the very least, this method isolates the indirection code
that was duplicated so often.
write indirection tag
Use parent.getRealIndex() so that it can be overridden by TypeCodeOutputStreams
Write rep. id
Write Value chunk
Make sure to chunk the custom data
Check to see if we need to start another block for a
possible outer value.  Since we're in the stream
format 2 custom type contained by another custom
type, mustChunk should always be true.
Here's why we need to open a continuation chunk:
We need to enclose the default data of the
next subclass down in chunks.  There won't be
an end tag separating the superclass optional
data and the subclass's default data.
tell BufferManagerWrite to release any ByteBuffers
It's possible bbwi.byteBuffer is shared between
this OutputStream and an InputStream. Thus, we check
if the Input/Output streams are using the same ByteBuffer.
If they sharing the same ByteBuffer we need to ensure only
one of those ByteBuffers are released to the ByteBufferPool.
Set InputStream's ByteBuffer and bbwi to null
so its ByteBuffer cannot be released to the pool
release this stream's ByteBuffer to the pool
print address of ByteBuffer being released
must be power 2 - 1
Values for lock state and stamp operations
note overlap with ABITS
Initial value for lock state; avoid failure value zero
Special value from cancelled acquire methods so caller can throw IE
Values for node status; order matters
Modes for nodes (int not boolean to allow arithmetic)
list of linked readers
non-null while possibly parked
0, WAITING, or CANCELLED
RMODE or WMODE
bypass acquireWrite in fully unlocked case only
bypass acquireRead on common uncontended case
status monitoring methods
Unlock methods without stamp argument checks for view classes.
Needed because view-class lock methods throw away stamps.
reset to unlocked state
spin while enqueuing
spin at head
help release stale waiters
0 argument to park means no timeout
spin at head
unsplice cancelled nodes from group
wake up uncancelled co-waiters
find valid successor
find successor the slow way
don't link if succ cancelled
ensure accurate successor
unsplice pred link
wake up succ to observe new pred
repeat if new pred wrong/cancelled
Possibly release first waiter
similar to release() but check eligibility
waiter is eligible
Paint the lines
Draw a line at the top
end class PaletteListener
setup to use Unsafe.compareAndSwapInt for updates
just make a copy of the base if spec is empty
check for scheme
This is a fix for XALANJ-2059.
a) If <uriSpec> starts with a slash (/), it means <uriSpec> is absolute
and p_base can be ignored.
uriSpec = file:/myDIR/myXSLFile.xsl
p_base = file:/myWork/
Here, uriSpec has absolute path after scheme file and :
Hence p_base can be ignored.
b) Similarily, according to RFC 2396, uri is resolved for <uriSpec> relative to <p_base>
if scheme in <uriSpec> is same as scheme in <p_base>, else p_base can be ignored.
c) if <p_base> is not hierarchical, it can be ignored.
Fix for XALANJ-2059
two slashes means generic URI syntax, so we get the authority
get authority - everything up to path, query or fragment
if we found authority, parse it out, otherwise we set the
host to empty string
Resolve relative URI to base URI - see RFC 2396 Section 5.2
In some cases, it might make more sense to throw an exception
(when scheme is specified is the string spec and the base URI
is also specified, for example), but we're just following the
check to see if this is the current doc - RFC 2396 5.2 #2
note that this is slightly different from the RFC spec in that
we don't include the check for query string being null
- this handles cases where the urispec is just a query
string or a fragment (e.g. "?y" or "#s") -
see <http:www.ics.uci.edu/~fielding/url/test1.html> which
identified this as a bug in the RFC
check for scheme - RFC 2396 5.2 #3
if we found a scheme, it means absolute URI, so we're done
check for authority - RFC 2396 5.2 #4
if we found a host, then we've got a network path, so we're done
check for absolute path - RFC 2396 5.2 #5
if we get to this point, we need to resolve relative path
RFC 2396 5.2 #6
6a - get all but the last segment of the base URI path
6b - append the relative URI path
6c - remove all "./" where "." is a complete path segment
6d - remove "." if path ends with "." as a complete path segment
6e - remove all "<segment>/../" where "<segment>" is a complete
path segment not equal to ".."
6f - remove ending "<segment>/.." where "<segment>" is a
complete path segment
userinfo is everything up @
host is everything up to ':'
path - everything up to query string or fragment
check for valid escape sequence
"Path contains invalid character: "
query - starts with ? and up to fragment or end
fragment - starts with #
userinfo can contain alphanumerics, mark characters, escaped
presence of the host (whether valid or empty) means
double-slashes which means generic uri
rightmost domain label starting with digit indicates IP address
since top level domain label can only start with an alpha
see RFC 2396 Section 3.2.2
make sure that 1) we see only digits and dot separators, 2) that
any dot separator is preceded and followed by a digit and
3) that we find 3 dots
domain labels can contain alphanumerics and '-"
but must start and end with an alphanumeric
On the off chance some one created a UI, honor it
---- Component methods ------------------------------------------
On the off chance some one created a UI, honor it
Accessibility support for Box$Filler
Accessibility support for Box
inner class AccessibleBox
private constructor defined to "hide" the default public constructor
Check if the MBean implements the DynamicMBean interface
Check if the class is a concrete class
Check if the MBean has a public constructor
Is Standard MBean?
Ignore exception - we need to check whether
mbean is an MXBean first.
Ignore exception - we cannot decide whether mbean was supposed
to be an MBean or an MXBean. We will call checkCompliance()
to generate the appropriate exception.
Check if the MBean implements the MBean or the Dynamic
Check if the given class implements the MBean interface
or the Dynamic MBean interface
Avoid checking access more than once per annotation
we don't expect this - except for possibly
RuntimeExceptions shouldn't be "UndeclaredThrowable".
we don't expect this
Convert a value from an annotation element to a descriptor field value
will produce a Descriptor field value "java.lang.String"
An annotation element cannot have a null value but never mind
Remaining possibilities: array of primitive (e.g. int[]),
enum, class, array of enum or class.
The only other possibility is that the value is another
annotation, or that the language has evolved since this code
was written.  We don't allow for either of those currently.
If it is indeed another annotation, then x will be a proxy
with an unhelpful name like $Proxy2.  So we extract the
proxy's interface to use that in the exception message.
array "can't be empty"
This must be consistent with the check for duplicate field values in
ImmutableDescriptor.union.  But we don't expect to be called very
often so this inefficient check should be enough.
Java Beans introspection
Java Beans not available so use simple introspection
to locate method
cache to avoid repeated lookups
return cached methods if possible
ignore static methods
return cached result if available
get list of public methods, filtering out methods that have
been overridden to return a more specific type.
filter out the non-getter methods
favor isXXX over getXXX
add result to cache
first character in uppercase (compatibility with JavaBeans)
Initialize local ivars to default
Modifying the model
Post columnAdded event notification
Adjust for the selection
Post columnAdded event notification.  (JTable and JTableHeader
listens so they can adjust size and redraw)
If the column has not yet moved far enough to change positions
post the event anyway, the "draggedDistance" property of the
tableHeader will say how far the column has been dragged.
Here we are really trying to get the best out of an
API that could do with some rethinking. We preserve backward
compatibility by slightly bending the meaning of these methods.
Post columnMarginChanged event notification.
Querying the model
Compare them this way in case the column's identifier is null.
Listener Support Methods
Event firing methods
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
if (e == null)
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
if (e == null)
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
if (e == null)
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
if (e == null)
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
Lazily create the event:
Implementing the PropertyChangeListener interface
This is a misnomer, we're using this method
simply to cause a relayout.
Implementing ListSelectionListener interface
End of class DefaultTableColumnModel
JKESS 20020514: Longer-term solution is to force
folks to request length through an accessor, so we can defer this
retrieval... but that requires an API change.
JKESS 20020514: Longer-term solution is to force
folks to request length through an accessor, so we can defer this
retrieval... but that requires an API change.
TextLayout can't render only part of it's range, so if a
partial range is required, add a clip region.
vertical at the baseline, should use slope and check if glyphs
are being rendered vertically.
Move the y co-ord of the hit onto the baseline.  This is because TextLayout supports
italic carets and we do not.
note: this only works because swing uses TextLayouts that are
only pure rtl or pure ltr
End case for bidi text where newline is at beginning
Entering view from the left.
If the layout's base direction is different from
this view's run direction, we need to use the weak
A move to the right from an internal position will
only take us to the endOffset in a left to right run.
End case for bidi text where newline is at beginning
Entering view from the right
If the layout's base direction is different from
this view's run direction, we need to use the weak
A move to the left from an internal position will
only take us to the endOffset in a right to left run.
--- variables ---------------------------------------------
ABSTRACT METHOD IMPLEMENTATIONS: CONTROL
what kind of data we're dealing with
try and make count be a multiple of the number of bytes we're looking for
this looks ugly, but it avoids an if at any rate...
end of input; something likely went wrong!A  Pad buffer with nulls.
end of input; something likely went wrong!A  Pad buffer with nulls.
now count is a multiple of the right number of bytes
charWidth will represent the number of bits to move
n leftward to get num of bytes to skip, and then move the result rightward
to get num of chars effectively skipped.
The trick with &'ing, as with elsewhere in this dcode, is
intended to avoid an expensive use of / that might not be optimized
Complete the uncompressed output
Finish decompressing and writing pending output data
Decompress pending output data
Write the uncompressed output data block
Improperly formatted compressed (ZIP) data
Finish decompressing and writing pending output data
Write a single byte of data
Write uncompressed data to the output stream
Fill the decompressor buffer with output data
Decompress and write blocks of output data
Check the decompressor
Improperly formatted compressed (ZIP) data
There are no abstract methods, but to be useful the user must
The system-wide authenticator object.  See setDefault().
Non-public classes supporting the public methods
Calls to getContextClassLoader from this class
never trigger a security check, but we check
whether our callers have this permission anyways.
Whether setContextClassLoader turns out to be necessary
or not, we fail fast if permission is not available.
Calls to getContextClassLoader from this class
never trigger a security check, but we check
whether our callers have this permission anyways.
Use try/catch block to support applets
getContextClassLoader() undefined in JDK1.1
system property look up
try to read from $java.home/lib/jaxp.properties
Try with ServiceLoader
The following assertion should always be true.
Uncomment it, recompile, and run with -ea in case of doubts:
make sure we have access to restricted packages
get Class from className
instantiate Class as a SchemaFactory
Retain maximum compatibility if no security manager.
Do not call the method if it's not public static.
Only calls "newXMLSchemaFactoryNoServiceLoader" if it's
declared to return an instance of SchemaFactory.
Should not happen since
declared to return XMLSchemaFactory.
Call isSchemaLanguageSupported with initial context.
store current context.
restore initial context to call
no factory found.
Create the context to parse the document against
Run through each node up to the document node and find any xmlns: nodes
Create the context to parse the document against
Run through each node up to the document node and find any xmlns: nodes
null means use default syntax
null means use default syntax
null means use default syntax
null means use default syntax
number of components
this is impossible, but again better safe than sorry
Bound skip by beginning and end of the source
Check we have access to package.
Define system property "jaxp.debug" to get output
Use try/catch block to support applets, which throws
SecurityException out of this code.
Allow simply setting the prop to turn on debug
Use current class loader - should always be bootstrap CL
make sure we have access to restricted packages
Extra check to avoid computing cl strings
Use the system property first
Try read $java.home/lib/stax.properties followed by
$java.home/lib/jaxp.properties if former not present
Try Jar Service Provider Mechanism
We're in the case where a 'custom' factoryId was provided,
and in every case where that happens, we expect that
fallbackClassName will be null.
the current thread's context class loader
It is not possible to wrap an error directly in
FactoryConfigurationError - so we need to wrap the
ServiceConfigurationError in a RuntimeException.
The alternative would be to modify the logic in
FactoryConfigurationError to allow setting a
Throwable as the cause, but that could cause
compatibility issues down the road.
read and discard the repository ID
write the repository ID
Check to see if the debug property is set
Allow simply setting the prop to turn on debug
Use the system property first
Check to see if we found the RowSetFactory via a System property
If the RowSetFactory is not found via a System Property, now
look it up via the ServiceLoader API and if not found, use the
Java SE default.
Use current class loader
Support for mixed 1.4/pre-1.4 focus APIs. If a particular root's
traversal policy is non-legacy, then honor it.
Support for mixed 1.4/pre-1.4 focus APIs. If a particular root's
traversal policy is non-legacy, then honor it.
Support for mixed 1.4/pre-1.4 focus APIs. If a particular root's
traversal policy is non-legacy, then honor it.
Support for mixed 1.4/pre-1.4 focus APIs. If a particular root's
traversal policy is non-legacy, then honor it.
This is not initialized from ParserTable.
Public accessor methods ========================================================================
Always grow for 1.0
public void setPersistentServerPort(int sp)
this is a user-activated server
public void setPersistentServerId(int id)
Methods for constructing and initializing this object ===========================================
End of file.
package private integers representing the available states that
this painter will paint. These are used when creating a new instance
of SpinnerPanelSpinnerFormattedTextFieldPainter to determine which region/state is being painted
by that instance.
refers to one of the static final ints above
the following 4 variables are reused during the painting code of the layers
All Colors used for painting are stored here. Ideally, only those colors being used
by a particular instance of SpinnerPanelSpinnerFormattedTextFieldPainter would be created. For the moment at least,
however, all are created for each instance.
Array of current component colors, updated in each paint call
populate componentColors array with colors calculated in getExtendedCacheKeys call
generate this entire method. Each state/bg/fg/border combo that has
been painted gets its own KEY and paint method.
End of file.
add this message to fix bug 21478
Earlier (JDK 1.4 XALAN 2.2-D11) at key code '204' the key name was ER_PRIORITY_NOT_PARSABLE
In latest Xalan code base key name is  ER_VALUE_SHOULD_BE_NUMBER. This should also be taken care
in locale specific files like XSLTErrorResources_de.java, XSLTErrorResources_fr.java etc.
NOTE: Not only the key name but message has also been changed.
Note to translators:  The following message should not normally be displayed
to users.  It describes a situation in which the processor has detected
an internal consistency problem in itself, and it provides this message
for the developer to help diagnose the problem.  The name
'ElemTemplateElement' is the name of a class, and should not be
Note to translators:  The following message should not normally be displayed
to users.  It describes a situation in which the processor has detected
an internal consistency problem in itself, and it provides this message
for the developer to help diagnose the problem.  The substitution text
provides further information in order to diagnose the problem.  The name
'RedundentExprEliminator' is the name of a class, and should not be
This code is shared with warning codes.
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "QNAME" is the XML data-type of
The following codes are shared with the warning codes...
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "ENUM" is the XML data-type of
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "NMTOKEN" is the XML data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "NCNAME" is the XML data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "boolean" is the XSLT data-type
Note to translators:  The following message is used if the value of
an attribute in a stylesheet is invalid.  "number" is the XSLT data-type
End of shared codes...
Note to translators:  A "match pattern" is a special form of XPath expression
that is used for matching patterns.  The substitution text is the name of
a function.  The message indicates that when this function is referenced in
a match pattern, its argument must be a string literal (or constant.)
ER_ARG_LITERAL - new error message for bugzilla 5202
Note to translators:  The following message indicates that two definitions of
a variable.  A "global variable" is a variable that is accessible everywher
in the stylesheet.
ER_DUPLICATE_GLOBAL_VAR - new error message for bugzilla #790
Note to translators:  The following message indicates that two definitions of
a variable were encountered.
ER_DUPLICATE_VAR - new error message for bugzilla #790
Note to translators:  "xsl:template, "name" and "match" are XSLT keywords
which must not be translated.
ER_TEMPLATE_NAME_MATCH - new error message for bugzilla #789
Note to translators:  "exclude-result-prefixes" is an XSLT keyword which
should not be translated.  The message indicates that a namespace prefix
encountered as part of the value of the exclude-result-prefixes attribute
was in error.
ER_INVALID_PREFIX - new error message for bugzilla #788
Note to translators:  An "attribute set" is a set of attributes that can
be added to an element in the output document as a group.  The message
was never defined.
ER_NO_ATTRIB_SET - new error message for bugzilla #782
Note to translators:  This message indicates that there was a reference
Note to translators:  This message indicates that the XSLT instruction
instructions (content) or a "select" attribute.  The word "select" is
an XSLT keyword in this case and must not be translated.
Note to translators:  This message indicates that the value argument
of setParameter must be a valid Java Object.
Following are the new WARNING keys added in XALAN code base after Jdk 1.4 (Xalan 2.2-D11)
Note to translators:  "name" and "xsl:processing-instruction" are keywords
and must not be translated.
Note to translators:  "name" and "xsl:processing-instruction" are keywords
and must not be translated.  "NCName" is an XML data-type and must not be
Note to translators:  This message is reported if the stylesheet that is
being processed attempted to construct an XML document with an attribute in a
place other than on an element.  The substitution text specifies the name of
Check: WHY THERE IS A GAP B/W NUMBERS in the XSLTErrorResources properties file?
Other miscellaneous text used inside the code...
Note to translators:  The following messages provide usage information
for the Xalan Process command line.  "Process" is the name of a Java class,
and should not be translated.
Note to translators: The option name and the parameter name do not need to
be translated. Only translate the messages in parentheses.  Note also that
leading whitespace in the messages is used to indent the usage information
for each option in the English messages.
Do not translate the keywords: XSLTC, SAX, DOM and DTM.
Following are the new options added in XSLTErrorResources.properties files after Jdk 1.4 (Xalan 2.2-D11)
Added by sboag/scurcuru; experimental
AddITIONAL  STRINGS that need L10n
Note to translators:  The following message describes usage of a particular
command-line option that is used to enable the "template inlining"
optimization.  The optimization involves making a copy of the code
generated for a template in another template that refers to it.
================= INFRASTRUCTURE ======================
BUGFIX by Chris Harris <ckharris@ucsd.edu>:
correct a one-off error by commenting out
this next line.
Concatanate initialization strings.
location in initialization string
check whether currentNode and the node containing the XPath expression
are in the same document
returns a node-set containing the attribute /  processing instruction node
returns a node-set containing the parent element of the
text node that directly bears the XPath expression
create an instance of a service ref
add a requestor and assoc listener
remove a requestor
check a requestors listener
the provider is delegated
the provider is registered with this BCS
note usage of service per requestor, per service
first, process mapping from serviceClass to requestor(s)
new service being used ...
existing service ...
now handle mapping from requestor to service(s)
release a service reference
oops its not there anymore!
oops its not there anymore!
revoke a service
release all references for this child since it has been unnested.
get the BCSChild values.
get the BCSChild values.
not a child ...
do bookkeeping ...
unchecked rt exception
try to delegate ...
do bookkeeping ...
unchecked rt exception
do nothing ...
SolarisSystem to retrieve underlying system info
the authentication status
Underlying system info
initialize any configured options
Clean out state
overall authentication succeeded and commit succeeded,
but someone else's commit failed
remove the added Principals from the Subject
clean out state
Disallow subsequent initCause
Disallow subsequent initCause
--- FlowStrategy methods --------------------------------------------
Get the child view that contains the given starting position
return the entire view
return a unidirectional fragment.
install a TextLayout based renderer if the view is responsible
for glyphs.  If the view represents a tab, the default
glyph painter is used (may want to handle tabs differently).
check for tab
check for direction change
check for tab
if the first character is a tab, create a dedicated
view for just the tab
found a tab, don't include it in the text
determine limit from LineBreakMeasurer
If the children of the FlowView's logical view are GlyphViews, they
need to have their painters updated.
--- variables -------------------------------------------------------
this run is different
--- AttributedCharacterIterator methods -------------------------
number of elements in list
byte code offsets corresponding to instructions
&& end == null
else constrain search area
target > j
Can't be more than that
Contains actual length
Remember byte offset and associate it with the instruction
Use proper append() method
Trim to proper size
Search for target position
If it is a Select instruction, update all branch targets
Either LOOKUPSWITCH or TABLESWITCH
Nothing to do
i == end ?
Update end ...
Also applies for empty list
Nothing to do
Nothing to do
ih == start ?
Update start ...
Code is identical for this case
Step 1: Check constraints
At end of list, end not found yet
target may be null
Step 2: Temporarily remove the given instructions from the list
start == this.start!
end == this.end!
Step 3: append after target
append to start of list
First and last deleted instruction
At start of list
At end of list
Completely separated from rest of list
e.g. BranchInstructions release their targets
Still got targeters?
target instruction within list?
Trim to proper size
Update position indices of instructions
Use clone for shallow copy
New target is in hash map
Either LOOKUPSWITCH or TABLESWITCH
Update all targets
Traverse in reverse order, because ih.next is overwritten
Either LOOKUPSWITCH or TABLESWITCH
largest numerical value
These would not be used for EN. Only used for traditional numbering
These only used for mutiplicative-additive numbering
Number of lower bits used to represent node index.
Masks the lower order of node handle.
Masks the higher order Document handle
masked document handle for this dtm document
nodeHandle to the root of the actual dtm doc content
Context for parse-and-append operations
current parent - default is document root
previous sibling - no previous sibling
The tree under construction can itself be used as
the element stack, so m_elemStack isn't needed.
protected Stack m_elemStack = new Stack();      element stack
Local cache for record-at-a-time fetch
========= DTM data structure declarations. ==============
nodes array: integer array blocks to hold the first level reference of the nodes,
each reference slot is addressed by a nodeHandle index value.
text/comment table: string buffer to hold the text string values of the document,
each of which is addressed by the absolute offset and length in the buffer
needed because the string may be appended in several chunks.
%TBD% INITIALIZATION/STARTUP ISSUES
-- Should we really be creating these, or should they be
passed in from outside? Scott want to be able to share
pools across multiple documents, so setting them here is
probably not the right default.
%TBD% If we use the current ExpandedNameTable mapper, it
needs to be bound to the NS and local name pools. Which
means it needs to attach to them AFTER we've resolved their
startup. Or it needs to attach to this document and
retrieve them each time. Or this needs to be
an interface _implemented_ by this class... which might be simplest!
clear nodes and document handle
Establish SAX-stream link so we can receive the requested data
Are the following really needed? IncrementalSAXSource doesn't yet
support them, and they're mostly no-ops here...
A decent compiler may inline this.
Set the default; endElement overrides
========= DTM Implementation Control Functions. ==============
========= SAX2 ContentHandler methods =========
Accept SAX events, use them to build/extend the DTM tree.
Replaces the deprecated DocumentHandler interface.
Actually creating the text node is handled by
processAccumulatedText(); here we just accumulate the
characters into the buffer.
Flush string accumulation into a text node
The FastStringBuffer has been previously agreed upon
May need to tell the low-level builder code to pop up a level.
There _should't_ be any significant pending text at this point.
No args but we do need to tell the low-level builder code to
pop up a level.
%TBD% I believe ignorable text isn't part of the DTM model...?
%TBD% Which pools do target and data go into?
No-op for DTM
%TBD% Split prefix off qname
%TBD% Where do we pool expandedName, or is it just the union, or...
%TBD% I'm assuming that DTM will require resequencing of
NS decls before other attrs, hence two passes are taken.
%TBD% Is there an easier way to test for NSDecl?
%TBD% Countdown is more efficient if nobody cares about sequence.
%REVEIW% Null or ""?
%TBD% I hate having to extract the prefix into a new
string when we may never use it. Consider pooling whole
qNames, which are already strings?
No-op in DTM, handled during element/attr processing?
LexicalHandler support. Not all SAX2 parsers support these events
but we may want to pass them through when they exist...
No-op in DTM
No-op in DTM
No-op in DTM
No-op in DTM
No-op in DTM
No-op in DTM
========= Document Handler Functions =========
%REVIEW% jjk -- DocumentHandler is  SAX Level 1, and deprecated....
and this wasn't a fully compliant or declared implementation of that API
in any case. Phase out in favor of SAX2 ContentHandler/LexicalHandler
save masked DTM document handle
Initialize the doc -- no parent, no next-sib
wait for the first startElement to create the doc root node
* Receive hint of the end of a document.
* <p>The content handler will invoke this method only once, and it will
* be the last method invoked during the parse.  The handler shall not
* not invoke this method until it has either abandoned parsing
* (because of an unrecoverable error) or reached the end of
public void documentEnd()
%TBD% may need to notice the last slot number and slot count to avoid
residual data from provious use of this DTM
* Receive notification of the beginning of a document.
* <p>The SAX parser will invoke this method only once, before any
* other methods in this interface.</p>
public void reset()
%TBD% reset slot 0 to indicate ChunkedIntArray reuse or wait for
the next initDocument().
m_docElement = NULL;      reset nodeHandle to the root of the actual dtm doc content
* Factory method; creates an Element node in this document.
* The node created will be chained according to its natural order of request
* received.  %TBD% It can be rechained later via the optional DTM writable interface.
* <p>The XML content handler will invoke endElement() method after all
* of the element's content are processed in order to give DTM the indication
* to prepare and patch up parent and sibling node pointers.</p>
* <p>The following interface for createElement will use an index value corresponds
* to the symbol entry in the DTMDStringPool based symbol tables.</p>
* @param nsIndex The namespace of the node
* @param nameIndex The element name.
* @see #endElement
* @see org.xml.sax.Attributes
* @return nodeHandle int of the element created
public int createElement(int nsIndex, int nameIndex, Attributes atts)
do document root node creation here on the first element, create nodes for
this element and its attributes, store the element, namespace, and attritute
name indexes to the nodes array, keep track of the current node and parent
W0  High:  Namespace  Low:  Node Type
W2: Next  (initialized as 0)
set the root element pointer when creating the first element node
if (m_docElement == NULL)
Factory method to create an Element node not associated with a given name space
using String value parameters passed in from a content handler or application
* Factory method; creates an Element node not associated with a given name space in this document.
* The node created will be chained according to its natural order of request
* received.  %TBD% It can be rechained later via the optional DTM writable interface.
* <p>The XML content handler or application will invoke endElement() method after all
* of the element's content are processed in order to give DTM the indication
* to prepare and patch up parent and sibling node pointers.</p>
* <p>The following parameters for createElement contains raw string values for name
* symbols used in an Element node.</p>
* @param name String the element name, including the prefix if any.
* @param atts The attributes attached to the element, if any.
* @see #endElement
* @see org.xml.sax.Attributes
public int createElement(String name, Attributes atts)
This method wraps around the index valued interface of the createElement interface.
The raw string values are stored into the current DTM name symbol tables.  The method
method will then use the index values returned to invoke the other createElement()
onverted to index values modified to match a
note - there should be no prefix separator in the name because it is not associated
with a name space
Factory method to create an Element node associated with a given name space
using String value parameters passed in from a content handler or application
* Factory method; creates an Element node associated with a given name space in this document.
* The node created will be chained according to its natural order of request
* received.  %TBD% It can be rechained later via the optional DTM writable interface.
* <p>The XML content handler or application will invoke endElement() method after all
* of the element's content are processed in order to give DTM the indication
* to prepare and patch up parent and sibling node pointers.</p>
* <p>The following parameters for createElementNS contains raw string values for name
* symbols used in an Element node.</p>
* @param ns String the namespace of the node
* @param name String the element name, including the prefix if any.
* @param atts The attributes attached to the element, if any.
* @see #endElement
* @see org.xml.sax.Attributes
public int createElementNS(String ns, String name, Attributes atts)
This method wraps around the index valued interface of the createElement interface.
The raw string values are stored into the current DTM name symbol tables.  The method
method will then use the index values returned to invoke the other createElement()
onverted to index values modified to match a
The prefixIndex is not needed by the indexed interface of the createElement method
* Receive an indication for the end of an element.
* <p>The XML content handler will invoke this method at the end of every
* element in the XML document to give hint its time to pop up the current
* element and parent and patch up parent and sibling pointers if necessary
* <p>%tbd% The following interface may need to be modified to match a
* coordinated access to the DTMDStringPool based symbol tables.</p>
* @param ns the namespace of the element
* @param name The element name
public void endElement(String ns, String name)
pop up the stacks
The element just being finished will be
the previous sibling for the next operation
Pop a level of namespace table
* Creates attributes for the current node.
* @param atts Attributes to be created.
* Appends an attribute to the document.
* @param qname Qualified Name of the attribute
* @param value Value of the attribute
* @return Handle of node
w0 = ATTRIBUTE_NODE |
w0 = ATTRIBUTE_NODE |
W2:  Next (not yet resolved)
W3:  Tag name
previousSibling = ourslot;       Should attributes be previous siblings
W0: Node Type
W2: Start Position within buffer
Attrs are Parents
* Factory method; creates a Text node in this document.
* The node created will be chained according to its natural order of request
* received.  %TBD% It can be rechained later via the optional DTM writable interface.
* @param text String The characters text string from the XML document.
* @return int DTM node-number of the text node created
public int createTextNode(String text)
wraps around the index value based createTextNode method
* Factory method; creates a Text node in this document.
* The node created will be chained according to its natural order of request
* received.  %TBD% It can be rechained later via the optional DTM writable interface.
* %REVIEW% for text normalization issues, unless we are willing to
* insist that all adjacent text must be merged before this method
* is called.
* @param ch The characters from the XML document.
* @param start The start position in the array.
* @param length The number of characters to read from the array.
public int createTextNode(char ch[], int start, int length)
m_char.append(ch, start, length);                store the chunk to the text/comment string table
create a Text Node
%TBD% may be possible to combine with appendNode()to replace the next chunk of code
W2: Start position within m_char
W3: Length of the full string
* Factory method; creates a Comment node in this document.
* The node created will be chained according to its natural order of request
* received.  %TBD% It can be rechained later via the optional DTM writable interface.
* @param text String The characters text string from the XML document.
* @return int DTM node-number of the text node created
public int createComment(String text)
wraps around the index value based createTextNode method
* Factory method; creates a Comment node in this document.
* The node created will be chained according to its natural order of request
* received.  %TBD% It can be rechained later via the optional DTM writable interface.
* @param ch An array holding the characters in the comment.
* @param start The starting position in the array.
* @param length The number of characters to use from the array.
* @see DTMException
public int createComment(char ch[], int start, int length)
m_char.append(ch, start, length);                store the comment string to the text/comment string table
create a Comment Node
%TBD% may be possible to combine with appendNode()to replace the next chunk of code
W2: Start position within m_char
W3: Length of the full string
Counters to keep track of the current text string being accumulated with respect
to the text/comment string table: charStringStart should point to the starting
offset of the string in the table and charStringLength the acccumulated length when
appendAccumulatedText starts, and reset to the end of the table and 0 at the end
of appendAccumulatedText for the next set of characters receives
========= Document Navigation Functions =========
###shs worry about tracing/debug later
Read node into variable
type is the last half of first slot
Check to see if Element or Document node
In case when Document root is given
%TBD% Probably was a mistake.
If someone explicitly asks for first child
of Document, I would expect them to want
that and only that.
points to next sibling
Return NULL if node has only attributes
If parent slot matches given parent, return kid
No child found
###shs put trace/debug later
do not need to test node type since getFirstChild does that
If nodeHandle points to element next slot would be first attribute
Iterate through Attribute Nodes
Goto next sibling
%REVIEW% jjk: Just a quick observation: If you're going to
call readEntry repeatedly on the same node, it may be
more efficiently to do a readSlot to get the data locally,
reducing the addressing and call-and-return overhead.
Should we check if handle is element (do we want sanity checks?)
First Attribute (if any) should be at next position in table
Document root has no next sibling
###shs should cycle/wait if nextSib is 0? Working on threading next
Next Sibling is in the next position if it shares the same parent
Document root has no previous sibling
%REVIEW% Why are we using short here? There's no storage
reduction for an automatic variable, especially one used
so briefly, and it typically costs more cycles to process
than an int would.
###shs need to work on namespace
Document root [Document Node? -- jjk] - no next-sib
Document done and node out of bounds
Add wait logic here
Probably should throw error here like original instead of returning
###shs still working on
###shs copied from Xalan 1, what is this suppose to do?
if nodeHandle is _not_ an ancestor of
axisContextHandle, specialFind will return it.
If it _is_ an ancestor, specialFind will return -1
%REVIEW% unconditional return defeats the
purpose of the while loop -- does this
logic make any sense?
Should check to see within range?
Document Root should not have to be handled differently
Assumption that Document Node is always in 0 slot
Assumption that Document Node is always in 0 slot
###zaj - researching
###zaj - tbd
###zaj    return value
###zaj - tbd
Remove prefix from qName
%TBD% jjk This is assuming the elementName is the qName.
Create expanded name
Create expanded name
%TBD% jjk Expanded name is bitfield-encoded as
typeID[6]nsuriID[10]localID[16]. Switch to that form, and to
accessing the ns/local via their tables rather than confusing
nsnames and expandednames.
Get expanded name
Remove prefix from expanded name
Remove local name from expanded name
###zaj use mask to get node type
###zaj todo - document nodetypes
============== Document query functions ==============
============== Boolean methods ================
========== Direct SAX Dispatch, for optimization purposes ========
==== Construction methods (may not be supported by some implementations!) =====
%REVIEW% jjk: These probably aren't the right API. At the very least
they need to deal with current-insertion-location and end-element
###shs Think more about how this differs from createTextNode
==== BUILDER methods ====
%TBD% jjk: SHOULD PROBABLY BE INLINED, unless we want to support
both SAX1 and SAX2 and share this logic between them.
create a Text Node
%TBD% may be possible to combine with appendNode()to replace the next chunk of code
W2: Start position within m_char
W3: Length of the full string
create a Comment Node
%TBD% may be possible to combine with appendNode()to replace the next chunk of code
W2: Start position within m_char
W3: Length of the full string
do document root node creation here on the first element, create nodes for
this element and its attributes, store the element, namespace, and attritute
name indexes to the nodes array, keep track of the current node and parent
W0  High:  Namespace  Low:  Node Type
W2: Next  (initialized as 0)
W3: Tagname high: prefix Low: local name
set the root element pointer when creating the first element node
%REVIEW% I'm assigning this node the "namespace for namespaces"
which the DOM defined. It is expected that the Namespace spec will
adopt this as official. It isn't strictly needed since it's implied
by the nodetype, but for now...
%REVIEW% Prefix need not be recorded; it's implied too. But
recording it might simplify the design.
%TBD% isID is not currently honored.
W0  High:  Namespace  Low:  Node Type
W2:  CURRENTLY UNUSED -- It's next-sib in attrs, but we have no kids.
W3:  namespace name
Should attributes be previous siblings
%TBD% isID is not currently honored.
W0  High:  Namespace  Low:  Node Type
W2:  Next (not yet resolved)
W3:  Tagname high: prefix Low: local name
Should attributes be previous siblings
Attribute's content is currently appended as a Text Node
W0: Node Type
W2: Start Position within buffer
Attrs are Parents
pop up the stacks
The element just being finished will be
the previous sibling for the next operation
Pop a level of namespace table
%TBD% reset slot 0 to indicate ChunkedIntArray reuse or wait for
the next initDocument().
reset nodeHandle to the root of the actual dtm doc content
%TBD% may need to notice the last slot number and slot count to avoid
residual data from provious use of this DTM
_REVISIT_ Need to worry about wrap around some day
REVISIT - A less expensive alternative connection reclaiming
algorithm could be investigated.
Find least recently used and not busy connection in cache
REVISIT - log
XXX is necessary to do a GC to reclaim
closed network connections ??
This is public so folb.Server test can access it.
End of file.
init to 0 by new
init to 0 by new
add IANA to Java encoding mappings.
is this an error???
Add support for Cp1252 and its friends
added since this encoding only differs w.r.t. presentation
support for 1047, as proposed to be added to the
IANA registry in
Adding new aliases as proposed in
j:CNS11643 -> EUC-TW?
add Java to IANA encoding mappings
aJava2IANAMap.put("8859_1",    "US-ASCII");  ?
proposed addition (see above for details):
Public static methods
cannot be serialized
do not fallback if given classloader can't find the class, throw exception
do not fallback if given classloader can't find the class, throw exception
read and discard the repository ID
write the repository ID
%OPT% Use smaller sizes for all internal storage units when
the blocksize is small. This reduces the cost of creating an RTF.
%REVIEW%  Initial size pushed way down to reduce weight of RTFs
(I'm not entirely sure 0 would work, so I'm playing it safe for now.)
Need placeholder in case index into here must be <0.
Check to see if the information requested has been processed, and,
if not, advance the iterator until we the information has been
Establish coroutine link so we can request more data
Note: It's possible that some versions of IncrementalSAXSource may
not actually use a CoroutineManager, and hence may not require
that we obtain an Application Coroutine ID. (This relies on the
coroutine transaction details having been encapsulated in the
Establish SAX-stream link so we can receive the requested data
Are the following really needed? incrementalSAXSource doesn't yet
support them, and they're mostly no-ops here...
If just testing nonzero, no need to shift...
Don't retrieve name until/unless needed
I'm not sure if I want to do anything with this...
gotMore may be a Boolean (TRUE if still parsing, FALSE if
EOF) or an exception if IncrementalSAXSource malfunctioned
(code error rather than user error).
%REVIEW% Currently the ErrorHandlers sketched herein are
no-ops, so I'm going to initially leave this also as a
EOF reached without satisfying the request
Drop connection, stop trying
%TBD% deregister as its listener?
* Ensure that the size of the information arrays can hold another entry
* at the given index.
* @param on exit from this function, the information arrays sizes must be
* at least index+1.
* NEEDSDOC @param index
protected void ensureSize(int index)
dataOrQName is an SuballocatedIntVector and hence self-sizing.
But DTMDefaultBase may need fixup.
Common to all nodes:
Have we overflowed a DTM Identity's addressing range?
Note that nextSibling is not processed until charactersFlush()
is called, to handle successive characters() events.
Special handling by type: Declare namespaces, attach first child
Handle as Extended Addressing
%REVIEW% Wrong error message, but I've been told we're trying
not to add messages right not for I18N reasons.
%REVIEW% Should this be a Fatal Error?
We have to reset the information in m_dtmIdent and
register the DTM with the new manager.
%REVIEW% %BUG% Prevent this from arising in the first place
by not allowing the enabling conditions to change after we start
building the document.
%OPT% We should cache this, I guess.
The draft says: "The XSLT processor may use the public
identifier to generate a URI for the entity instead of the URI
specified in the system identifier. If the XSLT processor does
not use the public identifier to generate the URI, it must use
the system identifier; if the system identifier is a relative
URI, it must be resolved into an absolute URI using the URI of
the resource containing the entity declaration as the base
So I'm falling a bit short here.
Separate lines because I wanted to breakpoint it
Separate lines because I wanted to breakpoint it
-1 indicates no-text-in-progress
Discard accumulated text
Guard against characters/ignorableWhitespace events that
contained no characters.  They should not result in a node.
Reset for next text block
Implementation of the EntityResolver interface.
Implementation of DTDHandler interface.
Implementation of ContentHandler interface.
for the next element.
Bugzilla 4858: throw away m_locator. we cache m_systemId
JDK 1.1.x compat -sc
JDK 1.1.x compat -sc
SPECIAL CASE: Implied declaration at root element
go to the next attribute.
Bit of a hack... if somehow valString is null, stringToIndex will
return -1, which will make things very unhappy.
for the children.
If no one noticed, startPrefixMapping is a drag.
Pop the context for the last child (the one pushed by startElement)
Do it again for this one (the one pushed by the last endElement).
If lastNode is still DTM.NULL, this element had no children
First one in this block
Type logic: If all adjacent text is CDATASections, the
concatentated text is treated as a single CDATASection (see
initialization above).  If any were ordinary Text, the whole
thing is treated as Text. This may be worth %REVIEW%ing.
%OPT% We can probably take advantage of the fact that we know this
%REVIEW% What should be done here?
Implementation of the ErrorHandler interface.
%REVIEW% Is there anyway to get the JAXP error listener here?
Implementation of the DeclHandler interface.
Implementation of the LexicalHandler interface.
ignore comments if we're inside the DTD
For now, treat comments as strings...  I guess we should do a
seperate FSB buffer instead.
for javadoc and covariant return type
override for performance
override for performance
override for performance
MinguoChronology is implicit in the MINGUO_DATE_TYPE
recognized features and properties
the validator to which we look for our grammar bucket (the
validator needs to hold the bucket so that it can initialize
the grammar with details like whether it's for a standalone document...
the grammar pool we'll try to add the grammar to:
what's our Locale?
information regarding the current element
to check for duplicate ID or ANNOTATION attribute declare in
ATTLIST, and misc VCs
parser settings have not been changed
get needed components
we get our grammarBucket from the validator...
XMLDTDContentModelHandler and XMLDTDHandler methods
check VC: Standalone Document Declartion, entities references appear in the document.
the grammar bucket's DTDGrammar will now be the
one we want, whether we're constructing it or not.
if we're not constructing it, then we should not have a reference
ignored characters in DTD
check VC: Unique Element Declaration
Get Grammar index to grammar array
more than one attribute definition is provided for the same attribute of a given element type.
this feature works only when validation is true.
a) VC: One ID per Element Type, If duplicate ID attribute
b) VC: ID attribute Default. if there is a declareared attribute
default for ID it should be of type #IMPLIED or #REQUIRED
we should not report an error, when there is duplicate attribute definition for given element type
according to XML 1.0 spec, When more than one definition is provided for the same attribute of a given
element type, the first declaration is binding and later declaration are *ignored*. So processor should
ignore the second declarations, however an application would be warned of the duplicate attribute defintion
if http:apache.org/xml/features/validation/warn-on-duplicate-attdef feature is set to true,
one typical case where this could be a  problem, when any XML file
provide the ID type information through internal subset so that it is available to the parser which read
only internal subset. Now that attribute declaration(ID Type) can again be part of external parsed entity
referenced. At that time if parser doesn't make this distinction it will throw an error for VC One ID per
Element Type, which (second defintion) actually should be ignored. Application behavior may differ on the
basis of error or warning thrown. - nb.
VC: One Notation Per Element Type, should check if there is a
duplicate NOTATION attribute
VC: Notation Attributes: all notation names in the
(attribute) declaration must be declared.
we should not report an error, when there is duplicate attribute definition for given element type
according to XML 1.0 spec, When more than one definition is provided for the same attribute of a given
element type, the first declaration is binding and later declaration are *ignored*. So processor should
ignore the second declarations, however an application would be warned of the duplicate attribute definition
if http:apache.org/xml/features/validation/warn-on-duplicate-attdef feature is set to true, Application behavior may differ on the basis of error or
warning thrown. - nb.
VC: No Duplicate Tokens
XML 1.0 SE Errata - E2
Only report the first uniqueness violation. There could be others,
but additional overhead would be incurred tracking unique tokens
that have already been encountered. -- mrglavas
VC: Attribute Default Legal
attributeDecl(String,String,String,String[],String,XMLString, XMLString, Augmentations)
If the same entity is declared more than once, the first declaration
encountered is binding, SAX requires only effective(first) declaration
to be reported to the application
REVISIT: Does it make sense to pass duplicate Entity information across
the pipeline -- nb?
its a new entity and hasn't been declared.
store internal entity declaration in grammar
If the same entity is declared more than once, the first declaration
encountered is binding, SAX requires only effective(first) declaration
to be reported to the application
REVISIT: Does it make sense to pass duplicate entity information across
the pipeline -- nb?
its a new entity and hasn't been declared.
store external entity declaration in grammar
VC: Notation declared,  in the production of NDataDecl
VC: Unique Notation Name
VC : Notation Declared. for external entity declaration [Production 76].
VC: Notation Attributes:
all notation names in the (attribute) declaration must be declared.
VC: No Notation on Empty Element
An attribute of type NOTATION must not be declared on an element declared EMPTY.
should be safe to release these references
check whether each element referenced in a content model is declared
sets the XMLDTDSource of this handler
returns the XMLDTDSource of this handler
sets the XMLContentModelDTDSource of this handler
returns the XMLDTDSource of this handler
check VC: No duplicate Types, in a single mixed-content declaration
skip leading spaces
take the first whitespace as a space and skip the others
just skip it.
simply shift non space chars if needed
if we finished on a space trim it
set the new value length
It's not a leaf, so we have to recurse its left and maybe right
nodes. Save both values before we recurse and trash the node.
Recurse on both children.
Guaranteed to return a non-null array
Process the listeners last to first, notifying
those that are interested in this event
different url or POST method, load the new content
open stream synchronously
At this point, one could either load up the model with no
view notifications slowing it down (i.e. best synchronous
behavior) or set the model and start to feed it on a separate
thread (best asynchronous behavior).
we may need to cancel background loading
Do everything in a background thread.
Model initialization is deferred to that thread, too.
Have to scroll after painted.
transfer properties discovered in stream to the
document property collection.
mark was invalidated
there is nothing we can do to recover stream
We received document of unknown content type.
scroll the page if necessary, but do it on the
event thread... that is the only guarantee that
modelToView can be safely called.
Connection properties handler should be forced to run on EDT,
as it instantiates the EditorKit.
found a matching reference in the document.
the view is visible, scroll it to the
center of the current visible area.
The type could have optional info is part of it,
for example some charset info.  We need to strip that
of and save it.
Save the paramList.
update the content type string.
paramlist is handed to us with a leading ';', strip it.
parse the paramlist into attr-value pairs & get the
charset pair's value
malformed parameter list, use charset we have
malformed parameter list, use charset we have
malformed parameter list, use charset we have; but complain
try to dynamically load the support
Will only happen if developer has invoked
registerEditorKitForContentType(type, class, null).
create a copy of the prototype or null if there
is no prototype.
--- java.awt.Component methods --------------------------
Only adjust to min if we have a valid size
Only adjust to min if we have a valid size
--- JTextComponent methods -----------------------------
--- Scrollable  ----------------------------------------
--- Serialization ------------------------------------
--- variables ---------------------------------------
fallback to client property
link invalid or i != 0
link invalid or i != 0
don't need to verify that it's an HREF element; if
not, then it won't be in the hyperlinks Vector, and
so indexOf will return -1 in any case
build a view that support bidi
no limit if unwrapped
min is pref if unwrapped
The following methods don't do anything useful, they
simply keep the class from being abstract.
end of a key
end key/val, of whatever we're in
get last key/val, if any
The Border on the verticall scrollbar matches
what we installed, reset it.
-- socket options and related --
-- state --
-- asynchronous operations --
Based on the constant definitions TYPE_2CLR=12 through
TYPE_FCLR=25. This will return unknown types for
numComponents > 15.
The following methods simply copy the input array to the
output array while otherwise attempting to adhere to the
specified behavior of the methods vis-a-vis exceptions.
$$fb 2001-07-20: Fix for bug 4400392: setValue() in ReverbControl always throws Exception
ABSTRACT METHOD IMPLEMENTATIONS: CONTROL
xxx: setting the default value as false, as we dont need to calculate this value
we should have a feature when set to true computes this value
NOTE: These objects are private to help prevent accidental modification
of values by a subclass. If there were protected *and* the sub-
modified the values, it would be difficult to track down the real
cause of the bug. By making these private, we avoid this
temporary location for Resource identification information.
parser settings have not been changed
this step is extra because we have separated the storage of entity
anybody calling this had better have set Symtoltable!
DTD preparsing defaults:
DTD preparsing defaults:
common scanning methods
since pseudoattributes are *not* attributes,
their quotes don't need to be preserved in external parameter entities.
the XMLEntityScanner#scanLiteral method will continue to
emit -1 in such cases when it finds a quote; this is
fine for other methods that parse scanned entities,
but not for the scanning of pseudoattributes.  So,
temporarily, we must mark the current entity as not being "literal"
TODO: check encoding name; set encoding on
restore original literal value
REVISIT: should we remove this error reporting?
If there is no data in the xml or text decl then we fail to report error
for version or encoding info above.
fill in return array
it makes things more easy if XMLStringBUffer is passed. Motivation for this change is same
as that for scanContent()
Earlier:This method uses the fStringBuffer and later buffer values are set to
the supplied XMLString....
Now: Changed the signature of this function to pass XMLStringBuffer.. and data would
be appended to that buffer
we found the end, there is no data just return
if there is data there should be some space
since scanData appends the parsed data to the buffer passed
a while loop would append the whole of parsed data to the buffer(data:XMLStringBuffer)
until all of the data is buffered.
REVISIT: handle invalid character, eof
WFC & VC: Entity Declared
Todo ::Move this check  to Attributes , do conversion
only if attribute is being accessed. -Venu
looks like we don't have any system id
simply return the public id
store result in array
skip leading whitespace
take the first whitespace as a space and skip the others
if we finished on a space let's trim it
keep track of the entity depth
must reset entity scanner
keep track of the entity depth
scan hexadecimal value
scan decimal value
convert string to number
character reference must be a valid XML character
Conversion failed, let -1 value drop through.
If we end up here, the character reference was invalid.
append corresponding chars to the given buffer
character is supplemental, split it into surrogate chars
char refs notification code
returns true if the given character is not
valid with respect to the version of
XML understood by this scanner.
returns true if the given character is not
valid or may not be used outside a character reference
with respect to the version of XML understood by this scanner.
returns true if the given character is
a valid nameChar with respect to the version of
XML understood by this scanner.
returns true if the given character is
a valid NCName character with respect to the version of
XML understood by this scanner.
returns true if the given character is
a valid nameStartChar with respect to the version of
XML understood by this scanner.
returns true if the given character is
a valid high surrogate for a nameStartChar
with respect to the version of XML understood
by this scanner.
convert surrogates to supplemental character
supplemental character must be a valid XML character
fill in the buffer
A new ORB started server registers itself with the Activator
Install a particular kind of endpoint
list active servers
If the server is not running, start it up.
If the server is running, shut it down
currently running, this method will activate it.
list all registered ORBs for a server
After this hook completes, the server may still be running.
Type-specific CORBA::Object operations
Content Model Types
Host Name and Port Number
Default IIOP Version
Default host is localhost
Default INS Port
if namespaceURI, qualifiedName and doctype are null, returned document is empty with
no document element
This prefix is used for the method name of attribute set methods
Get this attribute set's name
Get any included attribute sets (similar to inheritance...)
Parse the contents of this node. All child elements must be
<xsl:attribute> elements. Other elements cause an error.
Point the symbol table back at us...
_mergeSet Point to any previous definition of this attribute set
Create a new method generator for an attribute set method
Generate a reference to previous attribute-set definitions with the
same name first.  Those later in the stylesheet take precedence.
Translate other used attribute sets first, as local attributes
take precedence (last attributes overrides first)
Translate all local attributes
Translate all local attributes
XML 1.0 components
XML 1.1 components
create a vector to hold all the components in use
XML 1.0 specialized components
XML 1.1 specialized components
Common components for XML 1.1. and XML 1.0
create table for features and properties
add default recognized features
set state for default features
add default recognized properties
add message formatters
REVISIT: What is the right thing to do? -Ac
REVISIT: this method used to reset all the components and
construct the pipeline. Now reset() is called
in parse (boolean) just before we parse the document
Should this method still throw exceptions..?
REVISIT: Should this be a property?
REVISIT - need to add new error message
close all streams opened by xerces
reset and configure pipeline and set InputSource.
mark configuration as fixed
resets and sets the pipeline.
make this feature special
forward to every XML 1.0 component
forward it to common components
forward to every XML 1.1 component
save state if noone "objects"
forward to every XML 1.0 component
forward it to every common Component
forward it to every XML 1.1 component
store value if noone "objects"
reset common components
reset every component
setup XML 1.1 document pipeline
non namespace document pipeline
use XML 1.0 datatype library
setup DTD pipeline
setup document pipeline
features and properties
Allows the parser to validate a document only when it
contains a grammar. Validation is turned on/off based
on each document instance, automatically.
special performance feature: only component manager is allowed to set it.
Value type: String
Get the literal string of characters associated with the
current event.  If the parser recognises and supports this
property but is not currently parsing text, it should return
null (this is a good way to check for availability before the
REVISIT - we should probably ask xml-dev for a precise
definition of what this is actually supposed to return, and
in exactly which circumstances.
don't add a component more than once
don't add a component more than once
don't add a component more than once
register component's recognized features
register component's recognized properties
set default values
Do not overwrite values already set on the configuration.
For newly added components who recognize this feature
but did not offer a default value, we need to make
sure these components will get an opportunity to read
the value before parsing begins.
Do not overwrite values already set on the configuration.
For newly added components who recognize this property
but did not offer a default value, we need to make
sure these components will get an opportunity to read
the value before parsing begins.
create datatype factory
setup XML 1.1 DTD pipeline
setup XML 1.1. document pipeline - namespace aware
If the current frame is maximized, transfer that
attribute to the frame being activated.
Special case.  If key binding was used to select next
frame instead of minimizing the icon via the minimize
* Return the first node out of the nodeset, if this expression is
* a nodeset expression.  This is the default implementation for
* <p>WARNING: Do not mutate this class from this function!</p>
* @param xctxt The XPath runtime context.
* @return the first node out of the nodeset, or DTM.NULL.
public int asNode(XPathContext xctxt)
if(getPredicateCount() > 0)
if(DTMFilter.SHOW_ALL == what
|| ((DTMFilter.SHOW_ELEMENT & what) == 0)
|| localName == NodeTest.WILD
|| namespace == NodeTest.WILD)
read and discard the repository ID
write the repository ID
