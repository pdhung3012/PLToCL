int version
Randomly permute the values of array "A"
for each i swap A[i-1] with a random element 
for each i swap A[i-1] with a random element 
Hold the Random class object
Graph class ADT
Create a graph from file
Read in edges
No weight given -- set at 1
Put in edge in other direction
Equivalence array
Minheap array
Count of edges
Put edges in the array
Initially n classes
Combine equiv classes
Next cheapest
If in different classes
Combine equiv classes
Add this edge to MST
One less MST
Graph class ADT
int version
Randomly permute the values of array "A"
for each i swap A[i-1] with a random element 
for each i swap A[i-1] with a random element 
Hold the Random class object
Graph class ADT
Found k
k not found
Quicksort
Pick a pivot
Stick pivot at end
k will be the first position in the right subarray
Put pivot in place
Sort left partition
Sort right partition
Move bounds inward until they meet
Swap out-of-place values
Stop when they cross
Reverse last, wasted swap
Return first position in right partition
Reverse sorted
Random
Sorted
Create a graph from file
Read in edges
No weight given -- set at 1
Put in edge in other direction
Take appropriate action
Take appropriate action
Do nothing
New node's level
If new node is deeper adjust the header 
Track end of level
Start at header node
Find insert position
Track end at level i
Splice into list
Who x points to
Who y points to
Increment dictionary size
Dummy header node
For each level...
go forward
Go one last step
Move to actual record, if it exists
Got it
Its not there
Pointer to front queue node
Pointer to rear queuenode
Number of elements in queue
Ignore size
Store dequeued value
Advance front
Last Object
Return Object
Extra stuff not printed in the book.
Number of records in a block
Size of working memory (in blocks)
Indices for I/O files.
Use two input files and two output files.
////Code for Quicksort ////////////////////////////////////
Move the bounds inward until they meet
Move left bound right
Move right bound
Swap out-of-place values
Stop when they cross
Reverse last, wasted swap
Return first position in right partition
Quicksort
Stick pivot at end
k will be the first position in the right subarray
Put pivot in place
Sort left partition
Sort right partition
////End code for Quicksort ////////////////////////////////
Use quicksort to generate initial runs, placing half of the runs
into each output file.
Working memory
Do a single 2-way merge pass
In this case, numruns is the number of runs in each file,
while runlen is the number of records in a run.
Flush second run
Flush first run
Do an external sort
For first pass, need the original input file.  Won't use again
Divide the original input into two
Now, do a series of 2-way merge passes
Finally, merge the last two runs into the output file
Main routine for external sort
Now test that this worked correctly
Priming read
Create a graph from file
Read in edges
No weight given -- set at 1
Put in edge in other direction
The edge matrix
Number of edges
The mark array
Constructors
# of vertices
# of edges
No edge for this vertex
No next edge;
Delete edge (i, j)
Create a graph from file
Read in edges
No weight given -- set at 1
Put in edge in other direction
Initialize D with weights
Compute all k paths
Override Object.toString
Value for this node
Pointer to next node in list
Pointer to previous node
Found k
k not found
Value for this node
Pointer to next node in list
Constructors
Return next field
Set next field
Return element field
Set element field
int version
Randomly permute the values of array "A"
for each i swap A[i-1] with a random element 
for each i swap A[i-1] with a random element 
Hold the Random class object
The hash table
# of records now in table
Maximum size of dictionary
int version
Randomly permute the values of array "A"
for each i swap A[i-1] with a random element 
for each i swap A[i-1] with a random element 
Hold the Random class object
int version
Randomly permute the values of array "A"
for each i swap A[i-1] with a random element 
for each i swap A[i-1] with a random element 
Hold the Random class object
An access handle for the
memory manager
Position of data in memory
Key for this node
Element for this node
Pointer to left child
Pointer to right child
The edge matrix
Number of edges
The mark array
Constructors
# of vertices
# of edges
No edge for this vertex
No next edge;
Delete edge (i, j)
Allow the generic array allocation
Allow the generic array allocation
Remove test
Allow the generic array allocation
Value for this node
Pointer to next node in list
Constructors
Return next field
Set next field
Return element field
Set element field
Graph class ADT
Generic array allocation
Insert i'th record
Select the midpoint
List has one element
Do the merge operation.  First, copy 2 halves to temp.
Merge sublists back to array
Value for this node
Pointer to next node in list
Constructors
Return next field
Set next field
Return element field
Set element field
int version
Randomly permute the values of array "A"
for each i swap A[i-1] with a random element 
for each i swap A[i-1] with a random element 
Hold the Random class object
Generic array allocation
Count[i] stores number of records in bin[i]
For k digits
Initialize count
Count the number of records for each bin on this pass
count[j] will be index in B for last slot of bin j.
Put records into bins, working from bottom of bin
Since bins fill from bottom, j counts downwards
Copy B back
int version
Randomly permute the values of array "A"
for each i swap A[i-1] with a random element 
for each i swap A[i-1] with a random element 
Hold the Random class object
Create a graph from file
Read in edges
No weight given -- set at 1
Put in edge in other direction
The current vertex
Heap for edges
Initial vertex
Initialize distance
For each vertex
Get position
Unreachable
Update D
Key for this node
Element for this node
Pointer to left child
Pointer to right child
Write out random numbers
Write out numbers ascending
Write out numbers descending
int version
Randomly permute the values of array "A"
for each i swap A[i-1] with a random element 
for each i swap A[i-1] with a random element 
Hold the Random class object
Value for this node
Pointer to next node in list
Constructors
Return next field
Set next field
Return element field
Set element field
Constructor
Pointer to the heap array
Maximum size of the heap
Number of things in heap
Start at end of heap
Now sift up until curr's parent's key > curr's key
j is now index of child with greater value
Move down
Remove minimum value
Swap minimum with last value
Not on last element
Put new heap root val in correct place
Last element, no work to be done
Swap with last value
If we just swapped in a small value, push it up
If it is big, push down
The heap constructor invokes the buildheap method
Now sort
Removemax places max at end of heap
Reverse sorted
Random
Sorted
int version
Randomly permute the values of array "A"
for each i swap A[i-1] with a random element 
for each i swap A[i-1] with a random element 
Hold the Random class object
Constructor
Found k
k not found
Value for this node
Pointer to next node in list
Constructors
Return next field
Set next field
Return element field
Set element field
Suck it in for (int i=0; i<NumRec; i++) 
Now, write it out
int version
Randomly permute the values of array "A"
for each i swap A[i-1] with a random element 
for each i swap A[i-1] with a random element 
Hold the Random class object
The vertex list
Number of edges
The mark array
Constructor
# of vertices
# of edges
No neighbor
No neighbor
Edge already exists in graph
Keep neighbors sorted by vertex index
Check if j is the current neighbor in the list
Check whole list
The edge matrix
Number of edges
The mark array
Constructors
# of vertices
# of edges
No edge for this vertex
No next edge;
Delete edge (i, j)
Insert i'th record
Stack for array bounds
Initialize stack
While there are unprocessed subarrays
Pop Stack
Findpivot
Stick pivot at end
Partition
Undo final swap
Put pivot value in place
Put new subarrays onto Stack if they are small
Left partition
Right partition
Final Insertion Sort
Default array size
Maximum size of list
Actual number of elements in list
Position of current element
Array holding list elements
Constructor: use default size
Constructor: user-specified size
Allow the generic array allocation
Do actual initialization work
Create listArray
Reinitialize the list
Simply reinitialize values
Shift elements up to make room 
Increment list size
Remove and return the current element
Return null if there is no such element to remove.
Copy the element
Shift them down
Decrement size
Reset current
Reset current
Back up
Next
Return list size
Reset list position to "pos"
Return current position
Return current element
Return current element
Extra stuff not printed in the book.
Save the current position of the list
Reset the fence to its original position
Pointer to the heap array
Maximum size of the heap
Number of things in heap
Start at end of heap
Now sift up until curr's parent's key > curr's key
j is now index of child with greater value
Move down
Remove minimum value
Swap minimum with last value
Not on last element
Put new heap root val in correct place
Last element, no work to be done
Swap with last value
If we just swapped in a small value, push it up
If it is big, push down
Constructor
Maximum size of queue
Index of front element
Index of rear element
Array holding queue elements
For generic array
One extra space is allocated
Create listArray
Circular increment
Circular increment
Extra stuff not printed in the book.
Maximum size of stack
Index for top Object
Array holding stack
Generic array allocation
Create listArray
Extra stuff not printed in the book.
int version
Randomly permute the values of array "A"
for each i swap A[i-1] with a random element 
for each i swap A[i-1] with a random element 
Hold the Random class object
Value for this node
Pointer to next node in list
Constructors
Return next field
Set next field
Return element field
Set element field
Create a graph from file
Read in edges
No weight given -- set at 1
Put in edge in other direction
Process each vertex on Q
Take appropriate action
Put neighbors on Q
Take appropriate action
Create a graph from file
Read in edges
No weight given -- set at 1
Put in edge in other direction
Topological sort: Queue
Initialize
Process every edge
Add to v2's prereq count
Initialize Queue
V has no prerequisites
Process the vertices
PreVisit for Vertex V
One less prerequisite
This vertex is now free
Graph class ADT
Generic array allocation
Home position for r
Initial position
Next pobe slot
Insert R
Home position for k
Initial position
Next probe position
Key not in hash table
Found it
Constructor
The edge matrix
Number of edges
The mark array
Constructors
# of vertices
# of edges
No edge for this vertex
No next edge;
Delete edge (i, j)
Maximum size of queue
Index of front element
Index of rear element
Array holding queue elements
For generic array
One extra space is allocated
Create listArray
Circular increment
Circular increment
Extra stuff not printed in the book.
Create a graph from file
Read in edges
No weight given -- set at 1
Put in edge in other direction
Equivalence array
Minheap array
Count of edges
Put edges in the array
Initially n classes
Combine equiv classes
Next cheapest
If in different classes
Combine equiv classes
Add this edge to MST
One less MST
Create a graph from file
Read in edges
No weight given -- set at 1
Put in edge in other direction
The current vertex
Heap for edges
Initial vertex
Initialize distances 
Now, get distances
Get position
Add edge to MST
Unreachable
Update D
Where it came from
V[i] stores closest vertex to i
Now b contains original value of a
Now a contains original value of b
The edge matrix
Number of edges
The mark array
Constructors
# of vertices
# of edges
No edge for this vertex
No next edge;
Delete edge (i, j)
int version
Randomly permute the values of array "A"
for each i swap A[i-1] with a random element 
for each i swap A[i-1] with a random element 
Hold the Random class object
Maximum size of queue
Index of front element
Index of rear element
Array holding queue elements
For generic array
One extra space is allocated
Create listArray
Circular increment
Circular increment
Extra stuff not printed in the book.
Default size
Maximum size of list
Current # of list items
Position of current element
Array holding list elements
Generic array allocation
Create listArray
Reinitialize the list
Simply reinitialize values
Shift elements up to make room 
Increment list size
No current element
Copy the element
Shift them down
Decrement size
Set to front
Set at end
Back up
Extra stuff not printed in the book.
Save the current position of the list
Reset the fence to its original position
Tell the size of a buffer
This is not the book's code.  That is repeated below.
The book's code does not have a print statement.
/collatz.x
Pointer to list header
Pointer to last element
Access to current element
Size of list
Constructor -- Ignore size
Create header
Drop access to links
Create header
New tail
Nothing to remove
Remember value
Removed last
Remove from list
Decrement count
Return value
No previous element
March down list until we find the previous element
Extra stuff not printed in the book.
Save the current position of the list
Reset the fence to its original position
Create a graph from file
Read in edges
No weight given -- set at 1
Put in edge in other direction
Initialize Mark array
Process all vertices
Recursive helper function
PostVisit for Vertex v
Leaf node
Doubly linked list implementation
Pointer to list header
Pointer to last element in list
Pointer ahead of current element
Size of list
//Constructors
Ignore size
Create header node
Remove all elements from list
Drop access to rest of links
Create header node
Set curr at list start
Set curr at list end
Nothing to remove
Remember value
Remove from list
Decrement the count
Return value removed
Can't back up from list head
Move curr one step right; no change if at end
Return the position of the current element
Move down list to "pos" position
Return current element
Extra stuff not printed in the book.
Save the current position of the list
Reset the fence to its original position
Example in book
Pointer to the heap array
Maximum size of the heap
Number of things in heap
Start at end of heap
Now sift up until curr's parent's key > curr's key
j is now index of child with greater value
Move down
Remove minimum value
Swap minimum with last value
Not on last element
Put new heap root val in correct place
Last element, no work to be done
Swap with last value
If we just swapped in a small value, push it up
If it is big, push down
Create a graph from file
Read in edges
No weight given -- set at 1
Put in edge in other direction
Initialize v to any unvisited vertex;
Now find smallest value
Compute shortest path distances from s, store them in D
Initialize
Process the vertices
Find next-closest vertex
Unreachable
int version
Randomly permute the values of array "A"
for each i swap A[i-1] with a random element 
for each i swap A[i-1] with a random element 
Hold the Random class object
Default array size
Maximum size of list
Actual number of elements in list
Position of current element
Array holding list elements
Constructor: use default size
Constructor: user-specified size
Allow the generic array allocation
Do actual initialization work
Create listArray
Reinitialize the list
Simply reinitialize values
Shift elements up to make room 
Increment list size
Remove and return the current element
Return null if there is no such element to remove.
Copy the element
Shift them down
Decrement size
Reset current
Reset current
Back up
Next
Return list size
Reset list position to "pos"
Return current position
Return current element
Return current element
Extra stuff not printed in the book.
Save the current position of the list
Reset the fence to its original position
Tell the size of a buffer
Pointer to list header
Pointer to last element
Access to current element
Size of list
Constructor -- Ignore size
Create header
Drop access to links
Create header
New tail
Nothing to remove
Remember value
Removed last
Remove from list
Decrement count
Return value
No previous element
March down list until we find the previous element
Extra stuff not printed in the book.
Save the current position of the list
Reset the fence to its original position
Constructor
Graph class ADT
Graph class ADT
Only supporting 2D points
Number of nodes in the KD tree
First find it
Now remove it
Now, temp1 has the smaller value
Found it
Just drop element
Switch subtree to right
The vertex list
Number of edges
The mark array
Constructor
# of vertices
# of edges
No neighbor
No neighbor
Edge already exists in graph
Keep neighbors sorted by vertex index
Check if j is the current neighbor in the list
Check whole list
Quicksort
Pick a pivot
Stick pivot at end
k will be the first position in the right subarray
Put pivot in place
Sort left partition
Sort right partition
Move bounds inward until they meet
Swap out-of-place values
Stop when they cross
Reverse last, wasted swap
Return first position in right partition
int version
Randomly permute the values of array "A"
for each i swap A[i-1] with a random element 
for each i swap A[i-1] with a random element 
Hold the Random class object
The vertex list
Number of edges
The mark array
Constructor
# of vertices
# of edges
No neighbor
No neighbor
Edge already exists in graph
Keep neighbors sorted by vertex index
Check if j is the current neighbor in the list
Check whole list
The vertex list
Number of edges
The mark array
Constructor
# of vertices
# of edges
No neighbor
No neighbor
Edge already exists in graph
Keep neighbors sorted by vertex index
Check if j is the current neighbor in the list
Check whole list
main
class MemMain
Graph class ADT
The edge matrix
Number of edges
The mark array
Constructors
# of vertices
# of edges
No edge for this vertex
No next edge;
Delete edge (i, j)
int version
Randomly permute the values of array "A"
for each i swap A[i-1] with a random element 
for each i swap A[i-1] with a random element 
Hold the Random class object
The edge matrix
Number of edges
The mark array
Constructors
# of vertices
# of edges
No edge for this vertex
No next edge;
Delete edge (i, j)
Nothing to visit
Process leaf node
Process internal node
The vertex list
Number of edges
The mark array
Constructor
# of vertices
# of edges
No neighbor
No neighbor
Edge already exists in graph
Keep neighbors sorted by vertex index
Check if j is the current neighbor in the list
Check whole list
To fit n! in a long variable, require n < 21
Make a stack just big enough
We really need to figure out a way to do this that doesn't
include a control variable
do nothing
We really need to figure out a way to do this that doesn't
include a control variable
do nothing
int version
Randomly permute the values of array "A"
for each i swap A[i-1] with a random element 
for each i swap A[i-1] with a random element 
Hold the Random class object
Value for this node
Pointer to next node in list
Constructors
Return next field
Set next field
Return element field
Set element field
Create a graph from file
Read in edges
No weight given -- set at 1
Put in edge in other direction
For n vertices in graph
Vertex i in no component
Current component
Start a new component
Operand value
Maximum size of stack
Index for top Object
Array holding stack
Generic array allocation
Create listArray
Extra stuff not printed in the book.
This is the pseudo hash table, twice the # of records
Data collecting variables
Maximum length of any chain, ever
Average for the maximum (per iteration) chain length
Minimum slots used by any interation
Average number of slots used per iteration
Intialize the table for this iteration
"insert" records into the hash table
Imagine that we are inserting here, bump the count
Update the statistics
longest chain ever
longest chain this iteration
Something hit this slot
Calculate the final statistics
Create a graph from file
Read in edges
No weight given -- set at 1
Put in edge in other direction
Initialize v to any unvisited vertex;
Now find smallest value
Compute shortest path distances from s, store them in D
Initialize
Process the vertices
Find next-closest vertex
Unreachable
Default size
Maximum size of list
Current # of list items
Position of current element
Array holding list elements
Generic array allocation
Create listArray
Reinitialize the list
Simply reinitialize values
Shift elements up to make room 
Increment list size
No current element
Copy the element
Shift them down
Decrement size
Set to front
Set at end
Back up
Extra stuff not printed in the book.
Save the current position of the list
Reset the fence to its original position
Insert i'th record
Stack for array bounds
Initialize stack
While there are unprocessed subarrays
Pop Stack
Findpivot
Stick pivot at end
Partition
Undo final swap
Put pivot value in place
Put new subarrays onto Stack if they are small
Left partition
Right partition
Final Insertion Sort
Reverse sorted
Random
Sorted
int version
Randomly permute the values of array "A"
for each i swap A[i-1] with a random element 
for each i swap A[i-1] with a random element 
Hold the Random class object
IDdict organizes Payroll records by ID
namedict organizes Payroll records by name
IDdict organizes Payroll records by ID
namedict organizes Payroll records by name
Root of the tree
Weight of tree is weight of root
int version
Randomly permute the values of array "A"
for each i swap A[i-1] with a random element 
for each i swap A[i-1] with a random element 
n=1
n=2
n>2
Hold the Random class object
Create a graph from file
Read in edges
No weight given -- set at 1
Put in edge in other direction
Initialize D with weights
Compute all k paths
Bubble up i'th record
Reverse sorted
Random
Sorted
Value for this node
Pointer to next node in list
Constructors
Return next field
Set next field
Return element field
Set element field
Constructor
Create a graph from file
Read in edges
No weight given -- set at 1
Put in edge in other direction
The current vertex
Heap for edges
Initial vertex
Initialize distances 
Now, get distances
Get position
Add edge to MST
Unreachable
Update D
Where it came from
V[i] stores closest vertex to i
Graph class ADT
Pointer to the heap array
Maximum size of the heap
Number of things in heap
Start at end of heap
Now sift up until curr's parent's key > curr's key
j is now index of child with greater value
Move down
Swap maximum with last value
Not on last element
Put new heap root val in correct place
Last element, no work to be done
Swap with last value
If we just swapped in a big value, push it up
If it is little, push down
/binsimp1.x
/End binsimp1.x
/binsimp2.x
Swap element A[i] with A[A[i]]
/End binsimp2.x
Factor out overhead
Swap element A[i] with A[A[i]]
Create a graph from file
Read in edges
No weight given -- set at 1
Put in edge in other direction
Process each vertex on Q
Take appropriate action
Put neighbors on Q
Take appropriate action
int version
Randomly permute the values of array "A"
for each i swap A[i-1] with a random element 
for each i swap A[i-1] with a random element 
Hold the Random class object
For each increment
Sort each sublist
Could call regular inssort here
Graph class ADT
Generic array allocation
Count[i] stores number of records in bin[i]
For k digits
Initialize count
Count the number of records for each bin on this pass
count[j] will be index in B for last slot of bin j.
Put records into bins, working from bottom of bin
Since bins fill from bottom, j counts downwards
Copy B back
Reverse sorted
Random
Sorted
The vertex list
Number of edges
The mark array
Constructor
# of vertices
# of edges
No neighbor
No neighbor
Edge already exists in graph
Keep neighbors sorted by vertex index
Check if j is the current neighbor in the list
Check whole list
The vertex list
Number of edges
The mark array
Constructor
# of vertices
# of edges
No neighbor
No neighbor
Edge already exists in graph
Keep neighbors sorted by vertex index
Check if j is the current neighbor in the list
Check whole list
Pointer to list header
Pointer to last element
Access to current element
Size of list
Constructor -- Ignore size
Create header
Drop access to links
Create header
New tail
Nothing to remove
Remember value
Removed last
Remove from list
Decrement count
Return value
No previous element
March down list until we find the previous element
Extra stuff not printed in the book.
Save the current position of the list
Reset the fence to its original position
Internal node
Left child
Right child
Operator value
Value for this node
Point to next node in list
Freelist for the class
Get from "new"
Get from freelist
Drop reference to the element
Pointer to list header
Pointer to last element
Access to current element
Size of list
Constructor -- Ignore size
Create header
Drop access to links
Create header
New tail
Nothing to remove
Remember value
Removed last
Remove from list
Decrement count
Return value
No previous element
March down list until we find the previous element
Extra stuff not printed in the book.
Save the current position of the list
Reset the fence to its original position
Constructor
Insert i'th record
Reverse sorted
Random
Sorted
Value for this node
Pointer to next node in list
Constructors
Return next field
Set next field
Return element field
Set element field
Somebody better change
Generic array allocation
Select midpoint
List has one element
Mergesort first half
Mergesort second half
Copy subarray to temp
Do the merge operation back to A
Left sublist exhausted
Right sublist exhausted
Get smaller
Reverse sorted
Random
Sorted
Root of the BST
Number of nodes in the BST
First find it
Now remove it
Found it
Two children
Holds largest element position
For each element
if A[i] is larger remember its position 
Return largest position
Default size
Maximum size of list
Current # of list items
Position of current element
Array holding list elements
Generic array allocation
Create listArray
Reinitialize the list
Simply reinitialize values
Shift elements up to make room 
Increment list size
No current element
Copy the element
Shift them down
Decrement size
Set to front
Set at end
Back up
Extra stuff not printed in the book.
Save the current position of the list
Reset the fence to its original position
Left child
Right child
Operator value
Node array
Create node array
Find root of node a
Find root of node b
Compare roots
Find root of node a
Find root of node b
Merge
At root
do nothing
Start tag offset
Size field offset
User size offset
Left freelist pointer
Right freelist pointer
Start of data
Tag value
Tag value
Size field offset
Tag field offset
Tag field offset
Extra space needed
Number free fields
Number of res fields
Smallest data request
The data space
Free memory access
Constructor
Allocate space
Start of freelist
Circ doubly-linked list
Return data for h
Sample sequential fit implementation: First fit
No free block
No block available
Minimum necessary for a sustainable block 
No block is big enough
Fix up the remaining free space
Now, fix up the new block
Give over the whole block, remove from freelist
First, adjust the freelist
This is the last block
Now, fill in the block
Implementation is left as an exercise
class MemManager
Pointer to list header
Pointer to last element
Access to current element
Size of list
Constructor -- Ignore size
Create header
Drop access to links
Create header
New tail
Nothing to remove
Remember value
Removed last
Remove from list
Decrement count
Return value
No previous element
March down list until we find the previous element
Extra stuff not printed in the book.
Save the current position of the list
Reset the fence to its original position
Graph class ADT
int version
Randomly permute the values of array "A"
for each i swap A[i-1] with a random element 
for each i swap A[i-1] with a random element 
Hold the Random class object
Root of 2-3 tree
# of records now in 2-3 tree
Empty tree: create a leaf node for root
At leaf node: insert here
Add to internal node
Insert left
Insert right
val not found
Search left
Search center
Search center
Search right
Pointer to list header
Pointer to last element
Access to current element
Size of list
Constructor -- Ignore size
Create header
Drop access to links
Create header
New tail
Nothing to remove
Remember value
Removed last
Remove from list
Decrement count
Return value
No previous element
March down list until we find the previous element
Extra stuff not printed in the book.
Save the current position of the list
Reset the fence to its original position
Node array
Create node array
Find root of node a
Find root of node b
Compare roots
Find root of node a
Find root of node b
Merge
At root
Create a graph from file
Read in edges
No weight given -- set at 1
Put in edge in other direction
Initialize v to any unvisited vertex;
Now find smallest value
Initialize
Process the vertices
Unreachable
V[i] stores closest vertex to i
Maximum size of stack
Index for top Object
Array holding stack
Generic array allocation
Create listArray
Extra stuff not printed in the book.
Pointer to the heap array
Maximum size of the heap
Number of things in heap
Start at end of heap
Now sift up until curr's parent's key > curr's key
j is now index of child with greater value
Move down
Remove minimum value
Swap minimum with last value
Not on last element
Put new heap root val in correct place
Last element, no work to be done
Swap with last value
If we just swapped in a small value, push it up
If it is big, push down
Number of records in a block
Number of blocks in the buffer (run)
Move the bounds inward until they meet
Move left bound right
Move right bound
Swap out-of-place values
Stop when they cross
Reverse last, wasted swap
Return first position in right partition
Quicksort
Stick pivot at end
k will be the first position in the right subarray
Put pivot in place
Sort left partition
Sort right partition
Use quicksort to generate initial runs, placing the runs
one after another into the temporary file.
Suck in the original data
Now, do the multiway merge
Now, read in a new block if necessary
For first pass, need the original input file.  Won't use again
Now, do a single multi-way merge pass
Pointer to the heap array
Maximum size of the heap
Number of things in heap
Start at end of heap
Now sift up until curr's parent's key > curr's key
j is now index of child with greater value
Move down
Remove minimum value
Swap minimum with last value
Not on last element
Put new heap root val in correct place
Last element, no work to be done
Swap with last value
If we just swapped in a small value, push it up
If it is big, push down
fact(20) is the largest value that fits in a long
Base case: return base solution
Recursive call for n > 1
We really need to figure out a way to do this that doesn't
include a control variable
do nothing
We really need to figure out a way to do this that doesn't
include a control variable
do nothing
int version
Randomly permute the values of array "A"
for each i swap A[i-1] with a random element 
for each i swap A[i-1] with a random element 
Hold the Random class object
Select i'th record
Remember its index
Find the least value
Put it in place
Reverse sorted
Random
Sorted
Base case
Recursive call: n-1 rings
Move bottom disk to goal
Recursive call: n-1 rings
Create a graph from file
Read in edges
No weight given -- set at 1
Put in edge in other direction
Initialize Mark array
Process all vertices
Recursive helper function
PostVisit for Vertex v
Root of B+ tree
# of records now in 2-3 tree
Collapse root
At leaf node: insert here
Add to internal node
Process internal node
Child will merge if necessary
int version
Randomly permute the values of array "A"
for each i swap A[i-1] with a random element 
for each i swap A[i-1] with a random element 
Hold the Random class object
All subclasses must implement
The vertex list
Number of edges
The mark array
Constructor
# of vertices
# of edges
No neighbor
No neighbor
Edge already exists in graph
Keep neighbors sorted by vertex index
Check if j is the current neighbor in the list
Check whole list
Default size
To store dictionary
"k" does not appear in dictionary
Graph class ADT
Clear the tree
Return the root
Make the tree have a new root, give first child and sib
Add left child
Constructor
2D key for this node
Element for this node
Pointer to left child
Pointer to right child
Graph class ADT
Create a graph from file
Read in edges
No weight given -- set at 1
Put in edge in other direction
Initialize v to any unvisited vertex;
Now find smallest value
Initialize
Process the vertices
Unreachable
V[i] stores closest vertex to i
fibr(91) is the largest value that fits in a long
curr holds current Fib value
Compute next value
past holds fibi(i-2)
prev holds fibi(i-1)
curr now holds fibi(i)
fibr(91) is the largest value that fits in a long
Base case
Recursive call
We really need to figure out a way to do this that doesn't
include a control variable
do nothing
We really need to figure out a way to do this that doesn't
include a control variable
do nothing
The vertex list
Number of edges
The mark array
Constructor
# of vertices
# of edges
No neighbor
No neighbor
Edge already exists in graph
Keep neighbors sorted by vertex index
Check if j is the current neighbor in the list
Check whole list
Select i'th record
Remember its index
Find the least value
Put it in place
Return true if "k" matches the key for an element in list "L",
false otherwise
K not found
The left record
The node's left key
The right record
The node's right key
Pointer to left child
Pointer to middle child
Pointer to right child
Left key
Left value
Right key
Right value
Only one key, add here
Add left
Add center
Add right
Bubble up i'th record
Pointer to the heap array
Maximum size of the heap
Number of things in heap
Start at end of heap
Now sift up until curr's parent's key > curr's key
j is now index of child with greater value
Move down
Remove minimum value
Swap minimum with last value
Not on last element
Put new heap root val in correct place
Last element, no work to be done
Swap with last value
If we just swapped in a small value, push it up
If it is big, push down
Graph class ADT
Graph class ADT
Value for this node
Pointer to next node in list
Constructors
Return next field
Set next field
Return element field
Set element field
Make a stack just big enough
Get next task
Do a move
Imitate TOH recursive
solution (in reverse)
A move to do
Allow the generic array allocation
Allow the generic array allocation
Test the remove function.
Allow the generic array allocation
Constructor
Graph class ADT
Generic array allocation
Insert i'th record
Select the midpoint
List has one element
Do the merge operation.  First, copy 2 halves to temp.
Merge sublists back to array
Reverse sorted
Random
Sorted
The edge matrix
Number of edges
The mark array
Constructors
# of vertices
# of edges
No edge for this vertex
No next edge;
Delete edge (i, j)
Graph class ADT
Linked list implementation -- Freelist
Pointer to list header
Pointer to last element in list
Pointer one ahead of current element
Size of list
//Constructors
Constructor -- Ignore size
Create header
Remove all elements
Drop access to links
Create header
Set curr at list start
Set curr at list end
Get link
New tail
Nothing to remove
Remember value
Removed last
Remember link
Remove from list
Release link
Decrement count
Return removed
Move curr one step left; no change if at front
No previous element
March down list until we find the previous element
Move curr one step right; no change if at end
Return the position of the current element
Move down list to "pos" position
Return current element
Extra stuff not printed in the book.
Save the current position of the list
Reset the fence to its original position
Pointer to list header
Pointer to last element
Access to current element
Size of list
Constructor -- Ignore size
Create header
Drop access to links
Create header
New tail
Nothing to remove
Remember value
Removed last
Remove from list
Decrement count
Return value
No previous element
March down list until we find the previous element
Extra stuff not printed in the book.
Save the current position of the list
Reset the fence to its original position
A count of the number of times that we do a read
A count of the number of times that we do a write
Divide the records in the input file between the two
output files, leaving numrecs records in each.
Flush second run
Flush first run
For first pass, need the original input file.  Won't use again
Divide the original input into two
Now, do a series of 2-way merge passes
Finally, merge the last two runs into the output file
Now test that this worked correctly
Priming read
Default size
Maximum size of list
Current # of list items
Position of current element
Array holding list elements
Generic array allocation
Create listArray
Reinitialize the list
Simply reinitialize values
Shift elements up to make room 
Increment list size
No current element
Copy the element
Shift them down
Decrement size
Set to front
Set at end
Back up
Extra stuff not printed in the book.
Save the current position of the list
Reset the fence to its original position
Default size
To store dictionary
"k" does not appear in dictionary
Leaf node
Maximum size of queue
Index of front element
Index of rear element
Array holding queue elements
For generic array
One extra space is allocated
Create listArray
Circular increment
Circular increment
Extra stuff not printed in the book.
Node array
Create node array
Find root of node a
Find root of node b
Compare roots
Find root of node a
Find root of node b
Merge
At root
Graph class ADT
Pointer to list header
Pointer to last element
Access to current element
Size of list
Constructor -- Ignore size
Create header
Drop access to links
Create header
New tail
Nothing to remove
Remember value
Removed last
Remove from list
Decrement count
Return value
No previous element
March down list until we find the previous element
Extra stuff not printed in the book.
Save the current position of the list
Reset the fence to its original position
int version
Randomly permute the values of array "A"
for each i swap A[i-1] with a random element 
for each i swap A[i-1] with a random element 
Hold the Random class object
This gives a compiler warning. But it will work correctly.
This also gives a compiler warning and will work correctly.
Constructor
int version
Randomly permute the values of array "A"
for each i swap A[i-1] with a random element 
for each i swap A[i-1] with a random element 
Hold the Random class object
Pointer to the heap array
Maximum size of the heap
Number of things in heap
Start at end of heap
Now sift up until curr's parent's key > curr's key
j is now index of child with greater value
Move down
Swap maximum with last value
Not on last element
Put new heap root val in correct place
Last element, no work to be done
Swap with last value
If we just swapped in a big value, push it up
If it is little, push down
Pointer to list header
Pointer to last element
Access to current element
Size of list
Constructor -- Ignore size
Create header
Drop access to links
Create header
New tail
Nothing to remove
Remember value
Removed last
Remove from list
Decrement count
Return value
No previous element
March down list until we find the previous element
Extra stuff not printed in the book.
Save the current position of the list
Reset the fence to its original position
Default size
To store dictionary
"k" does not appear in dictionary
Node array
Create node array
Find root of node a
Find root of node b
Compare roots
Find root of node a
Find root of node b
Merge
At root
The vertex list
Number of edges
The mark array
Constructor
# of vertices
# of edges
No neighbor
No neighbor
Edge already exists in graph
Keep neighbors sorted by vertex index
Check if j is the current neighbor in the list
Check whole list
Graph class ADT
Maximum size of queue
Index of front element
Index of rear element
Array holding queue elements
For generic array
One extra space is allocated
Create listArray
Circular increment
Circular increment
Extra stuff not printed in the book.
Element for this node
Weight for this node
Insert i'th record
Pointer to list header
Pointer to last element
Access to current element
Size of list
Constructor -- Ignore size
Create header
Drop access to links
Create header
New tail
Nothing to remove
Remember value
Removed last
Remove from list
Decrement count
Return value
No previous element
March down list until we find the previous element
Extra stuff not printed in the book.
Save the current position of the list
Reset the fence to its original position
Generic array allocation
Select midpoint
List has one element
Mergesort first half
Mergesort second half
Copy subarray to temp
Do the merge operation back to A
Left sublist exhausted
Right sublist exhausted
Get smaller
Graph class ADT
Create a graph from file
Read in edges
No weight given -- set at 1
Put in edge in other direction
The current vertex
Heap for edges
Initial vertex
Initialize distance
For each vertex
Get position
Unreachable
Update D
Found k
k not found
int version
Randomly permute the values of array "A"
for each i swap A[i-1] with a random element 
for each i swap A[i-1] with a random element 
Hold the Random class object
Value for this node
Pointer to next node in list
Constructors
Return next field
Set next field
Return element field
Set element field
Pointer to list header
Pointer to last element
Access to current element
Size of list
Constructor -- Ignore size
Create header
Drop access to links
Create header
New tail
Nothing to remove
Remember value
Removed last
Remove from list
Decrement count
Return value
No previous element
March down list until we find the previous element
Extra stuff not printed in the book.
Save the current position of the list
Reset the fence to its original position
Value for this node
Pointer to next node in list
Constructors
Return next field
Set next field
Return element field
Set element field
Create a graph from file
Read in edges
No weight given -- set at 1
Put in edge in other direction
Initialize
Take appropriate action
Take appropriate action
Graph class ADT
Graph class ADT
The edge matrix
Number of edges
The mark array
Constructors
# of vertices
# of edges
No edge for this vertex
No next edge;
Delete edge (i, j)
Stick this in to test the preorder routine
The first version of preorder
is the preferred structure for preorder traversal.
It tests the pointer to the current node before visiting it,
but does not test that children are NULL before calling a
visit on them. This version does not rely on the caller
to test the root for safety.
The second version of preorder does "look ahead" to test if
a child should be visited before doing the visit.
This requires an external test of the root to make it safe
from calls on an empty tree.
Empty subtree - do nothing
Process root node
Process all nodes in left
Process all nodes in right
Nothing to count
Empty subtree
Out of range
Left side failed
The following tests for checkBST are a little dicey. The book
code uses a simple BinNode abstract class. Syntactically, this
works fine since the function uses only base class
functionality. But logically, this works only so long as the key
and element of the BSTNode are the same (since BinNode.element()
returns the element, not the key).
c3p1.book
/c3p2.book
/c3p3.book
c3p4.book
First for loop is a double loop 
Second for loop
c3p5.book
First double loop do n times 
Second double loop do i times 
/c3p6.x
Do log n times
Do n times
Do log n times
Do k times
c3p16.book
Initialize count
Look at all of the pixels
Increment a pixel value count
Sort pixel value counts
/c3p7.x
/End c3p7.x
/c3p8.x
/End c3p8.x
/c3p9.x
/End c3p9.x
/c3p10.x
/End c3p10.book
/c3p11.book
/c3p12.book
Initialize count
Look at all of the pixels
Increment a pixel value count
Sort pixel value counts
For each increment
Sort each sublist
Could call regular inssort here
Reverse sorted
Random
Sorted
Weight (sum of children)
Pointer to left child
Pointer to right child
The edge matrix
Number of edges
The mark array
Constructors
# of vertices
# of edges
No edge for this vertex
No next edge;
Delete edge (i, j)
Create a graph from file
Read in edges
No weight given -- set at 1
Put in edge in other direction
int version
Randomly permute the values of array "A"
for each i swap A[i-1] with a random element 
for each i swap A[i-1] with a random element 
Hold the Random class object
Pointer to list header
Pointer to last element
Access to current element
Size of list
Constructor -- Ignore size
Create header
Drop access to links
Create header
New tail
Nothing to remove
Remember value
Removed last
Remove from list
Decrement count
Return value
No previous element
March down list until we find the previous element
Extra stuff not printed in the book.
Save the current position of the list
Reset the fence to its original position
Override Object.toString
Default size
Consturctors
Reinitialize
This really should get replaced with binary search
Find "k" using sequential search -- Should use binary search
"k" does not appear in dictionary
Return list size
Value for this node
Pointer to next node in list
Constructors
Return next field
Set next field
Return element field
Set element field
The code lookup table
Total weight of codes
Allow the generic array allocation
process the entry, creating a new HuffTree
While two items left
Return new tree to heap
Return the tree
Find the index in CodeTable for the given codeword
Not found
Print out the codes; insert these codes into CodeTable
This is a full binary tree so must not be null subtree
Process Encode and Decode commands
Traverse the tree
reset at root
Assume codes are characters.  Should generalize this.
while
Read from standard input
Data file entered as parameter
The heap constructor invokes the buildheap method
Now sort
Removemax places max at end of heap
Pointer to the heap array
Maximum size of the heap
Number of things in heap
Start at end of heap
Now sift up until curr's parent's key > curr's key
j is now index of child with greater value
Move down
Remove minimum value
Swap minimum with last value
Not on last element
Put new heap root val in correct place
Last element, no work to be done
Swap with last value
If we just swapped in a small value, push it up
If it is big, push down
Constructor
The edge matrix
Number of edges
The mark array
Constructors
# of vertices
# of edges
No edge for this vertex
No next edge;
Delete edge (i, j)
Pointer to first element
Number of elements
Extra stuff not printed in the book.
Value for this node
Pointer to next node in list
Constructors
Return next field
Set next field
Return element field
Set element field
Operand value
The vertex list
Number of edges
The mark array
Constructor
# of vertices
# of edges
No neighbor
No neighbor
Edge already exists in graph
Keep neighbors sorted by vertex index
Check if j is the current neighbor in the list
Check whole list
Pointer to the heap array
Maximum size of the heap
Number of things in heap
Start at end of heap
Now sift up until curr's parent's key > curr's key
j is now index of child with greater value
Move down
Remove minimum value
Swap minimum with last value
Not on last element
Put new heap root val in correct place
Last element, no work to be done
Swap with last value
If we just swapped in a small value, push it up
If it is big, push down
Value for this node
Pointer to next node in list
Constructors
Return next field
Set next field
Return element field
Set element field
Graph class ADT
The edge matrix
Number of edges
The mark array
Constructors
# of vertices
# of edges
No edge for this vertex
No next edge;
Delete edge (i, j)
l and r are beyond array bounds
Stop when l and r meet
Check middle of remaining subarray
In left half
Found it
In right half
Search value not in A
One code stored in a code table
Pointer to list header
Pointer to last element
Access to current element
Size of list
Constructor -- Ignore size
Create header
Drop access to links
Create header
New tail
Nothing to remove
Remember value
Removed last
Remove from list
Decrement count
Return value
No previous element
March down list until we find the previous element
Extra stuff not printed in the book.
Save the current position of the list
Reset the fence to its original position
We don't actually care if Key is Comparable, we only do it for consistency
Tombstone flyweight
Allow the generic array allocation
Bugged for now -- this skips tombstones
Home position for r
Initial position
Next probe slot
Insert R
Home position for k
Initial position
Next probe position
K not in hash table
Found it
Home position for k
Initial position
Next probe position
K not in hash table
Found it
Create a graph from file
Read in edges
No weight given -- set at 1
Put in edge in other direction
Topological sort: Queue
Initialize
Process every edge
Add to v2's prereq count
Initialize Queue
V has no prerequisites
Process the vertices
PreVisit for Vertex V
One less prerequisite
This vertex is now free
